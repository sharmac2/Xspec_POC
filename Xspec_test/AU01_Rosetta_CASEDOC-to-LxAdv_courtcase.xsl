<?xml version="1.0" encoding="UTF-8"?>
<!--  ***This XSLT conversion file is a stand-alone, generated release created from a module based source code.  Any changes to this conversion must be propagated to its original source. ***
This file is not intended to be edited directly, except in a time critical situation such as a  "sev1" webstar.
Please contact Content Architecture for support and for ensuring the source code is updated as needed and a new stand-alone delivery is released.
Compiled:  2018-03-12T15:11:46.337+05:30-->
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:xsltdoc="http://www.lexisnexis.com/xmlstylesheets/documentation/xslt-documentation/1/"
                xmlns:xs="http://www.w3.org/2001/XMLSchema"
                xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"
                xmlns:admindoc="urn:x-lexisnexis:content:administrative-document:sharedservices:1"
                xmlns:annot="http://www.lexisnexis.com/xmlschemas/content/shared/annotations/1/"
                xmlns:base="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"
                xmlns:case="http://www.lexis-nexis.com/glp/case"
                xmlns:case2="http://www.lexisnexis.com/xmlschemas/content/legal/case/1/"
                xmlns:caseinfo="http://www.lexisnexis.com/xmlschemas/content/legal/case-information/1/"
                xmlns:casesum="http://www.lexisnexis.com/xmlschemas/content/legal/case-summary/1/"
                xmlns:ci="http://www.lexis-nexis.com/ci"
                xmlns:classify="http://www.lexisnexis.com/xmlschemas/content/shared/classification/1/"
                xmlns:comm="http://www.lexis-nexis.com/glp/comm"
                xmlns:contact="http://www.lexisnexis.com/xmlschemas/content/shared/contact/1/"
                xmlns:courtcase="http://www.lexisnexis.com/xmlschemas/content/legal/courtcase/1/"
                xmlns:courtfiling="http://www.lexisnexis.com/xmlschemas/content/legal/courtfiling/1/"
                xmlns:dc="http://purl.org/dc/elements/1.1/"
                xmlns:decision="http://www.lexisnexis.com/xmlschemas/content/legal/decision/1/"
                xmlns:dig="http://www.lexis-nexis.com/glp/dig"
                xmlns:dita="http://dita.oasis-open.org/architecture/2005/"
                xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/"
                xmlns:doc="http://www.lexisnexis.com/xmlschemas/content/shared/document-level-metadata/1/"
                xmlns:docinfo="http://www.lexis-nexis.com/glp/docinfo"
                xmlns:entity="http://www.lexisnexis.com/xmlschemas/content/shared/identified-entities/1/"
                xmlns:error="urn:x-lexisnexis:conversion:global:error:1"
                xmlns:ext="http://exslt.org/common"
                xmlns:form="http://www.lexisnexis.com/xmlschemas/content/shared/form/1/"
                xmlns:frm="http://www.lexis-nexis.com/glp/frm"
                xmlns:glp="http://www.lexis-nexis.com/glp"
                xmlns:guid="urn:x-lexisnexis:content:guid:global:1"
                xmlns:in="http://www.lexis-nexis.com/glp/in"
                xmlns:index="urn:x-lexisnexis:content:publicationindex:sharedservices:1"
                xmlns:jrnl="http://www.lexis-nexis.com/glp/jrnl"
                xmlns:jurisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/jurisdiction-info/1/"
                xmlns:leg="http://www.lexis-nexis.com/glp/leg"
                xmlns:legisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-info/1/"
                xmlns:lnci="http://www.lexisnexis.com/xmlschemas/content/shared/citations/1/"
                xmlns:lncr="http://www.lexis-nexis.com/lncr"
                xmlns:lnf="urn:x-lexisnexis:conversion:global:functions:1"
                xmlns:lnmeta="http://www.lexisnexis.com/xmlschemas/content/shared/lexisnexis-metadata/1/"
                xmlns:lnv="http://www.lexis-nexis.com/lnv"
                xmlns:lnvxe="http://www.lexis-nexis.com/lnvxe"
                xmlns:location="http://www.lexisnexis.com/xmlschemas/content/shared/location/1/"
                xmlns:newsitem="http://www.lexisnexis.com/xmlschemas/content/news/newsitem/1/"
                xmlns:nitf="http://iptc.org/std/NITF/2006-10-18/"
                xmlns:person="http://www.lexisnexis.com/xmlschemas/content/shared/person/1/"
                xmlns:primlaw="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw/1/"
                xmlns:primlawhist="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-history/1/"
                xmlns:primlawinfo="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-info/1/"
                xmlns:proc="http://www.lexisnexis.com/xmlschemas/content/shared/process-elements/1/"
                xmlns:pubfm="http://www.lexisnexis.com/xmlschemas/content/shared/publication-front-matter/1/"
                xmlns:pubinfo="http://www.lexisnexis.com/xmlschemas/content/shared/publication-info/1/"
                xmlns:ref="http://www.lexisnexis.com/xmlschemas/content/shared/reference/1/"
                xmlns:seclaw="http://www.lexisnexis.com/xmlschemas/content/legal/secondary-law/1/"
                xmlns:shared_legisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/legisinfo/1/"
                xmlns:source_cttr="http://www.lexis-nexis.com/glp/cttr"
                xmlns:source_dict="http://www.lexis-nexis.com/glp/dict"
                xmlns:source_docinfo="http://www.lexis-nexis.com/glp/docinfo"
                xmlns:source_lnci="http://www.lexis-nexis.com/lnci"
                xmlns:topic="urn:x-lexisnexis:content:topic:global:1"
                xmlns:xd="http://www.oxygenxml.com/ns/doc/xsl"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                version="2.0"
                exclude-result-prefixes="#all">
   <xsl:output use-character-maps="a-circumflex" method="xml" indent="no"/>
   <xsl:param name="outputSchemaLoc"
              select="'http://www.lexisnexis.com/xmlschemas/content/legal/courtcase/1/ http://www.lexisnexis.com/xmlschemas/content/legal/courtcase/1/sch_courtcase.xsd'"/>
   <xd:doc>
      <xd:desc><!--  this will become the title of the PDF created from the DITA modules (documentation)  -->
         <xd:p>
            <xd:b>AU01 Rosetta CASEDOC to LxAdv courtcase</xd:b>
         </xd:p>
         <xd:p>This is the driver stylesheet used in transforming ... instance files (...
				root element) into Lexis Advance ... instance files (... root element).</xd:p>
         <xd:p>First Last (first.last@lexisnexis.com)
		</xd:p>
         <xd:p>{date}</xd:p>
         <xd:p>
            <xd:b>Version History:</xd:b>
         </xd:p>
         <xd:p>1.0 ALPHA: XXXX</xd:p>
         <xd:p>First Last: 1.0 ALPHA version; first formal release of the
						stylesheet.</xd:p>
         <xd:p>
            <xd:b>Source: </xd:b>source description or name of dtd</xd:p>
         <xd:p>
            <xd:b>Target: </xd:b>\schema_modeling\sharedservices\lexisadvance\rootschemas\xxx\xxxxx.rng
					version x.y_PROD</xd:p>
      </xd:desc>
   </xd:doc>
   <!-- map  AU01 Rosetta CASEDOC to LxAdv courtcase  -->
   <xsl:key name="idTypeValue" match="*[@id]" use="@id"/>
   <xsl:key name="idTypeValue" match="*[@ID]" use="@ID"/>
   <xsl:key name="idTypeValue" match="footnote" use="@fntoken"/>
   <xsl:key name="idTypeValue" match="fnr" use="@fnrtoken"/>
   <xsl:key name="fnr-footnote-tokens" match="fnr" use="@fntoken"/>
   <xsl:variable name="streamID" as="xs:string" select="'AU01'"/>
   <xsl:param name="dpsi" as="xs:string" select=" 'From LBU Manifest File' "/>
   <xsl:param name="smi" as="xs:string" select="'From LBU Manifest File'"/>
   <xsl:param name="inlineobjBoilerplateFiles"/>
   <xsl:param name="inlineobjFilesToSuppress"
              select="('1.gif', '2.gif', '3.gif', '4.gif', '5.gif', 'IconSignalPositive.gif', 'IconSignalNegative.gif', 'IconSignalNeutral.gif', 'IconSignalPossibleNegative.gif', 'IconSignalCiteInfoOnly.gif', 'cbcc.gif', 'leg1.gif', 'mb.gif', 'au_repealed.gif', 'au_exclaim.gif', '1.png', '2.png', '3.png', '4.png', '5.png', 'IconSignalPositive.png', 'IconSignalNegative.png', 'IconSignalNeutral.png', 'IconSignalPossibleNegative.png', 'IconSignalCiteInfoOnly.png', 'cbcc.png', 'leg1.png', 'mb.png', 'au_repealed.png', 'au_exclaim.png')"/>
   <!-- Set as 'true' if you want inline (embedded) citations.  -->
   <xsl:param name="outputEmbeddedCitations" as="xs:string" select="'false'"/>
   <!-- Set as 'segmentsOnly' if you want as flat as possible (only segement elements containing strings) when performing transforms to VisfXML.  -->
   <xsl:param name="visfXmlOutputLevel" as="xs:string" select="'false'"/>
   <!-- Set as 'true' if you want globalentity:* pass-through.  -->
   <xsl:param name="passThroughGlobalEntityMarkup"
              as="xs:string"
              select="'false'"/>
   <xsl:variable name="outputCitation"
                 as="xs:boolean"
                 select="if ($outputEmbeddedCitations = 'true') then true() else false()"/>
   <xsl:variable name="passThroughGlobalEntity"
                 as="xs:boolean"
                 select="if ($passThroughGlobalEntityMarkup = 'true') then true() else false()"/>
   <!-- Set as 'true' if you want errors thrown for elements or attributes not explicitly matched elsewhere; elements are output and wrapped in error element.  Set to 'false' to drop entirely plus no errors; set to 'noErrors' to suppress errors but still copy elements and attributes to the output; set to ROCKET (default) for error messages to be output with offending element/attribute suppressed (no forced schema validation error).  -->
   <xsl:param name="outputUnmatchedElements" as="xs:string" select=" 'ROCKET' "/>
   <xsl:param name="debugMode" as="xs:string" select=" 'false' "/>
   <xsl:variable name="debug"
                 as="xs:boolean"
                 select="if ($debugMode = 'true') then true() else false()"/>
   <!-- Current date/time and file being processed; these global variables only really used for debug/error processing.  current-dateTime() outputs in YYYY-MM-DDTHH:MM:SS-TZ:TZ format when we need YYYY-MM-DD HH:MI:SS   -->
   <xsl:param name="sourceFilename"
              as="xs:string*"
              select=" tokenize( document-uri(/) , '/' )[last()] "/>
   <xsl:variable name="fileName"
                 as="xs:string"
                 select="if (string($sourceFilename) = '') then 'UNKNOWN' else $sourceFilename"/>
   <xsl:variable name="dateTime"
                 as="xs:string"
                 select=" translate( substring( string(current-dateTime()) , 1 , 19 ) , 'T' , ' ' ) "/>
   <!--  Helpfule for Fab pipeline processing to indicate bundle ID   -->
   <xsl:param name="bundleID" as="xs:string" select=" 'UNKNOWN' "/>
   <!--  @SBy:  2016-09-20  ROM 1218 IRM Strategic:  add variables introduced by copyright and LEGDOC-LDC conversions  -->
   <xsl:variable name="acceptableID_Chars"
                 as="xs:string"
                 select=" 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_:' "/>
   <xsl:variable name="unallowedFirstCharAcceptableID_Chars"
                 as="xs:string"
                 select=" '0123456789.-' "/>
   <xsl:variable name="irmSection"
                 as="xs:string"
                 select="substring-after( /LEGDOC-LDC/lnv:CITE/ref:cite4thisresource/source_lnci:cite/source_lnci:content , 'IRM ' )"/>
   <xsl:param name="legacy-filename" as="xs:string" select=" '' "/>
   <!-- Creating variable to hold all upper-case letters -->
   <xsl:variable name="vUpperCase"
                 as="xs:string"
                 select=" 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' "/>
   <!-- Creating variable to hold all lower-case letters -->
   <xsl:variable name="vLowerCase"
                 as="xs:string"
                 select=" 'abcdefghijklmnopqrstuvwxyz' "/>
   <xsl:variable name="outputErrors"
                 as="xs:boolean"
                 select="if ($outputUnmatchedElements = 'true') then true() else false()"/>
   <!-- comments | text | PIs START -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Explanation</xd:b>
         </xd:p>
         <xd:p>This template rule copies over text nodes, comment nodes, and processing instructions to the target as is.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="comment() | text() | processing-instruction()">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!-- comments | text | PIs END -->   <xd:doc>
      <xd:desc>
         <xd:p>When matching the <xd:i class="xmlSource">/</xd:i> root element, just process child nodes.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="/">
      <xsl:apply-templates/>
      <!--  for fab pipeline conversions, create an override template on the root node that defines tunnel parameters for $documentLNI and $targetPlatform.  Here is JCD example, note $outputTgroupXmlID may not be necessary for your conversion    -->
      <!--xsl:apply-templates>
			<xsl:with-param name="outputTgroupXmlID" tunnel="yes" as="xs:boolean" select="false()"/>
			<xsl:with-param name="documentLNI" tunnel="yes" as="xs:string" select="if (contains( */@guid:guid , 'urn:contentItem:' )) then
					substring-after( */@guid:guid , 'urn:contentItem:' )
				else if (*/@guid:guid) then
					*/@guid:guid
				else if (contains( */source_doc:metadata/source_mncrdocmeta:chunkinfo/source_mncrdocmeta:lnlni/@lnlni , 'urn:contentItem:' )) then
					substring-after( */source_doc:metadata/source_mncrdocmeta:chunkinfo/source_mncrdocmeta:lnlni/@lnlni , 'urn:contentItem:' )
				else if (*/source_doc:metadata/source_mncrdocmeta:chunkinfo/source_mncrdocmeta:lnlni/@lnlni) then
					*/source_doc:metadata/source_mncrdocmeta:chunkinfo/source_mncrdocmeta:lnlni/@lnlni
				else 'UNKNOWN' "/>
			<xsl:with-param name="targetPlatform" tunnel="yes" as="xs:string" select=" 'fabPipeline' "/>
		</xsl:apply-templates-->
   </xsl:template>
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i class="xmlSource">lncr:*</xd:i> are just pass through, just process child elements.  <xd:i class="xmlSource">lncr:metadata</xd:i> is suppressed.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="lncr:*"><!--  drop wrapper applied to any lncr:* elements and ignore all children but elements  -->
      <xsl:apply-templates select="*"/>
   </xsl:template>

   <xsl:template match="lncr:metadata"/>
   <!--  suppress lncr:metadata and it's children  -->   <!--  matched templates  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i class="xmlSource">* | @*</xd:i> (unmatched element and attribute nodes).  This template will throw an error, unless $outputUnmatchedElements is set to 'noErrors' as a parameter to the conversion.  Named template "outputErrorMessage" is called which will use the xsl:message instruction to generate an error message.  If $outputUnmatchedElements is set to 'ICCE' (the default), then the error message will be in the form of an exception element.</xd:p>
         <xd:p>Example exception handling output:</xd:p>
         <xd:pre>
&lt;exception timestamp="2017-01-04 14:54:22"&gt;
  &lt;filename&gt;test.xml&lt;/filename&gt;
  &lt;status&gt;W&lt;/status&gt;
  &lt;code&gt;402&lt;/code&gt;
  &lt;context&gt;/jcd:judicialCourtDecision[1]/jcd:information[1]/courtcase:history[1]/courtcase:historySummary[1]/courtcase:historyItem[1]/citation:citation[1]/citation:content[1]/citation:contentSpan[1]/@citation:contentSpanRole&lt;/context&gt;
  &lt;message&gt;Unexpected Attribute:  name()=citation:contentSpanRole encountered in source document!  Attribute value is=hierarchyReference&lt;/message&gt;
&lt;/exception&gt;
			</xd:pre>
      </xd:desc>
   </xd:doc>
   <xsl:template match="* | @*"><!--  matching this pattern is an error  -->
      <xsl:param name="errorStatus" tunnel="yes" as="xs:string" select=" 'W' "/>
      <!--  default is W for warning.  If 'E' is passed, then some systems will ensure the target document is not passed along in the pipeline  -->
      <xsl:param name="targetPlatform"
                 tunnel="yes"
                 as="xs:string"
                 select=" 'ROCKET' "/>
      <!--  default is ROCKET, which outputs exception element via xsl:message.  fabPipeline outputs to target document  -->
      <xsl:param name="documentLNI"
                 tunnel="yes"
                 as="xs:string"
                 select=" 'UNKNOWN' "/>
      <!--  Used for fabPipeline only, the LNI of the document since filename is not available  -->
      <!--  calling the elementOrAttributeCopy named template to copy the node as is   -->
      <!--    if element node, wrap withinin error element  -->
      <!--    if attribute node, also output an error attribute  -->
      <xsl:choose>
         <xsl:when test=" $outputUnmatchedElements = ( 'ROCKET' , 'ICCE' ) or $targetPlatform = 'fabPipeline' ">
            <xsl:call-template name="outputErrorMessage">
               <xsl:with-param name="messageText"
                               as="xs:string"
                               select="concat( if (self::*) then          'Unexpected Element:  name()='  (:  first item is either element (self::* = true()) or attribute (otherwise)  :)         else           'Unexpected Attribute:  name()=' ,        name() ,             (:  second item is element or attribute name  :)        ' encountered in source document!' ,   (:  third item  :)        if (self::* and text()) then       (:  last item is empty string if element and no text() nodes, or if attribute and no value.  :)          concat( '  Text value is=' , string-join( text() , '' ) ) (: Otherwise provide @ value or text() value  :)         else          if (not(self::*) and . != '') then            concat( '  Attribute value is=' , . )           else '' )"/>
               <xsl:with-param name="errorType" as="xs:string" select=" $targetPlatform "/>
               <!--   ROCKET or fabPipeline error type  -->
               <xsl:with-param name="errorCode"
                               as="xs:string"
                               select=" if (self::*) then '401' else '402' "/>
               <!--   401 if element node, 402 if attribute node  -->
               <xsl:with-param name="context" as="xs:string">
                  <xsl:call-template name="generateXPath"/>
               </xsl:with-param>
               <xsl:with-param name="status" as="xs:string" select=" $errorStatus "/>
               <xsl:with-param name="documentLNI" as="xs:string" select=" $documentLNI "/>
               <!--   fabPipeline only  -->
            </xsl:call-template>
         </xsl:when>
         <xsl:when test=" $outputUnmatchedElements = 'noErrors' ">
            <xsl:sequence select="."/>
         </xsl:when>
         <xsl:when test="not($outputErrors)"/>
         <xsl:when test="self::*"><!--  self:* is false for attribute nodes  -->
            <error:error>
               <xsl:sequence select="."/>
            </error:error>
            <xsl:call-template name="outputErrorMessage">
               <xsl:with-param name="messageText"
                               as="xs:string"
                               select="concat( 'Unexpected Element:  ' , name() , ' encountered in source document!' )"/>
            </xsl:call-template>
         </xsl:when>
         <xsl:otherwise><!--  must be an attribute  -->
            <xsl:attribute name="error:error" select="'error:  unexpected attribute!'"/>
            <xsl:sequence select="."/>
            <xsl:call-template name="outputErrorMessage">
               <xsl:with-param name="messageText"
                               as="xs:string"
                               select="concat( 'Unexpected Attribute:  ' , name(..) , '/@' , name() , ' (= ' , . , ') encountered in source document!' )"/>
            </xsl:call-template>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--configurationManagementInformation xmlns="urn:x-lexisnexis:configuration-management:1">
		<title>Globally Shared Functions and Named Templates</title>
		<purpose>This stylesheet module contains XSLT functions and named templates that are globally shared regardless of transformation direction or tier, such as the named template for processing errors, etc.</purpose>
		<versionInfo>
			<version>
				<rev>-00</rev>
				<date>20-Mar-2013</date>
				<author>S. Byland</author>
				<description>Initial version.</description>
			</version>
			<version>
				<rev>A00</rev>
				<date>26-Jan-2016</date>
				<author>S. Byland</author>
				<description>Some general cleanup of comments.  Also commented out elementOrAttributeCopy named template as this method was not really used.  There is some code in the CRM LA-to-MNCR baseline that will need to be modified so as to not use this named template anymore.</description>
			</version>
		</versionInfo>
	</configurationManagementInformation-->   <!--  global custom functions  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>Global functions apply primarily to XSL style conversions but would include such items as error messaging, etc.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--  named template rules START  -->
   <!--  error detected; throw a message to the output START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>outputErrorMessage Named Template</xd:b>
         </xd:p>
         <xd:p>This named template is called whenever the XSLT needs to throw an error or warning.  It will use the xsl:message instruction to generate an error message.  If $errorType is set to 'ROCKET' (the default), then the error message will be in the form of an exception element.</xd:p>
         <xd:p>Example exception handling output:</xd:p>
         <xd:pre>
&lt;exception timestamp="2017-01-04 14:54:22"&gt;
  &lt;filename&gt;test.xml&lt;/filename&gt;
  &lt;status&gt;W&lt;/status&gt;
  &lt;code&gt;402&lt;/code&gt;
  &lt;context&gt;/jcd:judicialCourtDecision[1]/jcd:information[1]/courtcase:history[1]/courtcase:historySummary[1]/courtcase:historyItem[1]/citation:citation[1]/citation:content[1]/citation:contentSpan[1]/@citation:contentSpanRole&lt;/context&gt;
  &lt;message&gt;Unexpected Attribute:  name()=citation:contentSpanRole encountered in source document!  Attribute value is=hierarchyReference&lt;/message&gt;
&lt;/exception&gt;
				</xd:pre>
      </xd:desc>
   </xd:doc>
   <xsl:template name="outputErrorMessage">
      <xsl:param name="CurrentDBD"
                 required="no"
                 as="xs:string"
                 select=" 'notApplicable' "/>
      <xsl:param name="messageText" as="xs:string*" select=" 'Error!' "/>
      <!--  text passed in by caller  -->
      <xsl:param name="errorType" as="xs:string*" select=" 'ROCKET' "/>
      <xsl:param name="errorCode" as="xs:string*" select=" '401' "/>
      <xsl:param name="context" as="xs:string*" select=" '/unknown' "/>
      <xsl:param name="status" as="xs:string*" select=" 'W' "/>
      <xsl:param name="documentLNI" as="xs:string*" select=" 'UNKNOWN' "/>
      <!--   fabPipeline only  -->
      <xsl:choose>
         <xsl:when test=" $errorType = 'debug' "><!-- Example of how debug mode might be used; maybe auto create something like these lines after each template rule when building the monolithic and a certain flag is passed? 
					<xsl:if test=" $debug and contains( . , 'Hello Errors' ) ">
						<xsl:call-template name="outputErrorMessage">
							<xsl:with-param name="messageText" as="xs:string" select=" 'Template:  xh:p[translate( normalize-space( string-join( descendant-or-self::*/text() , ... ]' "/>
							<xsl:with-param name="errorType" as="xs:string" select=" 'debug' "/>
							<xsl:with-param name="context" as="xs:string">
								<xsl:call-template name="generateXPath"/>
							</xsl:with-param>
						</xsl:call-template>
					</xsl:if>
					 end example debug mode  -->
            <xsl:message>
               <xsl:element name="debug" inherit-namespaces="no" namespace="">
                  <xsl:attribute name="timestamp" select=" $dateTime "/>
                  <xsl:element name="message" inherit-namespaces="no" namespace="">
                     <xsl:if test=" $context != '/unknown' ">
                        <xsl:text>Context/XPath:  </xsl:text>
                        <xsl:sequence select="$context"/>
                        <xsl:text>.  </xsl:text>
                     </xsl:if>
                     <xsl:sequence select="$messageText"/>
                  </xsl:element>
               </xsl:element>
            </xsl:message>
         </xsl:when>
         <xsl:when test=" upper-case($errorType) = 'ICCE' or upper-case($errorType)='ROCKET' or $errorType = 'fabPipeline' ">
            <xsl:message>
               <xsl:element name="exception" inherit-namespaces="no" namespace="">
                  <xsl:attribute name="timestamp" select=" $dateTime "/>
                  <xsl:element name="filename" inherit-namespaces="no" namespace="">
                     <xsl:sequence select="$fileName"/>
                  </xsl:element>
                  <xsl:element name="status" inherit-namespaces="no" namespace="">
                     <xsl:sequence select="$status"/>
                  </xsl:element>
                  <xsl:element name="code" inherit-namespaces="no" namespace="">
                     <xsl:sequence select="$errorCode"/>
                  </xsl:element>
                  <xsl:element name="context" inherit-namespaces="no" namespace="">
                     <xsl:sequence select="$context"/>
                  </xsl:element>
                  <xsl:element name="message" inherit-namespaces="no" namespace="">
                     <xsl:sequence select="$messageText"/>
                  </xsl:element>
               </xsl:element>
            </xsl:message>
            <xsl:if test=" $errorType = 'fabPipeline' ">
               <xsl:choose>
                  <xsl:when test=" $errorCode = '402' ">
                     <xsl:attribute name="lnf:exception"
                                    namespace="urn:x-lexisnexis:conversion:global:functions:1">
                        <xsl:value-of select="$messageText"/>
                        <xsl:text>; sourceXPath = </xsl:text>
                        <xsl:value-of select="$context"/>
                     </xsl:attribute>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:element name="exception"
                                  inherit-namespaces="no"
                                  namespace="urn:x-lexisnexis:conversion:global:functions:1">
                        <xsl:attribute name="timestamp" select=" $dateTime "/>
                        <xsl:element name="LNI"
                                     inherit-namespaces="no"
                                     namespace="urn:x-lexisnexis:conversion:global:functions:1">
                           <xsl:sequence select="$documentLNI"/>
                        </xsl:element>
                        <xsl:element name="bundle"
                                     inherit-namespaces="no"
                                     namespace="urn:x-lexisnexis:conversion:global:functions:1">
                           <xsl:sequence select="$bundleID"/>
                        </xsl:element>
                        <xsl:element name="code"
                                     inherit-namespaces="no"
                                     namespace="urn:x-lexisnexis:conversion:global:functions:1">
                           <xsl:sequence select="$errorCode"/>
                        </xsl:element>
                        <xsl:element name="sourceXPath"
                                     inherit-namespaces="no"
                                     namespace="urn:x-lexisnexis:conversion:global:functions:1">
                           <xsl:sequence select="$context"/>
                        </xsl:element>
                        <xsl:element name="message"
                                     inherit-namespaces="no"
                                     namespace="urn:x-lexisnexis:conversion:global:functions:1">
                           <xsl:sequence select="$messageText"/>
                        </xsl:element>
                     </xsl:element>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:if>
         </xsl:when>
         <!--for DBD errors, note template matched element name directly in the output file-->
         <xsl:when test="$errorType = 'DBD'">DBDerr:<xsl:value-of select="name()"/>
            <!--<xsl:value-of select="error()"/>-->
            <xsl:if test="not($CurrentDBD='DeScopedDbd' or $CurrentDBD = 'notApplicable' )">
               <xsl:message>
                  <xsl:text>DBDerr:</xsl:text>
                  <xsl:value-of select="$CurrentDBD"/>
                  <xsl:text>:</xsl:text>
                  <xsl:value-of select="name()"/>
               </xsl:message>
            </xsl:if>
         </xsl:when>
         <xsl:otherwise>
            <xsl:message>
               <xsl:value-of select="$messageText"/>
               <!--  just output the message text to the output  -->
               <xsl:value-of select="$context"/>
            </xsl:message>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--  error detected; throw a message to the output END  -->   <!--  generate and output the source XPath START  -->   <!--  @SBy:  2016-09-20  ROM 1218 IRM Strategic:  updated to allow optionally outputting without brackets (predicates indicating sibling order)  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>generateXPath Named Template</xd:b>
         </xd:p>
         <xd:p>This named template is used to create the XPath leading to the current node in the form of a string, such as "/jcd:judicialCourtDecision[1]/jcd:information[1]/courtcase:history[1]/courtcase:historySummary[1]/courtcase:historyItem[1]/citation:citation[1]/citation:content[1]/citation:contentSpan[1]/@citation:contentSpanRole".  Parameter $includeBrackets can be set to false() to suppress the predicate output if desired.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template name="generateXPath" as="xs:string">
      <xsl:param name="includeBrackets" as="xs:boolean" select="true()"/>
      <xsl:sequence select=" string-join(  (:  use string join function to insert the '/' chars of the XPath  :)      ( '' ,            (:  Build a sequence of strings.  First item is empty to ensure XPath starts with a '/'  :)       ( for $i in ancestor-or-self::* return   (:  Walk the ancestor-or-self:: axis and return the name of each element followed by position in brackets  :)         concat( name($i) ,   (:  next item is the element name followed by position in brackets  :)            if ($includeBrackets) then concat(             '[' ,     (:  open bracket, then count preceding sibling elements of same name and add 1; convert to string  :)             string( count($i/preceding-sibling::*[name(.) = name($i)]) + 1) ,              ']'  )   (:  close bracket. This for loop returns sequence of strings in form of 'element-name[#]'  :)            else             '' )       ) ,           (:  Last item in sequence is to add the attribute name if necessary, since  :)       if (self::*) then ()     (:  ancestor-or-self::* won't include 'self' if this is an attribute  :)        else concat( '@' , name() )       ) ,      '/' ) "/>
      <!--   Use '/' as the string separator since this is an XPath  -->
   </xsl:template>
   <!--  generate and output the source XPath END  -->   <!--  combined nested trees START  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>combineTrees Named Template</xd:b>
         </xd:p>
         <xd:p>This named template is used to combine the content from following sibling elements of the same base name into a single element, such as lnv:TEXT-1, lnv:TEXT-2, etc., into a single lnv:TEXT-1 element, when these elements contain nested hierarchical content requiring the hierarchies to be knitted back together.  It assumes the sibling element descendants are structured the same way, and that the nodes can be combined at specific levels identifed by $combiningElements parameter.</xd:p>
         <xd:p>The base element name (such as "lnv:TEXT-") must be passed as parameter $baseEleName, and the sibling nodes passed as $nodesToCombine.</xd:p>
         <xd:p>Recursion is used to process through all the siblings provided in $nodesToCombine.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template name="combineTrees" as="element()"><!--  combines the content from following sibling elements of the same base name into a single element (into the "-1" element of same name)  --><!--  assumes the sibling element descendants are structured the same way, and that the nodes can be combined at specific levels identifed by $combiningElements parameter  -->
      <xsl:param name="baseEleName" tunnel="yes" as="xs:string"/>
      <!--  base element name before the digit, such as 'lnv:TEXT-'  -->
      <xsl:param name="nodesToCombine" as="document-node()"/>
      <!--  all of the, or the remaing, sibling segments to be combined under one element  -->
      <xsl:param name="combiningElements" as="xs:string*"/>
      <!--  sequence of element names (strings) where node combining can occur  -->
      <xsl:variable name="updatedTree" as="element()"><!--  combine first remaining segment with second remaining segment and save in this variable  -->
         <xsl:apply-templates select="$nodesToCombine/*/*[1]" mode="combineTrees"><!--  perform combinging of nodes via the combineTrees mode   -->
            <xsl:with-param name="matchingXPath" tunnel="yes" as="xs:string"><!--  node combining will occur when current XPath matches this XPath   --><!--  the matching XPath is determined by first finding the last node in the document that contains text.  Then, start moving up the ancestor-or-self axis until arrive at one of the elements identified in $combiningElements   -->
               <xsl:for-each select="$nodesToCombine/*/*[1]/descendant-or-self::*[text()][last()]/ancestor-or-self::*[ name() = $combiningElements ][1]">
                  <xsl:call-template name="generateXPath"/>
                  <!--  utility that returnes the XPath of the current node   -->
               </xsl:for-each>
            </xsl:with-param>
            <xsl:with-param name="baseEleName"
                            tunnel="yes"
                            as="xs:string"
                            select="$baseEleName"/>
            <!--  pass on baseEleName  -->
            <xsl:with-param name="currentEleName"
                            tunnel="yes"
                            as="xs:string"
                            select=" name( $nodesToCombine/*/*[1] ) "/>
            <!--  pass on the name of the first remaining segment  -->
            <xsl:with-param name="nextEleName"
                            tunnel="yes"
                            as="xs:string"
                            select=" name( $nodesToCombine/*/*[2] ) "/>
            <!--  pass on the name of the next remaining segment  -->
         </xsl:apply-templates>
      </xsl:variable>
      <xsl:choose>
         <xsl:when test="$nodesToCombine/*/*[3]"><!--  if there are 3 or more siblings, then need to recurse   -->
            <xsl:call-template name="combineTrees">
               <xsl:with-param name="baseEleName"
                               tunnel="yes"
                               as="xs:string"
                               select="$baseEleName"/>
               <!--  pass on baseEleName  -->
               <xsl:with-param name="nodesToCombine" as="document-node()"><!--  update nodesToContinue to first be the $updatedTree followed by all other sibling after the 2nd one  -->
                  <xsl:document><!--  Forcing nodesToCombine element below to be in the empty namespace.  This is necessary because even though there is no default namespace declared in this XSLT file, 
											there usually is when building the monolithic deliverable stylesheet (and it is set to the base: namespace URI).  In that scenario, when transforming with the monolithic XSLT, 
											this element would be in the base: namespace, and will cause Saxon to throw various errors since the non-namespaced children being combined below are in the empty namespace.  
											Saxon is require to output all the namespace nodes that are in scope for each element, and to have a default namespace of base: copied for an element that is in no namespace is an error.  -->
                     <nodesToCombine xmlns="">
                        <xsl:copy-of select="$updatedTree"/>
                        <!--  first the $updatedTree containing the newly combined siblings  -->
                        <xsl:copy-of select="$nodesToCombine/*/*[ position() gt 2 ]"/>
                        <!--  remaining siblings to be combined  -->
                     </nodesToCombine>
                  </xsl:document>
               </xsl:with-param>
               <xsl:with-param name="combiningElements"
                               as="xs:string*"
                               select="$combiningElements"/>
               <!--  pass on combiningElements  -->
            </xsl:call-template>
         </xsl:when>
         <xsl:otherwise>
            <xsl:copy-of select="$updatedTree"/>
            <!--  all siblings combined, just output the newly combined tree   -->
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--  combined nested trees END  -->   <!--  combineSiblingsOfSameName START  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>combineSiblingsOfSameName Named Template</xd:b>
         </xd:p>
         <xd:p>This named template is used to combine immediate siblings of the same name into a single target element (instead of multiple target elements of same name).</xd:p>
         <xd:p>Within the template of the first sibling, create the output element and apply-templates on child nodes of that element first.  Then use for-each to change context to the next sibling and call this named template.</xd:p>
         <xd:p>Be sure to suppress elements of the same name that have preceding siblings with that name (elementXYX[ preceding-sibling::node()[1][ self::elementXYX ] ]).</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template name="combineSiblingsOfSameName" as="item()*"><!--  this named template assumes the first sibling's attribute and nodes were already processed, so first call to this rule is the second immediate sibling   --><!--  capture name of current element   -->
      <xsl:variable name="currentEleName" as="xs:string" select="name( . )"/>
      <!--  process child nodes; note attribute nodes are skipped in deference to the first sibling's attributes   -->
      <xsl:apply-templates select="node()"/>
      <!--  recursively process the next immediately following sibling node if it has the same name   -->
      <xsl:for-each select="following-sibling::node()[1][ name() = $currentEleName ]">
         <xsl:call-template name="combineSiblingsOfSameName"/>
      </xsl:for-each>
   </xsl:template>
   <!--  combineSiblingsOfSameName END  -->   <!--  named template rules END  -->   <!--  modal template rules START  -->   <!--  combined nested trees mode START  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>combineTrees Processing Mode</xd:b>
         </xd:p>
         <xd:p>mode="combineTrees" is used in conjunction with the combineTrees named template to combine multiple siblings into a single element (see description for "combineTrees Named Template").</xd:p>
         <xd:p>For most nodes in the tree, this mode will simply copy itself to the output destination (equivalent to the identity template).</xd:p>
         <xd:p>However, if the current node is a location where a pair of siblng structures can be combined, the combining is done as part of this mode and processing continues.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="node()" mode="combineTrees"><!--  the combineTree mode is used to copy nodes at the same location in a sibling tree as following siblings in current location  -->
      <xsl:param name="matchingXPath" tunnel="yes" as="xs:string"/>
      <!--  the path to the last node containing text in the tree to be combined into  -->
      <xsl:param name="baseEleName" tunnel="yes" as="xs:string"/>
      <!--  base element name before the digit, such as 'lnv:TEXT-'  -->
      <xsl:param name="currentEleName" tunnel="yes" as="xs:string"/>
      <!--  element name of the base of the tree to be combined into  -->
      <xsl:param name="nextEleName" tunnel="yes" as="xs:string"/>
      <!--  element name of the base of the tree to be combined from  -->
      <xsl:variable name="currentXPath" as="xs:string"><!--  determine XPath of current node for later use  -->
         <xsl:call-template name="generateXPath"/>
      </xsl:variable>
      <xsl:copy><!--  copy over current node and attributes to the combined tree  -->
         <xsl:copy-of select="@*"/>
         <xsl:apply-templates select="node()" mode="combineTrees"/>
         <!--  process child nodes to be output first, then determine if nodes from other tree need to be copied over as following siblings  -->
         <xsl:if test="$matchingXPath = $currentXPath"><!--  if processing the last text-containing node in the primary tree, then need to copy over remaining nodes in following tree as siblings  -->
            <xsl:variable name="currentXPathNoBrackets" as="xs:string"><!--  create and save version of current XPath without the square brackets (predicates)  -->
               <xsl:call-template name="generateXPath">
                  <xsl:with-param name="includeBrackets" as="xs:boolean" select="false()"/>
               </xsl:call-template>
            </xsl:variable>
            <xsl:for-each select="/*/*[ name() = $nextEleName ]/descendant-or-self::*[text()][1]"><!--  now change context over to the first text-containing node in the sibling tree (the one with base element name of $nextEleName)  -->
               <xsl:for-each select="ancestor-or-self::*"><!--  start up the ancestor-or-self axis until XPaths match.  Note this should end up at one of the elements identified in $combiningElements  -->
                  <xsl:variable name="altTreeXPath" as="xs:string"><!--  capture the XPath to compare against current XPath; again no predicates  -->
                     <xsl:call-template name="generateXPath">
                        <xsl:with-param name="includeBrackets" as="xs:boolean" select="false()"/>
                     </xsl:call-template>
                  </xsl:variable>
                  <!--  since the base element names are different, need to only compare strings after those element names  -->
                  <xsl:if test="substring-after( $altTreeXPath , $nextEleName ) = substring-after( $currentXPathNoBrackets , $currentEleName )">
                     <xsl:copy-of select="*"/>
                     <!--  if the XPaths match, copy over the children.  Note current output destination is the same spot in primary tree   -->
                  </xsl:if>
               </xsl:for-each>
            </xsl:for-each>
         </xsl:if>
      </xsl:copy>
      <!--  now need to check if there are nodes in sibling tree that need to get copied *after* current node.  Only check when XPath is the same, or starts with, the matching XPath (leading to last text-containing node in primary tree)  -->
      <xsl:if test="starts-with( $matchingXPath , $currentXPath )">
         <xsl:variable name="currentXPathNoBrackets" as="xs:string"><!--  again, create and save version of current XPath without the square brackets (predicates)  -->
            <xsl:call-template name="generateXPath">
               <xsl:with-param name="includeBrackets" as="xs:boolean" select="false()"/>
            </xsl:call-template>
         </xsl:variable>
         <xsl:for-each select="/*/*[ name() = $nextEleName ]/descendant-or-self::*[text()][1]"><!--  now change context just like before.  The processing below is same, except the copy-of will grab different nodes  -->
            <xsl:for-each select="ancestor-or-self::*">
               <xsl:variable name="altTreeXPath" as="xs:string">
                  <xsl:call-template name="generateXPath">
                     <xsl:with-param name="includeBrackets" as="xs:boolean" select="false()"/>
                  </xsl:call-template>
               </xsl:variable>
               <xsl:if test="substring-after( $altTreeXPath , $nextEleName ) = substring-after( $currentXPathNoBrackets , $currentEleName )"><!--  if the XPaths match, need to copy over the following siblings of the same node as in the output destination.  Just up to parent and copy child::* as long as not first one.  -->
                  <xsl:copy-of select="../*[position() != 1][not( starts-with( name() , $baseEleName ) )]"/>
               </xsl:if>
            </xsl:for-each>
         </xsl:for-each>
      </xsl:if>
   </xsl:template>
   <!--  combined nested trees mode END  -->   <!--  default fixSourceNesting mode START  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>fixSourceNesting Processing Mode (default rule)</xd:b>
         </xd:p>
         <xd:p>mode="fixSourceNesting" for any node matching this rule will simply copy itself to the output destination (equivalent to the identity template).</xd:p>
         <xd:p>It does trap elements in the lndocmeta <xd:i class="xmlSource">source</xd:i> namespace and ensures they remain in the source namespace after copying.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="node()" mode="fixSourceNesting"><!--  the fixSourceNesting mode can be used to resolve issues such as p/lnvxe:text/lnvxe:note when, in the target, note and p are siblings  --><!--  default for this mode is identity template, so first copy over current node and attributes  -->
      <xsl:choose>
         <xsl:when test=" not( self::* ) or ( contains( name() , ':' ) and not( substring-before( name() , ':' ) = 'lndocmeta' ) ) ">
            <xsl:copy>
               <xsl:copy-of select="@*"/>
               <xsl:apply-templates select="node()" mode="fixSourceNesting"/>
               <!--  process child nodes  -->
            </xsl:copy>
         </xsl:when>
         <xsl:otherwise>
            <xsl:variable name="nsURI"
                          as="xs:string"
                          select=" if ( substring-before( name() , ':' ) = 'lndocmeta' ) then 'http://www.lexis-nexis.com/lndocmeta' else '' "/>
            <xsl:variable name="eleName"
                          as="xs:string"
                          select=" if ( substring-before( name() , ':' ) = 'lndocmeta' ) then local-name() else name() "/>
            <xsl:element name="{name()}" namespace="{$nsURI}">
               <xsl:copy-of select="@*"/>
               <xsl:apply-templates select="node()" mode="fixSourceNesting"/>
               <!--  process child nodes  -->
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--  default fixSourceNesting mode END  -->   <!--  modal template rules END  -->   <!--  functions START  -->   <!--  lnf:trim Function START  -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:trim Function</xd:b>
         </xd:p>
         <xd:p>Adapted from "functx:trim" (http://www.xsltfunctions.com/xsl/functx_trim.html)</xd:p>
         <xd:p>This function removes whitespace at the beginning and end of a string.  Unlike the built-in normalize-space function, it only removes leading and trailing whitespace, not whitespace in the middle of the value. Whitespace is defined as it is in XML, namely as space, tab, carriage return and line feed characters. If $arg is the empty sequence, it returns a zero-length string.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:trim" as="xs:string">
      <xsl:param name="arg" as="xs:string?"/>
      <xsl:sequence select=" replace( replace( $arg , '\s+$' , '' ) , '^\s+' , '' ) "/>
   </xsl:function>
   <!--  lnf:trim Function END  -->
   <!--  replaceString START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:replaceString Function</xd:b>
         </xd:p>
         <xd:p>This function was created to remove specific string segments from the VISF output as part of the MNCR to VISF code base.</xd:p>
         <xd:p>It will remove all occurrences of all string segments contained within $states from the input string $fileCodeInput.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:replaceString" as="xs:string">
      <xsl:param name="fileCodeInput" as="xs:string"/>
      <xsl:param name="states" as="xs:string*"/>
      <xsl:choose>
         <xsl:when test=" (for $s in $states return contains( $fileCodeInput , $s ))[.][1] ">
            <xsl:variable name="fileCodeInputNew" as="xs:string*">
               <xsl:for-each select="$states[ contains( $fileCodeInput , . ) ][1]">
                  <xsl:sequence select="substring-before( $fileCodeInput , . )"/>
                  <xsl:sequence select="substring-after( $fileCodeInput , . )"/>
               </xsl:for-each>
            </xsl:variable>
            <xsl:sequence select="lnf:replaceString( string-join( $fileCodeInputNew , '' ) , $states )"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="$fileCodeInput"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:function>
   <!--  replaceString END  -->
   <!-- titleCase START -->
   <xd:doc>
      <xd:desc>
         <xd:p>Function to return a string in Title Case. Currently configured to exclude 'and', 'or'.</xd:p>
         <xd:p>Call using &lt;xsl:sequence select="string-join(for $x in tokenize($text,'\s') return lnf:titleCase($x),' ')"/&gt;</xd:p>
      </xd:desc>
   </xd:doc>
   <!-- function copied from http://p2p.wrox.com/xslt/80938-title-case-string.html -->
   <xsl:function name="lnf:titleCase">
      <xsl:param name="s" as="xs:string"/>
      <xsl:choose><!-- when lower case string is 'and', 'or' just output  -->
         <xsl:when test="lower-case($s)=('and','or')">
            <xsl:value-of select="lower-case($s)"/>
         </xsl:when>
         <!-- when the string is in upper case the below would originally pass through in all upper case; commenting -->
         <!--<xsl:when test="$s=upper-case($s)">
				<!-\-<xsl:value-of select="$s"/>-\->
			</xsl:when>-->
         <!-- otherwise convert the first char to upper case and subsequent chars to lower case  -->
         <xsl:otherwise>
            <xsl:value-of select="concat(upper-case(substring($s, 1, 1)), lower-case(substring($s, 2)))"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:function>
   <!-- titleCase END -->
   <!-- stringToTitleCase START -->
   <xsl:function name="lnf:stringToTitleCase" as="xs:string">
      <xsl:param name="inputString" as="xs:string"/>
      <!--  input string of one or more words  -->
      <xsl:param name="keepAllLower" as="xs:string*"/>
      <!--  string sequence of words to keep as lowercase, such as the, or, and, for, of  -->
      <xsl:variable name="outputSequence" as="xs:string*">
         <xsl:for-each select="tokenize( $inputString , '\s' )">
            <xsl:choose><!-- when lower case string is any one of $keepAllLower, just output lower-case of it  -->
               <xsl:when test="lower-case( . ) = $keepAllLower">
                  <xsl:value-of select="lower-case( . )"/>
               </xsl:when>
               <xsl:when test="contains( . , '-' )">
                  <xsl:value-of select="lnf:genStringToTitleCase( . , $keepAllLower , '-' )"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="concat( upper-case( substring( . , 1 , 1 ) ) , lower-case( substring( . , 2 ) ) )"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each>
      </xsl:variable>
      <xsl:sequence select="string-join( $outputSequence , ' ' )"/>
      <!--  string join the sequence with a space as the separator  -->
   </xsl:function>
   <!-- stringToTitleCase END -->
   <!-- genStringToTitleCase START -->
   <xsl:function name="lnf:genStringToTitleCase" as="xs:string">
      <xsl:param name="inputString" as="xs:string"/>
      <!--  input string of one or more words  -->
      <xsl:param name="keepAllLower" as="xs:string*"/>
      <!--  string sequence of words to keep as lowercase, such as the, or, and, for, of  -->
      <xsl:param name="stringSeparator" as="xs:string"/>
      <!--  character to break up/tokenize string, normally a space  -->
      <xsl:variable name="outputSequence" as="xs:string*">
         <xsl:for-each select="tokenize( $inputString , $stringSeparator )">
            <xsl:choose><!-- when lower case string is any one of $keepAllLower, just output lower-case of it  -->
               <xsl:when test="lower-case( . ) = $keepAllLower">
                  <xsl:value-of select="lower-case( . )"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="concat( upper-case( substring( . , 1 , 1 ) ) , lower-case( substring( . , 2 ) ) )"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each>
      </xsl:variable>
      <xsl:sequence select="string-join( $outputSequence , $stringSeparator )"/>
      <!--  string join the sequence with the separator  -->
   </xsl:function>
   <!-- genStringToTitleCase END -->
   <!--  removeSequenceOfStrings START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:removeSequenceOfStrings Function</xd:b>
         </xd:p>
         <xd:p>This function was created to remove a set of substrings from an input string, if any of these strings exist in the input string</xd:p>
         <xd:p>$stringsToRemove is the input string sequence of *regex* items; the function will go through this sequence one by one and remove all occurrences of each item in this sequence.</xd:p>
         <xd:p>The removal can be case sensitive or case insensitive.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:removeSequenceOfStrings" as="xs:string">
      <xsl:param name="inputString" as="xs:string"/>
      <xsl:param name="stringsToRemove" as="xs:string*"/>
      <xsl:param name="caseInsensitive" as="xs:boolean"/>
      <xsl:choose>
         <xsl:when test=" string-join( $stringsToRemove , '' ) = '' ">
            <xsl:sequence select="$inputString"/>
         </xsl:when>
         <xsl:when test=" $stringsToRemove[1] = '' or $stringsToRemove[1] = () ">
            <xsl:sequence select="lnf:removeSequenceOfStrings( $inputString , remove($stringsToRemove, 1) , $caseInsensitive )"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:sequence select="lnf:removeSequenceOfStrings( replace( $inputString , $stringsToRemove[1] , '' , if ($caseInsensitive) then 'i' else '' ) , remove($stringsToRemove, 1) , $caseInsensitive )"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:function>
   <!--  removeSequenceOfStrings END  -->
   <!--  @SBy:  2016-09-20  ROM 1218 IRM Strategic:  add substringBeforeLast function  -->
   <!--   Original idea from Tomalak at stackoverflow, http://stackoverflow.com/questions/1119449/removing-the-last-characters-in-an-xslt-string/1119666#1119666  -->
   <!--  substringBeforeLast START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:substringBeforeLast Function</xd:b>
         </xd:p>
         <xd:p>This function will return that part of an input string that appears before the final occurence of an input substring.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:substringBeforeLast" as="xs:string">
      <xsl:param name="inputString" as="xs:string"/>
      <xsl:param name="searchString" as="xs:string"/>
      <xsl:variable name="remString"
                    as="xs:string"
                    select="substring-after( $inputString , $searchString )"/>
      <xsl:sequence select="concat(              substring-before( $inputString , $searchString ) ,              if (contains( $remString , $searchString )) then               concat( $searchString ,                lnf:substringBeforeLast( $remString , $searchString )              )              else '' )"/>
   </xsl:function>
   <!--  substringBeforeLast END  -->
   <!--  @SBy:  2016-11-04  ROM 1218 IRM Strategic:  save the DOC-ID string logic for use in ref:cross-reference  -->
   <!--  createDocIdString START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:createDocIdString Function</xd:b>
         </xd:p>
         <xd:p>This function will create the correct string for DOC-ID style links for certain conversions.  For the Internal Revenue Manual as an example, where $legacy-filename = 'IRSMNL', and input string is 'IRM 3.10.72', the output string will be 'IRSMNL-3_10_72'.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:createDocIdString" as="xs:string">
      <xsl:param name="inputElement" as="element()"/>
      <xsl:variable name="inputString"
                    as="xs:string"
                    select="if ($inputElement/source_lnci:cite/@normcite != '') then                         $inputElement/source_lnci:cite/@normcite                        else                        if (starts-with( string( $inputElement ) , 'IRM ' )) then                         substring-after( string( $inputElement ) , 'IRM ' )                        else                         string( $inputElement )"/>
      <xsl:variable name="badCharacters"
                    as="xs:string"
                    select="translate( $inputString , $acceptableID_Chars , '' )"/>
      <xsl:variable name="normString"
                    select="translate( $inputString , $badCharacters , ' ' )"/>
      <xsl:variable name="outputString"
                    select="translate( normalize-space( $normString ) , ' .' , '__' )"/>
      <xsl:sequence select="concat( $legacy-filename , '-' , $outputString )"/>
   </xsl:function>
   <!--  createDocIdString END  -->
   <!--  @SBy:  2017-05-25  ROCKET ReWrites:  function to return a string that is a valid value for attributes of type ID  -->
   <!--  createValidIDstring START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:createValidIDstring Function</xd:b>
         </xd:p>
         <xd:p>Given an arbitrary input string, this function will return a string that is valid for attribute values of type ID. </xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:createValidIDstring" as="xs:string">
      <xsl:param name="inputString" as="xs:string"/>
      <xsl:variable name="badCharacters"
                    as="xs:string"
                    select="translate( $inputString , $acceptableID_Chars , '' )"/>
      <xsl:variable name="normString"
                    select="translate( $inputString , $badCharacters , '' )"/>
      <xsl:sequence select="if (translate( substring( $normString , 1 , 1 ) , $unallowedFirstCharAcceptableID_Chars , '' ) = '') then concat( '_' , $normString ) else $normString"/>
   </xsl:function>
   <!--  createValidIDstring END  -->
   <!--  NOTE:  the next two functions can allow a transformation to not require sibling recursion moded rules such as mode="textEleRecurse".   However, this function does not apply templates and so does not
				work in the "target" space.  One must use this function and throw results to a variable, then apply templates on that variable to transform the nodes to target format.  Keep in mind that any processing
				of such a variable only has the variable plus descendants in scope.  So, for example, footnote processing that looks for matching node values in the entire source document tree will not actually
				be searching the entire tree anymore, just the tree defined by the variable.  In general, it is safest to use these functions when writing the entire document to a variable and then A-T on that variable.  -->
   <!--  @SBy:  2017-01-17  ROM 1218 IRM Strategic:	general function version of sibling recursion type grouping, for situations such as 
																					handling children of "p" in the source converting to p/text - p/blockquote - p/text etc. in the target  -->
   <!--  siblingBlockGrouping START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:siblingBlockGrouping Function</xd:b>
         </xd:p>
         <xd:p>This function will sibling recursion type grouping for situations such as handling children of "p" in the source converting to p/text - p/blockquote - p/text etc. in the target; for that scenario, the $groupingContainer = 'text' (the text element), $blockElements = ('blockquote', 'table', etc), and $siblingNodes would contain the set of siblings that need to be split into groups of $groupingContainer elements broken up by $blockElements.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:siblingBlockGrouping" as="item()*">
      <xsl:param name="groupingContainer" as="xs:string"/>
      <!--  name of container element to group consecutive siblings under (typically the "text" element)   -->
      <xsl:param name="blockElements" as="xs:string*"/>
      <!--  list of element names (can be empty string) that cannot be grouped under $groupingContainer (typically table, blockquote, etc)   -->
      <xsl:param name="siblingNodes" as="element()"/>
      <!--  (remaining) sibling nodes (typically text() nodes and elements, can be instances of $groupingContainer too) to perform grouping on, all under a single element parent  -->
      <!--  save name of element parent  -->
      <xsl:variable name="siblingNodesParent"
                    as="xs:string"
                    select="name($siblingNodes)"/>
      <xsl:for-each select="$siblingNodes/node()[1]">
         <xsl:choose><!--  if the first node is not an element, OR it is an element but there are no blockElements and it's not groupingContainer, or it's an element not in blockElements and it's not groupingContainer; then create container and move on   -->
            <xsl:when test=" not(self::*) or ( $blockElements = '' and not( name() = $groupingContainer ) ) or not( name() = $blockElements or name() = $groupingContainer ) ">
               <xsl:element name="{$groupingContainer}" namespace=""><!--  create container   -->
                  <xsl:choose>
                     <xsl:when test=" $blockElements = '' or not( following-sibling::node()[name() = $blockElements or name() = $groupingContainer] ) "><!--  no grouping required; just copy self and all following siblings to output, and no recurse   -->
                        <xsl:copy-of select="."/>
                        <xsl:copy-of select="following-sibling::node()"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:for-each select="following-sibling::node()[name() = $blockElements or name() = $groupingContainer][1]"><!--  grouping required; change context to the first blocker (either a group container or block element) and then copy over alll preceding siblings; close container   -->
                           <xsl:copy-of select="preceding-sibling::node()"/>
                        </xsl:for-each>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:element>
               <!--  if grouping was required in prior section; change context to the first blocker again to copy over the blocker, and if necessary initiate recursive call   -->
               <xsl:if test=" not( $blockElements = '' or not( following-sibling::node()[name() = $blockElements or name() = $groupingContainer] ) ) ">
                  <xsl:for-each select="following-sibling::node()[name() = $blockElements or name() = $groupingContainer][1]"><!--  copy over the blocker or container   -->
                     <xsl:copy-of select="."/>
                     <!--  if there are following siblings, need to recurse   -->
                     <xsl:if test="following-sibling::node()"><!--  update sibling list to be only the remaining following siblings   -->
                        <xsl:variable name="siblingNodesUpdated" as="element()">
                           <xsl:element name="{$siblingNodesParent}">
                              <xsl:copy-of select="following-sibling::node()"/>
                           </xsl:element>
                        </xsl:variable>
                        <!--  recurse   -->
                        <xsl:sequence select=" lnf:siblingBlockGrouping( $groupingContainer , $blockElements , $siblingNodesUpdated ) "/>
                     </xsl:if>
                  </xsl:for-each>
               </xsl:if>
            </xsl:when>
            <!--  first node is an element, AND it is an element that is either in blockElements or in groupingContainer. This is the only other possibility, so using xsl:otherwise.  Copy myself over, and recurse    -->
            <!--xsl:when test=" name() eq $blockElements or name() eq $groupingContainer "-->
            <xsl:otherwise><!--  since we are a blocker or container, copy over myself   -->
               <xsl:copy-of select="."/>
               <!--  if there are following siblings, need to recurse   -->
               <xsl:if test="following-sibling::node()"><!--  update sibling list to be only the remaining following siblings   -->
                  <xsl:variable name="siblingNodesUpdated" as="element()"><!-- JD: 2017-04-04: added namespace="" and copy-namespaces="no" after 
							getting error "XTDE0440: Cannot output a namespace node for the default namespace when the element is in no namespace" (source lnvxe:footnote with p child)-->
                     <xsl:element name="{$siblingNodesParent}" namespace="">
                        <xsl:copy-of select="following-sibling::node()" copy-namespaces="no"/>
                     </xsl:element>
                  </xsl:variable>
                  <!--  recurse   -->
                  <xsl:sequence select=" lnf:siblingBlockGrouping( $groupingContainer , $blockElements , $siblingNodesUpdated ) "/>
               </xsl:if>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:function>
   <!--  siblingBlockGrouping END  -->
   <!--  @SBy:  2017-01-17  ROM 1218 IRM Strategic:	general function to pull child elements up to be intermingled with the parent.  For example,  
																					handling children note elements of "p" in the source converting to p then note then p then note etc.in the target  -->
   <!--  siblingToParentGrouping START  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>lnf:siblingToParentGrouping Function</xd:b>
         </xd:p>
         <xd:p>This function will pull child elements up to be intermingled with the parent, such as handling children lnvxe:note elements of "p" in the source converting to p then lnvxe:note then p then lnvxe:note etc.in the target; for that scenario, the $childElements = 'lnvxe:note' (the note element), $currentParent would contain the parent that had one or more $childElements elements needing to be pulled up to the parent level.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:function name="lnf:siblingToParentGrouping" as="item()*">
      <xsl:param name="childElements" as="xs:string*"/>
      <!--  list of element names (such as lnvxe:note) that need to be pulled up and mingled with the parent   -->
      <xsl:param name="currentParent" as="element()"/>
      <!--  the current single parent that contains one or more nodes including $childElements  -->
      <!--  save name of element parent  -->
      <xsl:variable name="currentParentName"
                    as="xs:string"
                    select="name($currentParent)"/>
      <xsl:for-each select="$currentParent/node()[1]">
         <xsl:choose><!--  if the first node is not an element, OR it is an element but there are no childElements, or it's an element not in childElements; then create currentParent and move on   -->
            <xsl:when test=" not(self::*) or ( $childElements = '' ) or not( name() = $childElements ) ">
               <xsl:choose>
                  <xsl:when test=" contains( $currentParentName , ':' ) ">
                     <xsl:element name="{$currentParentName}"><!--  create container   -->
                        <xsl:choose>
                           <xsl:when test=" $childElements = '' or not( following-sibling::node()[name() = $childElements] ) "><!--  no grouping required; just copy self and all following siblings to output, and no recurse   -->
                              <xsl:copy-of select="." copy-namespaces="no"/>
                              <xsl:copy-of select="following-sibling::node()" copy-namespaces="no"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:for-each select="following-sibling::node()[name() = $childElements][1]"><!--  grouping required; change context to the first childElements element and then copy over alll preceding siblings; close currentParent   -->
                                 <xsl:copy-of select="preceding-sibling::node()" copy-namespaces="no"/>
                              </xsl:for-each>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:element>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:element name="{$currentParentName}" namespace=""><!--  create container   -->
                        <xsl:choose>
                           <xsl:when test=" $childElements = '' or not( following-sibling::node()[name() = $childElements] ) "><!--  no grouping required; just copy self and all following siblings to output, and no recurse   -->
                              <xsl:copy-of select="." copy-namespaces="no"/>
                              <xsl:copy-of select="following-sibling::node()" copy-namespaces="no"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:for-each select="following-sibling::node()[name() = $childElements][1]"><!--  grouping required; change context to the first childElements element and then copy over alll preceding siblings; close currentParent   -->
                                 <xsl:copy-of select="preceding-sibling::node()" copy-namespaces="no"/>
                              </xsl:for-each>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:element>
                  </xsl:otherwise>
               </xsl:choose>
               <!--  if grouping was required in prior section; change context to the first childElements element again to copy over the childElements element, and if necessary initiate recursive call   -->
               <xsl:if test=" not( $childElements = '' or not( following-sibling::node()[name() = $childElements] ) ) ">
                  <xsl:for-each select="following-sibling::node()[name() = $childElements][1]"><!--  copy over the childElements element   -->
                     <xsl:copy-of select="." copy-namespaces="no"/>
                     <!--  if there are following siblings, need to recurse   -->
                     <xsl:if test="following-sibling::node()"><!--  update sibling list to be only the remaining following siblings   -->
                        <xsl:variable name="currentParentUpdated" as="element()">
                           <xsl:element name="{$currentParentName}">
                              <xsl:copy-of select="following-sibling::node()" copy-namespaces="no"/>
                           </xsl:element>
                        </xsl:variable>
                        <!--  recurse   -->
                        <xsl:sequence select=" lnf:siblingToParentGrouping( $childElements , $currentParentUpdated ) "/>
                     </xsl:if>
                  </xsl:for-each>
               </xsl:if>
            </xsl:when>
            <!--  first node is an element, AND it is an element that is in childElements. This is the only other possibility, so using xsl:otherwise.  Copy myself over, and recurse    -->
            <!--xsl:when test=" name() eq $blockElements or name() eq $groupngContainer "-->
            <xsl:otherwise><!--  since we are a childElements element, copy over myself   -->
               <xsl:copy-of select="." copy-namespaces="no"/>
               <!--  if there are following siblings, need to recurse   -->
               <xsl:if test="following-sibling::node()"><!--  update sibling list to be only the remaining following siblings   -->
                  <xsl:variable name="currentParentUpdated" as="element()">
                     <xsl:element name="{$currentParentName}">
                        <xsl:copy-of select="following-sibling::node()" copy-namespaces="no"/>
                     </xsl:element>
                  </xsl:variable>
                  <!--  recurse   -->
                  <xsl:sequence select=" lnf:siblingToParentGrouping( $childElements , $currentParentUpdated ) "/>
               </xsl:if>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:function>
   <!--  siblingToParentGrouping END  -->
   <!-- This template takes an element having @month, @day, or @year attributes and provides the provided attributes and their enhanced values back to the element. -->
   <!-- Much of the logic is designed to create a normalized date value of YYYY-MM-DD.   -->
   <!-- @month is tested for value between 1 and 12.  If other value exists, it outputs but does not create a normalized date. Leading zeros added if value is below 9. -->
   <!-- @day is tested for value between 1 and 31.  If other value exists, it outputs but does not create a normalized date. Leading zeros added if value is below 9. -->
   <!-- @year is tested for four characters.  By testing for current year value the template outputs a four digit year value when only provided with a two digit year value.  -->
   <!-- Some logic taken from DATE template in '/dataArch/XSLT/ContentArch/CRE-to-LA/modules/lnvxe/n=DATE.xsl' -->
   <xsl:template name="DATE_attributes">
      <xsl:param name="date"/>
      <xsl:variable name="dayValue" as="xs:integer">
         <xsl:choose>
            <xsl:when test="$date/date/@day">
               <xsl:value-of select="xs:integer($date/date/@day)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:text>0</xsl:text>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="monthValue" as="xs:integer">
         <xsl:choose>
            <xsl:when test="$date/date/@month">
               <xsl:value-of select="xs:integer($date/date/@month)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:text>0</xsl:text>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="monthValueString"
                    as="xs:string"
                    select="if ($monthValue lt 10 and $monthValue gt 0) then concat( '0' , string($monthValue) ) else string($monthValue)"/>
      <!-- 20170516:  MCJ:  Added default for $yearValue as was already done for $monthValue and $dayValue. -->
      <!-- <xsl:variable name="yearValue" as="xs:integer" select="xs:integer($date/date/@year)"/> -->
      <xsl:variable name="yearValue" as="xs:integer">
         <xsl:choose>
            <xsl:when test="$date/date/@year">
               <xsl:value-of select="xs:integer($date/date/@year)"/>
            </xsl:when>
            <xsl:otherwise>0</xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="current2digitYear"
                    as="xs:integer"
                    select="xs:integer(substring(string(current-date()),3,2))"/>
      <xsl:variable name="outputDay"
                    as="xs:boolean"
                    select="if ($dayValue gt 0 and $dayValue lt 32) then true() else false()"/>
      <xsl:variable name="outputMonth"
                    as="xs:boolean"
                    select="if ($monthValue gt 0 and $monthValue lt 13) then true() else false()"/>
      <xsl:variable name="outputYear"
                    as="xs:boolean"
                    select="if ($yearValue gt 0) then true() else false()"/>
      <xsl:variable name="dayNorm"
                    as="xs:string"
                    select="if ($dayValue lt 10) then concat( '0' , string($dayValue) ) else string($dayValue)"/>
      <xsl:variable name="yearNorm"
                    as="xs:string"
                    select="if ($yearValue lt 10) then concat( '200' , string($yearValue) ) else    if ($yearValue le $current2digitYear) then concat( '20' , string($yearValue) ) else    if ($yearValue lt 100) then concat( '19' , string($yearValue) ) else    if ($yearValue lt 1000) then concat( '0' , string($yearValue) ) else    string($yearValue)"/>
      <xsl:if test="$outputDay and $outputMonth and $outputYear">
         <xsl:attribute name="day" select="$dayValue"/>
      </xsl:if>
      <xsl:if test="$outputMonth and $outputYear">
         <xsl:attribute name="month" select="$monthValueString"/>
      </xsl:if>
      <xsl:if test="$outputYear">
         <xsl:attribute name="year" select="$yearValue"/>
      </xsl:if>
      <!-- NOTE: this is a globally-shared module, no non-global variables should be used. -->
      <!--<xsl:choose>
			<xsl:when test="$streamID='NZ11'"/>
			<xsl:otherwise>-->
      <xsl:if test="$outputDay and $outputMonth and $outputYear and $yearValue lt 10000">
         <xsl:attribute name="normdate"
                        select="concat( $yearNorm , '-' , $monthValueString , '-' , $dayNorm )"/>
      </xsl:if>
      <!--</xsl:otherwise>
		</xsl:choose>-->
   </xsl:template>
   <!-- begin translate -->
   <xsl:template name="translate"><!-- 
	this template was developed to translate French to English or English to French for Canadian alternate 
	language citation formats but can be used to translate words, phrases, or strings within a separate string.
	
	
	3 parameters need to be sent to it.
	
	"old" is a sequence of strings in the source language that need to be translated
	"new" is a sequence of strings in the target language corresponding to the strings in the source language
	The above odl and new constitute a translation dictionary of sorts.
	"string" is a string that needs to be translated from the old language to the new.
	
	e.g. translating an English citation to French:
	
	$old = ('R.S.C.' , 'Long Title' , 'Appendix' , 's.' , 'No.')
	$new = ('L.R.C.' , 'Titre intgral', 'appendice' , 'art.' , 'no' )
	$string='R.S.C. 1985, Appendix II, No. 5, s. 12'
	
	The template will replace every value of $old with the value in the corresponding position in $new, in $string,
	in the order they are placed in $old and $new. All matches are replaced.
	
	So, 
	
	for $ string='R.S.C. 1985, Appendix II, No. 5, s. 12'
	
	
	the template will output 'L.R.C. 1985, appendice II, no 5, art. 12'
	
	The order $old and $new values are placed is important because you don't want to overwrite the output of a previous replacement with another translation.  
	Never translate English-French "Enacting Clause" before translating "Form" because the French for Enacting Clause includes the string "Form" 
	which would  be translated again and become messed up.
	
	CA07 and CA08 leg:num and leg:officialnum modules can be looked at to see how this template can be called.
	-->
      <xsl:param name="string"/>
      <xsl:param name="old"/>
      <xsl:param name="new"/>
      <!-- 
			params old and new are sequences of streams, where the old string and new string value to replace it
			are in the same position in their respective sequences.
			param "string" is the string that is undergoing the replacments.
			Replacements are made in the ORDER DETERMINED by the position in old and new.
            Order can make a big difference, so make sure input param old and new order is carefully tested -->
      <!-- escape 'old' value for regex so we can use replace function 
		Many of the citation strings have characters like periods and parens which can't 
		be used unescaped in regular expressions. Escaping makes it more robust -->
      <xsl:variable name="oldRegexFormat" select="lnf:escapeForRegex($old[1])"/>
      <xsl:analyze-string select="$string" regex="{$oldRegexFormat}">
         <xsl:matching-substring>
            <xsl:value-of select="$new[1]"/>
         </xsl:matching-substring>
         <xsl:non-matching-substring>
            <xsl:choose>
               <xsl:when test="count($old) &gt; 1">
                  <xsl:call-template name="translate">
                     <xsl:with-param name="string" select="."/>
                     <xsl:with-param name="old" select="$old[position() &gt; 1]"/>
                     <xsl:with-param name="new" select="$new[position() &gt; 1]"/>
                  </xsl:call-template>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:value-of select="."/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:non-matching-substring>
      </xsl:analyze-string>
   </xsl:template>
   <!--end translate -->   <!--begin escapeForRegex-->   <xsl:function name="lnf:escapeForRegex" as="xs:string"><!-- takes one argument which is a string.  The string will be escaped for 
			use in regular expressions (replace and matches function, xsl:analyze-string, 
			etc.  Source code taken from functx.com libraries -->
      <xsl:param name="arg" as="xs:string?"/>
      <xsl:sequence select="    replace($arg,    '(\.|\[|\]|\\|\||\-|\^|\$|\?|\*|\+|\{|\}|\(|\))', '\\$1')    "/>
   </xsl:function>
   <!-- end escapeForRegex -->
   <!--  functions END  -->
   <!-- Awantika: Completed -->
   <!-- <topicref href="AU01_namespaces.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"</xd:li>
            <xd:li>xmlns:abstract="urn:x-lexisnexis:content:abstract:sharedservices:1"</xd:li>
            <xd:li>xmlns:admincode="http://www.lexisnexis.com/xmlschemas/content/legal/administrative-code/1/"</xd:li>
            <xd:li>xmlns:admindecision="urn:x-lexisnexis:content:administrative-decision:sharedservices:1"</xd:li>
            <xd:li>xmlns:admindoc="urn:x-lexisnexis:content:administrative-document:sharedservices:1"</xd:li>
            <xd:li>xmlns:annot="http://www.lexisnexis.com/xmlschemas/content/shared/annotations/1/"</xd:li>
            <xd:li>xmlns:annotinfo="http://www.lexisnexis.com/xmlschemas/content/shared/annotations-info/1/"</xd:li>
            <xd:li>xmlns:article="urn:x-lexisnexis:content:article:sharedservices:1"</xd:li>
            <xd:li>xmlns:base="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"</xd:li>
            <xd:li>xmlns:biblio="urn:x-lexisnexis:content:bibliography:sharedservices:1"</xd:li>
            <xd:li>xmlns:billhist="urn:x-lexisnexis:content:billhistory:sharedservices:1"</xd:li>
            <xd:li>xmlns:billtrack="urn:x-lexisnexis:content:billtracking:1"</xd:li>
            <xd:li>xmlns:casedigest="http://www.lexisnexis.com/xmlschemas/content/legal/case-digest/1/"</xd:li>
            <xd:li>xmlns:casehist="http://www.lexisnexis.com/xmlschemas/content/legal/case-history/1/"</xd:li>
            <xd:li>xmlns:caseinfo="http://www.lexisnexis.com/xmlschemas/content/legal/case-information/1/"</xd:li>
            <xd:li>xmlns:casesum="http://www.lexisnexis.com/xmlschemas/content/legal/case-summary/1/"</xd:li>
            <xd:li>xmlns:cfi="http://www.lexisnexis.com/xmlschemas/content/shared/cite-finding-information/1/"</xd:li>
            <xd:li>xmlns:classify="http://www.lexisnexis.com/xmlschemas/content/shared/classification/1/"</xd:li>
            <xd:li>xmlns:compcase="urn:x-lexisnexis:content:compositecourtcase:sharedservices:1"</xd:li>
            <xd:li>xmlns:const="http://www.lexisnexis.com/xmlschemas/content/legal/constitution/1/"</xd:li>
            <xd:li>xmlns:contact="http://www.lexisnexis.com/xmlschemas/content/shared/contact/1/"</xd:li>
            <xd:li>xmlns:courtcase="http://www.lexisnexis.com/xmlschemas/content/legal/courtcase/1/"</xd:li>
            <xd:li>xmlns:courtfiling="http://www.lexisnexis.com/xmlschemas/content/legal/courtfiling/1/"</xd:li>
            <xd:li>xmlns:courtorder="urn:x-lexisnexis:content:courtorder:sharedservices:1"</xd:li>
            <xd:li>xmlns:courtrule="http://www.lexisnexis.com/xmlschemas/content/legal/courtrule/1/"</xd:li>
            <xd:li>xmlns:cttr="urn:x-lexisnexis:content:citator:sharedservices:1"</xd:li>
            <xd:li>xmlns:currencystatement="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/currencystatement"</xd:li>
            <xd:li>xmlns:dc="http://purl.org/dc/elements/1.1/"</xd:li>
            <xd:li>xmlns:dcterms="http://purl.org/dc/terms/"</xd:li>
            <xd:li>xmlns:decision="http://www.lexisnexis.com/xmlschemas/content/legal/decision/1/"</xd:li>
            <xd:li>xmlns:dict="urn:x-lexisnexis:content:dict:sharedservices:1"</xd:li>
            <xd:li>xmlns:directory="urn:x-lexisnexis:content:directory:sharedservices:1"</xd:li>
            <xd:li>xmlns:doc="http://www.lexisnexis.com/xmlschemas/content/shared/document-level-metadata/1/"</xd:li>
            <xd:li>xmlns:entity="http://www.lexisnexis.com/xmlschemas/content/shared/identified-entities/1/"</xd:li>
            <xd:li>xmlns:form="http://www.lexisnexis.com/xmlschemas/content/shared/form/1/"</xd:li>
            <xd:li>xmlns:funddoc="urn:x-lexisnexis:content:fundamentallegaldocument:sharedservices:1"</xd:li>
            <xd:li>xmlns:globalentity="urn:x-lexisnexis:content:identified-entities:global:1"</xd:li>
            <xd:li>xmlns:guid="urn:x-lexisnexis:content:guid:global:1"</xd:li>
            <xd:li>xmlns:index="urn:x-lexisnexis:content:publicationindex:sharedservices:1"</xd:li>
            <xd:li>xmlns:jurisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/jurisdiction-info/1/"</xd:li>
            <xd:li>xmlns:legis="http://www.lexisnexis.com/xmlschemas/content/legal/legislation/1/"</xd:li>
            <xd:li>xmlns:legishist="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-history/1/"</xd:li>
            <xd:li>xmlns:legisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-info/1/"</xd:li>
            <xd:li>xmlns:lnci="http://www.lexisnexis.com/xmlschemas/content/shared/citations/1/"</xd:li>
            <xd:li>xmlns:lndocmeta="http://www.lexisnexis.com/xmlschemas/content/shared/lndocmeta/1/"</xd:li>
            <xd:li>xmlns:lnmeta="http://www.lexisnexis.com/xmlschemas/content/shared/lexisnexis-metadata/1/"</xd:li>
            <xd:li>xmlns:lnsys="http://www.lexisnexis.com/xmlschemas/content/shared/lnsys/1/"</xd:li>
            <xd:li>xmlns:lntbl="http://www.lexisnexis.com/xmlschemas/content/shared/lexisnexis-table-extensions/1/"</xd:li>
            <xd:li>xmlns:location="http://www.lexisnexis.com/xmlschemas/content/shared/location/1/"</xd:li>
            <xd:li>xmlns:lpa="urn:x-lexisnexis:content:parameter:lexispracticeadvisor:1"</xd:li>
            <xd:li>xmlns:navaid="urn:x-lexisnexis:content:navigationaid:sharedservices:1"</xd:li>
            <xd:li>xmlns:newsitem="http://www.lexisnexis.com/xmlschemas/content/news/newsitem/1/"</xd:li>
            <xd:li>xmlns:nitf="http://iptc.org/std/NITF/2006-10-18/"</xd:li>
            <xd:li>xmlns:org="urn:x-lexisnexis:content:organization:sharedservices:1"</xd:li>
            <xd:li>xmlns:person="http://www.lexisnexis.com/xmlschemas/content/shared/person/1/"</xd:li>
            <xd:li>xmlns:primlaw="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw/1/"</xd:li>
            <xd:li>xmlns:primlawhist="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-history/1/"</xd:li>
            <xd:li>xmlns:primlawinfo="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-info/1/"</xd:li>
            <xd:li>xmlns:proc="http://www.lexisnexis.com/xmlschemas/content/shared/process-elements/1/"</xd:li>
            <xd:li>xmlns:pubfm="http://www.lexisnexis.com/xmlschemas/content/shared/publication-front-matter/1/"</xd:li>
            <xd:li>xmlns:pubinfo="http://www.lexisnexis.com/xmlschemas/content/shared/publication-info/1/"</xd:li>
            <xd:li>xmlns:pubup="http://www.lexisnexis.com/xmlschemas/content/shared/publication-update/1/"</xd:li>
            <xd:li>xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"</xd:li>
            <xd:li>xmlns:ref="http://www.lexisnexis.com/xmlschemas/content/shared/reference/1/"</xd:li>
            <xd:li>xmlns:register="http://www.lexisnexis.com/xmlschemas/content/legal/register/1/"</xd:li>
            <xd:li>xmlns:registerinfo="http://www.lexisnexis.com/xmlschemas/content/legal/register-info/1/"</xd:li>
            <xd:li>xmlns:regulation="urn:x-lexisnexis:content:regulation:sharedservices:1"</xd:li>
            <xd:li>xmlns:rfc="http://www.lexisnexis.com/xmlschemas/content/legal/reason-for-citing/1/"</xd:li>
            <xd:li>xmlns:seclaw="http://www.lexisnexis.com/xmlschemas/content/legal/secondary-law/1/"</xd:li>
            <xd:li>xmlns:statcode="http://www.lexisnexis.com/xmlschemas/content/legal/statutorycode/1/"</xd:li>
            <xd:li>xmlns:tei="http://www.tei-c.org/ns/1.0/"</xd:li>
            <xd:li>xmlns:topic="urn:x-lexisnexis:content:topic:global:1"</xd:li>
            <xd:li>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</xd:li>
         </xd:ul>
      </xd:desc>
   </xd:doc>
   <xsl:variable name="lexisAdvNamespaces" as="element()">
      <lexisAdvNamepaces>
         <lexisAdvNamespace>xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:abstract="urn:x-lexisnexis:content:abstract:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:admincode="http://www.lexisnexis.com/xmlschemas/content/legal/administrative-code/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:admindecision="urn:x-lexisnexis:content:administrative-decision:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:admindoc="urn:x-lexisnexis:content:administrative-document:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:annot="http://www.lexisnexis.com/xmlschemas/content/shared/annotations/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:annotinfo="http://www.lexisnexis.com/xmlschemas/content/shared/annotations-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:article="urn:x-lexisnexis:content:article:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:base="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:biblio="urn:x-lexisnexis:content:bibliography:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:billhist="urn:x-lexisnexis:content:billhistory:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:billtrack="urn:x-lexisnexis:content:billtracking:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:casedigest="http://www.lexisnexis.com/xmlschemas/content/legal/case-digest/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:casehist="http://www.lexisnexis.com/xmlschemas/content/legal/case-history/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:caseinfo="http://www.lexisnexis.com/xmlschemas/content/legal/case-information/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:casesum="http://www.lexisnexis.com/xmlschemas/content/legal/case-summary/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:cfi="http://www.lexisnexis.com/xmlschemas/content/shared/cite-finding-information/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:classify="http://www.lexisnexis.com/xmlschemas/content/shared/classification/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:compcase="urn:x-lexisnexis:content:compositecourtcase:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:const="http://www.lexisnexis.com/xmlschemas/content/legal/constitution/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:contact="http://www.lexisnexis.com/xmlschemas/content/shared/contact/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:courtcase="http://www.lexisnexis.com/xmlschemas/content/legal/courtcase/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:courtfiling="http://www.lexisnexis.com/xmlschemas/content/legal/courtfiling/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:courtorder="urn:x-lexisnexis:content:courtorder:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:courtrule="http://www.lexisnexis.com/xmlschemas/content/legal/courtrule/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:cttr="urn:x-lexisnexis:content:citator:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:currencystatement="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/currencystatement"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:dc="http://purl.org/dc/elements/1.1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:dcterms="http://purl.org/dc/terms/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:decision="http://www.lexisnexis.com/xmlschemas/content/legal/decision/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:dict="urn:x-lexisnexis:content:dict:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:directory="urn:x-lexisnexis:content:directory:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:doc="http://www.lexisnexis.com/xmlschemas/content/shared/document-level-metadata/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:entity="http://www.lexisnexis.com/xmlschemas/content/shared/identified-entities/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:form="http://www.lexisnexis.com/xmlschemas/content/shared/form/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:funddoc="urn:x-lexisnexis:content:fundamentallegaldocument:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:globalentity="urn:x-lexisnexis:content:identified-entities:global:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:guid="urn:x-lexisnexis:content:guid:global:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:index="urn:x-lexisnexis:content:publicationindex:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:jurisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/jurisdiction-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:legis="http://www.lexisnexis.com/xmlschemas/content/legal/legislation/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:legishist="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-history/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:legisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lnci="http://www.lexisnexis.com/xmlschemas/content/shared/citations/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lndocmeta="http://www.lexisnexis.com/xmlschemas/content/shared/lndocmeta/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lnmeta="http://www.lexisnexis.com/xmlschemas/content/shared/lexisnexis-metadata/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lnsys="http://www.lexisnexis.com/xmlschemas/content/shared/lnsys/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lntbl="http://www.lexisnexis.com/xmlschemas/content/shared/lexisnexis-table-extensions/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:location="http://www.lexisnexis.com/xmlschemas/content/shared/location/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:lpa="urn:x-lexisnexis:content:parameter:lexispracticeadvisor:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:navaid="urn:x-lexisnexis:content:navigationaid:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:newsitem="http://www.lexisnexis.com/xmlschemas/content/news/newsitem/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:nitf="http://iptc.org/std/NITF/2006-10-18/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:org="urn:x-lexisnexis:content:organization:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:person="http://www.lexisnexis.com/xmlschemas/content/shared/person/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:primlaw="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:primlawhist="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-history/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:primlawinfo="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:proc="http://www.lexisnexis.com/xmlschemas/content/shared/process-elements/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:pubfm="http://www.lexisnexis.com/xmlschemas/content/shared/publication-front-matter/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:pubinfo="http://www.lexisnexis.com/xmlschemas/content/shared/publication-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:pubup="http://www.lexisnexis.com/xmlschemas/content/shared/publication-update/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:ref="http://www.lexisnexis.com/xmlschemas/content/shared/reference/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:register="http://www.lexisnexis.com/xmlschemas/content/legal/register/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:registerinfo="http://www.lexisnexis.com/xmlschemas/content/legal/register-info/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:regulation="urn:x-lexisnexis:content:regulation:sharedservices:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:rfc="http://www.lexisnexis.com/xmlschemas/content/legal/reason-for-citing/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:seclaw="http://www.lexisnexis.com/xmlschemas/content/legal/secondary-law/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:statcode="http://www.lexisnexis.com/xmlschemas/content/legal/statutorycode/1/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:tei="http://www.tei-c.org/ns/1.0/"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:topic="urn:x-lexisnexis:content:topic:global:1"</lexisAdvNamespace>
         <lexisAdvNamespace>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</lexisAdvNamespace>
      </lexisAdvNamepaces>
   </xsl:variable>
   <xsl:template name="generateNSGlobalBindings">
      <xsl:for-each select="$lexisAdvNamespaces/*">
         <xsl:sort/>
         <xsl:namespace name="{substring-after(substring-before(., '='), ':')}"
                        select="substring-after(translate(., '&#34;', ''), '=')"/>
      </xsl:for-each>
   </xsl:template>
   <!-- start topicref  AU01_introduction.dita  -->   <!-- <topicref href="AU01_introduction.dita"/> -->   <!-- Awantika: Completed -->   <xd:doc>
      <xd:desc>
         <xd:p>This Conversion Instruction describes the conversion of Courtcase 9.20 PROD schema in the
      document.</xd:p>
         <xd:p>AU cases are identified using the root element <xd:i>CASEDOC</xd:i> with attribute <xd:i>@type=fulltext</xd:i> and <xd:i>docinfo:doc-country iso-cc=AU</xd:i>.</xd:p>
         <xd:p>
            <xd:i>CASEDOC</xd:i> becomes <xd:b>courtcase:courtcase</xd:b>. Its a root element for CaseLaw. The source attributes are: 
      <xd:i>@id</xd:i> becomes <xd:b>@xml:id</xd:b>,
      <xd:i>@xml:lang</xd:i>, if present, suppress attribute and content, as a separate rule has been defined to populate <xd:b>courtcase:courtcase/@xml:lang</xd:b> and <xd:i>@type</xd:i> suppress attribute and content, because the distinction made by this attribute in source is handled by separate schema in NL.
    </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>The attribute <xd:i>@searchtype</xd:i> will be suppressed from the conversion except citation markup.</xd:p>
         <xd:pre>

&lt;CASEDOC xml:lang="en-AU" ...&gt;
        ...
        &lt;docinfo:doc-lang lang="en"/&gt;
        &lt;docinfo:doc-country iso-cc="AU"/&gt;
        ...
&lt;/CASEDOC&gt;
<xd:b>Becomes</xd:b>

&lt;courtcase:courtcase xml:lang="en-AU"&gt;
      
      &lt;courtcase:head&gt;...&lt;/courtcase:head&gt;

      &lt;courtcase:body&gt;...&lt;/courtcase:body&gt;

      &lt;doc:metadata&gt;...&lt;/doc:metadata&gt;
      
&lt;/courtcase:courtcase&gt;
</xd:pre>
         <xd:p>
            <xd:b>courtcase:head</xd:b>, <xd:b>courtcase:body</xd:b>, and <xd:b>doc:metadata</xd:b> are created as required children of <xd:b>courtcase:courtcase</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note:</xd:b>
         </xd:p>
         <xd:p>Source elements and attributes are highlighted like this: <xd:i>SOURCEXML</xd:i>
         </xd:p>
         <xd:p>Target elements and attributes are highlighted like this: <xd:b>TARGETXML</xd:b>
         </xd:p>
         <xd:p>Copy source attributes to target attributes unless otherwise specified.</xd:p>
         <xd:p>Every example is represented like "EXAMPLE" in all the dita's and is captured under <xd:pre>pre</xd:pre> tag.</xd:p>
         <xd:p>
            <xd:b>Changes:</xd:b>
         </xd:p>
         <xd:p>2016-06-07: Schema version updated to <xd:b>Courtcase 9.19
          PROD</xd:b>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_introduction.dita  -->
   <xsl:template match="CASEDOC[@type='fulltext']"><!--<xsl:attribute name="xsi:schemaLocation" select="$outputSchemaLoc"/>--><!--  Original Target XPath:  courtcase:courtcase   -->
      <courtcase:courtcase>
         <xsl:call-template name="generateNSGlobalBindings"/>
         <xsl:attribute name="xsi:schemaLocation" select="$outputSchemaLoc"/>
         <xsl:apply-templates select="@*"/>
         <xsl:if test="docinfo/docinfo:doc-lang">
            <xsl:call-template name="xml_lang"/>
         </xsl:if>
         <xsl:apply-templates select="case:body/case:headnote"/>
         <xsl:apply-templates select="toc"/>
         <xsl:apply-templates select="case:body"/>
         <doc:metadata>
            <xsl:if test="//copyright">
               <pubinfo:pubinfo>
                  <xsl:apply-templates select="//copyright"/>
               </pubinfo:pubinfo>
            </xsl:if>
            <xsl:apply-templates select="docinfo"/>
         </doc:metadata>
      </courtcase:courtcase>
   </xsl:template>

   <xsl:template match="case:disposition[parent::case:headnote]"/>

   <xsl:template match="@type"/>

   <xsl:template match="@xml:lang"/>
   <!-- topic: xml.lang attribute -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.doc-lang-and-doc-country-LxAdv-ROOT_xml.lang.dita"/> -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.doc-lang-and-doc-country-LxAdv-ROOT_xml.lang.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>xml:lang Instructions</xd:b>
         </xd:p>
         <xd:p>The combination of <xd:i>docinfo/docinfo:doc-lang[@lang]</xd:i> and <xd:i>docinfo/docinfo:doc-country[@iso-cc]</xd:i> becomes
                        <xd:b>{target.root.element}[@xml:lang]</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:doc-lang lang="en"/&gt; &lt;docinfo:doc-country iso-cc="NZ"/&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;{target.root.elm} xml:lang="en-NZ" ...&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:doc-lang lang="en"/&gt; &lt;docinfo:doc-country iso-cc="GB"/&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;{target.root.elm} xml:lang="en-GB" ...&gt; </xd:pre>
         <xd:p>
            <xd:b>xml:id Instructions</xd:b>
         </xd:p>
         <xd:p>The attribute <xd:b>xml:id</xd:b> is an W3C standard with a datatype of "ID". Outlined below are some of the cases where the source ID values need to be adjusted to
                    conform to the <xd:b>xml:id</xd:b> standard:</xd:p>
         <xd:p>
            <xd:b>Colon ":" in ID value</xd:b>
         </xd:p>
         <xd:p> When a colon is found within an XML ID replace the colon ":" with an underscore "_" as shown below:</xd:p>
         <xd:pre> &lt;level id="NZSTATUTES_ACTS-A4.SGM_PARA-1925A41:1908A96-EDITORIAL-NOTES" leveltype="comm.chap"&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;primlaw:level id="NZSTATUTES_ACTS-A4.SGM-PARA-1925A41_1908A96-EDITORIAL-NOTES" leveltype="chapter"&gt; </xd:pre>
         <xd:p>
            <xd:b>ID value begins with number</xd:b>
         </xd:p>
         <xd:p>When attribute XML ID value begins with number, then add an underscore "_" as shown below:</xd:p>
         <xd:pre> &lt;level id="475:B005_V2:H1" leveltype="chapter" subdoc="false" toc-caption="PART III THE ADMINISTRATION OF ASSETS"&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;seclaw:level xml:id="_475_B005_V2_H1" leveltype="chapter" includeintoc="false" alternatetoccaption="PART III THE ADMINISTRATION OF ASSETS"&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>The restrictions and required modifications for <xd:b>xml:id</xd:b> also apply to the following situations:</xd:p>
            <xd:ul>
               <xd:li>The mapping of <xd:i>refpt/@id</xd:i> to <xd:b>ref:anchor/@id</xd:b>
               </xd:li>
               <xd:li>The mapping of <xd:i>footnote/@fntoken</xd:i> to <xd:b>footnote/ref:anchor/@id</xd:b>
               </xd:li>
               <xd:li>The mapping <xd:i>fnr/@fnrtoken</xd:i> to <xd:b>footnote-ref/ref:anchor/@id</xd:b>
               </xd:li>
               <xd:li>The mapping of <xd:i>fnr/@fntoken</xd:i> to <xd:b>foonote-ref/@anchoridref</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <!--Changes2013-07-16: Instruction narrative edited for language; no changes to mappings, no impact to stylesheets.2013-04-19: Added note about applicability of restrictions and required modifications for xml:id to other scenarios.2012-12-13: Instruction and example update where "ID value begins with number".2012-10-05: Example added for UK content.2012-09-27: Added information for the handling of XML:ID2012-05-23: Added information for the handling of XML:ID2011-12-15: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.doc-lang-and-doc-country-LxAdv-ROOT_xml.lang.dita  -->
   <!-- WPK: this doc-country template is correct and tested -->
   <!--<xsl:template name="parse_id">
		<!-\- This template returns valid ID data type value.  -\->
		<xsl:param name="attr_value" select="."/>
		<xsl:if test="contains('0123456789', substring($attr_value, 1, 1))">
			<xsl:text>_</xsl:text>
		</xsl:if>
		<xsl:value-of select="translate($attr_value, ':', '_')"/>
	</xsl:template>-->
   <!-- WPK: this template is correct and tested -->
   <!--<xsl:template match="@id">
		<!-\- This template creates @xml:id target from @id source.  For any non-specific cases of @id.
                    For specific other use cases of @id, use more specific match, such as "refpt/@id".  -\->
		<xsl:attribute name="xml:id">
			<xsl:call-template name="parse_id">
				<xsl:with-param name="attr_value" select="."/>
			</xsl:call-template>
		</xsl:attribute>
	</xsl:template>-->
   <!-- Vikas Rohilla : Updated the template Removed the double slash	-->
   <!-- 2017-10-04 - MDS:  This should not be used.  Instead use the xml_lang named template -->
   <!--	<xsl:template name="xml_lang_HK">
		<!-\- This template creates @xml:lang from doc-lang and doc-country only for HK stream-\->
		<xsl:attribute name="xml:lang" select="concat(docinfo/docinfo:doc-lang/@lang, '-', docinfo/docinfo:doc-country/@iso-cc)"/>
	</xsl:template>-->
   <!-- WPK: this doc-lang template is correct and tested -->
   <xsl:template match="docinfo:doc-lang/@lang">
      <xsl:value-of select="."/>
   </xsl:template>
   <!-- WPK: this doc-country template is correct and tested -->
   <xsl:template match="docinfo:doc-country/@iso-cc">
      <xsl:value-of select="."/>
   </xsl:template>
   <!-- Old file: target_xml_char_ent -->   <!-- <topicref href="../../common_newest/Rosetta_XML_Character_Entities-LxAdv-Unicode.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>Throughout these instructions, XML character entities are used in both the source and target
						examples to ensure they are easily viewable in a variety of formats. However, please
						keep in mind that <xd:b>
               <xd:i>all XML character entities in the source files must be
								converted to Unicode code points in the target files.</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>Certain XML character entities will be interpreted by the browser or
							Database as code, rather than literal (Unicode exact) character. Therefore, we
							should not convert certain xml character entities to Unicode character. Refer
							the below table for your reference:</xd:p>
            <xd:ol>
               <xd:li>
                  <xd:b>XML Character Entity</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>Character name</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>Transformation Output</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b> Remarks </xd:b>
               </xd:li>
               <xd:li> &amp;lt; </xd:li>
               <xd:li> Less-Than Sign </xd:li>
               <xd:li> &amp;lt; </xd:li>
               <xd:li/>
               <xd:li> &amp;gt; </xd:li>
               <xd:li> Greater-Than Sign </xd:li>
               <xd:li> &amp;gt; </xd:li>
               <xd:li/>
               <xd:li> &amp;amp; </xd:li>
               <xd:li> Ampersand </xd:li>
               <xd:li> &amp;amp; </xd:li>
               <xd:li/>
               <xd:li> &amp;apos; </xd:li>
               <xd:li> Apostrophe </xd:li>
               <xd:li> ' </xd:li>
               <xd:li>If part of PCDATA this should be converted
										otherwise left as is in case of attribute value.</xd:li>
               <xd:li> &amp;quot; </xd:li>
               <xd:li> Quotation Mark </xd:li>
               <xd:li> " </xd:li>
               <xd:li>If part of PCDATA this should be converted
										otherwise left as is in case of attribute value.</xd:li>
            </xd:ol>
         </xd:p>
         <!--Changes2013-08-08: This change does not represent a change to
							conversion but rather documentation of the existing behavior.2011-12-22: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_XML_Character_Entities-LxAdv-Unicode.dita  -->
   <!--xsl:template match="*/text()[ contains( . , '&apos;' ) or contains( . , '&quot;' ) ]">
		<xsl:variable name="quoteLiterals" as="xs:string">'"</xsl:variable-->
   <!--  Original Target XPath:  Unicodecodepoints   -->
   <!--xsl:value-of select=" translate( . , '&apos;&quot;' , $quoteLiterals ) "/>

	</xsl:template-->
   <!-- Old file: target_maintain_element_order -->
   <!-- <topicref href="../../common_newest/Rosetta_Elements-LxAdv-Maintain_Sequential_Order.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>Each source element should be converted to its associated target element such that
					the target element will occur in the target document in the same relative order as
					its respective source element did in the source document, so long as <xd:i>the target
						schema does not require a specific order for that target element within that
						target element's parent element</xd:i> (first exception), and <xd:i>there are no other
						instructions regarding the moving of that target element</xd:i> (second exception).
					In other words, when converting elements from the source documents, the order of
					elements as they are encountered in the source documents should in general be
					maintained whenever possible, subject to the two important exceptions mentioned in
					the previous sentence and elaborated below. </xd:p>
         <xd:p>Note that according to this rule, the order of particular target elements within a
					parent target element may be different than the order that these elements are
					listed, noted or otherwise mentioned in these instructions. This includes situations
					when a set of child target elements are specified in these instructions as items in
					a list following instructions regarding the parent target element; the order of the
					items dictates the order that the target elements should occur.</xd:p>
         <xd:p>
            <xd:b>Elaboration regarding first exception:</xd:b> there are ordering constraints imposed
					by the target schema for some elements, requiring that target child elements must
					occur in a certain order within target parent elements, and this order may differ
					from the order of their corresponding source elements in the source documents. In
					this case, the constraints imposed by the target schema must be respected.</xd:p>
         <xd:p>
            <xd:b>Elaboration regarding second exception:</xd:b> there will be occasional scenarios
					when the source elements must not only be converted to particular target elements,
					but must also be shifted to specifically different locations within in the target
					documents. These scenarios will be explicitly mentioned for the source and target
					elements affected and must override the general rule to maintain element order.</xd:p>
         <xd:p>
            <xd:b>Processing Instructions</xd:b>
         </xd:p>
         <xd:p> In the source content there may be <xd:b>processing instructions</xd:b>. For example
					&lt;?page.*?&gt;. If a processing instruction is encountered it should be
					suppressed and not converted into the output.</xd:p>
         <!--Changes2012-01-19: Created. 2012-05-10: Added instruction for Processing Instructions. 2012-05-15: Adjusted the language for the instruction.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_Elements-LxAdv-Maintain_Sequential_Order.dita  -->
   <xsl:template match="processing-instruction()" priority="25"/>
   <!-- Old file: target_whitespace -->   <!-- <topicref href="../../common_newest/Rosetta_whitespace-LxAdv-preserve_whitespace.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>All significant whitespace characters (i.e. newlines, spaces, tabs, non-breaking spaces, etc. in data content or mixed content in elements) should be preserved. No significant whitespace should be added, removed or altered. In some cases, an element that contains only whitespace in the input may be stripped from the output by specific instruction; in those cases, both the tags and the whitespace should be removed.</xd:p>
         <!--Changes2012-06-07: Created. -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_whitespace-LxAdv-preserve_whitespace.dita  -->
   <!-- THIS IS INFORMATIONAL ONLY AND NEVER EVER EVER STRIP SPACE FOR EVERY ELEMENT.  -->
   <!-- <topicref href="../../common_newest/Rosetta_Elements-LxAdv-Empty_Elements.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Suppress empty elements unless:</xd:b>
         </xd:p>
         <xd:ol>
            <xd:li> It results in an invalid document. </xd:li>
            <xd:li> It is expressly exempted. </xd:li>
            <xd:li> It has attributes. </xd:li>
         </xd:ol>
         <xd:p>
            <xd:b>Note: </xd:b>The intent is to suppress meaningless markup (no semantic, formatting or other
					meaning). Not intended to cause re-evaluation of parent elements, i.e. do not go "up
					the tree".</xd:p>
         <xd:p>
            <xd:b>List of elements to suppress if empty</xd:b>
         </xd:p>
         <xd:ul>
            <xd:li>base:aliased-text</xd:li>
            <xd:li>base:altdesig</xd:li>
            <xd:li>base:alttitle</xd:li>
            <xd:li>base:byline</xd:li>
            <xd:li>base:connector</xd:li>
            <xd:li>base:copyright</xd:li>
            <xd:li>base:copyright-holder</xd:li>
            <xd:li>base:copyright-year</xd:li>
            <xd:li>base:credit</xd:li>
            <xd:li>base:currencystatement</xd:li>
            <xd:li>base:date</xd:li>
            <xd:li>base:date-text</xd:li>
            <xd:li>base:defterm</xd:li>
            <xd:li>base:denom</xd:li>
            <xd:li>base:desig</xd:li>
            <xd:li>base:desigrange</xd:li>
            <xd:li>base:emph</xd:li>
            <xd:li>base:formula</xd:li>
            <xd:li>base:h</xd:li>
            <xd:li>base:inlinenote</xd:li>
            <xd:li>base:label</xd:li>
            <xd:li>base:modified-word</xd:li>
            <xd:li>base:money</xd:li>
            <xd:li>base:num</xd:li>
            <xd:li>base:numer</xd:li>
            <xd:li>base:population</xd:li>
            <xd:li>base:redaction</xd:li>
            <xd:li>base:refnum</xd:li>
            <xd:li>base:role</xd:li>
            <xd:li>base:strike</xd:li>
            <xd:li>base:sub</xd:li>
            <xd:li>base:subtitle</xd:li>
            <xd:li>base:sup</xd:li>
            <xd:li>base:text</xd:li>
            <xd:li>base:textitem</xd:li>
            <xd:li>base:time</xd:li>
            <xd:li>base:title</xd:li>
            <xd:li>base:url</xd:li>
            <xd:li>contact:email</xd:li>
            <xd:li>contact:fax</xd:li>
            <xd:li>contact:phone</xd:li>
            <xd:li>doc:bookseqnum</xd:li>
            <xd:li>doc:processes</xd:li>
            <xd:li>location:address.line</xd:li>
            <xd:li>location:borough</xd:li>
            <xd:li>location:city</xd:li>
            <xd:li>location:country</xd:li>
            <xd:li>location:county</xd:li>
            <xd:li>location:location</xd:li>
            <xd:li>location:po-box</xd:li>
            <xd:li>location:post-office-name</xd:li>
            <xd:li>location:postalcode</xd:li>
            <xd:li>location:province</xd:li>
            <xd:li>location:region</xd:li>
            <xd:li>location:state</xd:li>
            <xd:li>location:street</xd:li>
            <xd:li>location:sublocation</xd:li>
            <xd:li>location:territory</xd:li>
            <xd:li>person:contributor</xd:li>
            <xd:li>person:degreetype</xd:li>
            <xd:li>person:employer</xd:li>
            <xd:li>person:fieldofstudy</xd:li>
            <xd:li>person:name.degree</xd:li>
            <xd:li>person:name.discrim</xd:li>
            <xd:li>person:name.family</xd:li>
            <xd:li>person:name.given</xd:li>
            <xd:li>person:name.honorific</xd:li>
            <xd:li>person:name.maiden</xd:li>
            <xd:li>person:name.mid</xd:li>
            <xd:li>person:name.nickname</xd:li>
            <xd:li>person:name.other</xd:li>
            <xd:li>person:name.prefix</xd:li>
            <xd:li>person:name.suffix</xd:li>
            <xd:li>person:name.text</xd:li>
            <xd:li>pubinfo:aggregationname</xd:li>
            <xd:li>pubinfo:edition</xd:li>
            <xd:li>pubinfo:isbn</xd:li>
            <xd:li>pubinfo:issn</xd:li>
            <xd:li>pubinfo:issue</xd:li>
            <xd:li>pubinfo:issuedate</xd:li>
            <xd:li>pubinfo:lccn</xd:li>
            <xd:li>pubinfo:pubdate</xd:li>
            <xd:li>pubinfo:publength</xd:li>
            <xd:li>pubinfo:publicationname</xd:li>
            <xd:li>pubinfo:publicationnum</xd:li>
            <xd:li>pubinfo:publicationsubtitle</xd:li>
            <xd:li>pubinfo:publisher</xd:li>
            <xd:li>pubinfo:pubunit</xd:li>
            <xd:li>pubinfo:relatedpublicationcite</xd:li>
            <xd:li>pubinfo:update</xd:li>
            <xd:li>pubinfo:volume</xd:li>
         </xd:ul>
         <!--Changes2014-01-16: Added list of elements to suppress if empty.2013-10-14: Changed antecedent to singular to match
						instructions.2013-03-28: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_Elements-LxAdv-Empty_Elements.dita  -->
   <!--xsl:template match="	base:aliased-text[ . = '' ][not( @* )] |
										base:altdesig[ . = '' ][not( @* )] |
										base:alttitle[ . = '' ][not( @* )] |
										base:byline[ . = '' ][not( @* )] |
										base:connector[ . = '' ][not( @* )] |
										base:copyright[ . = '' ][not( @* )] |
										base:copyright-holder[ . = '' ][not( @* )] |
										base:copyright-year[ . = '' ][not( @* )] |
										base:credit[ . = '' ][not( @* )] |
										base:currencystatement[ . = '' ][not( @* )] |
										base:date[ . = '' ][not( @* )] |
										base:date-text[ . = '' ][not( @* )] |
										base:defterm[ . = '' ][not( @* )] |
										base:denom[ . = '' ][not( @* )] |
										base:desig[ . = '' ][not( @* )] |
										base:desigrange[ . = '' ][not( @* )] |
										base:emph[ . = '' ][not( @* )] |
										base:formula[ . = '' ][not( @* )] |
										base:h[ . = '' ][not( @* )] |
										base:inlinenote[ . = '' ][not( @* )] |
										base:label[ . = '' ][not( @* )] |
										base:modified-word[ . = '' ][not( @* )] |
										base:money[ . = '' ][not( @* )] |
										base:num[ . = '' ][not( @* )] |
										base:numer[ . = '' ][not( @* )] |
										base:population[ . = '' ][not( @* )] |
										base:redaction[ . = '' ][not( @* )] |
										base:refnum[ . = '' ][not( @* )] |
										base:role[ . = '' ][not( @* )] |
										base:strike[ . = '' ][not( @* )] |
										base:sub[ . = '' ][not( @* )] |
										base:subtitle[ . = '' ][not( @* )] |
										base:sup[ . = '' ][not( @* )] |
										base:text[ . = '' ][not( @* )] |
										base:textitem[ . = '' ][not( @* )] |
										base:time[ . = '' ][not( @* )] |
										base:title[ . = '' ][not( @* )] |
										base:url[ . = '' ][not( @* )] |
										contact:email[ . = '' ][not( @* )] |
										contact:fax[ . = '' ][not( @* )] |
										contact:phone[ . = '' ][not( @* )] |
										doc:bookseqnum[ . = '' ][not( @* )] |
										doc:processes[ . = '' ][not( @* )] |
										location:address.line[ . = '' ][not( @* )] |
										location:borough[ . = '' ][not( @* )] |
										location:city[ . = '' ][not( @* )] |
										location:country[ . = '' ][not( @* )] |
										location:county[ . = '' ][not( @* )] |
										location:location[ . = '' ][not( @* )] |
										location:po-box[ . = '' ][not( @* )] |
										location:post-office-name[ . = '' ][not( @* )] |
										location:postalcode[ . = '' ][not( @* )] |
										location:province[ . = '' ][not( @* )] |
										location:region[ . = '' ][not( @* )] |
										location:state[ . = '' ][not( @* )] |
										location:street[ . = '' ][not( @* )] |
										location:sublocation[ . = '' ][not( @* )] |
										location:territory[ . = '' ][not( @* )] |
										person:contributor[ . = '' ][not( @* )] |
										person:degreetype[ . = '' ][not( @* )] |
										person:employer[ . = '' ][not( @* )] |
										person:fieldofstudy[ . = '' ][not( @* )] |
										person:name.degree[ . = '' ][not( @* )] |
										person:name.discrim[ . = '' ][not( @* )] |
										person:name.family[ . = '' ][not( @* )] |
										person:name.given[ . = '' ][not( @* )] |
										person:name.honorific[ . = '' ][not( @* )] |
										person:name.maiden[ . = '' ][not( @* )] |
										person:name.mid[ . = '' ][not( @* )] |
										person:name.nickname[ . = '' ][not( @* )] |
										person:name.other[ . = '' ][not( @* )] |
										person:name.prefix[ . = '' ][not( @* )] |
										person:name.suffix[ . = '' ][not( @* )] |
										person:name.text[ . = '' ][not( @* )] |
										pubinfo:aggregationname[ . = '' ][not( @* )] |
										pubinfo:edition[ . = '' ][not( @* )] |
										pubinfo:isbn[ . = '' ][not( @* )] |
										pubinfo:issn[ . = '' ][not( @* )] |
										pubinfo:issue[ . = '' ][not( @* )] |
										pubinfo:issuedate[ . = '' ][not( @* )] |
										pubinfo:lccn[ . = '' ][not( @* )] |
										pubinfo:pubdate[ . = '' ][not( @* )] |
										pubinfo:publength[ . = '' ][not( @* )] |
										pubinfo:publicationname[ . = '' ][not( @* )] |
										pubinfo:publicationnum[ . = '' ][not( @* )] |
										pubinfo:publicationsubtitle[ . = '' ][not( @* )] |
										pubinfo:publisher[ . = '' ][not( @* )] |
										pubinfo:pubunit[ . = '' ][not( @* )] |
										pubinfo:relatedpublicationcite[ . = '' ][not( @* )] |
										pubinfo:update[ . = '' ][not( @* )] |
										pubinfo:volume[ . = '' ][not( @* )]"/-->
   <!-- topic: Topic Identifiers-->
   <!-- <topicref href="../../common_newest/Rosetta_Topic_Identifiers.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>All topics in this conversion instruction document contain persistent identifiers.  They will appear
					next to the title for example: 
					<xd:ul>
               <xd:li>case:headnote (id-CA01-d330e3)</xd:li>
               <xd:li>alttitle to alttitle (id-CCCC-d57e3)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>They will take the form of (id<xd:b>-</xd:b>[<xd:i>stream id or common rule</xd:i>]<xd:b>-</xd:b>[<xd:i>unique id</xd:i>]) and have the 
					following characteristics:</xd:p>
         <xd:ul>
            <xd:li>IDs for a specific stream topic e.g. (id-AU01-d730e3) will occur only in a
						single CI document -- AU01 for this example.</xd:li>
            <xd:li>IDs for common reusable topics e.g. (id-CCCC-d57e3) will occur in many CI
						documents according to its reuse. While the ID is unique across all LNI topics, the
						topic itself is repeated along with the ID in numerous CI documents.</xd:li>
         </xd:ul>
         <!--Changes2014-05-02: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_Topic_Identifiers.dita  -->
   <xsl:character-map name="a-circumflex">
      <xsl:output-character character="" string=""/>
      <!--Satbir: Below junk character is equal to space character then replace with space keybaord charcater.-->
      <xsl:output-character character="" string=" "/>
      <xsl:output-character character="" string=" "/>
   </xsl:character-map>
   <!-- end topicref  AU01_introduction.dita  -->
   <!-- start topichead  Mapping to ID Data Type  -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>Identifiers such as <xd:b>xml:id</xd:b> and
					<xd:b>ref:anchor/@id</xd:b> are ID data typed. Refer to the target
				schema/documentation to determine whether or not the value is ID data typed. </xd:p>
         <xd:p>ID data types cannot contain colons and may not begin with a number (among other
				restrictions). To properly map to a node that is ID data typed, conversion
				instructions state to substitute a colon or a space with an underscore. Also, prefix
				values beginning with a number, with an underscore. The xml schema will enforce
				these constraints post conversion.</xd:p>
         <xd:p>Do not convert the following cases:<xd:ul>
               <xd:li>Leading and trailing space(s) (e.g. id=" example_id_value_001 ")</xd:li>
               <xd:li>XML Entities (e.g. id="example_id_value_001&amp;#xA;")</xd:li>
            </xd:ul>   </xd:p>
         <xd:p>
            <xd:b>Example Markup - Source</xd:b>
         </xd:p>
         <xd:pre>

&lt;refpt id="&amp;#xA;          0KMN_2_F_FC__S_CLAUSE:HTDICT-TERM&amp;#xA;        " type="ext"/&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Example Markup - Target</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:anchor id="_0KMN_2_F_FC__S_CLAUSE_HTDICT-TERM" anchortype="global"/&gt;

	</xd:pre>
         <xd:p>Other identifiers, such as <xd:b>@anchoridref</xd:b> are <xd:i>not</xd:i> ID
				data typed. However, they may link to those that are. For example, an
					<xd:b>@anchoridref</xd:b> may point a
					<xd:b>ref:anchor/@id</xd:b>. Since <xd:b>@anchoridref</xd:b>
				is not ID data typed, the ID constraints will not be enforced by the schema post
				conversion, and will result in broken links. So, to ensure proper link resolution,
				it is imperative that such identifiers also follow the ID data type restrictions
					(<xd:b>@anchoridref</xd:b> in this case).</xd:p>
         <!--Changes2013-07-17: Added instructions for handling
					leading/trailing space(s) and XML entities.2013-07-10: Added instruction to replace space with
					underscore.-->
         <!-- SEP 2015-8-12 added -->
         <!--<xsltinclusion>
			<xsl:stylesheet version="2.0">
				<xsl:template match="*[@id]">
					<!-\- need to better combine with other @id functions-\->
					<!-\- need to handle entities, currently does not -\->
					<xsl:variable name="idval" select="@id"/>
					<xsl:choose>
						<xsl:when test="contains($idval, ':') or contains($idval, ' ') or contains('0123456789', substring($idval, 1, 1)) ">
							<xsl:variable name="idvalNoBegNums">
							   <!-\- need recursive function call here to remove leading numerals , currently only handles one  -\->
							   <xsl:choose>
								   <xsl:when test="contains('0123456789', substring(normalize-space($idval), 1, 1))">                           
									   <xsl:value-of select="normalize-space(substring($idval,2))"/>                           
								   </xsl:when>
								   <xsl:otherwise>
									   <xsl:value-of select="normalize-space($idval)"/>                           
								   </xsl:otherwise>
							   </xsl:choose>
							</xsl:variable>
							<xsl:copy>
								<xsl:attribute name="id" select="translate(normalize-space($idvalNoBegNums), ' :', '__')"/>
								<xsl:apply-templates select="@*[name()!='id'] | node()"/>
							</xsl:copy>               
						</xsl:when>
						<xsl:otherwise>
							<xsl:copy>
								<xsl:apply-templates select="@* | node()"/>
							</xsl:copy>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:template>

				need recursive function to remove leading numerals , currently only handles one 

			</xsl:stylesheet>
		</xsltinclusion>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_identifier-LxAdv-ID_data_type-HandlingPatternRestrictions.dita  -->
   <!-- 
**************************************************************************************
NOTE:
The context node for this template MUST be a string value.
This template returns a string value that has been modified to 
meet the restrictions of the xs:id datatype.

It was originally intended for xml:id, id, and ID attributes, but would
also work for anything else where the xs:id datatype is required.

This template does not handle ALL entities,as 
Saxon will by default, *resolve* entities before this template 
processes the string.  XSLT cannot change this behavior. It will now identify and
replace pointy brackets and ampersands, however, with an underscore as resolving
those would definitely be a problem for the parser.

****************************************************************************************

-->
   <xsl:template name="normalizeIdString"><!-- first step: replace illegal characters with an underscore --><!-- WPK 2017-10-19.  Added mdash to list of disallowed chars. 
		 WPK 2017-10-24.  	
				added   (left double quote #x93;)
				added   (non printable control character #x80;)
				added 
				added 
				added 
				added    (en dash &#x2013;) 
				
			Background.  These are likely encoding issues.  This allows for valid IDs to be created because they are invalid characters nevertheless.
			AU10 PS2017050503412620096LNIAULNPG_input_BUS_GUID_74731000.xml	
			in		
			out		&#x80;&#x93;
			
			    becomes 
			    becomes &#x80;  (control character displays as blank)
			    becomes &#x93;  (back slanted double quote)
			
			http://www.i18nqa.com/debug/utf8-debug.html
			(expected is not what LN expects but what the website indicates as expected in its context)
			Unicode...Windows1252...Expected...Actual...UTF-8 Bytes
			U+00A2    0xA2                           %C2 %A2     (not tilde, but carrot - not exactly what is in data)
			U+201C    0x93                          %E2 %80 %9C   
			U+00E2    0xE2                           %C3 %A2     (carrot as found in data)
			
			AU10 PS2017050812233824638LNIAULNPG_input_BUS_GUID_93431000.xml
			   (en dash &#x2013;) 
	-->
      <xsl:variable name="idWithoutDisallowedChars">
         <xsl:value-of select="translate(. , ',!#$%()*+/:;=?@![]\^`|{}~&#x93;&#x80;', '__________________________________')"/>
      </xsl:variable>
      <!-- get rid of stubborn entities-->
      <xsl:variable name="idWithoutDisallowedEnts">
         <xsl:analyze-string select="$idWithoutDisallowedChars" regex="&lt;|&gt;|&amp;|'">
            <xsl:matching-substring>
               <xsl:text>_</xsl:text>
            </xsl:matching-substring>
            <xsl:non-matching-substring>
               <xsl:value-of select="."/>
            </xsl:non-matching-substring>
         </xsl:analyze-string>
      </xsl:variable>
      <!-- remove leading and trailing spaces and entities -->
      <xsl:variable name="idWoLeadingSpaces">
         <xsl:value-of select="replace($idWithoutDisallowedEnts, '^\s+', '')"/>
      </xsl:variable>
      <xsl:variable name="idWoTrailingSpaces"><!-- this should also handle resolved whitespace and ampersand entities -->
         <xsl:value-of select="replace($idWoLeadingSpaces, '\s+$', '')"/>
      </xsl:variable>
      <xsl:variable name="idWoInternalSpaces">
         <xsl:value-of select="replace($idWoTrailingSpaces, '\s+', '_')"/>
      </xsl:variable>
      <!--  prepend underscore with leading values of period, hyphen, or numeral -->
      <xsl:choose>
         <xsl:when test="matches($idWoInternalSpaces , '^[0-9]|^\.|^\-')">
            <xsl:value-of select="concat('_', $idWoInternalSpaces)"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="$idWoInternalSpaces"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- named template normalizeIdString_dropchars receives the same input (string) as 
	normalizeIdString, but replaces all illegal characters and spaces with nothing. It still
	prepends an underscore if the string begins with a number or illegal starting character. 
	The output should still be a valid id datatype and NMTOKEN.  This is less commonly used
	for IDs than the normalizeIdString template but may be useful for some other attributes-->
   <xsl:template name="normalizeIdString_dropchars"><!-- first step: replace illegal characters with an underscore -->
      <xsl:variable name="idWithoutDisallowedChars">
         <xsl:value-of select="translate(. , ',!#$%()*+/:;=?@![]\^`|{}~', '')"/>
      </xsl:variable>
      <!-- get rid of stubborn entities-->
      <xsl:variable name="idWithoutDisallowedEnts">
         <xsl:analyze-string select="$idWithoutDisallowedChars" regex="&lt;|&gt;|&amp;|'">
            <xsl:matching-substring/>
            <xsl:non-matching-substring>
               <xsl:value-of select="."/>
            </xsl:non-matching-substring>
         </xsl:analyze-string>
      </xsl:variable>
      <!-- remove leading and trailing spaces and entities -->
      <xsl:variable name="idWoLeadingSpaces">
         <xsl:value-of select="replace($idWithoutDisallowedEnts, '^\s+', '')"/>
      </xsl:variable>
      <xsl:variable name="idWoTrailingSpaces"><!-- this should also handle resolved whitespace and ampersand entities -->
         <xsl:value-of select="replace($idWoLeadingSpaces, '\s+$', '')"/>
      </xsl:variable>
      <xsl:variable name="idWoInternalSpaces">
         <xsl:value-of select="replace($idWoTrailingSpaces, '\s+', '')"/>
      </xsl:variable>
      <!--  prepend underscore with leading values of period, hyphen, or numeral -->
      <xsl:choose>
         <xsl:when test="matches($idWoInternalSpaces , '^[0-9]|^\.|^\-')">
            <xsl:value-of select="concat('_', $idWoInternalSpaces)"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="$idWoInternalSpaces"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--
stolen from the web, and for reference: id datatypes must follow NCName restrictions		
		
Practical restrictions of an NCName

The practical restrictions of NCName are that it cannot contain several symbol characters like :, @,  $, %, &, /, +, ,, ;, 
whitespace characters or different parenthesis. Furthermore an NCName cannot begin with a number, dot or minus character 
although they can appear later in an NCName.

Allowed characters: -, ., 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, _, 
a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z

Also, - and . cannot be used as the first character of the value.

Disallowed characters: , !, ", #, $, %, &, ', (, ), *, +, ,, /, :, ;, <, =, >, ?, @, [, \, ], ^, `, {, |, }, ~ -->   <!-- <topicref href="../../common_newest/Rosetta_identifier-LxAdv-ID_data_type-HandlingDuplicates.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>Identifier values in the source, such as <xd:i>@id</xd:i>, may not have
					uniqueness constraints applied to them. As a result, duplicate identifier values
					may exist. If such values are mapped to a target such as
						<xd:b>@xml:id</xd:b>, schema validation errors will occur. The
						<xd:b>@xml:id</xd:b> attribute is ID data typed, and therefore
						<xd:i>does</xd:i> have the uniqueness constraint applied. In this case:<xd:ul>
               <xd:li>convert the first value in the duplicate sequence</xd:li>
               <xd:li>drop the remaining values in the duplicate sequence</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;table id="T0103011"&gt; ... &lt;/table&gt; &lt;/p&gt;
					&lt;page count="302" /&gt; &lt;p&gt; &lt;table id="T0103011"&gt; ...
					&lt;/table&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;table xml:id="T0103011"&gt; ... &lt;/table&gt; &lt;/p&gt;
					&lt;ref:page num="302"/&gt; &lt;p&gt; &lt;table&gt; ... &lt;/table&gt;
					&lt;/p&gt; </xd:pre>
         <!--Changes2012-10-18: Created. -->
         <!-- SEP 2015-8-12 added;  need to better combine with other @id functions -->
         <!--<xsltinclusion>
				<xsl:stylesheet version="2.0">
				<xsl:template match="*[@id]">
					<xsl:variable name="idval" select="@id"/>
					<xsl:choose>
						<xsl:when test="preceding::*[@id=$idval]">
							<xsl:copy>
								<xsl:apply-templates select="@*[name()!='id'] | node()"/>
							</xsl:copy>               
						</xsl:when>
						<xsl:otherwise>
							<xsl:copy>
								<xsl:apply-templates select="@* | node()"/>
							</xsl:copy>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:template>      
			</xsl:stylesheet>
			</xsltinclusion>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_identifier-LxAdv-ID_data_type-HandlingDuplicates.dita  -->
   <!-- 1.	 There are @id and @ID elements in dictionarydoc-norm.dtd.  
		In some cases these need to be transformed to xml:id and in other cases they need to be transformed to @id.  
		All of them need to be checked for duplicate values. We know these 4 cases:
           The mapping of refpt/@id to ref:anchor/@id - IS DONE IN THIS AND modules/nonamespace/Rosetta_refpt-LxAdv-ref.anchor.xsl
           The following mapping is NOT YET DONE as of 3/20/17 because these modules are not in scope for HK05:
           The mapping of footnote/@fntoken to footnote/ref:anchor/@id
           The mapping fnr/@fnrtoken to footnote-ref/ref:anchor/@id
           The mapping of fnr/@fntoken to foonote-ref/@anchoridref
 -->
   <!-- keys for testing -->
   <!--
	<xsl:key name="idTypeValue" match="*[@id]" use="@id"/>
	<xsl:key name="idTypeValue" match="*[@ID]" use="@ID"/>
	<xsl:key name="idTypeValue" match="footnote" use="@fntoken"/>
	<xsl:key name="idTypeValue" match="fnr" use="@fnrtoken"/>

	<xsl:include href="Rosetta_identifier-LxAdv-ID_data_type-HandlingPatternRestrictions.xsl"/>
	
	<xsl:template match="refpt">
		<xsl:apply-templates/>	
		**<xsl:call-template name="amIaDuplicate"/>**
	</xsl:template>
	<xsl:template match="footnote">
		<xsl:apply-templates/>	
		**<xsl:call-template name="amIaDuplicate"/>**
	</xsl:template>
	<xsl:template match="fnr">
		<xsl:apply-templates/>	
		**<xsl:call-template name="amIaDuplicate"/>**
	</xsl:template>
	<xsl:template match="title">
		<xsl:apply-templates/>
		<xsl:if test="@ID or @id">	
			**<xsl:call-template name="amIaDuplicate"/>**
		</xsl:if>	
	</xsl:template>-->
   <!-- end testing code -->
   <xsl:template match="@id | @ID">
      <xsl:if test="not(.='')">
         <xsl:variable name="dupStatus">
            <xsl:for-each select="parent::*">
               <xsl:call-template name="amIaDuplicate"/>
            </xsl:for-each>
         </xsl:variable>
         <xsl:if test="$dupStatus = 'false'">
            <xsl:choose>
               <xsl:when test="local-name(parent::*)='refpt'">
                  <xsl:attribute name="id">
                     <xsl:call-template name="normalizeIdString"/>
                  </xsl:attribute>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:attribute name="xml:id">
                     <xsl:call-template name="normalizeIdString"/>
                  </xsl:attribute>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:if>
      </xsl:if>
   </xsl:template>
   <!-- *****************************************************************************
			 This named template "amIaDuplicate" returns 'false' if the @id or @ID is 
			 a unique */@ID or  */@id in the document. It returns 'true' if the @id 
			 or @ID is the 2nd or subsequent @id or @ID in the document with the same value.
			 The parent element name does not matter; whether the attribute name is @id 
			 or @ID does not matter.
			 
			 It must be used in conjunction with
			 
			 	<xsl:key name="idTypeValue" match="*[@id]" use="@id"/> 
				<xsl:key name="idTypeValue" match="*[@ID]" use="@ID"/>
				(if your stream contains footnotes also include)
				<xsl:key name="idTypeValue" match="footnote" use="@fntoken"/>
	            <xsl:key name="idTypeValue" match="fnr" use="@fnrtoken"/>
	            
			BOTH inserted at the TOP LEVEL of the stylesheet driver.
			
			It needs to be called from the element containing the attribute as a context
			node, not the attribute itself, or it won't work
			
			For example:
				<xsl:template match="refpt">
					<xsl:call-template name="amIaDuplicate"/>	
				</xsl:template>
				
			will return true if this is a refpt with unique @id or is the first of 
			more than one element in the document having the same @id or @ID value.
			How the context template handles this boolean value is left as an exercise
			for the developer of that template. 
						
			If the test for unique values is element-specific or attribute-specific
			within the document, a copy of/variation on this code with a more specific key is 
			recommended rather than reusing this generic template.
			
			- JL
		********************************************************************************-->
   <xsl:template name="amIaDuplicate">
      <xsl:choose>
         <xsl:when test="not(key('idTypeValue', @id | @ID | @fntoken[parent::footnote] | @fnrtoken[parent::fnr])[2])"><!-- id value is unique to document -->
            <xsl:text>false</xsl:text>
         </xsl:when>
         <xsl:otherwise>
            <xsl:variable name="contextNodeGenID" select="generate-id(.)"/>
            <xsl:choose>
               <xsl:when test="key('idTypeValue', @id | @ID | @fntoken[parent::footnote] | @fnrtoken[parent::fnr])[local-name(.)!=('refpt', 'footnote' , 'fnr')] and key('idTypeValue', @id | @ID)[local-name(.)=('refpt' , 'footnote', 'fnr')]"><!--*** key has mixed refpt, footnote, fnr / and other values ***--><!-- non-refpt/footenote/fnr values are all dupes by definition --><!-- TO DO only the first refpt/footnote/fnr key is false --><!-- so IF I am the first refpt/footnote/fnr, I am the only nondupe -->
                  <xsl:for-each select="key('idTypeValue', @id | @ID | @fntoken[parent::footnote] | @fnrtoken[parent::fnr])[local-name(.)=('refpt' , 'footnote', 'fnr')][1]">
                     <xsl:choose>
                        <xsl:when test="generate-id(.)=$contextNodeGenID">false</xsl:when>
                        <xsl:otherwise>true</xsl:otherwise>
                     </xsl:choose>
                  </xsl:for-each>
               </xsl:when>
               <xsl:otherwise><!-- everything with matching id is a refpt/footnote/fnr or everything with matching id is not a 
							refpt/footnote/fnr	so everything but the first id is a dup -->
                  <xsl:for-each select="key('idTypeValue', @id | @ID | @fntoken[parent::footnote] | @fnrtoken[parent::fnr])[1]">
                     <xsl:choose>
                        <xsl:when test="generate-id(.)=$contextNodeGenID">false</xsl:when>
                        <xsl:otherwise>true</xsl:otherwise>
                     </xsl:choose>
                  </xsl:for-each>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--<xsl:template match="@xml:id">	
		<xsl:variable name="idval" select="."/>
		<xsl:if test="not(preceding::*[@xml:id=$idval])">
			<xsl:attribute name="xml:id">	
				<xsl:call-template name="normalizeIdString"/>
			</xsl:attribute>
		</xsl:if>		
	</xsl:template>	-->   <!-- end topichead  Mapping to ID Data Type  -->   <!-- start topichead  Headnote  -->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.headnote-LxAdv_courtcase.head.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:headnote&gt;
    ...
    &lt;glp:note&gt;
        &lt;p&gt;
            &lt;text&gt;[&lt;emph typestyle="bf"&gt;Note. &lt;/emph&gt; As to the distinction between exemplary and aggravated damages, see &lt;emph typestyle="it"&gt;Luntz on Assessment of Damages &lt;/emph&gt; (2nd ed) para 1.7.01 &lt;emph typestyle="it"&gt;et seq &lt;/emph&gt; and 12 &lt;emph typestyle="it"&gt;Halsbury's Laws of England &lt;/emph&gt; (4th ed) para 1189.] &lt;/text&gt;
        &lt;/p&gt;
    &lt;/glp:note&gt;
&lt;/case:headnote&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:head&gt;
    ...
    &lt;note&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;[&lt;emph typestyle="bf"&gt;Note. &lt;/emph&gt; As to the distinction between exemplary and aggravated damages, see &lt;emph typestyle="it"&gt;Luntz on Assessment of Damages &lt;/emph&gt; (2nd ed) para 1.7.01 &lt;emph typestyle="it"&gt;et seq &lt;/emph&gt; and 12 &lt;emph typestyle="it"&gt;Halsbury's Laws of England &lt;/emph&gt; (4th ed) para 1189.] &lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/note&gt;
&lt;/courtcase:head&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>heading</xd:i> occurs as a direct child of <xd:i>case:headnote</xd:i>, then conversion
            should create <xd:b>heading</xd:b> as direct child of <xd:b>caseinfo:caseinfo</xd:b>, i.e.
            <xd:i>case:headnote/heading</xd:i> becomes
            <xd:b>courtcase:head/caseinfo:caseinfo/heading</xd:b>.</xd:p>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.headnote-LxAdv_courtcase.head.dita#Rosetta_case.headnote-LxAdv_courtcase.head/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
            </section>-->
         <xd:p>
            <xd:b>case:headnote/footnotegrp and case:headnote/page</xd:b>
         </xd:p>
         <xd:p>If <xd:i>footnotegrp</xd:i> occurs as a direct child of <xd:i>case:headnote</xd:i> 
             then the conversion should append this element as children of nearest element containing bodytext.</xd:p>
         <xd:p>If <xd:i>page</xd:i> occurs as a direct child of <xd:i>case:headnote</xd:i> 
             then the conversion should append this element as children of nearest element.</xd:p>
         <xd:p>The resulting conversion should maintain a physical order with the existing document content.</xd:p>
         <xd:p>
            <xd:b>Source: <xd:i>case:headnote/footnotegrp and case:headnote/page</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
             
&lt;case:body&gt;
  &lt;case:headnote&gt;
   &lt;case:length&gt;20 Pages&lt;/case:length&gt;
   &lt;case:info&gt;...&lt;/case:info&gt;
   &lt;catchwordgrp&gt;
    &lt;catchwords&gt;...&lt;/catchwords&gt;
   &lt;/catchwordgrp&gt;
   &lt;case:factsummary&gt;
   ...
    &lt;p&gt;
     &lt;text&gt;Section 135.4(9) provided that for a person to be guilty of such an offence, &lt;nl/&gt;that
      person must have entered into an agreement with one or more other persons, &lt;nl/&gt;the person and
      at least one other party to the agreement must have intended to do &lt;nl/&gt;the thing pursuant to
      the agreement, and those persons must have committed an &lt;nl/&gt;overt act pursuant to the
      agreement.&lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
     &lt;text&gt;By s&amp;#x2009;4.1(1) of the Code, a physical element of an offence could be conduct,
      &lt;nl/&gt;and, under s&amp;#x2009;4.1(2), &amp;#x201C;conduct&amp;#x201D; was defined to mean &amp;#x201C;an act,
      an omission to &lt;nl/&gt;perform an act or a state of affairs&amp;#x201D;.&lt;/text&gt;
    &lt;/p&gt;
   &lt;/case:factsummary&gt;
   &lt;footnotegrp&gt;
    &lt;footnote fntoken="2011-80-NSWLR-486.fn_a" fnrtokens="2011-80-NSWLR-486.fnr_a"&gt;
     &lt;fnlabel&gt;*&lt;/fnlabel&gt;
     &lt;fnbody&gt;
      &lt;p&gt;
       &lt;text&gt;[EDITORIAL NOTE: An application for special leave to appeal to the High Court was
        refused.]&lt;/text&gt;
      &lt;/p&gt;
     &lt;/fnbody&gt;
    &lt;/footnote&gt;
   &lt;/footnotegrp&gt;
   &lt;page count="487" reporter="NSWLR" text="(2011) 80 NSWLR 486 at " subdoc="true"/&gt;
   &lt;case:decisionsummary&gt;
    &lt;p&gt;
     &lt;text&gt;...             
             
         </xd:pre>
         <xd:p>
            <xd:b>Target: <xd:i>courtcase:head/casesum:summaries</xd:i> with <xd:b>footnotegroup</xd:b> and <xd:b>ref:page</xd:b>
            </xd:b>
         </xd:p>
         <xd:pre>
             
 &lt;courtcase:head&gt;
   &lt;caseinfo:caseinfo&gt;...&lt;/caseinfo:caseinfo&gt;
   &lt;casesum:summaries&gt;
      &lt;casesum:editorialsummary&gt;
         ...
         &lt;p&gt;
           &lt;text&gt;
           Section 135.4(9) provided that for a person to be guilty of such an offence, 
           &lt;proc:nl /&gt; 
           that person must have entered into an agreement with one or more other persons, 
           &lt;proc:nl /&gt; 
           the person and at least one other party to the agreement must have intended to do 
           &lt;proc:nl /&gt; 
           the thing pursuant to the agreement, and those persons must have committed an 
           &lt;proc:nl /&gt; 
           overt act pursuant to the agreement. 
           &lt;/text&gt;
         &lt;/p&gt;
          &lt;p&gt;
           &lt;text&gt;
           By s?4.1(1) of the Code, a physical element of an offence could be conduct, 
           &lt;proc:nl /&gt; 
           and, under s?4.1(2), conduct was defined to mean an act, an omission to 
           &lt;proc:nl /&gt; 
           perform an act or a state of affairs. 
           &lt;/text&gt;
         &lt;/p&gt;
         &lt;p&gt;
           &lt;text&gt;
             &lt;footnotegroup&gt;
               &lt;footnote&gt;
                 &lt;ref:anchor id="_2011-80-NSWLR-486.fn_a" /&gt; 
                 &lt;ref:returnreference&gt;
                    &lt;ref:locator anchoridref="_2011-80-NSWLR-486.fnr_a" anchortype="local" /&gt; 
                 &lt;/ref:returnreference&gt;
                 &lt;label&gt;*&lt;/label&gt; 
                 &lt;bodytext&gt;
                    &lt;p&gt;
                     &lt;text&gt;[EDITORIAL NOTE: An application for special leave to appeal to the High Court was refused.]&lt;/text&gt; 
                    &lt;/p&gt;
                 &lt;/bodytext&gt;
               &lt;/footnote&gt;
             &lt;/footnotegroup&gt;
           &lt;/text&gt;
        &lt;/p&gt;
       &lt;ref:page includeintoc="true" num="487" page-scheme="500067" page-scheme-type="reporter-series-code" /&gt; 
         &lt;/casesum:editorialsummary&gt;
         &lt;casesum:decisionsummary&gt;
           &lt;bodytext&gt;
             &lt;p&gt;...            
             
         </xd:pre>
         <!--Changes2015-01-21: Added instruction and example for footnotegroup and page elements that
                occur as child of case:headnote.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.headnote-LxAdv_courtcase.head.dita  -->
   <xsl:template match="case:headnote"><!--  Original Target XPath:  ref:page   -->
      <courtcase:head>
         <xsl:apply-templates select="case:info/case:reportercite[@searchtype='BCNUM']" mode="search"/>
         <xsl:for-each-group select="*" group-adjacent="if(self::case:info) then 1 else 0">
            <xsl:if test="current-grouping-key()=1">
               <caseinfo:caseinfo>
                  <xsl:apply-templates select="preceding::heading[parent::case:body]"/>
                  <xsl:for-each select="current-group()">
                     <xsl:apply-templates select="//case:body/case:headnote/heading"/>
                     <xsl:apply-templates select="@* | node() except preceding::heading[parent::case:body] except fnr[preceding-sibling::case:casename]"/>
                     <!--<xsl:apply-templates select="case:reportercite"/>-->
                     <xsl:apply-templates select="case:info/h"/>
                     <!--    <xsl:apply-templates select="case:courtinfo/case:judges[ancestor::case:headnote]"/>-->
                     <!--<xsl:apply-templates select="case:courtinfo/case:filenum"/> -->
                     <!--  <xsl:apply-templates select="case:courtinfo/case:courtcite"/>-->
                     <!--webstar 7046666 fix by Pawan Prasad-->
                     <!-- <xsl:apply-templates select="case:courtinfo/case:dates"/>-->
                  </xsl:for-each>
                  <xsl:apply-templates select="following-sibling::catchwordgrp"/>
               </caseinfo:caseinfo>
            </xsl:if>
         </xsl:for-each-group>
         <!--<xsl:apply-templates select="case:body/case:headnote/catchwordgrp"/>-->
         <!-- Awantika: wrapper casesum:summaries for factsummary and decisionsummary -->
         <xsl:if test="case:factsummary | case:decisionsummary | case:references">
            <casesum:summaries>
               <xsl:apply-templates select="case:factsummary" mode="summaries"/>
               <xsl:apply-templates select="case:decisionsummary" mode="summaries"/>
               <xsl:apply-templates select="case:disposition[parent::case:headnote]" mode="summaries"/>
               <!--<xsl:apply-templates select="case:body/case:headnote/case:citations" mode="summaries"></xsl:apply-templates>-->
               <!--<xsl:apply-templates select="case:body/case:content/case:typeofcase" mode="summaries-->
            </casesum:summaries>
            <xsl:apply-templates select="case:references"/>
            <xsl:apply-templates select="case:citations"/>
         </xsl:if>
         <xsl:apply-templates select="footnotegrp"/>
      </courtcase:head>
   </xsl:template>

   <xsl:template match="case:headnote/heading">
      <heading>
         <xsl:apply-templates/>
      </heading>
   </xsl:template>
   <!-- Already Done -->   <!-- <topicref href="AU01_Rosetta_case.length-LxAdv_doc.doclength.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:length&gt;47 Paragraphs&lt;/case:length&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;doc:metadata&gt;
    &lt;doc:docinfo&gt;
        ...
        &lt;doc:doclength num="47" unit="Paragraphs" source="conversion"/&gt;
        ...
    &lt;/doc:docinfo&gt;
&lt;/doc:metadata&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>case:length</xd:i> occurs within
                <xd:i>case:embeddedcase</xd:i>, then conversion should suppress
                <xd:i>case:length</xd:i> and its content.</xd:p>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.length-LxAdv_doc.doclength.dita#Rosetta_case.length-LxAdv_doc.doclength/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
            </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.length-LxAdv_doc.doclength.dita  -->
   <xsl:template match="case:length">
      <doc:doclength source="conversion">
         <xsl:attribute name="num">
            <xsl:value-of select="normalize-space(replace(.,'\D+',''))"/>
         </xsl:attribute>
         <xsl:attribute name="unit">
            <xsl:value-of select="normalize-space(replace(.,'\d+',''))"/>
         </xsl:attribute>
      </doc:doclength>
   </xsl:template>

   <xsl:template match="case:length[ancestor::case:embeddedcase]"/>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.info-LxAdv_caseinfo.caseinfo.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:info&gt;
  ...
&lt;/case:info&gt;
      </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
  ...
&lt;/caseinfo:caseinfo&gt;
            </xd:pre>
         <xd:p>When <xd:i>heading</xd:i> occurs as direct child of
          <xd:i>case:body</xd:i> conversion should create <xd:b>heading</xd:b>
        as direct child of <xd:b>caseinfo:caseinfo</xd:b>, i.e.
          <xd:i>case:body/heading</xd:i> becomes
          <xd:b>caseinfo:caseinfo/heading</xd:b>.</xd:p>
         <xd:p>When <xd:i>h</xd:i> occurs as direct child of <xd:i>case:info</xd:i>
        conversion should create <xd:b>heading</xd:b> as direct child of
          <xd:b>caseinfo:caseinfo</xd:b>, i.e. <xd:i>case:info/h</xd:i> becomes
          <xd:b>caseinfo:caseinfo/heading</xd:b>.</xd:p>
         <xd:pre>
&lt;case:info&gt;
  ...
  &lt;h&gt;Application for registration of trade mark &lt;emph typestyle="smcaps"&gt;&lt;emph typestyle="ro"&gt;cedarapids&lt;/emph&gt;&lt;/emph&gt;&lt;/h&gt;
  ...
&lt;/case:info&gt;
      </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
  ...
  &lt;heading&gt;
    &lt;title&gt;Application for registration of trade mark &lt;emph typestyle="smcaps"&gt;&lt;emph typestyle="ro"&gt;cedarapids&lt;/emph&gt;&lt;/emph&gt;&lt;/title&gt;
  &lt;/heading&gt;
  ...
&lt;/caseinfo:caseinfo&gt;
            </xd:pre>
         <!--<section
      conref="../../common_caselaw/conref_content/Rosetta_case.info-LxAdv_caseinfo.caseinfo.dita#Rosetta_case.info-LxAdv_caseinfo.caseinfo/changes"/>-->
         <!--<section>
      <title>Changes Specific to AU01</title>
      </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.info-LxAdv_caseinfo.caseinfo.dita  -->
   <xsl:template match="case:info"><!--<caseinfo:caseinfo>
      <xsl:apply-templates select="preceding::heading[parent::case:body]"/> 
      <xsl:apply-templates select="//case:body/case:headnote/heading"/>
      
      <xsl:apply-templates select="@* | node() except preceding::heading[parent::case:body]"/>   
      <!-\-<xsl:apply-templates select="case:reportercite"/>-\->
      <xsl:apply-templates select="case:info/h"/>
      <xsl:apply-templates select="case:courtinfo/case:judges[ancestor::case:headnote]"/>
      <xsl:apply-templates select="case:courtinfo/case:filenum"/>     
      <xsl:apply-templates select="case:courtinfo/case:courtcite"/>
      <xsl:apply-templates select="case:courtinfo/case:dates"/>
      <xsl:apply-templates select="//catchwordgrp"/>           
    </caseinfo:caseinfo>--></xsl:template>
   <!-- Awantika:2017-10-31- added title  -->
   <xsl:template match="case:info/h">
      <heading>
         <title>
            <xsl:apply-templates/>
         </title>
      </heading>
   </xsl:template>
   <!-- Awantika: Completed -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.casename-LxAdv_caseinfo.casename_caseinfo.fullcasename.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:casename</xd:i> becomes
          <xd:b>caseinfo:casename/caseinfo:fullcasename</xd:b>.</xd:p>
         <xd:p>Any <xd:i>nl</xd:i> elements that occur inside
          <xd:i>case:casename</xd:i> should be suppressed if they are preceded or followed
        by a space. Any <xd:i>nl</xd:i> elements that are not preceded or followed by a
        space should be converted into a single space character.</xd:p>
         <xd:p>Any occurrences of the attribute <xd:i>@ln.user-displayed</xd:i> in
        <xd:i>case:casename</xd:i> should be suppressed.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Special note for UK01-UK04, please see <xd:a href="../common_newest/Rosetta_UK_case.casename-Plus-case.reportercite-LxAdv-dc.title.dita"/> for an additional conversion that uses
        <xd:i>case:info/case:casename</xd:i>.</xd:p>
         <xd:p>
            <xd:b>Example: CA content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:casename&gt;Entre&lt;nl/&gt; Irving Oil Limited, Demanderesse, et&lt;nl/&gt; Sa Majest la Reine, Dfenderesse&lt;/case:casename&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
  &lt;caseinfo:fullcasename&gt;Entre Irving Oil Limited, Demanderesse, et Sa Majest la Reine, Dfenderesse&lt;/caseinfo:fullcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:casename&gt;Re: GOLDEN BREAD PTY. LTD.; THE QUEENSLAND &lt;nl/&gt;CO-OPERATIVE MILLING ASSOCIATION v HUTCHISON&lt;/case:casename&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
  &lt;caseinfo:fullcasename&gt;Re: GOLDEN BREAD PTY. LTD.; THE QUEENSLAND CO-OPERATIVE MILLING ASSOCIATION v HUTCHISON&lt;/caseinfo:fullcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:casename&gt;Smith (Appellant) v Mackenzie (Respondent)&lt;/case:casename&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
  &lt;caseinfo:fullcasename&gt;Smith (Appellant) v Mackenzie (Respondent)&lt;/caseinfo:fullcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:casename&gt;Crozier v Wishart &amp;amp; Company Limited and Western Printing Services Ltd&lt;/case:casename&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
    &lt;caseinfo:fullcasename&gt;Crozier v Wishart &amp;#x0026; Company Limited and Western Printing Services Ltd&lt;/caseinfo:fullcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <!--Changes2015-12-05: Added special note for UK01-UK04, RFA # 2602.2013-02-20: Added a note regarding the suppression of
        @ln.user-displayed.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.casename-LxAdv_caseinfo.casename_caseinfo.fullcasename.dita  -->
   <!-- JD: added $streamID test for VSTS Bug 379082: all casenames should be combined under a single wrapper. -->
   <xsl:template match="case:casename[$streamID='UK01']"><!--  Original Target XPath:  caseinfo:casename/caseinfo:fullcasename   --><!--		<caseinfo:casename>-->
      <caseinfo:fullcasename>
         <xsl:apply-templates select="@* | node()"/>
         <xsl:apply-templates select="following-sibling::fnr[1]"/>
      </caseinfo:fullcasename>
      <xsl:if test="following-sibling::*[1][self::case:casename]">
         <caseinfo:fullcasename>
            <xsl:apply-templates select="following-sibling::*[1][self::case:casename]/node()"/>
         </caseinfo:fullcasename>
      </xsl:if>
      <xsl:apply-templates select="parent::case:info/child::abbrvname"/>
      <!--</caseinfo:casename>-->
   </xsl:template>
   <!-- MDS 2017-07-27 - Added following-sibling::fnr[1] to address input in AU13 -->   <!-- Awantika:2017-10-31- Added the [not(preceding-sibling::*[1][self::case:casename][$streamID='AU01'])] condition to resolve the ambiguity between two case:casename on line 99 and 116-->
   <xsl:template match="case:casename[$streamID!='UK01'][not(preceding-sibling::*[1][self::case:casename][$streamID=('AU01', 'AU13')])]"><!--  Original Target XPath:  caseinfo:casename/caseinfo:fullcasename   -->
      <caseinfo:casename>
         <caseinfo:fullcasename>
            <xsl:apply-templates select="@* | node()"/>
            <xsl:apply-templates select="following-sibling::fnr[1]"/>
         </caseinfo:fullcasename>
         <xsl:if test="following-sibling::*[1][self::case:casename]">
            <caseinfo:fullcasename>
               <xsl:apply-templates select="following-sibling::*[1][self::case:casename]/node()"/>
            </caseinfo:fullcasename>
         </xsl:if>
         <xsl:apply-templates select="parent::case:info/child::abbrvname"/>
      </caseinfo:casename>
   </xsl:template>

   <xsl:template match="case:casename[preceding-sibling::*[1][self::case:casename]]"/>

   <xsl:template match="case:casename/nl[starts-with(following-sibling::*[1][self::node()],' ') or ends-with(preceding-sibling::*[1][self::node()],' ')][$streamID='CA01']"
                 priority="2"/>

   <xsl:template match="case:casename/nl[$streamID='CA01']" priority="1">
      <xsl:text xml:space="preserve"> </xsl:text>
   </xsl:template>
   <!-- Awantika: 2018-02-02- Updated for space issue with nl. W*7104004 -->
   <xsl:template match="case:casename/text()[following-sibling::*[name() = 'nl']]">
      <xsl:value-of select="normalize-space(.)"/>
   </xsl:template>

   <xsl:template match="case:casename/nl">
      <xsl:choose>
         <xsl:when test="ends-with(preceding-sibling::text()[1], ' ') or starts-with(following-sibling::text()[1], ' ')">
            <xsl:text> </xsl:text>
         </xsl:when>
         <xsl:otherwise><!--<xsl:text> </xsl:text>--></xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="case:casename/@ln.user-displayed"/>

   <xsl:template match="case:casename/@searchtype"/>
   <!-- <topicref href="../../common_caselaw/Rosetta_case.altname-LxAdv_caseinfo.alternatecasename.dita"/> -->   <!-- Awantika: Completed -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:altname</xd:i> becomes
          <xd:b>caseinfo:caseinfo/caseinfo:alternatecasename</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b>
        elements. When 2 or more consecutive sibling source elements map to
          <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to a single
          <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content
        ordering.</xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:info&gt;
    &lt;case:casename&gt;ELECON AUSTRALIA PTY LTD v BREVINI AUSTRALIA PTY LTD (NSD 1423 of
        2004)&lt;/case:casename&gt;
    &lt;case:altname&gt;PIV DRIVES GMBH and Another v ELECON AUSTRALIA PTY LTD and Others (NSD 1955 of
        2004)&lt;/case:altname&gt;
&lt;/case:info&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
    &lt;caseinfo:casename&gt;
        &lt;caseinfo:fullcasename&gt;ELECON AUSTRALIA PTY LTD v BREVINI AUSTRALIA PTY LTD (NSD 1423 of
            2004)&lt;/caseinfo:fullcasename&gt;
    &lt;/caseinfo:casename&gt;
    &lt;caseinfo:alternatecasename&gt;PIV DRIVES GMBH and Another v ELECON AUSTRALIA PTY LTD and Others
        (NSD 1955 of 2004)&lt;/caseinfo:alternatecasename&gt;
&lt;/caseinfo:caseinfo&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:info&gt;
    &lt;case:casename&gt;HITCHENS v DOUBLE ZERO HOLDINGS LTD&lt;/case:casename&gt;
    &lt;case:altname&gt;RABSON v DOUBLE ZERO HOLDINGS LTD&lt;/case:altname&gt;
&lt;/case:info&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
    &lt;caseinfo:casename&gt;
        &lt;caseinfo:fullcasename&gt;HITCHENS v DOUBLE ZERO HOLDINGS LTD&lt;/caseinfo:fullcasename&gt;
    &lt;/caseinfo:casename&gt;
    &lt;caseinfo:alternatecasename&gt;RABSON v DOUBLE ZERO HOLDINGS LTD&lt;/caseinfo:alternatecasename&gt;
&lt;/caseinfo:caseinfo&gt;
           </xd:pre>
         <!--<section>
      <title>Changes</title>
    </section>-->
         <xd:p>For AU13 Content - <xd:i>case:altname</xd:i> becomes
              <xd:b>compcase:caseinfo/caseinfo:alternatecasename</xd:b>.</xd:p>
         <xd:pre>
              &lt;case:info&gt;
              &lt;case:casename&gt;Re SFE CORPORATION LTD (ABN 74 000 299 392) (No 1)
              &lt;/case:casename&gt;
              &lt;case:altname&gt;Re SFE CORPORATION LTD (ABN 74 000 299 392) (No 2)&lt;/case:altname&gt;
              ...
              &lt;/case:info&gt;
          </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
              &lt;compcase:caseinfo&gt;
              &lt;caseinfo:casename&gt;
              &lt;caseinfo:fullcasename&gt;Re SFE CORPORATION LTD (ABN 74 000 299 392) (No 1)
              &lt;/caseinfo:fullcasename&gt;
              &lt;/caseinfo:casename&gt;
              &lt;caseinfo:alternatecasename&gt;Re SFE CORPORATION LTD (ABN 74 000 299 392) (No 2)
              &lt;/caseinfo:alternatecasename&gt;
              ...
              &lt;/compcase:caseinfo&gt;
          </xd:pre>
         <!--Changes2013-09-23: Created per WebTeam #236556.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.altname-LxAdv_caseinfo.alternatecasename.dita  -->
   <xsl:template match="case:altname"><!--  Original Target XPath:  caseinfo:caseinfo/caseinfo:alternatecasename   -->
      <caseinfo:alternatecasename>
         <xsl:apply-templates select="@* | node()"/>
      </caseinfo:alternatecasename>
   </xsl:template>
   <!-- <topicref href="AU01_Rosetta_case.courtinfo_abbrvname-LxAdv_caseinfo.shortcasename.dita"/> -->   <!-- Awantika: Completed -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:courtinfo/abbrvname</xd:i> becomes
          <xd:b>caseinfo:casename/caseinfo:shortcasename</xd:b>.</xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
  &lt;abbrvname&gt;SPEDDING v NOBLES;&lt;/abbrvname&gt;
&lt;/case:courtinfo&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
  &lt;caseinfo:shortcasename&gt;SPEDDING v NOBLES;&lt;/caseinfo:shortcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <xd:p>When <xd:i>emph</xd:i> is a child of <xd:i>abbrvname</xd:i> then
        conversion should suppressed the <xd:i>emph</xd:i> element from the conversion and
        retain the text in lowecase.</xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
    &lt;abbrvname&gt;R &lt;emph typestyle="smcaps"&gt;V&lt;/emph&gt; SAFFRON&lt;/abbrvname&gt;
&lt;/case:courtinfo&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:casename&gt;
    &lt;caseinfo:shortcasename&gt;R v SAFFRON&lt;/caseinfo:shortcasename&gt;
&lt;/caseinfo:casename&gt;
           </xd:pre>
         <!--Changes2013-11-12: Added Instruction and example when emph is a child of abbrvname. Webstar #: 5093906. This change immediately applies to AU01 Caselaw.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.courtinfo_abbrvname-LxAdv_caseinfo.shortcasename.dita  -->
   <xsl:template match="abbrvname"><!--  Original Target XPath:  caseinfo:casename/caseinfo:shortcasename   -->
      <caseinfo:shortcasename>
         <xsl:apply-templates select="@* | node()"/>
      </caseinfo:shortcasename>
   </xsl:template>
   <!-- Awantika: 2017-11-22- -->
   <xsl:template match="abbrvname/@display-name">
      <xsl:attribute name="name">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="abbrvname/emph"/>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.reportercite-LxAdv_ref.cite4thisresource.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:reportercite</xd:i> becomes <xd:b>ref:citations</xd:b> with child elements as described below: <xd:ul>
                  <xd:li> Create <xd:b>caseinfo:caseinfo/ref:citations/ref:cite4thisresource</xd:b> with attribute <xd:b>@citetype</xd:b> defines the type of citation "reporter". <xd:p>
                        <xd:b>Note: </xd:b>For handling of citation markup; kindly
                refer to the instructions for <xd:i>ci:cite</xd:i> in the General Markup section.</xd:p>
                     <xd:p>
                        <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b> elements. When 2 or more consecutive sibling
                source elements map to <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to a single
                  <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content ordering.</xd:p>
                  </xd:li>
               </xd:ul>
               <xd:pre>

&lt;case:reportercite&gt;
  &lt;ci:cite type="cite4thisdoc"&gt;
    &lt;ci:case&gt;
      &lt;ci:caseinfo&gt;
        &lt;ci:decisiondate year="2009"/&gt;
      &lt;/ci:caseinfo&gt;
      &lt;ci:caseref&gt;
        &lt;ci:reporter value="ALR"/&gt;
        &lt;ci:volume num="256"/&gt;
        &lt;ci:edition&gt;
          &lt;ci:date year="2009"/&gt;
        &lt;/ci:edition&gt;
        &lt;ci:page num="25"/&gt;
        &lt;ci:pinpoint targettype="para" num="4"/&gt;
      &lt;/ci:caseref&gt;
    &lt;/ci:case&gt;
    &lt;ci:content&gt;
      &lt;citefragment searchtype="CASE-CITE-REF"&gt;(2009) 256 ALR 25&lt;/citefragment&gt;
    &lt;/ci:content&gt;    
  &lt;/ci:cite&gt;
&lt;/case:reportercite&gt;
<xd:b>Becomes</xd:b>

&lt;ref:citations&gt;
  &lt;ref:cite4thisresource citetype="reporter"&gt;
    &lt;lnci:cite&gt;
      &lt;lnci:case&gt;
        &lt;lnci:caseinfo&gt;
          &lt;lnci:decisiondate year="2009"/&gt;
        &lt;/lnci:caseinfo&gt;
        &lt;lnci:caseref&gt;
          &lt;lnci:reporter value="ALR"/&gt;
          &lt;lnci:volume num="256"/&gt;
          &lt;lnci:edition&gt;
            &lt;lnci:date year="2009"/&gt;
          &lt;/lnci:edition&gt;
          &lt;lnci:page num="25"/&gt;
          &lt;lnci:pinpoint targettype="para" num="4"/&gt;
        &lt;/lnci:caseref&gt;
      &lt;/lnci:case&gt;
      &lt;lnci:content&gt;(2009) 256 ALR 25&lt;/lnci:content&gt;
    &lt;/lnci:cite&gt;
  &lt;/ref:cite4thisresource&gt;
&lt;/ref:citations&gt;
</xd:pre>
            </xd:li>
         </xd:ul>
         <xd:p>If <xd:i>case:reportercite/@searchtype</xd:i> has a value of "BCNUM", this indicates that the case is unreported and additional
        markup should be added to <xd:b>courtcase:head</xd:b>: <xd:ul>
               <xd:li>Create <xd:b>courtcase:statusnotice</xd:b>.<xd:ul>
                     <xd:li>Create <xd:b>courtcase:pubstatus</xd:b> with the attribute <xd:b>@status</xd:b> set to "none". <xd:ul>
                           <xd:li>Create <xd:b>p/text</xd:b> and populate <xd:b>text</xd:b> with "unreported case" (don't include
                    quotes).</xd:li>
                        </xd:ul>
                     </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Additional markup for an unreported case</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:reportercite searchtype="BCNUM"&gt;
    &lt;ci:cite type="cite4thisdoc"&gt;
        &lt;ci:case&gt;
            &lt;ci:caseref&gt;
                &lt;ci:reporter value="urj"/&gt;
                &lt;ci:refnum num="BC9002970"/&gt;
            &lt;/ci:caseref&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;
            &lt;citefragment searchtype="CASE-CITE-REF"&gt;BC9002970&lt;/citefragment&gt;
        &lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:reportercite&gt;

           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>

&lt;courtcase:head&gt;
    &lt;courtcase:statusnotice&gt;
        &lt;courtcase:pubstatus status="none"&gt;
            &lt;p&gt;
                &lt;text&gt;unreported case&lt;/text&gt;
            &lt;/p&gt;
        &lt;/courtcase:pubstatus&gt;
    &lt;/courtcase:statusnotice&gt;
    ...
    &lt;ref:citations&gt;
    &lt;ref:cite4thisresource citetype="reporter"&gt;
        &lt;lnci:cite&gt;
            &lt;lnci:case&gt;
                &lt;lnci:caseref&gt;
                    &lt;lnci:reporter value="urj"/&gt;
                    &lt;lnci:refnum num="BC9002970"/&gt;
                &lt;/lnci:caseref&gt;
            &lt;/lnci:case&gt;
            &lt;lnci:content&gt;BC9002970&lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;
    &lt;/ref:cite4thisresource&gt;
&lt;/ref:citations&gt;
&lt;/courtcase:head&gt;

           </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.reportercite-LxAdv_ref.cite4thisresource.dita  -->
   <xsl:template match="case:reportercite"><!--  Original Target XPath:  ref:citations   -->
      <ref:citations>
         <ref:cite4thisresource>
            <xsl:attribute name="citetype">
               <xsl:text>reporter</xsl:text>
            </xsl:attribute>
            <xsl:apply-templates select="@* | node()"/>
         </ref:cite4thisresource>
      </ref:citations>
   </xsl:template>

   <xsl:template match="case:reportercite[@searchtype='BCNUM']" mode="search">
      <courtcase:statusnotice>
         <courtcase:pubstatus status="none">
            <p>
               <text>unreported case</text>
            </p>
         </courtcase:pubstatus>
      </courtcase:statusnotice>
   </xsl:template>
   <!--<xsl:template match="case:reportercite[@searchtype!='BCNUM']">
		<ref:citations>
			<ref:cite4thisresource citetype="reporter">
				<xsl:apply-templates select="@* | node()"/>
			</ref:cite4thisresource>
		</ref:citations>
	</xsl:template>
	
	<xsl:template match="case:reportercite/@searchtype"/>

	<xsl:template match="case:reportercite[@searchtype='BCNUM']">
		<courtcase:statusnotice>
			<courtcase:pubstatus status="none">
				<p>
					<text>unreported case</text>
				</p>
			</courtcase:pubstatus>
		</courtcase:statusnotice>
	  <!-\-<xsl:apply-templates select="case:reportercite"/>-\->
		<!-\-<ref:citations>
			<ref:cite4thisresource citetype="reporter">				
				<xsl:apply-templates select="@* | node()"/>
			</ref:cite4thisresource>
		</ref:citations>-\->
	</xsl:template>-->
   <xsl:template match="case:reportercite/@searchtype"/>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.parallelcite-LxAdv_ref.cite4thisresource.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Text occurring between <xd:i>case:parallelcite</xd:i> and
          <xd:i>ci:cite</xd:i> should be dropped since it will be handled on a
        presentation spec level.</xd:p>
         <xd:p>For <xd:i>case:parallelcite[ci:cite@type="reporter"]</xd:i>then it becomes
        <xd:b> ref:parallelcite[@citetype="reporter"]</xd:b>.</xd:p>
         <xd:pre>
&lt;case:info&gt;
  &lt;case:parallelcite&gt;Also reported at: &lt;ci:cite searchtype="CASE-REF"&gt;
      &lt;ci:case&gt;
        &lt;ci:caseref ID="cr000001" spanref="cr000001-001"&gt;
          &lt;ci:reporter value="Qd R"/&gt;
          &lt;ci:volume num="2"/&gt;
          &lt;ci:edition&gt;
            &lt;ci:date year="1995"/&gt;
          &lt;/ci:edition&gt;
          &lt;ci:page num="506"/&gt;
        &lt;/ci:caseref&gt;
      &lt;/ci:case&gt;
      &lt;ci:content&gt;
        &lt;citefragment searchtype="CASE-CITE-REF"&gt;
          &lt;ci:span spanid="cr000001-001"&gt;[1995] 2 Qd R 506&lt;/ci:span&gt;
        &lt;/citefragment&gt;
      &lt;/ci:content&gt;
    &lt;/ci:cite&gt;
  &lt;/case:parallelcite&gt;
&lt;/case:info&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
  &lt;ref:citations&gt;
    &lt;ref:cite4thisresource citetype="parallel"&gt;
      &lt;lnci:cite&gt;
        &lt;lnci:case&gt;
          &lt;lnci:caseref ID="cr000001"&gt;
            &lt;lnci:reporter value="Qd R"/&gt;
            &lt;lnci:volume num="2"/&gt;
            &lt;lnci:edition&gt;
              &lt;lnci:date year="1995"/&gt;
            &lt;/lnci:edition&gt;
            &lt;lnci:page num="506"/&gt;
          &lt;/lnci:caseref&gt;
        &lt;/lnci:case&gt;
        &lt;lnci:content&gt;[1995] 2 Qd R 506&lt;/lnci:content&gt;
      &lt;/lnci:cite&gt;
    &lt;/ref:cite4thisresource&gt;
  &lt;/ref:citations&gt;
&lt;/caseinfo:caseinfo&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Changes Specific to AU01</xd:b>
         </xd:p>
         <xd:p>2016-06-07: Added new instruction <xd:i>case:parallelcite[ci:cite@type="reporter"]</xd:i>to
        <xd:b> ref:parallelcite[@citetype="reporter"]</xd:b> Applicable on AU01, Webstar # 6497089.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.parallelcite-LxAdv_ref.cite4thisresource.dita  -->
   <xsl:template match="case:parallelcite"><!--  Original Target XPath:  ref:parallelcite[@citetype="reporter"]
		-->
      <ref:citations>
         <ref:cite4thisresource citetype="parallel">
            <xsl:apply-templates select="@* | node()"/>
         </ref:cite4thisresource>
      </ref:citations>
   </xsl:template>

   <xsl:template match="case:parallelcite/@ln.user-displayed"/>

   <xsl:template match="text()[parent::case:parallelcite and following-sibling::ci:cite]"/>

   <xsl:template match="case:parallelcite[ci:cite[@type='reporter']]">
      <ref:citations>
         <ref:parallelcite>
            <xsl:apply-templates select="@* | node()"/>
         </ref:parallelcite>
      </ref:citations>
   </xsl:template>
   <!-- Already Done -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.courtinfo-LxAdv_caseinfo.caseinfo_caseinfo.jurisinfo.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:courtinfo</xd:i> becomes
					<xd:b>/caseinfo:caseinfo/jurisinfo:courtinfo</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b> elements. When 2 or more
					consecutive sibling source elements map to <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to
					a single <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content ordering.</xd:p>
         <!--<section>
      <title>Changes</title>
    </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.courtinfo-LxAdv_caseinfo.caseinfo_caseinfo.jurisinfo.dita  -->
   <xsl:template match="case:courtinfo"><!--  Original Target XPath:  /caseinfo:caseinfo/jurisinfo:courtinfo   -->
      <xsl:choose>
         <xsl:when test="parent::case:judgment">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:otherwise>
            <jurisinfo:courtinfo>
               <xsl:apply-templates select="case:courtcode"/>
               <xsl:apply-templates select="case:courtname"/>
               <xsl:apply-templates select="case:juris"/>
            </jurisinfo:courtinfo>
            <!-- Awantika: 2017-10-17: Added case:dates and case:judges in except condition for HK03 -->
            <!-- Awantika: 2017-10-27- removing page if coming under case:courtinfo and placing it inside courtcase:panel -->
            <!--SS[2017-11-21]: Added this condition "./text()[preceding-sibling::case:courtcode and following-sibling::case:judges][$streamID='AU01']" for moving text() of case:courtinfo under target 'courtcase:judges' element -->
            <!--SS[2017-01-12]: Added this condition "./text()[preceding-sibling::case:courtcode and following-sibling::case:courtloc][$streamID='NZ03']" for moving text() of case:courtinfo under target 'location:city' element -->
            <!--RS[2018-01-04]: Modify the condition "./text()[preceding-sibling::case:courtcode or preceding-sibling::case:courtname and following-sibling::case:judges][$streamID='AU01']" for moving text() of case:courtinfo under target 'courtcase:judges' element -->
            <xsl:apply-templates select="@* | node() except (case:courtcode | case:courtname | case:juris | ./text()[following-sibling::case:courtloc][$streamID=('AU09','AU01')] | ./text()[preceding-sibling::case:courtcode or preceding-sibling::case:courtname and following-sibling::case:judges][$streamID='AU01'] | ./text()[preceding-sibling::case:courtcode and following-sibling::case:courtloc][$streamID='NZ03'] | case:courtloc[$streamID=('AU09','AU01', 'NZ03')] | case:judges[$streamID=('HK03')] | case:dates[$streamID=('HK03')] | page[$streamID='HK03'] | ./text()[preceding-sibling::case:filenum and following-sibling::filenum][$streamID='NZ03'] | ./text()[preceding-sibling::case:dates and following-sibling::case:dates][$streamID='NZ03'])"/>
            <!--<xsl:apply-templates select="case:filenum"/>
                  <xsl:apply-templates select="case:judges[ancestor::case:headnote]"/>
                  <xsl:apply-templates select="case:dates"/>-->
            <!--<xsl:apply-templates select="case:judges[ancestor::case:headnote]"/>
                                <xsl:apply-templates select="case:dates"/>-->
            <!--<xsl:apply-templates select="@* | node()"/>-->
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--	<xsl:template match="case:courtinfo">
		<!-\-  Original Target XPath:  /caseinfo:caseinfo/jurisinfo:courtinfo   -\->
		<jurisinfo:courtinfo>
			<xsl:apply-templates select="case:courtcode"/>
			<xsl:apply-templates select="case:courtname"/>
			<xsl:apply-templates select="case:juris"/>
		</jurisinfo:courtinfo>
		<xsl:apply-templates select="@* | node() except (case:courtcode | case:courtname | case:juris | ./text()[following-sibling::case:courtloc][$streamID='AU09'] | case:courtloc[$streamID='AU09'])"/>
		<!-\-<xsl:apply-templates select="case:filenum"/>
	  <xsl:apply-templates select="case:judges[ancestor::case:headnote]"/>
	  <xsl:apply-templates select="case:dates"/>-\->
		<!-\-<xsl:apply-templates select="case:judges[ancestor::case:headnote]"/>
		<xsl:apply-templates select="case:dates"/>-\->
		<!-\-<xsl:apply-templates select="@* | node()"/>-\->-->   <!-- Awantika: Completed -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.courtname-LxAdv_jurisinfo.courtname.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:courtname</xd:i> becomes
        <xd:b>jurisinfo:courtname</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Any <xd:i>nl</xd:i> elements that occur inside
        <xd:i>case:courtname</xd:i> should be suppressed if they are preceded or
        followed by a space. Any <xd:i>nl</xd:i> elements that are not preceded or
        followed by a space should be converted into a single space character.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Exception scenario for CA01-Cases: <xd:i>nl</xd:i> becomes
          <xd:b>proc:nl</xd:b> that occur inside
        <xd:i>case:courtname</xd:i>.</xd:p>
         <xd:p>
            <xd:b>Example: CA Content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
    ...
    &lt;abbrvname ln.user-displayed="false"&gt;NTSC&lt;/abbrvname&gt;
    &lt;case:courtname&gt;Supreme Court of The Northwest Territories&lt;nl/&gt; Yellowknife, Northwest Territories&lt;/case:courtname&gt;
    ...
&lt;/case:courtinfo&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;jurisinfo:courtinfo&gt;
    ...
    &lt;jurisinfo:courtname normscheme="calongabbr"&gt;Supreme Court of The Northwest Territories&lt;proc:nl/&gt;
    Yellowknife, Northwest Territories&lt;/jurisinfo:courtname&gt;
    ...
&lt;/jurisinfo:courtinfo&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: NZ Content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
  &lt;case:courtname&gt;Court of Appeal&lt;/case:courtname&gt;
&lt;/case:courtinfo&gt;
      </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;jurisinfo:courtinfo&gt;
    &lt;jurisinfo:courtname&gt;Court of Appeal&lt;/jurisinfo:courtname&gt;
&lt;/jurisinfo:courtinfo&gt;
      </xd:pre>signing 
    <xd:p>
            <xd:b>Example: UK Content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
  &lt;case:courtname&gt;TRIBUNAL CENTRE: LONDON&lt;/case:courtname&gt;
&lt;/case:courtinfo&gt;
      </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;jurisinfo:courtinfo&gt;
    &lt;jurisinfo:courtname&gt;TRIBUNAL CENTRE: LONDON&lt;/jurisinfo:courtname&gt;
&lt;/jurisinfo:courtinfo&gt;
      </xd:pre>
         <!--Changes2015-02-09: Updated target example, removed attribute @normlongname from target, Applicable on CA01.2013-02-13: Added instructions for handling
        case:courtname/nl and a sample mapping.2014-02-19: Added note and updated snippet for CA content, This change immediately applies to CA01-Cases.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.courtname-LxAdv_jurisinfo.courtname.dita  -->
   <!-- Vikas Rohilla : Template to match the case:courtname and create the jurisinfo:courtname -->
   <xsl:template match="case:courtname">
      <jurisinfo:courtname><!-- JD: 2017-06-15: In UK01 this is shown in example code in CI but not mentioned elsewhere and not present in DT output.
			Adding exclusion test for UK01, but I suspect rather than include this will need to be specifically included for certain streams.
			--><!-- Ravikant: 2018-03-09 Added the streamID MY01 for case:courtname in below if condition -->
         <xsl:if test="not($streamID='UK01' or $streamID='MY01')">
            <xsl:attribute name="normscheme">
               <xsl:text>calongabbr</xsl:text>
            </xsl:attribute>
         </xsl:if>
         <xsl:apply-templates select="preceding-sibling::abbrvname"/>
         <xsl:apply-templates select="@* | node()"/>
      </jurisinfo:courtname>
   </xsl:template>

   <xsl:template match="case:courtname[$streamID=('AU01', 'NZ03', 'AU09')]"><!--Satbir: Added condition for dropping EMPTY element-->
      <xsl:choose>
         <xsl:when test="not(*) and not(normalize-space())"/>
         <xsl:otherwise>
            <jurisinfo:courtname>
               <xsl:apply-templates select="@* | node()"/>
            </jurisinfo:courtname>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Already Done -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.courtcode.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:courtcode</xd:i> is mapped to the target: <xd:ul>
               <xd:li>
                  <xd:b>jurisinfo:courtinfo/jurisinfo:alternatecourtcode/@alternatecourtcode</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>doc:metadata/doc:docinfo/doc:legacy-metadata[metadatasource="lbu-meta"]/meta/metaitem</xd:b>.
							The attributes of <xd:b>metaitem</xd:b> are populated as follows: <xd:ul>
                     <xd:li>
                        <xd:b>metaitem/@name</xd:b> should be set to "case:courtcode".</xd:li>
                     <xd:li>
                        <xd:b>metaitem/@value</xd:b> should be set to the value of
										<xd:i>case:courtcode</xd:i>.</xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>For Canada Specific only</xd:b>
         </xd:p>
         <xd:p>
            <xd:i>case:courtcode</xd:i> becomes
						<xd:b>doc:metadata/doc:docinfo/doc:legacy-metadata[metadatasource="lbu-meta"]/meta/metaitem</xd:b>.
					The attributes of <xd:b>metaitem</xd:b> are populated as follows:</xd:p>
         <xd:ul>
            <xd:li>
               <xd:b>metaitem/@name</xd:b> should be set to "case:courtcode".</xd:li>
            <xd:li>
               <xd:b>metaitem/@value</xd:b> should be set to the value of
						<xd:i>case:courtcode</xd:i>.</xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Example: CA content</xd:b>
         </xd:p>
         <xd:pre> &lt;case:courtcode ln.user-displayed="false"&gt;NSSC&lt;/case:courtcode&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;doc:metadata&gt; &lt;doc:docinfo doc-content-country="CA"&gt; ... &lt;doc:legacy-metadata
					metadatasource="lbu-meta"&gt; &lt;meta&gt; ... &lt;metaitem name="case:courtcode" value="NSSC"/&gt;
					&lt;/meta&gt; &lt;/doc:legacy-metadata&gt; &lt;/doc:docinfo&gt; &lt;/doc:metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre> &lt;case:courtinfo&gt; &lt;case:courtcode&gt;FCA&lt;/case:courtcode&gt; ... &lt;/case:courtinfo&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;jurisinfo:courtinfo&gt; &lt;jurisinfo:alternatecourtcode alternatecourtcode="FCA" /&gt;
					&lt;/jurisinfo:courtinfo&gt; ... &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt;
					&lt;metaitem name="case:courtcode" value="FCA"&gt; &lt;/meta&gt; &lt;/doc:legacy-metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre> &lt;case:courtinfo&gt; &lt;case:courtcode&gt;NZCA&lt;/case:courtcode&gt; ... &lt;/case:courtinfo&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;jurisinfo:courtinfo&gt; &lt;jurisinfo:alternatecourtcode alternatecourtcode="NZCA" /&gt;
					&lt;/jurisinfo:courtinfo&gt; &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; &lt;metaitem
					name="case:courtcode" value="NZCA"&gt; &lt;/meta&gt; &lt;/doc:legacy-metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre> &lt;case:courtcode&gt;CA&lt;/case:courtcode&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;jurisinfo:courtinfo&gt; &lt;jurisinfo:alternatecourtcode alternatecourtcode="CA"/&gt;
					&lt;/jurisinfo:courtinfo&gt; ... &lt;doc:metadata&gt; &lt;doc:docinfo doc-content-country="GB"&gt; ...
					&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; ... &lt;metaitem name="case:courtcode"
					value="CA"/&gt; &lt;/meta&gt; &lt;/doc:legacy-metadata&gt; &lt;/doc:docinfo&gt; &lt;/doc:metadata&gt;
				</xd:pre>
         <!--Changes2014-11-11: Created separate rule of case:courtcode for
						Canada specific.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.courtcode.dita  -->
   <xsl:template match="case:courtcode[not($streamID = ('NZ03', 'AU09'))]"><!--  Original Target XPath:  jurisinfo:courtinfo/jurisinfo:alternatecourtcode/@alternatecourtcode   --><!-- Awantika: 2017-10-30- Updated for AU01 where colon (:) was coming between case:courtcode and case:judges which was coming inside caseinfo:caseinfo
		which caused validation error-->
      <jurisinfo:alternatecourtcode>
         <xsl:attribute name="alternatecourtcode">
            <xsl:choose>
               <xsl:when test="$streamID = 'CA01'">
                  <xsl:value-of select="following-sibling::abbrvname"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="@* | node()"/>
                  <xsl:if test="normalize-space(following-sibling::text()[1]) = ':' and $streamID='AU01'">
                     <xsl:value-of select="following-sibling::text()[1]"/>
                  </xsl:if>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:attribute>
      </jurisinfo:alternatecourtcode>
   </xsl:template>
   <!-- Awantika: 2017-10-30- Updated for AU01 where colon (:) was coming between case:courtcode and case:judges which was coming inside caseinfo:caseinfo
		which caused validation error-->
   <xsl:template match="text()[preceding-sibling::*[1][local-name()='courtcode']][normalize-space(.)=':'][$streamID='AU01']"/>
   <!--Satbir: Created separate template for NZ03 because case:courtcode comes double times single input-->
   <xsl:template match="case:courtcode[$streamID = ('NZ03', 'AU09')]">
      <xsl:choose>
         <xsl:when test="not(following-sibling::case:courtcode)">
            <jurisinfo:alternatecourtcode>
               <xsl:attribute name="alternatecourtcode">
                  <xsl:value-of select="//case:courtcode[last()]"/>
               </xsl:attribute>
            </jurisinfo:alternatecourtcode>
         </xsl:when>
         <xsl:otherwise>
            <xsl:apply-templates select="@* | node() except text()"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Awantika: Completed- already done some templates -->   <!-- <topicref href="AU01_Rosetta_case.dates.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:dates</xd:i> becomes <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates</xd:b>
               <xd:p>
                  <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b>
            elements. When 2 or more consecutive sibling source elements map to
              <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to a single
              <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content
            ordering.</xd:p>
               <xd:ul>
                  <xd:li>
                     <xd:i>case:hearingdates</xd:i> becomes
                <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:argueddate</xd:b>
                     <xd:p>
                        <xd:b>Note: </xd:b>This likely not a complete date, rather just a day. Do not
                attempt to place a complete date if there is not sufficient content in source (year,
                month and day). It should remain PCDATA. See example.</xd:p>
                  </xd:li>
                  <xd:li>
                     <xd:i>case:decisiondate</xd:i> becomes
                <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:decisiondate</xd:b>
              populated with below mentioned attributes:
                <xd:i>case:decisiondate/date/@day</xd:i> becomes <xd:b>decision:decisiondate/@day</xd:b>,
                <xd:i>case:decisiondate/date/@month</xd:i> becomes <xd:b>decision:decisiondate/@month</xd:b> and
                <xd:i>case:decisiondate/date/@year</xd:i> becomes <xd:b>decision:decisiondate/@year</xd:b>
                     <xd:p> The attribute <xd:b>decision:decisiondate/@normdate</xd:b> should be
                populated with the values of <xd:i>case:decisiondate/date/@year</xd:i>,
                  <xd:i>case:decisiondate/date/@month</xd:i> and
                  <xd:i>case:decisiondate/date/@day</xd:i> concatenated and separated by a
                single hyphen. The values of <xd:i>case:decisiondate/date/@month</xd:i>
                and <xd:i>case:decisiondate/date/@day</xd:i> should be padded with zeroes
                so that they are 2 digits. <xd:p>
                           <xd:b>Note: </xd:b>If one or more of the three date values (year,
                  month or day) are absent, then
                    <xd:b>decision:decisiondate/@normdate</xd:b> should <xd:b>not</xd:b> be
                  populated.</xd:p>
                     </xd:p>
                     <xd:ul>
                        <xd:li>
                           <xd:i>date</xd:i> becomes <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:decisiondate/date-text</xd:b>
                        </xd:li>
                     </xd:ul>
                     <xd:pre>

  &lt;case:dates&gt;
    &lt;case:hearingdates&gt;8, &lt;/case:hearingdates&gt;
    &lt;case:decisiondate&gt;
      &lt;date day="20" month="05" year="2009"&gt;20 May 2009&lt;/date&gt;
    &lt;/case:decisiondate&gt;
  &lt;/case:dates&gt;
<xd:b>Becomes</xd:b>

  &lt;decision:dates&gt;
    &lt;decision:argueddate&gt;8, &lt;/decision:argueddate&gt;
    &lt;decision:decisiondate day="20" month="05" year="2009" normdate="2009-05-20"&gt;
      &lt;date-text&gt;20 May 2009&lt;/date-text&gt;
    &lt;/decision:decisiondate&gt;
  &lt;/decision:dates&gt;
</xd:pre>
              Example where complete date occurs within case:hearingdate: <xd:pre>

&lt;case:hearingdates&gt;
  &lt;date day="12" month="05" year="2000"&gt;12 May 2000&lt;/date&gt;
&lt;/case:hearingdates&gt;

<xd:b>Becomes</xd:b>

&lt;decision:argueddate day="12" month="05" year="2000"&gt;
  &lt;date-text&gt;12 May 2000&lt;/date-text&gt;
&lt;/decision:argueddate&gt;
</xd:pre>
                     <xd:p>
                        <xd:b>Note: </xd:b>when <xd:i>@ln.user-displayed="false</xd:i>
                appears on a date element (i.e,
                  <xd:i>case:decisiondate/@ln.user-displayed="false"</xd:i>), that element
                is translated into the target but with the element content omitted. Only the
                attributes are populated. So there is no display content.</xd:p>
                     <xd:pre>

&lt;case:dates&gt;
  &lt;case:decisiondate ln.user-displayed="false"&gt;
    &lt;date year="1995" month="04" day="28"&gt;28 April 1995&lt;/date&gt; 
  &lt;/case:decisiondate&gt;
&lt;/case:dates&gt;

<xd:b>Becomes</xd:b>

&lt;decision:dates&gt;  
  &lt;decision:decisiondate day="28" month="04" year="1995" normdate="1995-04-28"/&gt;
&lt;/decision:dates&gt;

</xd:pre>
                  </xd:li>
                  <xd:li>
                     <xd:i>case:publishdate</xd:i> becomes <xd:b>decision:releaseddate</xd:b>
                     <xd:pre>

&lt;case:dates&gt;
  ...
  &lt;case:publishdate&gt;; Date of publication of reasons: 7 July 2009&lt;/case:publishdate&gt;
&lt;/case:dates&gt;
<xd:b>Becomes</xd:b>

&lt;decision:dates&gt;
  ...
  &lt;decision:releaseddate&gt;; Date of publication of reasons: 7 July 2009&lt;/decision:releaseddate&gt;
&lt;/decision:dates&gt;
</xd:pre>
                  </xd:li>
                  <xd:li>
                     <xd:i>case:reviseddate</xd:i> becomes
                <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:revisiondate</xd:b>
              populated with below mentioned attributes:
                <xd:i>case:reviseddate/date/@day</xd:i> becomes
                <xd:b>decision:revisiondate/@day</xd:b>,
                <xd:i>case:reviseddate/date/@month</xd:i> becomes
                <xd:b>decision:revisiondate/@month</xd:b> and
                <xd:i>case:reviseddate/date/@year</xd:i> becomes
                <xd:b>decision:revisiondate/@year</xd:b>
                     <xd:ul>
                        <xd:li>
                           <xd:i>date</xd:i> becomes
                    <xd:b>/courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:revisiondate/date-text</xd:b>
                        </xd:li>
                     </xd:ul>
                     <xd:pre>

&lt;case:dates&gt;
  &lt;case:hearingdates&gt;1012 August&lt;/case:hearingdates&gt;
  &lt;case:decisiondate&gt;
    &lt;date day="16" month="09" year="2005"&gt;, 16 September 2005&lt;/date&gt;
  &lt;/case:decisiondate&gt;
  &lt;case:reviseddate&gt;
    &lt;date day="22" month="09" year="2005"&gt;, 22 September 2005&lt;/date&gt;
  &lt;/case:reviseddate&gt;
&lt;/case:dates&gt;

<xd:b>Becomes</xd:b>

&lt;decision:dates&gt;
  &lt;decision:argueddate&gt;1012 August&lt;/decision:argueddate&gt;
  &lt;decision:decisiondate day="16" month="09" year="2005" normdate="2005-09-16"&gt;, 
    &lt;date-text&gt;16 September 2005&lt;/date-text&gt;
  &lt;/decision:decisiondate&gt;
  &lt;decision:revisiondate day="22" month="09" year="2005"&gt;, 
    &lt;date-text&gt;22 September 2005&lt;/date-text&gt;
  &lt;/decision:revisiondate&gt;
&lt;/decision:dates&gt;

</xd:pre>
                  </xd:li>
               </xd:ul>
               <xd:p>
                  <xd:b>Note: </xd:b>The formatting of the date-text should not be normalized to
            YYYY-MM-DD. The attributes are used for normalization, but the element content should
            remain the same but whitespace and comma should retain outside the <xd:b>date-text</xd:b> element.</xd:p>
            </xd:li>
         </xd:ul>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.dates.dita  -->
   <xsl:template match="case:dates"><!--  Original Target XPath:  /courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates   --><!-- NOTE: it is assumed that this template will be called from whatever generates required parent wrapper elements -->
      <xsl:choose>
         <xsl:when test="parent::case:judgments">
            <xsl:apply-templates select="case:decisiondate"/>
         </xsl:when>
         <xsl:otherwise>
            <decision:dates>
               <xsl:apply-templates select="@* | node()"/>
            </decision:dates>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="case:hearingdates"><!--  Original Target XPath:  /courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:argueddate   -->
      <decision:argueddate>
         <xsl:if test="./date/@year">
            <xsl:attribute name="year" select="./date/@year"/>
         </xsl:if>
         <xsl:if test="./date/@month">
            <xsl:attribute name="month" select="./date/@month"/>
         </xsl:if>
         <xsl:if test="./date/@day">
            <xsl:attribute name="day" select="./date/@day"/>
         </xsl:if>
         <xsl:if test="./date/@day and ./date/@month and ./date/@year">
            <xsl:attribute name="normdate"
                           select="concat(./date/@year,'-',./date/@month,'-',./date/@day)"/>
         </xsl:if>
         <xsl:if test="@ln.user-displayed !='false' or not(@ln.user-displayed)">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:if>
      </decision:argueddate>
   </xsl:template>

   <xsl:template match="case:decisiondate">
      <decision:decisiondate>
         <xsl:if test="./date/@year">
            <xsl:attribute name="year" select="./date/@year"/>
         </xsl:if>
         <xsl:if test="./date/@month">
            <xsl:attribute name="month" select="./date/@month"/>
         </xsl:if>
         <xsl:if test="./date/@day">
            <xsl:attribute name="day" select="./date/@day"/>
         </xsl:if>
         <xsl:if test="./date/@day and ./date/@month and ./date/@year">
            <xsl:attribute name="normdate"
                           select="concat(./date/@year,'-',./date/@month,'-',./date/@day)"/>
         </xsl:if>
         <xsl:if test="@ln.user-displayed !='false' or not(@ln.user-displayed)">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:if>
      </decision:decisiondate>
   </xsl:template>
   <!-- NOTE: probably belongs in a nonamespace module -->   <!-- NOTE: source <date> attributes must be moved to target parent of <date-text> (see templates in this file) -->   <!--	<xsl:template match="date">
		<date-text>
			<xsl:apply-templates select="node()"/>
		</date-text>
	</xsl:template>-->
   <xsl:template match="case:publishdate"><!--  Original Target XPath:  decision:releaseddate   -->
      <decision:releaseddate>
         <xsl:if test="./date/@year">
            <xsl:attribute name="year" select="./date/@year"/>
         </xsl:if>
         <xsl:if test="./date/@month">
            <xsl:attribute name="month" select="./date/@month"/>
         </xsl:if>
         <xsl:if test="./date/@day">
            <xsl:attribute name="day" select="./date/@day"/>
         </xsl:if>
         <xsl:if test="./date/@day and ./date/@month and ./date/@year">
            <xsl:attribute name="normdate"
                           select="concat(./date/@year,'-',./date/@month,'-',./date/@day)"/>
         </xsl:if>
         <xsl:if test="@ln.user-displayed !='false' or not(@ln.user-displayed)">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:if>
      </decision:releaseddate>
   </xsl:template>

   <xsl:template match="case:reviseddate"><!--  Original Target XPath:  /courtcase:courtcase/courtcase:head/caseinfo:caseinfo/decision:dates/decision:revisiondate   -->
      <decision:revisiondate>
         <xsl:if test="./date/@year">
            <xsl:attribute name="year" select="./date/@year"/>
         </xsl:if>
         <xsl:if test="./date/@month">
            <xsl:attribute name="month" select="./date/@month"/>
         </xsl:if>
         <xsl:if test="./date/@day">
            <xsl:attribute name="day" select="./date/@day"/>
         </xsl:if>
         <xsl:if test="./date/@day and ./date/@month and ./date/@year">
            <xsl:attribute name="normdate"
                           select="concat(./date/@year,'-',./date/@month,'-',./date/@day)"/>
         </xsl:if>
         <xsl:if test="@ln.user-displayed !='false' or not(@ln.user-displayed)">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:if>
      </decision:revisiondate>
   </xsl:template>
   <!-- Awantika: Complete -->   <!-- <topicref href="AU01_Rosetta_case.courtloc-LxAdv_jurisinfo.jurisdiction_jurisinfo.location.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b>
            elements. When 2 or more consecutive sibling source elements map to
                <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to a single
                <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content
            ordering.</xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
  &lt;case:courtname&gt;FEDERAL COURT OF AUSTRALIA&lt;/case:courtname&gt;
  &lt;case:courtcode&gt;FCA&lt;/case:courtcode&gt;  - will be moved under doc:legacy-metadata.
  &lt;case:courtloc&gt;Sydney&lt;/case:courtloc&gt;
&lt;/case:courtinfo&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:head&gt;
  &lt;caseinfo:caseinfo&gt;
    &lt;jurisinfo:courtinfo&gt;
      &lt;jurisinfo:courtname&gt;FEDERAL COURT OF AUSTRALIA&lt;/jurisinfo:courtname&gt;
      &lt;jurisinfo:jurisdiction&gt;
        &lt;jurisinfo:location&gt;
          &lt;location:city&gt;Sydney&lt;/location:city&gt;
        &lt;/jurisinfo:location&gt;
      &lt;/jurisinfo:jurisdiction&gt;
    &lt;/jurisinfo:courtinfo&gt;
  &lt;/caseinfo:caseinfo&gt;
&lt;/courtcase:head&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>Connecting punctuation and text must be captured by using
                <xd:b>connector</xd:b> within
            <xd:b>jurisinfo:location</xd:b>.</xd:p>
         <xd:pre>
&lt;case:courtinfo&gt;
    &lt;case:courtname&gt;COMMERCIAL TRIBUNAL OF NEW SOUTH WALES&lt;/case:courtname&gt; 
    &lt;case:courtcode&gt;NSWSC&lt;/case:courtcode&gt; 
    &lt;case:judges&gt;
        Deputy Chairman 
        &lt;case:judge&gt;Vermeesch&lt;/case:judge&gt; 
    &lt;/case:judges&gt;
    &lt;case:dates&gt;
        &lt;case:decisiondate&gt;
            &lt;date day="19" month="12" year="1994"&gt;19 December 1994&lt;/date&gt; 
        &lt;/case:decisiondate&gt;
    &lt;/case:dates&gt;
     
    &lt;case:courtloc&gt;Sydney&lt;/case:courtloc&gt; 
    &lt;case:juris&gt;nsw&lt;/case:juris&gt; 
&lt;/case:courtinfo&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;jurisinfo:courtinfo&gt;
    &lt;jurisinfo:courtname&gt;COMMERCIAL TRIBUNAL OF NEW SOUTH WALES&lt;/jurisinfo:courtname&gt;
    &lt;jurisinfo:jurisdiction&gt;
        &lt;jurisinfo:location&gt;
            &lt;connector&gt;
            
            &lt;/connector&gt;
            &lt;location:city&gt;Sydney&lt;/location:city&gt;
        &lt;/jurisinfo:location&gt;
    &lt;/jurisinfo:jurisdiction&gt;
&lt;/jurisinfo:courtinfo&gt;
       </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.courtloc-LxAdv_jurisinfo.jurisdiction_jurisinfo.location.dita#Rosetta_case.courtloc-LxAdv_jurisinfo.jurisdiction_jurisinfo.location/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.courtloc-LxAdv_jurisinfo.jurisdiction_jurisinfo.location.dita  -->
   <xsl:template match="case:courtloc">
      <jurisinfo:location><!-- Awantika: CI doesn't have any instruction for how to mark the content in city or state or country. DT is outputting city always following the same -->
         <location:city>
            <xsl:apply-templates select="@* | node()"/>
         </location:city>
      </jurisinfo:location>
   </xsl:template>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.juris.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:juris</xd:i> can have State/Territory code or Country code. <xd:ol>
                  <xd:li> When <xd:i>case:juris</xd:i> has State/Territory code:
                <xd:i>case:juris</xd:i> becomes
                <xd:b>jurisinfo:courtinfo/jurisinfo:jurisdiction/jurisinfo:system</xd:b>
              and create <xd:b>dc:metadata/dc:coverage/location:state</xd:b> with
              attributes @codescheme="ISO-3166-2" and @statecode, value for this attribute will be
              picked from the below mentioned pick list: <xd:ol>
                        <xd:li> AU-NS : New South Wales (NSW) </xd:li>
                        <xd:li> AU-QL : Queensland (QLD) </xd:li>
                        <xd:li> AU-SA : South Australia (SA) </xd:li>
                        <xd:li> AU-TS : Tasmania (TAS) </xd:li>
                        <xd:li> AU-VI : Victoria (VIC) </xd:li>
                        <xd:li> AU-WA : Western Australia (WA) </xd:li>
                        <xd:li> AU-CT : Australian Capital Territory (ACT) </xd:li>
                        <xd:li> AU-NT : Northern Territory (NT) </xd:li>
                     </xd:ol> and the value for
                <xd:b>jurisinfo:courtinfo/jurisinfo:alternatecourtcode/@alternatecourtcode</xd:b>
              will be picked up from
              <xd:i>case:courtcode</xd:i>.<xd:pre>

&lt;case:courtinfo&gt;
  ...
  &lt;case:courtcode&gt;NSWSC&lt;/case:courtcode&gt;
  ...
  &lt;case:juris&gt;nsw&lt;/case:juris&gt;
&lt;/case:courtinfo&gt;
<xd:b>Becomes</xd:b>

&lt;jurisinfo:courtinfo&gt;
  &lt;jurisinfo:alternatecourtcode alternatecourtcode="NSWSC" /&gt;
  &lt;jurisinfo:jurisdiction&gt;
    &lt;jurisinfo:system&gt;nsw&lt;/jurisinfo:system&gt;
  &lt;/jurisinfo:jurisdiction&gt;
&lt;/jurisinfo:courtinfo&gt;

&lt;dc:metadata&gt;
  &lt;dc:coverage&gt;
    &lt;location:state codescheme="ISO-3166-2" statecode="AU-NS"/&gt;
  &lt;/dc:coverage&gt;
&lt;/dc:metadata&gt;

</xd:pre>
                  </xd:li>
                  <xd:li> When <xd:i>case:juris</xd:i> has Country code: <xd:p>
                        <xd:b>Note: </xd:b>If value for
                  <xd:i>case:juris</xd:i> is "CTH" then <xd:i>case:juris</xd:i>
                will become
                  <xd:b>jurisinfo:courtinfo/jurisinfo:jurisdiction/jurisinfo:system</xd:b>
                and create <xd:b>dc:metadata/dc:coverage/location:country</xd:b> with
                attributes @codescheme="ISO-3166-1" and @countrycode="AU". </xd:p>
                     <xd:pre>
&lt;case:juris&gt;CTH&lt;/case:juris&gt;

<xd:b>Becomes</xd:b>
              
&lt;jurisinfo:courtinfo&gt;
  &lt;jurisinfo:jurisdiction&gt;
    &lt;jurisinfo:system&gt;CTH&lt;/jurisinfo:system&gt;
  &lt;/jurisinfo:jurisdiction&gt;
&lt;/jurisinfo:courtinfo&gt;

&lt;dc:metadata&gt;
  &lt;dc:coverage&gt;
    &lt;location:country codescheme="ISO-3166-1" countrycode="AU"/&gt;
  &lt;/dc:coverage&gt;
&lt;/dc:metadata&gt;
</xd:pre>
                     <xd:p>
                        <xd:b>Note: </xd:b>The ordering of the <xd:b>jurisinfo:alternatecourtcode</xd:b> and
                  <xd:b>jurisinfo:jurisdiction\jurisinfo:system</xd:b> is not significant
                in terms of display.</xd:p>
                  </xd:li>
               </xd:ol>
            </xd:li>
         </xd:ul>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.juris.dita  -->
   <!-- Awantika: 2017-11-01- Added fj value as AU-FJ source has fj value in case:juris -->
   <!-- Awantika: 2017-11-07- Added markup for uk,can,nz in case:juris. Webstar # 7041469  -->
   <!-- Ankita : 20-12-2017- Added markup for "us" in case:juris . Webtar# 7071460 -->
   <xsl:template match="case:juris[starts-with(upper-case(.),'NSW') or starts-with(upper-case(.),'QLD') or starts-with(upper-case(.),'SA') or starts-with(upper-case(.),'TAS') or starts-with(upper-case(.),'VIC') or starts-with(upper-case(.),'WA') or starts-with(upper-case(.),'ACT') or starts-with(upper-case(.),'NT') or starts-with(upper-case(.),'CTH') or starts-with(lower-case(.),'cth') or starts-with(lower-case(.),'fj') or starts-with(lower-case(.),'uk') or starts-with(lower-case(.),'nz') or starts-with(lower-case(.),'can') or starts-with(lower-case(.),'sg')or starts-with(lower-case(.),'us')]"><!-- TODO: check that jurisinfo:courtinfo is created from case:courtinfo --><!--<jurisinfo:courtinfo--><!--	<xsl:apply-templates select="preceding-sibling::case:courtcode[1]"/>-->
      <jurisinfo:jurisdiction>
         <jurisinfo:system>
            <xsl:apply-templates select="@* | node()"/>
         </jurisinfo:system>
         <xsl:apply-templates select="case:courtloc"/>
         <!--<xsl:apply-templates select="preceding-sibling::case:courtloc[$streamID='AU01']"/>-->
      </jurisinfo:jurisdiction>
      <!--</jurisinfo:courtinfo>-->
   </xsl:template>
   <!-- Awantika: common module of case:courtcode is already created -->   <!--<xsl:template match="case:courtcode">
		<jurisinfo:alternatecourtcode alternatecourtcode="{.}" />
	</xsl:template>-->
   <xsl:template match="case:juris[starts-with(upper-case(.),'NSW') or starts-with(upper-case(.),'QLD') or starts-with(upper-case(.),'SA') or starts-with(upper-case(.),'TAS') or starts-with(upper-case(.),'VIC') or starts-with(upper-case(.),'WA') or starts-with(upper-case(.),'ACT') or starts-with(upper-case(.),'NT') or starts-with(lower-case(.),'fj')]"
                 mode="metadata">
      <dc:coverage>
         <location:state codescheme="ISO-3166-2">
            <xsl:attribute name="statecode">
               <xsl:choose>
                  <xsl:when test="starts-with(upper-case(.),'NSW')">
                     <xsl:value-of select="'AU-NS'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'QLD')">
                     <xsl:value-of select="'AU-QL'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'SA')">
                     <xsl:value-of select="'AU-SA'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'TAS')">
                     <xsl:value-of select="'AU-TS'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'VIC')">
                     <xsl:value-of select="'AU-VI'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'WA')">
                     <xsl:value-of select="'AU-WA'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'ACT')">
                     <xsl:value-of select="'AU-CT'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'NT')">
                     <xsl:value-of select="'AU-NT'"/>
                  </xsl:when>
                  <xsl:when test="starts-with(upper-case(.),'FJ')">
                     <xsl:value-of select="'AU-FJ'"/>
                  </xsl:when>
                  <!--<xsl:when test="starts-with(upper-case(.),'SG')"><xsl:value-of select="'AU-SG'"/></xsl:when>-->
               </xsl:choose>
            </xsl:attribute>
            <!--<xsl:apply-templates />-->
         </location:state>
      </dc:coverage>
   </xsl:template>
   <!--<xsl:template match="case:juris[starts-with(upper-case(.),'CTH') or starts-with(lower-case(.),'cth')]" mode="metadata" priority="20">
		<!-\-<jurisinfo:courtinfo>-\->
		<jurisinfo:jurisdiction>
			<jurisinfo:system>
				<xsl:apply-templates select="@* | node()"/>
			</jurisinfo:system>
		</jurisinfo:jurisdiction>
		<!-\-</jurisinfo:courtinfo>-\->
	</xsl:template>-->
   <xsl:template match="case:juris[starts-with(upper-case(.),'CTH') or starts-with(lower-case(.),'cth')or starts-with(lower-case(.),'uk') or starts-with(lower-case(.),'nz') or starts-with(lower-case(.),'can') or starts-with(lower-case(.),'sg')or starts-with(lower-case(.),'us')]"
                 mode="metadata"
                 priority="20">
      <dc:coverage>
         <xsl:choose>
            <xsl:when test="starts-with(upper-case(.),'CTH') or starts-with(lower-case(.),'cth')">
               <location:country codescheme="ISO-3166-1">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'AU'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
            <xsl:when test="starts-with(lower-case(.),'uk')">
               <location:country codescheme="ISO-3166-2">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'UK'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
            <xsl:when test="starts-with(lower-case(.),'can')">
               <location:country codescheme="ISO-3166-1">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'CA'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
            <xsl:when test="starts-with(lower-case(.),'sg')">
               <location:country codescheme="ISO-3166-1">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'SG'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
            <xsl:when test="starts-with(lower-case(.),'us')">
               <location:country codescheme="ISO-3166-1">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'US'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
            <xsl:when test="starts-with(lower-case(.),'nz')">
               <location:country codescheme="ISO-3166-1">
                  <xsl:attribute name="countrycode">
                     <xsl:value-of select="'NZ'"/>
                  </xsl:attribute>
               </location:country>
            </xsl:when>
         </xsl:choose>
      </dc:coverage>
      <!--</jurisinfo:courtinfo>-->
   </xsl:template>
   <!--
	<xsl:template match="case:juris" mode="metadata">
		<dc:coverage>
			<location:country>
				<xsl:attribute name="countrycode" select="'AU'"/>
				<xsl:attribute name="codescheme">ISO-3166-2</xsl:attribute>       
			</location:country>						
		</dc:coverage>
	</xsl:template>
-->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.courtcite-LxAdv_ref.cite4thisresource.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:courtcite</xd:i> conversion depends upon its child elements,
                refer below scenarios:</xd:p>
         <xd:p>When <xd:i>ci:cite/@type="parallel"</xd:i> is a child of
                    <xd:i>case:courtcite</xd:i> then its become
                    <xd:b>ref:parallelcite/@citetype="court"</xd:b>.</xd:p>
         <xd:pre>
&lt;case:courtcite&gt;
    &lt;ci:cite type="parallel"&gt;
        &lt;ci:content&gt;THE STATE OF WESTERN AUSTRALIA -v- A F [2014] WADC 124&lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:courtcite&gt;
</xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:parallelcite citetype="court"&gt;
    &lt;lnci:cite&gt;
        &lt;lnci:content&gt;THE STATE OF WESTERN AUSTRALIA -v- A F [2014] WADC 124&lt;/lnci:content&gt;
    &lt;/lnci:cite&gt;
&lt;/ref:parallelcite&gt;
           </xd:pre>
         <xd:p>When <xd:i>ci:cite/@type="cite4thisdoc"</xd:i> is a child of
                    <xd:i>case:courtcite</xd:i> then its become
                    <xd:b>ref:cite4thisresource/@citetype="court"</xd:b>.</xd:p>
         <xd:pre>
&lt;case:courtcite&gt;
    &lt;ci:cite type="cite4thisdoc"&gt;
        &lt;ci:content&gt;Maritime Union of Australia v Geraldton Port Authority [2000] FCA
            16&lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:courtcite&gt;
</xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:cite4thisresource citetype="court"&gt;
    &lt;lnci:cite&gt;
        &lt;lnci:content&gt;Maritime Union of Australia v Geraldton Port Authority [2000] FCA
            16&lt;/lnci:content&gt;
    &lt;/lnci:cite&gt;
&lt;/ref:cite4thisresource&gt;
           </xd:pre>
         <xd:p>When <xd:i>@type</xd:i> attribute is not present in the
                    <xd:i>ci:cite</xd:i> element then
                    <xd:i>case:courtcite</xd:i> becomes
                    <xd:b>ref:cite4thisresource/@citetype="court"</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:courtcite&gt;
    &lt;ci:cite&gt;
        &lt;ci:content&gt;Le Brun (An Incapable Person Suing By His Next Friend Elaine Le Brun) v Joseph
            and Ors [2006] WADC 200&lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:courtcite&gt;
</xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:cite4thisresource citetype="court"&gt;
    &lt;lnci:cite&gt;
        &lt;lnci:content&gt;Le Brun (An Incapable Person Suing By His Next Friend Elaine Le Brun) v Joseph
            and Ors [2006] WADC 200&lt;/lnci:content&gt;
    &lt;/lnci:cite&gt;
&lt;/ref:cite4thisresource&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>case:courtcite/ci:cite/@type="cite4thisdoc"</xd:i> then duplicate
            all the <xd:b>ref:para</xd:b> in the document using the
                <xd:b>lnci:au@courtcode</xd:b> value in
                <xd:b>@para-scheme</xd:b> and
                <xd:b>@paraschemetype="court-code"</xd:b>. For more clarification please
            refer the example below. </xd:p>
         <xd:pre>
            <xd:b>SOURCE XML</xd:b>

&lt;case:courtcite&gt;
    &lt;ci:cite type="cite4thisdoc"&gt;
        &lt;ci:case&gt;
            &lt;ci:caseinfo&gt;
                &lt;ci:opinionnum num="201"/&gt;
                &lt;ci:jurisinfo&gt;
                    &lt;ci:au courtcode="nswca"/&gt;
                &lt;/ci:jurisinfo&gt;
                &lt;ci:decisiondate year="2008"/&gt;
            &lt;/ci:caseinfo&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;[2008] NSWCA 201&lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:courtcite&gt;

           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:citations&gt;    
    &lt;ref:cite4thisresource citetype="court"&gt;        
        &lt;lnci:cite&gt;            
            &lt;lnci:case&gt;                
                &lt;lnci:caseinfo&gt;                    
                    &lt;lnci:opinionnum num="201"/&gt;                    
                    &lt;lnci:jurisinfo&gt;                        
                        &lt;lnci:au courtcode="nswca"/&gt;                        
                    &lt;/lnci:jurisinfo&gt;                    
                    &lt;lnci:decisiondate year="2008"/&gt;                    
                &lt;/lnci:caseinfo&gt;                
            &lt;/lnci:case&gt;            
            &lt;lnci:content&gt;[2008] NSWCA 201&lt;/lnci:content&gt;            
        &lt;/lnci:cite&gt;        
    &lt;/ref:cite4thisresource&gt;    
&lt;/ref:citations&gt;

and

&lt;ref:para num="1" para-scheme="nswlr" para-scheme-type="reporter-abbreviation"&gt;[1]&lt;/ref:para&gt;
&lt;ref:para num="1" para-scheme="nswca" para-scheme-type="court-code"/&gt;  


            </xd:pre>
         <!--Changes2016-11-15: Added instruction and example when
                case:courtcite/ci:cite/@type="cite4thisdoc" then duplicate all the ref:para using the lnci:au@courtcode Applicable for AU01 and NZ03. Webstar # 6366618 and VSTS #1479772015-12-24: Added instruction and example when
                        @type attribute is not present in
                        ci:cite element. Applicable on AU01, Webstar #
                    60044062015-12-22: Updated target mapping and snippet based on
                    the ci:cite/@type value, Applicable on AU01, Webstar #
                    6004406.2014-06-18: Updated target mapping and snippet, Webteam
                    #: 236888.2013-05-30: Added direction to create textitem inside
                    caseinfo:courtcite (already reflected in example). Updated example so that
                    ci:cite is no longer dropped as part of mapping.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.courtcite-LxAdv_ref.cite4thisresource.dita  -->
   <xsl:template match="case:courtcite">
      <xsl:if test="child::ci:cite[@type='parallel']">
         <ref:citations>
            <ref:parallelcite citetype="court">
               <xsl:apply-templates select="node() | @*"/>
            </ref:parallelcite>
         </ref:citations>
      </xsl:if>
   </xsl:template>

   <xsl:template match="case:courtcite[ci:cite[@type='cite4thisdoc' or not(@type)]]">
      <ref:citations>
         <ref:cite4thisresource citetype="court">
            <xsl:apply-templates select="node() | @*"/>
         </ref:cite4thisresource>
      </ref:citations>
   </xsl:template>
   <!--<xsl:template match="case:courtcite[ci:cite[@type='parallel']]">
	    <ref:citations>
	    <ref:parallelcite citetype="court">
			<xsl:apply-templates select="node() | @*"/>
		</ref:parallelcite>
	    </ref:citations>
	</xsl:template>


	<xsl:template match="case:courtcite[ci:cite[@type='cite4thisdoc' or not(@type)]]">
	    <ref:citations>
	    <ref:cite4thisresource citetype="court">
			<xsl:apply-templates select="node() | @*"/>
		</ref:cite4thisresource>
	    </ref:citations>
	</xsl:template>-->   <!-- TODO: implement DITA <note> above:
	If case:courtcite/ci:cite[@type="cite4thisdoc"] then duplicate all the ref:para in the document using the lnci:au@courtcode 
	value in @para-scheme and @paraschemetype="court-code". For more clarification please refer the example below. 
	-->   <!-- Already: Completed -->   <!-- <topicref href="AU01_Rosetta_case.libnum-LxAdv_refnum-refnumscheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:libnum</xd:i> becomes <xd:b>jurisinfo:courtinfo/refnum/@refnumscheme="wa-AU-library-number"</xd:b>
               <xd:pre>

&lt;case:info&gt;
  ...
  &lt;case:courtinfo&gt;
    ...
    &lt;case:filenum&gt;No. CIV 1695 of 1993&lt;/case:filenum&gt;
    &lt;case:dates&gt;
      &lt;case:hearingdates&gt;23 September 1996&lt;/case:hearingdates&gt;
      &lt;case:decisiondate&gt;
        &lt;date day="11" month="10" year="1996"&gt;, 11 October 1996&lt; /date&gt;
      &lt;/case:decisiondate&gt;
    &lt;/case:dates&gt;
    &lt;case:libnum&gt;960591&lt;/case:libnum&gt;
    &lt;case:juris&gt;wa&lt;/case:juris&gt;
  &lt;/case:courtinfo&gt;
&lt;/case:info&gt;
<xd:b>Becomes</xd:b>

&lt;caseinfo:caseinfo&gt;
  ...
  &lt;caseinfo:docketnum&gt;No. CIV 1695 of 1993&lt;/caseinfo:docketnum&gt;
  &lt;jurisinfo:courtinfo&gt;
    &lt;jurisinfo:courtname&gt;SUPREME COURT OF WESTERN AUSTRALIA IN CHAMBERS&lt;/jurisinfo:courtname&gt;
    &lt;refnum refnumscheme="wa-AU-library-number"&gt;960591&lt;/refnum&gt;
  &lt;/jurisinfo:courtinfo&gt;
  &lt;decision:dates&gt;
    &lt;decision:argueddate&gt;23 September 1996&lt;/decision:argueddate&gt;
    &lt;decision:decisiondate day="11" month="10" year="1996"&gt;, 
      &lt;datetext&gt;11 October 1996&lt;/datetext&gt;
    &lt;/decision:decisiondate&gt;
  &lt;/decision:dates&gt;
&lt;/caseinfo:caseinfo&gt;

</xd:pre>
            </xd:li>
         </xd:ul>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.libnum-LxAdv_refnum-refnumscheme.dita  -->
   <xsl:template match="case:libnum"><!--  Original Target XPath:  jurisinfo:courtinfo/refnum/@refnumscheme="wa-AU-library-number"   --><!-- assume jurisinfo:courtinfo wrapper created elsewhere --><!--<jurisinfo:courtinfo>-->
      <refnum refnumscheme="wa-AU-library-number">
         <xsl:apply-templates/>
      </refnum>
      <!--</jurisinfo:courtinfo>-->
   </xsl:template>
   <!-- start topicref  ../../common_caselaw/Rosetta_catchwordgrp.dita  -->   <!-- Already Done -->   <!-- <topicref href="../../common_caselaw/Rosetta_catchwordgrp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>catchwordgrp</xd:i> is a container element that should be omitted, but its content should be
					retained and converted as follows: <xd:ul>
               <xd:li>
                  <xd:i>catchwordgrp/heading</xd:i> becomes
								<xd:b>caseinfo:caseinfo/classify:classification/heading</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>catchwordgrp/catchwords</xd:i> becomes
								<xd:b>caseinfo:caseinfo/classify:classification</xd:b> with the value of
								<xd:b>classify:classification/@classscheme</xd:b> set to "catchwords". Each instance of
								<xd:i>catchwords</xd:i> should be converted to its own
								<xd:b>classify:classification[@classscheme="catchwords"]</xd:b> element. The children of
								<xd:i>catchwords</xd:i> are converted as follows:<xd:ul>
                     <xd:li>
                        <xd:i>catchwords/catchphrase</xd:i> becomes
										<xd:b>classify:classification/classify:classitem/classify:classitem-identifier/classify:classname</xd:b>.</xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>caseinfo:caseinfo</xd:b> elements. When 2 or more
					consecutive sibling source elements map to <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to
					a single <xd:b>caseinfo:caseinfo</xd:b> element unless this would hamper content ordering.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>Exception for Pacific Content (AU):</xd:b> If <xd:i>nl</xd:i> occur within
						<xd:i>catchwords/catchphrase</xd:i> then conversion should replace the <xd:i>nl</xd:i>
					with a space.</xd:p>
         <xd:p>
            <xd:b>Example: CA content</xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;catchwords&gt; &lt;catchphrase&gt;Zoning by-laws&lt;/catchphrase&gt;
					&lt;catchphrase&gt;Defendant's commercial greenhouse not permitted under prior by-law and therefore not a
					continuing non-conforming legal use&lt;/catchphrase&gt; &lt;catchphrase&gt;Municipality having right to
					enforce by-law by injunction&lt;/catchphrase&gt; &lt;catchphrase&gt;Planning Act, R.S.P.E.I. 1974, c. P-6, ss.
					46(1)(e), (f), (g), 49, 52, 56&lt;/catchphrase&gt; &lt;catchphrase&gt;Municipalities Act, R.S.P.E.I. 1974, c.
					M-15.1, s. 1(b).&lt;/catchphrase&gt; &lt;/catchwords&gt; &lt;/catchwordgrp&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;classify:classification classscheme="catchwords"&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Zoning by-laws&lt;/classify:classname&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Defendant's commercial greenhouse not
					permitted under prior by-law and therefore not a continuing non-conforming legal
					use&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Municipality having
					right to enforce by-law by injunction&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Planning Act, R.S.P.E.I. 1974, c. P-6, ss. 46(1)(e), (f), (g), 49, 52,
					56&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Municipalities Act,
					R.S.P.E.I. 1974, c. M-15.1, s. 1(b).&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;/classify:classification&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: CA content <xd:i>catchwordgrp</xd:i> with child <xd:i>heading</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;heading&gt; &lt;title&gt;Indexation :&lt;/title&gt; &lt;/heading&gt;
					&lt;catchwords&gt; &lt;catchphrase&gt;Assurance&lt;/catchphrase&gt; &lt;catchphrase&gt;Assurance
					automobile&lt;/catchphrase&gt; &lt;catchphrase&gt;Rgime d'indemnisation sans gard  la
					responsabilit&lt;/catchphrase&gt; ... &lt;/catchwords&gt; &lt;/catchwordgrp&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;classify:classification classscheme="catchwords"&gt; &lt;heading&gt; &lt;title&gt;Indexation
					:&lt;/title&gt; &lt;/heading&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Assurance&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Assurance automobile&lt;/classify:classname&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Rgime d'indemnisation sans gard  la
					responsabilit&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					... &lt;/classify:classification&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;catchwords&gt; &lt;catchphrase&gt;Practice and
					procedure&lt;/catchphrase&gt; &lt;catchphrase&gt;Applications&lt;/catchphrase&gt; &lt;catchphrase&gt;Applicant
					sought declaration that insurance agents were independent contractors&lt;/catchphrase&gt;
					&lt;catchphrase&gt;Agents had already commenced proceedings in the Chief Industrial Magistrates Court of NSW
					claiming entitlements&lt;/catchphrase&gt; &lt;/catchwords&gt; &lt;/catchwordgrp&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;classify:classification classscheme="catchwords"&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Practice and
					procedure&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Applications&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Applicant sought declaration that insurance agents were independent
					contractors&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Agents had already
					commenced proceedings in the Chief Industrial Magistrates Court of NSW claiming
					entitlements&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;/classify:classification&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;catchwords&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;Deceit&lt;/emph&gt; &lt;/catchphrase&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;Amendment of Declaration&lt;/emph&gt; &lt;/catchphrase&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;Terms&lt;/emph&gt; &lt;/catchphrase&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;Reservation of leave&lt;/emph&gt; &lt;/catchphrase&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;New Trial&lt;/emph&gt; &lt;/catchphrase&gt; &lt;catchphrase&gt; &lt;emph
					typestyle="it"&gt;Two concurring verdicts&lt;/emph&gt; &lt;/catchphrase&gt; &lt;/catchwords&gt;
					&lt;/catchwordgrp&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;classify:classification classscheme="catchwords"&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt; &lt;emph
					typestyle="it"&gt;Deceit&lt;/emph&gt; &lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt; &lt;emph typestyle="it"&gt;Amendment of Declaration&lt;/emph&gt;
					&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt; &lt;emph
					typestyle="it"&gt;Terms&lt;/emph&gt; &lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt; &lt;emph typestyle="it"&gt;Reservation of leave&lt;/emph&gt;
					&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt; &lt;emph
					typestyle="it"&gt;New Trial&lt;/emph&gt; &lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt; &lt;emph typestyle="it"&gt;Two concurring verdicts&lt;/emph&gt;
					&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;/classify:classification&gt; </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;catchwords&gt; &lt;catchphrase&gt;Copyright &amp;#x2013; Compilation
					&amp;#x2013; No evidence of any specific infringement &amp;#x2013; Declaratory judgment &amp;#x2013; Possible
					infringement by documents not yet in existence &amp;#x2013; RSC Ord XXV, r 5.&lt;/catchphrase&gt;
					&lt;/catchwords&gt; &lt;/catchwordgrp&gt; </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre> &lt;classify:classification classscheme="catchwords"&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Copyright &amp;#x2013; Compilation
					&amp;#x2013; No evidence of any specific infringement &amp;#x2013; Declaratory judgment &amp;#x2013; Possible
					infringement by documents not yet in existence &amp;#x2013; RSC Ord XXV, r 5.&lt;/classify:classname&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt; &lt;/classify:classification&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If the punctuation marks occuring between <xd:i>catchwords</xd:i> and
					<xd:i>catchphrase</xd:i> conversion should drop these punctuation in output this will be handle by
				stylesheet.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If the punctuation marks occuring inside the <xd:i>catchphrase</xd:i> then, these will be retain
				in output.</xd:p>
         <xd:p>
            <xd:b>Example: UK content, punctuation marks occuring between <xd:i>catchwords</xd:i> and
						<xd:i>catchphrase</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;catchwordgrp&gt; &lt;catchwords&gt; ( &lt;catchphrase&gt;Comitology&lt;/catchphrase&gt; 
					&lt;catchphrase&gt;Council Decision 1999/468/EC laying down the procedures for the exercise of implementing
					powers conferred on the Commission&lt;/catchphrase&gt;  &lt;catchphrase&gt;Criteria for choosing between the
					different procedures for adopting implementing measures&lt;/catchphrase&gt; 
					&lt;catchphrase&gt;Effects&lt;/catchphrase&gt;  &lt;catchphrase&gt;Obligation to state
					reasons&lt;/catchphrase&gt;  &lt;catchphrase&gt;Annulment in part of Regulation (EC) No 1655/2000 of the
					European Parliament and of the Council concerning the Financial Instrument for the Environment
					(LIFE)&lt;/catchphrase&gt; ) &lt;/catchwords&gt; &lt;/catchwordgrp&gt; <xd:b>becomes</xd:b>
					&lt;classify:classification classscheme="catchwords"&gt; &lt;classify:classitem&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Comitology&lt;/classify:classname&gt;
					&lt;/classify:classitem-identifier&gt; &lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Council
					Decision 1999/468/EC laying down the procedures for the exercise of implementing powers conferred on the
					Commission&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Criteria for choosing between the different
					procedures for adopting implementing measures&lt;/classify:classname&gt;
					&lt;/classify:classitem-identifier&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classname&gt;Effects&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Obligation to state
					reasons&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;classify:classitem-identifier&gt; &lt;classify:classname&gt;Annulment in part of Regulation (EC) No
					1655/2000 of the European Parliament and of the Council concerning the Financial Instrument for the
					Environment (LIFE)&lt;/classify:classname&gt; &lt;/classify:classitem-identifier&gt;
					&lt;/classify:classitem&gt; &lt;/classify:classification&gt; </xd:pre>
         <!--Changes2015-05-12: Updated note for Pacific Content (AU) to replace
							nl with space when occur in catchwords/catchphrase, Webstar
						# 5992021, Applicable on AU01.2015-01-07: Added note for Pacific Content (AU) to drop nl
						if occur within catchwords/catchphrase, Webteam # 282244, Applicable on
					AU01.2013-12-13: Added instruction to drop punctuation occuring between catchwords
						and catchphrase Webteam# 247658-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_catchwordgrp.dita  -->
   <xsl:template match="catchwordgrp">
      <xsl:apply-templates select="node() except heading | @*"/>
   </xsl:template>
   <!--<!-\- Vikas Rohilla: added for the streamID CA01	-\->
	<xsl:template match="catchwordgrp[preceding-sibling::*[1][self::case:info]][$streamID='CA01']"/>
	
	<!-\- Vikas Rohilla: added for the streamID CA01	-\->
	<xsl:template match="catchwordgrp[not(preceding-sibling::*[1][self::case:info])][$streamID='CA01']">
		<caseinfo:caseinfo>
			<xsl:apply-templates select="node() except heading | @*"/>
		</caseinfo:caseinfo>
	</xsl:template>
	<!-\- Vikas Rohilla: added for the streamID CA01	-\->
	<xsl:template match="case:headnote/catchwordgrp[$streamID='CA01']" mode="headnote-catchwordgrp">
		<xsl:apply-templates select="node() except heading | @*"/>
	</xsl:template>-->
   <xsl:template match="catchwords"><!--  Original Target XPath:  caseinfo:caseinfo/classify:classification/heading   --><!-- Sudhanshu 5 May 2017- implemented for CA01 --><!--
		<xsl:choose>
			<xsl:when test="$streamID = 'CA01'">
				<caseinfo:caseinfo>
					<classify:classification>
						<xsl:attribute name="classscheme">
							<xsl:text>catchwords</xsl:text>
						</xsl:attribute>
						<xsl:apply-templates select="preceding-sibling::heading"/>
						<xsl:apply-templates select="@* | node() except page"/>
					</classify:classification>
				</caseinfo:caseinfo>
			</xsl:when>
			<xsl:when test="$streamID = 'HK03'">
					<classify:classification>
						<xsl:attribute name="classscheme">
							<xsl:text>catchwords</xsl:text>
						</xsl:attribute>
						<xsl:apply-templates select="preceding-sibling::heading"/>
						<xsl:apply-templates select="@* | node() | child::page"/>
					</classify:classification>
			</xsl:when>
			<xsl:otherwise>--><!-- Awantika: 2017-10-30- checking for empty catchwords element, As catchwords is coming blank in source for AU01, 
			therefore empty classify:classification is being created and thus resulting in validation -->
      <xsl:if test=".!=''">
         <classify:classification>
            <xsl:attribute name="classscheme">
               <xsl:text>catchwords</xsl:text>
            </xsl:attribute>
            <xsl:apply-templates select="preceding-sibling::heading"/>
            <xsl:apply-templates select="@* | node() except page"/>
         </classify:classification>
      </xsl:if>
      <!--	</xsl:otherwise>
		</xsl:choose>
-->
      <!-- MDS 2017-06-21 - The if and all to the named template are not needed.  
			The apply-templates only runs with a page child exists. 
			The named template (located in Rosetta_catchwordgrp_page.xsl) already only functions when page has a parent catchwordgrp or catchwords.
		-->
      <xsl:apply-templates select="page[not($streamID='HK03')]"/>
      <!--<xsl:if test="child::page">
			<xsl:call-template name="page"/>
		</xsl:if>-->
      <!--<xsl:if test="page">
	    <classify:classification>
	      <classify:classitem>
	        <classify:classitem-identifier>
	          <classify:classname>
	            <xsl:apply-templates select="page"/>	          
	          </classify:classname>
	        </classify:classitem-identifier>
	      </classify:classitem>
	    </classify:classification>
	  </xsl:if>-->
   </xsl:template>

   <xsl:template match="catchwordgrp/heading"><!--  Original Target XPath:  caseinfo:caseinfo/classify:classification/heading   -->
      <heading>
         <xsl:apply-templates select="@* | node()"/>
      </heading>
   </xsl:template>
   <!--<xsl:template match="catchwordgrp/catchwords">

		<!-\-  Original Target XPath:  caseinfo:caseinfo/classify:classification   -\->
		<caseinfo:caseinfo>
			<classify:classification>
				<xsl:apply-templates select="@* | node()"/>
			</classify:classification>
		</caseinfo:caseinfo>

	</xsl:template>-->   <!-- If the punctuation marks occuring between catchwords and catchphrase conversion should drop these punctuation in output this will be
handle by stylesheet. -->   <!-- Awntika-2017-11-15- Updated for webstar 7047020, where text is coming outside catchphrase and it should be taken inside
					classify:classname and text should drop from the caseinfo:caseinfo -->
   <xsl:template match="catchwords/text()[following::catchphrase or preceding::catchphrase]">
      <xsl:choose>
         <xsl:when test="$streamID='AU01'"/>
         <xsl:otherwise>
            <xsl:value-of select="replace(., '[^a-zA-Z0-9]', ' ')"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="catchwords/catchphrase"><!--  Original Target XPath:  classify:classification/classify:classitem/classify:classitem-identifier/classify:classname   --><!-- JD: 2017-06-15: I can find no instruction for creating @classscheme='catchphrase' in id-CCCC-12023 -->
      <classify:classitem><!-- classscheme="catchphrase">-->
         <xsl:if test="$streamID=('AU13','UK02','HK09')">
            <xsl:attribute name="classscheme">catchphrase</xsl:attribute>
         </xsl:if>
         <classify:classitem-identifier>
            <classify:classname>
               <xsl:apply-templates select="@* | node()"/>
               <!-- Awantika: 2017-11-15- Updated for webstar 7047020, where text is coming outside catchphrase and it should be taken inside
					classify:classname and text should drop from the caseinfo:caseinfo-->
               <xsl:if test="$streamID='AU01' and following-sibling::text()[1]">
                  <xsl:value-of select="./following-sibling::text()[1]"/>
               </xsl:if>
            </classify:classname>
         </classify:classitem-identifier>
      </classify:classitem>
   </xsl:template>
   <!--	<xsl:template match="nl">

		<!-\-  Original Target XPath:     -\->
		<!-\-  Could not determine target element or attribute name:  <>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </>  -\->

	</xsl:template>-->
   <xsl:template match="catchphrase"><!--  Original Target XPath:     --><!--  Could not determine target element or attribute name:  <>  -->
      <xsl:apply-templates select="@* | node()"/>
      <!--  Could not determine target element or attribute name:  </>  -->
   </xsl:template>
   <!-- Already Done -->   <!-- <topicref href="../../common_caselaw/Rosetta_catchwordgrp_page.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>catchwordgrp/page</xd:i> becomes
          <xd:b>classify:classification/classify:classitem/classify:classitem-identifier/classify:classname/ref:page</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;catchwordgrp&gt;
  &lt;catchwords&gt;
    &lt;catchphrase&gt;Emergency Legislation &amp;#x2013; Trading with the enemy &amp;#x2013; Guarantee by English
      company of debt due to neutral by German company &amp;#x2013; Whether payment under guarantee for
      benefit or in discharge of obligation of enemy &lt;ci:cite searchtype="LEG-REF" status="valid"&gt;
        &lt;ci:sesslaw&gt;
          &lt;ci:sesslawinfo&gt;
            &lt;ci:sesslawnum num="1939_89a"/&gt;
            &lt;ci:hierpinpoint&gt;
              &lt;ci:hierlev label="section" num="1"/&gt;
            &lt;/ci:hierpinpoint&gt;
          &lt;/ci:sesslawinfo&gt;
          &lt;ci:sesslawref&gt;
            &lt;ci:standardname normpubcode="UK_ACTS"/&gt;
          &lt;/ci:sesslawref&gt;
        &lt;/ci:sesslaw&gt;
        &lt;ci:content&gt;Trading with the Enemy Act 1939 (c 89), s 1(2)(a) &lt;/ci:content&gt;
      &lt;/ci:cite&gt;. &lt;/catchphrase&gt;
  &lt;/catchwords&gt;
  &lt;page text="[1941] 1 All ER 257 at " count="258" reporter="ALLER"/&gt;
&lt;/catchwordgrp&gt;
      </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;classify:classification classscheme="catchwords"&gt;
  &lt;classify:classitem&gt;
    &lt;classify:classitem-identifier&gt;
      &lt;classify:classname&gt; Emergency Legislation &amp;#x2013; Trading with the enemy &amp;#x2013; Guarantee
        by English company of debt due to neutral by German company &amp;#x2013; Whether payment under
        guarantee for benefit or in discharge of obligation of enemy &lt;lnci:cite status="valid"&gt;
          &lt;lnci:sesslaw&gt;
            &lt;lnci:sesslawinfo&gt;
              &lt;lnci:sesslawnum num="1939_89a"/&gt;
              &lt;lnci:hierpinpoint&gt;
                &lt;lnci:hierlev label="section" num="1"/&gt;
              &lt;/lnci:hierpinpoint&gt;
            &lt;/lnci:sesslawinfo&gt;
            &lt;lnci:sesslawref&gt;
              &lt;lnci:standardname normpubcode="UK_ACTS"/&gt;
            &lt;/lnci:sesslawref&gt;
          &lt;/lnci:sesslaw&gt;
          &lt;lnci:content&gt;Trading with the Enemy Act 1939 (c 89), s 1(2)(a) &lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;. &lt;/classify:classname&gt;
    &lt;/classify:classitem-identifier&gt;
  &lt;/classify:classitem&gt;
&lt;/classify:classification&gt;
&lt;classify:classification classscheme="catchwords"&gt;
  &lt;classify:classitem&gt;
    &lt;classify:classitem-identifier&gt;
      &lt;classify:classname&gt;
        &lt;ref:page num="258" page-scheme="ALLER" page-scheme-type="reporterabbreviation"/&gt;
      &lt;/classify:classname&gt;
    &lt;/classify:classitem-identifier&gt;
  &lt;/classify:classitem&gt;
&lt;/classify:classification&gt;
      </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_catchwordgrp_page.dita  -->
   <xsl:template match="page[parent::catchwordgrp or parent::catchwords]" name="page"><!--  Original Target XPath:  classify:classification/classify:classitem/classify:classitem-identifier/classify:classname/ref:page   -->
      <classify:classification>
         <classify:classitem>
            <classify:classitem-identifier>
               <classify:classname>
                  <ref:page>
                     <xsl:attribute name="num">
                        <xsl:value-of select="@count"/>
                     </xsl:attribute>
                     <!-- JD: 2017-07-12: added if test to prevent schema validation errors 
	          		      "cvc-datatype-valid.1.2.1: '' is not a valid value for 'NMTOKEN'." 
	          		   and 
	          		   	  "cvc-attribute.3: The value '' of attribute 'page-scheme' on element 'ref:page' is not valid with respect to its type, 'NMTOKEN'." -->
                     <xsl:if test="normalize-space(@reporter)!=''">
                        <xsl:attribute name="page-scheme">
                           <xsl:value-of select="@reporter"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:attribute name="page-scheme-type">
                        <xsl:text>reporter-abbreviation</xsl:text>
                     </xsl:attribute>
                  </ref:page>
               </classify:classname>
            </classify:classitem-identifier>
         </classify:classitem>
      </classify:classification>
   </xsl:template>
   <!-- end topicref  ../../common_caselaw/Rosetta_catchwordgrp.dita  -->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.factsummary-LxAdv_casesum.editorialsummary.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>The attributes of <xd:i>case:factsummary</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>case:factsummary/@subdoc</xd:i> becomes
              <xd:b>casesum:editorialsummary/@includeintoc</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:factsummary/@toc-caption</xd:i> becomes
              <xd:b>casesum:editorialsummary/@alternatetoccaption</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>casesum:summaries</xd:b>
        elements. When 2 or more consecutive sibling source elements map to
          <xd:b>casesum:summaries</xd:b>, target data should be merged to a single
          <xd:b>casesum:summaries</xd:b> element unless this would hamper content
        ordering.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b> Andrew: Editorially added content. </xd:p>
         <xd:pre>
&lt;case:factsummary&gt;
  &lt;p&gt;
    &lt;text&gt;The respondents (the agents) were engaged by Combined as insurance agents. Therespondents commenced proceedings in the Chief Industrial Magistrates Court ofNSW (Industrial Court) claiming entitlements to annual and long service leave. Thatcourt&amp;#x2019;s jurisdiction to make orders was conferred by the Workplace Relations Act1996 (Cth). Combined commenced proceedings in the Federal Court seeking declarations that the respondents were independent contractors. It also sought an indemnity from each agent for misrepresenting that each was an independent contractor if they were not; and damages. On 27April 2009, the agents filed a notice of motion seeking that the proceedings against them be dismissed primarily on the basis none of the claims was in federal jurisdiction.
    &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:factsummary&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:summaries&gt;
  &lt;casesum:editorialsummary&gt;
    &lt;p&gt;
      &lt;text&gt;The respondents (the agents) were engaged by Combined as insurance agents. Therespondents commenced proceedings in the Chief Industrial Magistrates Court ofNSW (Industrial Court) claiming entitlements to annual and long service leave. Thatcourt&amp;#x2019;s jurisdiction to make orders was conferred by the Workplace Relations Act1996 (Cth). Combined commenced proceedings in the Federal Court seeking declarations that the respondents were independent contractors. It also sought an indemnity from each agent for misrepresenting that each was an independent contractor if they were not; and damages. On 27April 2009, the agents filed a notice of motion seeking that the proceedings against them be dismissed primarily on the basis none of the claims was in federal jurisdiction.
      &lt;/text&gt;
    &lt;/p&gt;
  &lt;/casesum:editorialsummary&gt;
&lt;/casesum:summaries&gt;
           </xd:pre>
         <xd:pre>
&lt;case:factsummary&gt;
  &lt;l&gt;
    &lt;li&gt;
      &lt;lilabel&gt;&lt;emph typestyle="ro"&gt;&amp;hellip;&lt;/emph&gt;&lt;/lilabel&gt;
      &lt;p&gt;
        &lt;text&gt;&lt;/text&gt;
      &lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;lilabel&gt;&lt;emph typestyle="ro"&gt;(d)&lt;/emph&gt;&lt;/lilabel&gt;
      &lt;p&gt;
        &lt;text&gt;in the opinion of the Commission, the death of the veteran was due to an accident that would not have occurred, or to a disease that would not have been contracted, but for his or her having rendered eligible war service or but for changes in the veteran's environment consequent upon his or her having rendered eligible war service &amp;hellip;&amp;rdquo;&lt;/text&gt;
      &lt;/p&gt;
    &lt;/li&gt;
  &lt;/l&gt;
  &lt;p&gt;&lt;text&gt;Counsel for W relied upon dictionary definitions of &amp;ldquo;consequent upon&amp;rdquo; to mean &amp;ldquo;following as a result&amp;rdquo; and &amp;ldquo;following logically&amp;rdquo;.&lt;/text&gt;
  &lt;/p&gt;
&lt;/case:factsummary&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:summaries&gt;
  &lt;casesum:editorialsummary&gt;
    &lt;p&gt;
      &lt;list&gt;
      &lt;listitem&gt;
        &lt;label&gt;&lt;emph typestyle="ro"&gt;&amp;#x2026;&lt;/emph&gt;&lt;/label&gt;
        &lt;p&gt;
          &lt;text&gt;&lt;/text&gt;
        &lt;/p&gt;
      &lt;/listitem&gt;
      &lt;listitem&gt;
        &lt;label&gt;&lt;emph typestyle="ro"&gt;(d)&lt;/emph&gt;&lt;/label&gt;
        &lt;p&gt;
          &lt;text&gt;in the opinion of the Commission, the death of the veteran was due to an accident that would not have occurred, or to a disease that would not have been contracted, but for his or her having rendered eligible war service or but for changes in the veteran's environment consequent upon his or her having rendered eligible war service &amp;#x2026;&amp;#x201D;&lt;/text&gt;
        &lt;/p&gt;
      &lt;/listitem&gt;
      &lt;/list&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;text&gt;Counsel for W relied upon dictionary definitions of &amp;#x201C;consequent upon&amp;#x201D; to mean &amp;#x201C;following as a result&amp;#x201D; and &amp;#x201C;following logically&amp;#x201D;.&lt;/text&gt;
    &lt;/p&gt;
  &lt;/casesum:editorialsummary&gt;
&lt;/casesum:summaries&gt;
           </xd:pre>
         <!--<section
      conref="../../common_caselaw/conref_content/Rosetta_case.factsummary-LxAdv_casesum.editorialsummary.dita.dita#Rosetta_case.factsummary-LxAdv_casesum.editorialsummary.dita/changes"/>-->
         <!--<section>
      <title>Changes Specific to AU01</title>
    </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.factsummary-LxAdv_casesum.editorialsummary.dita  -->
   <xsl:template match="case:factsummary" mode="summaries"><!--  Original Target XPath:  casesum:editorialsummary/@includeintoc   -->
      <casesum:editorialsummary>
         <xsl:if test="@subdoc">
            <xsl:attribute name="includeintoc">
               <xsl:value-of select="@subdoc"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="@toc-caption">
            <xsl:attribute name="alternatetoccaption">
               <xsl:value-of select="@toc-caption"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:apply-templates select="@* | node()"/>
      </casesum:editorialsummary>
   </xsl:template>
   <!--<xsl:template match="case:factsummary">
		<!-\-  Original Target XPath:  casesum:editorialsummary/@includeintoc   -\->
		<casesum:editorialsummary>
			<xsl:apply-templates select="node() | @*"/>
		</casesum:editorialsummary>
	</xsl:template>
	
	<xsl:template match="l[parent::case:factsummary]">
		<p>
			<list>
				<xsl:apply-templates/>
			</list>
		</p>
	</xsl:template>

	<xsl:template match="case:factsummary/@subdoc">
		<!-\-  Original Target XPath:  casesum:editorialsummary/@includeintoc   -\->
		<xsl:attribute name="includeintoc">
			<xsl:value-of select="."/>
		</xsl:attribute>
	</xsl:template>

	<xsl:template match="case:factsummary/@toc-caption">
		<xsl:attribute name="alternatetoccaption">
			<xsl:value-of select="."/>
		</xsl:attribute>
	</xsl:template>-->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.decisionsummary-LxAdv_casesum.decisionsummary.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>The optional attributes of <xd:i>case:decisionsummary</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>case:decisionsummary/@summarytype</xd:i> becomes
                            <xd:b>casesum:decisionsummary/@summarysource</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>case:decisionsummary/@subdoc</xd:i> becomes
                            <xd:b>casesum:decisionsummary/@includeintoc</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>case:decisionsummary/@toc-caption</xd:i> becomes
                            <xd:b>casesum:decisionsummary/@alternatetoccaption</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:pre>
&lt;case:decisionsummary summarytype="held"&gt;
  &lt;p&gt;
    &lt;text&gt;
      &lt;emph typestyle="bf"&gt;Held&lt;/emph&gt;, dismissing the motion:
    &lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;text&gt;(i)&amp;#x2003;The proceedings before the Industrial Court were wholly in federal jurisdiction. The claim by Combined against each agent in the Federal Court and the claim by each agent against Combined in the Industrial Court arose largely out of the same substratum of fact. It followed there was, as between each agent and Combined, a single matter comprising the basic question of whether each agent was an employee, related questions of estoppel and misleading conduct and remedial issues relating to money and penalties: at[13], [16].
    &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:decisionsummary&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:summaries&gt;
  &lt;casesum:decisionsummary summarysource="held"&gt;
    &lt;bodytext&gt;
      &lt;p&gt;
        &lt;text&gt;&lt;emph typestyle="bf"&gt;Held&lt;/emph&gt;, dismissing the motion:&lt;/text&gt;
      &lt;/p&gt;
      &lt;p&gt;
        &lt;text&gt;(i)&amp;#x2003;The proceedings before the Industrial Court were wholly in federal jurisdiction. The claim by Combined against each agent in the Federal Court and the claim by each agent against Combined in the Industrial Court arose largely out of the same substratum of fact. It followed there was, as between each agent and Combined, a single matter comprising the basic question of whether each agent was an employee, related questions of estoppel and misleading conduct and remedial issues relating to money and penalties: at[13], [16].
        &lt;/text&gt;
      &lt;/p&gt;
    &lt;/bodytext&gt;
  &lt;/casesum:decisionsummary&gt;
&lt;/casesum:summaries&gt;
       </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.filenum-LxAdv_caseinfo.docketnum.dita#Rosetta_case.filenum-LxAdv_caseinfo.docketnum/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
            </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.decisionsummary-LxAdv_casesum.decisionsummary.dita  -->
   <!--<xsl:template match="case:decisionsummary">
		<!-\-  Original Target XPath:  casesum:decisionsummary/@summarysource   -\->
		<casesum:decisionsummary>
				<xsl:apply-templates select="@*"/>
			<xsl:if test="heading">
				<xsl:apply-templates select="heading"/>
			</xsl:if>
			<xsl:if test="node() except (heading,blockquote[child::case:embeddedcase])">
				<bodytext>
					<xsl:apply-templates select="node() except heading"/>
				</bodytext>
			</xsl:if>
			<xsl:if test="blockquote[child::case:embeddedcase]">
				<xsl:apply-templates select="./blockquote/case:embeddedcase"/>
			</xsl:if>
		</casesum:decisionsummary>
	</xsl:template>

	<xsl:template match="case:decisionsummary/@summarytype">
		<!-\-  Original Target XPath:  casesum:decisionsummary/@summarysource   -\->
			<xsl:attribute name="summarysource">
				<xsl:value-of select="."/>
			</xsl:attribute>
	</xsl:template>

	<xsl:template match="case:decisionsummary/@subdoc">
		<!-\-  Original Target XPath:  casesum:decisionsummary/@includeintoc   -\->
			<xsl:attribute name="includeintoc">
				<xsl:value-of select="."/>
			</xsl:attribute>
	</xsl:template>

	<xsl:template match="case:decisionsummary/@toc-caption">
		<!-\-  Original Target XPath:  casesum:decisionsummary/@alternatetoccaption   -\->
			<xsl:attribute name="alternatetoccaption">
				<xsl:value-of select="."/>
			</xsl:attribute>
	</xsl:template>-->
   <xsl:template match="case:decisionsummary" mode="summaries"><!--  Original Target XPath:  casesum:decisionsummary/@summarysource   -->
      <casesum:decisionsummary>
         <xsl:if test="@summarytype">
            <xsl:attribute name="summarysource">
               <xsl:value-of select="@summarytype"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="@subdoc">
            <xsl:attribute name="includeintoc">
               <xsl:value-of select="@subdoc"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="@toc-caption">
            <xsl:attribute name="alternatetoccaption">
               <xsl:value-of select="@toc-caption"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:apply-templates select="heading"/>
         <bodytext>
            <xsl:apply-templates select="@* | node() except heading"/>
         </bodytext>
         <xsl:apply-templates select="//case:headnote/page"/>
      </casesum:decisionsummary>
   </xsl:template>

   <xsl:template match="case:decisionsummary/@summarytype"/>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.consideredcases-LxAdv_ref.relatedrefs.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:consideredcases&gt;
  &lt;p&gt;
    &lt;text&gt;
      &lt;ci:cite searchtype="CASE-REF"&gt;
        &lt;ci:case&gt;
          &lt;ci:caseinfo&gt;
            &lt;ci:decisiondate year="1995"/&gt;
          &lt;/ci:caseinfo&gt;
          &lt;ci:caseref ID="cr000001" spanref="cr000001-001" status="unval"&gt;
            &lt;ci:reporter value="clr"/&gt;
            &lt;ci:volume num="183"/&gt;
            &lt;ci:page num="501"/&gt;
          &lt;/ci:caseref&gt;
          &lt;ci:caseref ID="cr000002" spanref="cr000002-002"&gt;
            &lt;ci:reporter value="alr"/&gt;
            &lt;ci:volume num="130"/&gt;
            &lt;ci:page num="529"/&gt;
          &lt;/ci:caseref&gt;
          &lt;ci:caseref ID="cr000003" spanref="cr000003-003"&gt;
            &lt;ci:reporter value="acsr"/&gt;
            &lt;ci:volume num="17"/&gt;
            &lt;ci:page num="551"/&gt;
          &lt;/ci:caseref&gt;
          &lt;ci:caseref ID="cr000004" spanref="cr000004-004"&gt;
            &lt;ci:reporter value="urj"/&gt;
            &lt;ci:refnum num="BC9506451"/&gt;
          &lt;/ci:caseref&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;
          &lt;citefragment searchtype="CASE-NAME-REF"&gt;
            &lt;emph typestyle="it"&gt;R v Byrnes &amp;amp; Hopwood&lt;/emph&gt;
          &lt;/citefragment&gt;
          &lt;citefragment searchtype="CASE-CITE-REF"&gt; 
            &lt;ci:span spanid="cr000001-001" status="unval"&gt;(1995) 183 CLR 501&lt;/ci:span&gt; ; 
            &lt;ci:span spanid="cr000002-002"&gt;130 ALR 529&lt;/ci:span&gt; ; 
            &lt;ci:span spanid="cr000003-003"&gt;17 ACSR 551&lt;/ci:span&gt; ; 
            &lt;ci:span spanid="cr000004-004"&gt; [1995] HCA 1&lt;/ci:span&gt;
          &lt;/citefragment&gt;
        &lt;/ci:content&gt;
      &lt;/ci:cite&gt;
      , followed
    &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:consideredcases&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:relatedrefs referenctype="consideredcases"&gt;
  &lt;bodytext&gt;
    &lt;p&gt;
      &lt;text&gt;
        &lt;lnci:cite&gt;
          &lt;lnci:case&gt;
            &lt;lnci:caseinfo&gt;
              &lt;lnci:decisiondate year="1995"/&gt;
            &lt;/lnci:caseinfo&gt;
            &lt;lnci:caseref ID="cr000001" status="unval"&gt;
              &lt;lnci:reporter value="clr"/&gt;
              &lt;lnci:volume num="183"/&gt;
              &lt;lnci:page num="501"/&gt;
            &lt;/lnci:caseref&gt;
            &lt;lnci:caseref ID="cr000002"&gt;
              &lt;lnci:reporter value="alr"/&gt;
              &lt;lnci:volume num="130"/&gt;
              &lt;lnci:page num="529"/&gt;
            &lt;/lnci:caseref&gt;
            &lt;lnci:caseref ID="cr000003"&gt;
              &lt;lnci:reporter value="acsr"/&gt;
              &lt;lnci:volume num="17"/&gt;
              &lt;lnci:page num="551"/&gt;
            &lt;/lnci:caseref&gt;
            &lt;lnci:caseref ID="cr000004"&gt;
              &lt;lnci:reporter value="urj"/&gt;
              &lt;lnci:refnum num="BC9506451"/&gt;
            &lt;/lnci:caseref&gt;
          &lt;/lnci:case&gt;
          &lt;ci:content&gt;
            &lt;emph typestyle="it"&gt;R v Byrnes &amp;amp; Hopwood&lt;/emph&gt; (1995) 183 CLR 501; 130 ALR 529; 17 ACSR 551; [1995] HCA 1
          &lt;/ci:content&gt;
        &lt;/lnci:cite&gt;
        , followed
      &lt;/text&gt;
    &lt;/p&gt;
  &lt;/bodytext&gt;
&lt;/ref:relatedrefs&gt;
           </xd:pre>
         <!--<section
      conref="../../common_caselaw/conref_content/Rosetta_case.consideredcases-LxAdv_ref.relatedrefs.dita#Rosetta_case.consideredcases-LxAdv_ref.relatedrefs/changes"/>-->
         <!--<section>
      <title>Changes Specific to AU01</title>
    </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.consideredcases-LxAdv_ref.relatedrefs.dita  -->
   <xsl:template match="case:consideredcases">
      <ref:relatedrefs>
         <xsl:attribute name="referencetype">
            <xsl:text>consideredcases</xsl:text>
         </xsl:attribute>
         <xsl:if test="child::heading">
            <xsl:apply-templates select="heading"/>
         </xsl:if>
         <xsl:if test="node() except heading">
            <bodytext>
               <xsl:apply-templates select="@* | node() except heading"/>
            </bodytext>
         </xsl:if>
         <!--<xsl:apply-templates select="@* | node()"/>-->
      </ref:relatedrefs>
   </xsl:template>
   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.embeddedcase-LxAdv_courtcase.caseexcerpt.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:embeddedcase</xd:i>
                    becomes <xd:b>courtcase:caseexcerpt</xd:b> and attribute <xd:i>@id</xd:i> becomes <xd:b>@xml:id</xd:b>. <xd:p>
                  <xd:b>Note: </xd:b>
                  <xd:b>courtcase:caseexcerpt/@xml:id</xd:b> that begins with a number
                        must have an underscore added at start.</xd:p>
               <xd:p>
                  <xd:b>Note: </xd:b>If <xd:i>case:embeddedcase</xd:i>
                        occurs as a child element of <xd:i>blockquote</xd:i> then
                        conversion need to omit tag (<xd:i>blockquote</xd:i>) and
                        retain content.</xd:p>
               <xd:pre>

&lt;case:decisionsummary&gt;
  &lt;blockquote&gt;
      &lt;case:embeddedcase id="1980_QD_R_411"&gt;
            &lt;case:content&gt;
                &lt;case:judgments&gt;
                    &lt;case:judgment subdoc="true" toc-caption="Judgment 1"&gt;
                        &lt;case:judgmentbody&gt;
                            &lt;p&gt;
                                &lt;text&gt;This was an action...&lt;/text&gt;
                            &lt;/p&gt;
                        &lt;/case:judgmentbody&gt;
                    &lt;/case:judgment&gt;
                &lt;/case:judgments&gt;
            &lt;/case:content&gt;
      &lt;/case:embeddedcase&gt;
  &lt;/blockquote&gt;
&lt;/case:decisionsummary&gt;

<xd:b>Becomes</xd:b>

&lt;casesum:decisionsummary&gt;
            &lt;courtcase:caseexcerpt xml:id="_1980_QD_R_411"&gt;
                &lt;courtcase:body&gt;
                    &lt;courtcase:opinions&gt;
                        &lt;courtcase:opinion includeintoc="true" alternatetoccaption="Judgment 1"&gt;
                            &lt;bodytext&gt;
                                &lt;p&gt;
                                    &lt;text&gt;This was an action...&lt;/text&gt;
                                &lt;/p&gt;
                            &lt;/bodytext&gt;
                        &lt;/courtcase:opinion&gt;
                    &lt;/courtcase:opinions&gt;
                &lt;/courtcase:body&gt;    
            &lt;/courtcase:caseexcerpt&gt;
&lt;/casesum:decisionsummary&gt;

</xd:pre>
            </xd:li>
         </xd:ul>
         <!--Changes2012-08-23: Modified instructions to use an underscore instead of the two digit country code for xml:id.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.embeddedcase-LxAdv_courtcase.caseexcerpt.dita  -->
   <xsl:template match="case:embeddedcase"><!--  Original Target XPath:  courtcase:caseexcerpt   -->
      <courtcase:caseexcerpt>
         <xsl:choose>
            <xsl:when test="case:body/case:headnote/case:factsummary | case:body/case:headnote/case:decisionsummary | case:body/case:headnote/case:references | case:body/case:headnote/case:info">
               <courtcase:head>
                  <xsl:apply-templates select="case:body/case:headnote/case:info"/>
                  <casesum:summaries>
                     <xsl:apply-templates select="case:body/case:headnote/case:factsummary" mode="summaries"/>
                     <xsl:apply-templates select="case:body/case:headnote/case:decisionsummary" mode="summaries"/>
                     <xsl:apply-templates select="case:disposition[parent::case:headnote]" mode="summaries"/>
                     <!--<xsl:apply-templates select="case:body/case:content/case:typeofcase" mode="summaries-->
                  </casesum:summaries>
                  <xsl:apply-templates select="case:body/case:headnote/case:references"/>
               </courtcase:head>
            </xsl:when>
            <xsl:otherwise>
               <courtcase:body>
                  <xsl:apply-templates select="case:content/case:typeofcase"/>
                  <xsl:apply-templates select="case:embeddedcase"/>
                  <xsl:apply-templates select="case:content/case:judgments"/>
                  <!--<xsl:apply-templates select="case:content/case:judgments/case:judgment/case:courtinfo/case:judges[ancestor::case:content]"/>-->
                  <!--<xsl:apply-templates select="case:content/case:judgments/case:constituents"/>-->
                  <!--<xsl:apply-templates select="case:content/case:judgments/case:disposition"/>-->
                  <!--<xsl:apply-templates select="case:content/case:judgments/case:appendix"/>-->
                  <xsl:apply-templates select="case:courtinfo"/>
                  <xsl:apply-templates select="case:content/case:author"/>
                  <xsl:apply-templates select="case:content/case:appendix[not(parent::case:judgments)]"/>
                  <xsl:apply-templates select="case:content/page"/>
                  <xsl:choose>
                     <xsl:when test="heading">
                        <xsl:apply-templates select="@* | node() except heading"/>
                     </xsl:when>
                  </xsl:choose>
                  <!--			<xsl:apply-templates select="case:content/case:author"/>-->
                  <!--<xsl:apply-templates select="case:content/case:judgments"/>
			<xsl:apply-templates select="case:content/page"/>
			<xsl:apply-templates select="case:content/case:typeofcase"/>
			<xsl:apply-templates select="case:content/case:appendix[not(parent::case:judgments)]"/>
			
			<xsl:apply-templates select="case:content/case:judgments/case:constituents"/>
			<xsl:apply-templates select="case:content/case:author"/>
			<xsl:apply-templates select="@* | node() except case:info[parent::case:headnote]"/>-->
               </courtcase:body>
            </xsl:otherwise>
         </xsl:choose>
      </courtcase:caseexcerpt>
   </xsl:template>
   <!--<xsl:template match="case:embeddedcase/@id">
		<!-\-  Original Target XPath:  @xml:id   -\->
		<xsl:attribute name="xml:id">
			<xsl:apply-templates select="@*"/>
		</xsl:attribute>
	</xsl:template>-->   <!-- NOTE: this condition should be in the 'blockquote' or 'case:decionsummary' template (output element would already be created) 
	"Note: If case:embeddedcase occurs as a child element of blockquote then conversion need to omit tag (blockquote) and retain content."
	-->   <!--	<xsl:template match="blockquote">
		<!-\-  Original Target XPath:  xml:id   -\->
		<xml:id>
			<xsl:apply-templates select="@* | node()"/>
		</xml:id>

	</xsl:template>-->   <!-- Already Done -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.references-LxAdv_ref.relatedrefs.dita"/> -->   <xsl:variable name="references">
      <ext:references>
         <ext:reference key="Articles cited:" value="consideredcases"/>
         <ext:reference key="Authorities Cited:" value="consideredcases"/>
         <ext:reference key="Authorities cited:" value="consideredcases"/>
         <ext:reference key="Authorities Considered:" value="consideredcases"/>
         <ext:reference key="Authors and Works cited:" value="consideredcases"/>
         <ext:reference key="AUTHORS AND WORKS JUDICIALLY NOTICED:" value="consideredcases"/>
         <ext:reference key="AUTHORS AND WORKS NOTICED:" value="consideredcases"/>
         <ext:reference key="Authors and Works Noticed:" value="consideredcases"/>
         <ext:reference key="Authors Cited" value="consideredcases"/>
         <ext:reference key="Authors cited" value="consideredcases"/>
         <ext:reference key="Autorit cite :" value="consideredcases"/>
         <ext:reference key="Autorits :" value="consideredcases"/>
         <ext:reference key="Autorits cites :" value="consideredcases"/>
         <ext:reference key="CASE CITED:" value="consideredcases"/>
         <ext:reference key="Cases Cited" value="consideredcases"/>
         <ext:reference key="CASES CITED:" value="consideredcases"/>
         <ext:reference key="Cases Cited:" value="consideredcases"/>
         <ext:reference key="Cases cited:" value="consideredcases"/>
         <ext:reference key="Cases Considered:" value="consideredcases"/>
         <ext:reference key="CASES JUDICIALLY CONSIDERED" value="consideredcases"/>
         <ext:reference key="Cases Judicially Considered" value="consideredcases"/>
         <ext:reference key="CASES JUDICIALLY NOTICED:" value="consideredcases"/>
         <ext:reference key="CASES NOTICED:" value="consideredcases"/>
         <ext:reference key="Cases Noticed:" value="consideredcases"/>
         <ext:reference key="Dcision cite :" value="consideredcases"/>
         <ext:reference key="Dcisions cites :" value="consideredcases"/>
         <ext:reference key="DOCTRINE" value="consideredcases"/>
         <ext:reference key="Doctrine" value="consideredcases"/>
         <ext:reference key="Doctrine cite" value="consideredcases"/>
         <ext:reference key="JURISPRUDENCE" value="consideredcases"/>
         <ext:reference key="Jurisprudence" value="consideredcases"/>
         <ext:reference key="Jurisprudence cite" value="consideredcases"/>
         <ext:reference key="Jurisprudence cite :" value="consideredcases"/>
         <ext:reference key="Jurisprudence consulte :" value="consideredcases"/>
         <ext:reference key="Lgislation cite :" value="legislation"/>
         <ext:reference key="Lois et rglements" value="legislation"/>
         <ext:reference key="Lois et rglements cits" value="legislation"/>
         <ext:reference key="MISCELLANEOUS WORKS CITED:" value="consideredcases"/>
         <ext:reference key="Statutes and Regulations Cited" value="legislation"/>
         <ext:reference key="STATUTES AND REGULATIONS CITED:" value="legislation"/>
         <ext:reference key="Statutes and Regulations cited:" value="legislation"/>
         <ext:reference key="Statutes and Regulations Judicially Considered"
                        value="legislation"/>
         <ext:reference key="Statutes Cited:" value="legislation"/>
         <ext:reference key="Statutes cited:" value="legislation"/>
         <ext:reference key="STATUTES JUDICIALLY NOTICED:" value="legislation"/>
         <ext:reference key="STATUTES NOTICED:" value="legislation"/>
         <ext:reference key="Statutes Noticed:" value="legislation"/>
         <ext:reference key="Statutes, Regulations and Rule Cited:" value="legislation"/>
         <ext:reference key="Statutes, Regulations and Rules cited" value="legislation"/>
         <ext:reference key="STATUTES, REGULATIONS AND RULES CITED:" value="legislation"/>
         <ext:reference key="Statutes, Regulations and Rules Cited:" value="legislation"/>
         <ext:reference key="Authorities Cited" value="consideredcases"/>
         <ext:reference key="Authors Cited" value="consideredcases"/>
         <ext:reference key="Cases and texts cited" value="consideredcases"/>
         <ext:reference key="CASES CITED" value="consideredcases"/>
         <ext:reference key="Cases Cited" value="consideredcases"/>
         <ext:reference key="Cases cited" value="consideredcases"/>
         <ext:reference key="Doctrine cite" value="consideredcases"/>
         <ext:reference key="Jurisprudence" value="consideredcases"/>
         <ext:reference key="Lgislation cite" value="legislation"/>
         <ext:reference key="Lois et rglements cits" value="legislation"/>
         <ext:reference key="MISCELLANEOUS WORKS CITED" value="consideredcases"/>
         <ext:reference key="Statutes and Regulations Cited" value="legislation"/>
         <ext:reference key="Statutes cited" value="legislation"/>
         <ext:reference key="STATUTES, REGULATIONS AND RULES CITED" value="legislation"/>
         <ext:reference key="Statutes, Regulations and Rules Cited" value="legislation"/>
         <ext:reference key="Statutes, Regulations and Rules cited" value="legislation"/>
         <ext:reference key="Lgislation cite:" value="legislation"/>
         <ext:reference key="JURISPRUDENCE CITE :" value="consideredcases"/>
         <ext:reference key="Affaire cite:" value="consideredcases"/>
         <ext:reference key="Affaires cites:" value="consideredcases"/>
         <ext:reference key="Affaires cites:" value="consideredcases"/>
         <ext:reference key="Authorities &amp; Texts:" value="consideredcases"/>
         <ext:reference key="Authorities" value="consideredcases"/>
         <ext:reference key="Autorits cites *" value="consideredcases"/>
         <ext:reference key="Autorits cites par l'appelante :" value="consideredcases"/>
         <ext:reference key="Autorits cites par l'intim :" value="consideredcases"/>
         <ext:reference key="Autorits cites" value="consideredcases"/>
         <ext:reference key="Case Authorities and Texts:" value="consideredcases"/>
         <ext:reference key="Cases considered:" value="consideredcases"/>
         <ext:reference key="Cases referred to:" value="consideredcases"/>
         <ext:reference key="Dictionnaire cit :" value="consideredcases"/>
         <ext:reference key="Jurisprudence :" value="consideredcases"/>
         <ext:reference key="Jurisprudence :" value="consideredcases"/>
         <ext:reference key="JURISPRUDENCE DPOSE PAR L'INTIME" value="consideredcases"/>
         <ext:reference key="Jurisprudence soumise" value="consideredcases"/>
         <ext:reference key="Jurisprudence:" value="consideredcases"/>
         <ext:reference key="Lgislation cite:" value="legislation"/>
         <ext:reference key="Liste de jurisprudence" value="legislation"/>
         <ext:reference key="Liste des jugements  l'appui:" value="consideredcases"/>
         <ext:reference key="LISTE DES JUGEMENTS  L'APPUI" value="consideredcases"/>
         <ext:reference key="Loi cite:" value="legislation"/>
         <ext:reference key="Lois cites:" value="legislation"/>
         <ext:reference key="Lois et rglements cits :" value="legislation"/>
         <ext:reference key="Par l'intim :" value="consideredcases"/>
         <ext:reference key="Statutes considered:" value="legislation"/>
         <ext:reference key="Statutes Referred to:" value="legislation"/>
         <ext:reference key="Statutes referred to:" value="legislation"/>
         <ext:reference key="Tribunal decisions considered:" value="consideredcases"/>
         <ext:reference key="STATUTE AND REGULATION CITED" value="legislation"/>
         <ext:reference key="STATUTES AND REGULATION CITED" value="legislation"/>
         <ext:reference key="STATUTES AND REGULATION CITED:" value="legislation"/>
         <ext:reference key="REGULATION CITED" value="legislation"/>
         <ext:reference key="STATUTE CITED" value="legislation"/>
         <ext:reference key="Rules and Regulations considered" value="legislation"/>
         <ext:reference key="Lois, rglements et rgles cits:" value="legislation"/>
         <ext:reference key="STATUTES, RULES AND REGULATIONS CITED" value="legislation"/>
         <ext:reference key="Rules cited" value="legislation"/>
         <ext:reference key="Regulations Cited" value="legislation"/>
         <ext:reference key="Lois et rglement cits" value="legislation"/>
         <ext:reference key="LOI ET RGLEMENT CITS" value="legislation"/>
         <ext:reference key="RGLEMENT CIT" value="legislation"/>
         <ext:reference key="STATUTES, RULES AND REGULATIONS CITED" value="legislation"/>
         <ext:reference key="Autorits consultes:" value="consideredcases"/>
         <ext:reference key="AUTORITS CONSULTES" value="consideredcases"/>
         <ext:reference key="Autorits cites par la requrante:" value="consideredcases"/>
         <ext:reference key="Autres autorits consultes" value="consideredcases"/>
         <ext:reference key="Case Authorities Referred to" value="consideredcases"/>
         <ext:reference key="Liste des autorits cites" value="consideredcases"/>
         <ext:reference key="JURISPRUDENCE CITE" value="consideredcases"/>
         <ext:reference key="Doctrine et jurisprudence :" value="consideredcases"/>
         <ext:reference key="Cases referred to" value="consideredcases"/>
         <ext:reference key="LEGISLATION:" value="legislation"/>
      </ext:references>
   </xsl:variable>
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:references</xd:i> becomes
          <xd:b>courtcase:head/ref:relatedrefs</xd:b>.</xd:p>
         <xd:p>With the exception of <xd:i>heading</xd:i>, all children of
          <xd:i>case:references</xd:i> should be mapped to children of
          <xd:b>ref:relatedrefs/bodytext</xd:b>.</xd:p>
         <xd:p>
            <xd:b>
               <xd:b>Canada streams only:</xd:b>
            </xd:b>
         </xd:p>
         <xd:p>Please refer the below table for the following scenario: If initial contents of
          <xd:i>case:references</xd:i> equals first column of table then (either within
        heading/title, text/emph typestyle="bf", etc), add an attribute
          <xd:b>@referencetype</xd:b> and set the value
          <xd:b>@referencetype=</xd:b> second column of table. See CA Example 2 &amp;
        3.</xd:p>
         <xd:ol>
            <xd:li>Unique Values for search</xd:li>
            <xd:li>Replace attribute Value</xd:li>
            <xd:li>Articles cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authorities Cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authorities cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authorities Considered:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authors and Works cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>AUTHORS AND WORKS JUDICIALLY NOTICED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>AUTHORS AND WORKS NOTICED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authors and Works Noticed:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authors Cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authors cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorit cite :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASE CITED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASES CITED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases cited:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Considered:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASES JUDICIALLY CONSIDERED</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Judicially Considered</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASES JUDICIALLY NOTICED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASES NOTICED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Noticed:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Dcision cite :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Dcisions cites :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>DOCTRINE</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Doctrine</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Doctrine cite</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>JURISPRUDENCE</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence cite</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence cite :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence consulte :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Lgislation cite :</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois et rglements</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois et rglements cits</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>MISCELLANEOUS WORKS CITED:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Statutes and Regulations Cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES AND REGULATIONS CITED:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes and Regulations cited:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes and Regulations Judicially Considered</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes Cited:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes cited:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES JUDICIALLY NOTICED:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES NOTICED:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes Noticed:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes, Regulations and Rule Cited:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes, Regulations and Rules cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES, REGULATIONS AND RULES CITED:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes, Regulations and Rules Cited:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Authorities Cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authors Cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases and texts cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>CASES CITED</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases Cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases cited</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Doctrine cite</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Lgislation cite</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois et rglements cits</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>MISCELLANEOUS WORKS CITED</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Statutes and Regulations Cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES, REGULATIONS AND RULES CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes, Regulations and Rules Cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes, Regulations and Rules cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lgislation cite:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>JURISPRUDENCE CITE :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Affaire cite:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Affaires cites:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Affaires cites:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authorities &amp; Texts:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Authorities</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites *</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites par l'appelante :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites par l'intim :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Case Authorities and Texts:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases considered:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases referred to:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Dictionnaire cit :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>JURISPRUDENCE DPOSE PAR L'INTIME</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence soumise</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Jurisprudence:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Lgislation cite:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Liste de jurisprudence</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Liste des jugements  l'appui:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>LISTE DES JUGEMENTS  L'APPUI</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Loi cite:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois cites:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois et rglements cits :</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Par l'intim :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Statutes considered:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes Referred to:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Statutes referred to:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Tribunal decisions considered:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>STATUTE AND REGULATION CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES AND REGULATION CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES AND REGULATION CITED:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>REGULATION CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTE CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Rules and Regulations considered</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois, rglements et rgles cits:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES, RULES AND REGULATIONS CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Rules cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Regulations Cited</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Lois et rglement cits</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>LOI ET RGLEMENT CITS</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>RGLEMENT CIT</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>STATUTES, RULES AND REGULATIONS CITED</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Autorits consultes:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>AUTORITS CONSULTES</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autorits cites par la requrante:</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Autres autorits consultes</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Case Authorities Referred to</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Liste des autorits cites</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>JURISPRUDENCE CITE</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Doctrine et jurisprudence :</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>Cases referred to</xd:li>
            <xd:li>consideredcases</xd:li>
            <xd:li>LEGISLATION:</xd:li>
            <xd:li>legislation</xd:li>
            <xd:li>Doctrine et jurisprudence</xd:li>
            <xd:li>consideredcases</xd:li>
         </xd:ol>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>Remove the colon (:) or space colon ( :) which comes under
        <xd:b>ref:relatedrefs</xd:b> under
        <xd:b>heading/title</xd:b>.
        <xd:ul>
                  <xd:li>
                     <xd:i>Avocats:</xd:i> to <xd:b>Avocats</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Avocats :</xd:i> to <xd:b>Avocats</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Cases cited:</xd:i> to <xd:b>Cases cited</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Cases Cited:</xd:i> to <xd:b>Cases Cited</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Jurisprudence cite :</xd:i> to <xd:b>Jurisprudence
            cite</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Statutes, Regulations and Rules Cited:</xd:i> to
            <xd:b>Statutes, Regulations and Rules Cited</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Lgislation cite :</xd:i> to <xd:b>Lgislation
            cite</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Authors and Texts Cited:</xd:i> to <xd:b>Authors and Texts
            Cited</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Texts Cited:</xd:i> to <xd:b>Texts Cited</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Causes cites et consultes :</xd:i> to <xd:b>Causes cites
            et consultes</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Jurisprudence et doctrine cites et consultes :</xd:i> to
            <xd:b>Jurisprudence et doctrine cites et
              consultes</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Doctrine et jurisprudence cites :</xd:i> to <xd:b>Doctrine
            et jurisprudence cites</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Doctrine cite :</xd:i> to <xd:b>Doctrine
            cite</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>Counsel:</xd:i> to <xd:b>Counsel</xd:b>
                  </xd:li>
               </xd:ul>
            </xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references&gt;
  &lt;p&gt;
    &lt;text&gt;
      &lt;ci:cite searchtype="LEG-REF"&gt;
        &lt;ci:content&gt;(CTH) 
          &lt;citefragment searchtype="LEG-NAME-REF"&gt;Criminal Code (Q)&lt;/citefragment&gt;
          &lt;citefragment searchtype="CI-LEG-LAWNUM"&gt;minal Code (Q), s 31(1)(d)&lt;/citefragment&gt;
        &lt;/ci:content&gt;
      &lt;/ci:cite&gt;
    &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:relatedrefs&gt;
  &lt;bodytext&gt;
    &lt;p&gt;
      &lt;text&gt;
        &lt;lnci:cite type="legislation"&gt;
          &lt;lnci:content&gt;(CTH) Criminal Code (Q) minal Code (Q), s 31(1)(d)&lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;
      &lt;/text&gt;
    &lt;/p&gt;
  &lt;/bodytext&gt;   
&lt;/ref:relatedrefs&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references&gt;
  &lt;heading&gt;&lt;title&gt;Cases mentioned in judgment&lt;/title&gt;&lt;/heading&gt;
  &lt;p&gt;
    &lt;text&gt;
      &lt;ci:cite searchtype="CASE-REF"&gt;
        &lt;ci:case&gt;
          &lt;ci:caseref ID="x20110NZCCLR_1-1" spanref="x20110NZCCLR_1-1-1"&gt;
            &lt;ci:reporter value="nzclc" country="nz"/&gt;
            &lt;ci:volume num="3"&gt;&lt;/ci:volume&gt;
            &lt;ci:edition&gt;
              &lt;ci:date year="1986"/&gt;
            &lt;/ci:edition&gt;
            &lt;ci:page num="100,054"/&gt;
          &lt;/ci:caseref&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;
          &lt;citefragment searchtype="CASE-NAME-REF"&gt;
            &lt;emph typestyle="it"&gt;Cotterall v Fidelity Life Assurance Co Ltd&lt;/emph&gt;
          &lt;/citefragment&gt; 
          &lt;citefragment searchtype="CASE-CITE-REF"&gt;
            &lt;ci:span spanid="x20110NZCCLR_1-1-1"&gt;(1986) 3 NZCLC 100,054 (HC)&lt;/ci:span&gt;
          &lt;/citefragment&gt;.
        &lt;/ci:content&gt;
      &lt;/ci:cite&gt;
    &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;ref:relatedrefs&gt;
  &lt;heading&gt;&lt;title&gt;Cases mentioned in judgment&lt;/title&gt;&lt;/heading&gt;
  &lt;bodytext&gt;
    &lt;p&gt;
      &lt;text&gt;
        &lt;lnci:cite&gt;
          &lt;lnci:case&gt;
            &lt;lnci:caseref ID="x20110NZCCLR_1-1"&gt;
              &lt;lnci:reporter value="nzclc" country="nz"/&gt;
              &lt;lnci:volume num="3"&gt;&lt;/ci:volume&gt;
              &lt;lnci:edition&gt;
                &lt;lnci:date year="1986"/&gt;
              &lt;/lnci:edition&gt;
              &lt;lnci:page num="100,054"/&gt;
            &lt;/lnci:caseref&gt;
          &lt;/lnci:case&gt;
          &lt;lnci:content&gt;
            &lt;emph typestyle="it"&gt;Cotterall v Fidelity Life Assurance Co Ltd&lt;/emph&gt; (1986) 3 NZCLC 100,054 (HC)
          &lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;
      &lt;/text&gt;
    &lt;/p&gt;
  &lt;/bodytext&gt;   
&lt;/ref:relatedrefs&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: CA content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references&gt;
    &lt;heading&gt;
        &lt;title&gt;Cases Cited:&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
        &lt;text&gt;Soo Mill and Lumber Co. Ltd. v. City of Sault Ste-Marie &lt;ci:cite searchtype="SUMM-CASE-REF"&gt;
                &lt;ci:case&gt;
                    &lt;ci:caseref ID="cref00003130" spanref="cspan00003130"&gt;
                        &lt;ci:reporter value="NR"/&gt;
                        &lt;ci:volume num="2"/&gt;
                        &lt;ci:page num="492"/&gt;
                    &lt;/ci:caseref&gt;
                &lt;/ci:case&gt;
                &lt;ci:content&gt;&lt;ci:span spanid="cspan00003130"&gt;2 N.R. 492&lt;/ci:span&gt;&lt;/ci:content&gt;
            &lt;/ci:cite&gt;; City of Montreal v. Morgan &lt;ci:cite searchtype="SUMM-CASE-REF"&gt;
                &lt;ci:case&gt;
                    &lt;ci:caseinfo&gt;
                        &lt;ci:decisiondate year="1920"/&gt;
                    &lt;/ci:caseinfo&gt;
                    &lt;ci:caseref ID="cref00003131" spanref="cspan00003131"&gt;
                        &lt;ci:reporter value="DLR"/&gt;
                        &lt;ci:volume num="54"/&gt;
                        &lt;ci:page num="165"/&gt;
                    &lt;/ci:caseref&gt;
                &lt;/ci:case&gt;
                &lt;ci:content&gt;&lt;ci:span spanid="cspan00003131"&gt;(1920), 54 D.L.R. 165&lt;/ci:span&gt;&lt;/ci:content&gt;
            &lt;/ci:cite&gt;.&lt;/text&gt;
    &lt;/p&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:head&gt;
    ...
    &lt;ref:relatedrefs referencetype="consideredcases"&gt;
        &lt;heading&gt;
            &lt;title&gt;Cases Cited&lt;/title&gt;
        &lt;/heading&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;Soo Mill and Lumber Co. Ltd. v. City of Sault Ste-Marie &lt;lnci:cite&gt;
                        &lt;lnci:case&gt;
                            &lt;lnci:caseref ID="cref00003130"&gt;
                                &lt;lnci:reporter value="NR"/&gt;
                                &lt;lnci:volume num="2"/&gt;
                                &lt;lnci:page num="492"/&gt;
                            &lt;/lnci:caseref&gt;
                        &lt;/lnci:case&gt;
                        &lt;lnci:content&gt;2 N.R. 492&lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt;; City of Montreal v. Morgan &lt;lnci:cite&gt;
                        &lt;lnci:case&gt;
                            &lt;lnci:caseinfo&gt;
                                &lt;lnci:decisiondate year="1920"/&gt;
                            &lt;/lnci:caseinfo&gt;
                            &lt;lnci:caseref ID="cref00003131"&gt;
                                &lt;lnci:reporter value="DLR"/&gt;
                                &lt;lnci:volume num="54"/&gt;
                                &lt;lnci:page num="165"/&gt;
                            &lt;/lnci:caseref&gt;
                        &lt;/lnci:case&gt;
                        &lt;lnci:content&gt;(1920), 54 D.L.R. 165&lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt;.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/ref:relatedrefs&gt;
    ...
&lt;/courtcase:head&gt;
           </xd:pre>
         <xd:p>
            <xd:b>CA Example 2 - <xd:b>@referencetype="consideredcases"</xd:b>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references&gt;
    &lt;heading&gt;
        &lt;title&gt;Cases Judicially Considered&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
		...
    &lt;/p&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:head&gt;
    ...
    &lt;ref:relatedrefs referencetype="consideredcases"&gt;
        &lt;heading&gt;
            &lt;title&gt;Cases Judicially Considered&lt;/title&gt;
        &lt;/heading&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
				...
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/ref:relatedrefs&gt;
    ...
&lt;/courtcase:head&gt;
           </xd:pre>
         <xd:p>
            <xd:b>CA Example 3 - <xd:b>@referencetype="legislation"</xd:b>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references&gt;
	&lt;p&gt;
		&lt;text&gt;
			&lt;emph typestyle="bf"&gt;Statutes and Regulations Judicially Considered&lt;/emph&gt;
		&lt;/text&gt;
	&lt;/p&gt;
    &lt;p&gt;
		...
    &lt;/p&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:head&gt;
    ...
    &lt;ref:relatedrefs referencetype="legislation"&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
				&lt;text&gt;
					&lt;emph typestyle="bf"&gt;Statutes and Regulations Judicially Considered&lt;/emph&gt;
				&lt;/text&gt;
            &lt;/p&gt;
				...
        &lt;/bodytext&gt;
    &lt;/ref:relatedrefs&gt;
    ...
&lt;/courtcase:head&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:references referencetype="cases"&gt;
    &lt;h&gt;
        &lt;emph typestyle="bf"&gt;Cases referred to&lt;/emph&gt;
    &lt;/h&gt;
    &lt;pgrp&gt;
        &lt;p&gt;
            &lt;text&gt;&lt;emph typestyle="it"&gt;Guaranty Trust Co of New York v Hannay &amp;amp; Co&lt;/emph&gt;
                &lt;ci:cite searchtype="CASE-REF"&gt;
                    &lt;ci:case&gt;
                        &lt;ci:caseref&gt;
                            &lt;ci:reporter value="KB"/&gt;
                            &lt;ci:volume num="2"/&gt;
                            &lt;ci:edition&gt;
                                &lt;ci:date year="1915"/&gt;
                            &lt;/ci:edition&gt;
                            &lt;ci:page num="536"/&gt;
                        &lt;/ci:caseref&gt;
                    &lt;/ci:case&gt;
                    &lt;ci:content&gt;[1915] 2 KB 536&lt;/ci:content&gt;
                &lt;/ci:cite&gt;; 30 Digest 147, &lt;emph typestyle="it"&gt;219&lt;/emph&gt;.
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/pgrp&gt;
&lt;/case:references&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>

&lt;ref:relatedrefs referencetype="cases"&gt;
    &lt;bodytext&gt;
        &lt;h&gt;
            &lt;emph typestyle="bf"&gt;Cases referred to&lt;/emph&gt;
        &lt;/h&gt;
        &lt;pgrp&gt;
            &lt;p&gt;
                &lt;text&gt;&lt;emph typestyle="it"&gt;Guaranty Trust Co of New York v Hannay &amp;#x0026; Co&lt;/emph&gt;
                    &lt;lnci:cite&gt;
                        &lt;lnci:case&gt;
                            &lt;lnci:caseref&gt;
                                &lt;lnci:reporter value="KB"/&gt;
                                &lt;lnci:volume num="2"/&gt;
                                &lt;lnci:edition&gt;
                                    &lt;lnci:date year="1915"/&gt;
                                &lt;/lnci:edition&gt;
                                &lt;lnci:page num="536"/&gt;
                            &lt;/lnci:caseref&gt;
                        &lt;/lnci:case&gt;
                        &lt;lnci:content&gt;[1915] 2 KB 536&lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt;; 30 Digest 147, &lt;emph typestyle="it"&gt;219&lt;/emph&gt;.
                &lt;/text&gt;
            &lt;/p&gt;
        &lt;/pgrp&gt;
    &lt;/bodytext&gt;
&lt;/ref:relatedrefs&gt;
           </xd:pre>
         <!--Changes2016-04-22: Added new term "Doctrine et jurisprudence"
          to the table to generate "consideredcases". Applicable on CA01.2015-03-13: Added STATUTES AND REGULATION CITED: to the @referencetype substitution table. Webteam #2927872014-09-04: Updated instruction for removal of colon from ref:relatedrefs based on list included. Applicable on CA01.2014-07-24: Added  "LEGISLATION:" to table with @referencetype legislation. R4.5 DB Item #1278.2014-07-18: Updated CA target snippet to capture
            @referencetype="consideredcases" attribute in
            ref:relatedrefs element and change all references of
            "Jurisprudence" from "legislation" to "consideredcases", and also
          added new terms.2014-06-23: Attribute @referencetype all lower case for
          "legislation" and "consideredcases". R4.5 DB Item #1278.2014-06-04: Updates Canada-only instruction and examples for where
            @referencetype value generated based on table value. R4.5 Item
          #1587.2014-05-26: Updated note and added one more instruction to remove
          space colon ( :) from target, this immediately applies to Canada only.2014-04-22 Added Note and Updated source example to remove
          colon (:) for Canada-only.2014-04-15 Updated source and target example for
          Canada-only.2014-03-31 Add Canada-only instruction and two Canada examples
          for where @referencetype becomes "consideredcases" or
            "legislation".R4.5 Item #1109.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.references-LxAdv_ref.relatedrefs.dita  -->
   <!--<xsl:param name="references" select="document('../../modules/nonamespace/references.xml')"/>-->
   <!--	<xsl:template match="case:references">
	 
	  <xsl:variable name="case-data" select="normalize-space(.)"/>	
	  <xsl:choose> 
	    <!-\- Awantika: Please add stream ID as per the requirement -\->
	    <xsl:when test="$streamID=('CA01','CA02','CA04','CA05')">
	      <xsl:choose>
	        <xsl:when test="count($references//reference[starts-with($case-data,./@key)[1]])>0">
	          <ref:relatedrefs>		
	            <xsl:attribute name="referencetype">
	              <xsl:value-of select="($references//reference[starts-with($case-data,./@key)[1]]/@value)[1]"/>
	            </xsl:attribute>
	            <xsl:choose>
	              <xsl:when test="descendant::heading">
	                <xsl:apply-templates select="heading"/>
	                <bodytext>
	                  <xsl:apply-templates select="@* | node() except heading"/>
	                </bodytext>
	              </xsl:when>
	              <xsl:otherwise>
	                <xsl:apply-templates select="node()"/>
	              </xsl:otherwise>
	            </xsl:choose>	          
	          </ref:relatedrefs>
	        </xsl:when>
	        <xsl:otherwise>
	          <ref:relatedrefs>		
	            <xsl:choose>
	              <xsl:when test="descendant::heading">
	                <xsl:apply-templates select="heading"/>
	                <bodytext>
	                  <xsl:apply-templates select="@* | node() except heading"/>
	                </bodytext>
	              </xsl:when>
	              <xsl:otherwise>
	                <xsl:apply-templates select="@* | node()"/>
	              </xsl:otherwise>
	            </xsl:choose>
	          </ref:relatedrefs>
	        </xsl:otherwise>
	      </xsl:choose>
	    </xsl:when>
	    <xsl:otherwise>
	      <ref:relatedrefs>		
	        <xsl:choose>
	          <xsl:when test="descendant::heading">
	            <xsl:apply-templates select="heading"/>
	            <bodytext>
	              <xsl:apply-templates select="@* | node() except heading"/>
	            </bodytext>
	          </xsl:when>
	          <xsl:otherwise>
	            <xsl:apply-templates select="@* | node()"/>
	          </xsl:otherwise>
	        </xsl:choose>
	      </ref:relatedrefs>
	    </xsl:otherwise>
	  </xsl:choose>
	
	</xsl:template>-->
   <!-- Vikas Rohilla : bodytext is the Mandatory Element so it is moved out to the if condition -->
   <xsl:template match="case:references">
      <xsl:variable name="case-data" select="normalize-space(.)"/>
      <xsl:choose><!--SP LBU needs this via conversation with product lawyers-->
         <xsl:when test="$streamID=('CA19')">
            <xsl:choose>
               <xsl:when test="count($references//reference[starts-with($case-data,./@key)[1]])&gt;0">
                  <courtfiling:citedauthorities><!-- Awantika: Updated if heading is coming -->
                     <xsl:apply-templates select="heading"/>
                     <bodytext><!--SP: For CA19, there is currently no need to process the referencetype attribute on case:references-->
                        <xsl:apply-templates select=" node() except (heading | @referencetype)"/>
                     </bodytext>
                  </courtfiling:citedauthorities>
               </xsl:when>
               <xsl:otherwise>
                  <courtfiling:citedauthorities>
                     <xsl:apply-templates select="heading"/>
                     <bodytext><!--SP: For CA19, there is currently no need to process the referencetype attribute on case:references-->
                        <xsl:apply-templates select=" node() except (heading | @referencetype)"/>
                     </bodytext>
                  </courtfiling:citedauthorities>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <!-- Awantika: Please add stream ID as per the requirement -->
         <xsl:when test="$streamID=('CA01','CA02CC','CA04','CA05')">
            <xsl:choose>
               <xsl:when test="count($references//ext:reference[starts-with($case-data,./@key)[1]])&gt;0">
                  <ref:relatedrefs>
                     <xsl:attribute name="referencetype">
                        <xsl:value-of select="($references//ext:reference[starts-with($case-data,./@key)[1]]/@value)[1]"/>
                     </xsl:attribute>
                     <!-- Awantika: Updated if heading is coming -->
                     <xsl:apply-templates select="heading"/>
                     <bodytext>
                        <xsl:apply-templates select="@* | node() except heading"/>
                     </bodytext>
                  </ref:relatedrefs>
               </xsl:when>
               <xsl:otherwise>
                  <ref:relatedrefs>
                     <xsl:apply-templates select="heading"/>
                     <bodytext>
                        <xsl:apply-templates select="@* | node() except heading"/>
                     </bodytext>
                  </ref:relatedrefs>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise>
            <ref:relatedrefs>
               <xsl:apply-templates select="@*"/>
               <xsl:apply-templates select="heading"/>
               <bodytext>
                  <xsl:apply-templates select="node() except heading"/>
               </bodytext>
            </ref:relatedrefs>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="case:references/heading/title/text()">
      <xsl:value-of select="replace(.,': ','')"/>
   </xsl:template>
   <!-- JD: 2017-06-15: adding for UK01; although it's not mentioned in the CI it is shown in examples.
	Hard to see any downside to mapping case:references/@referencytype to ref:relatedrefs/@referencetype
	-->
   <xsl:template match="case:references/@referencetype">
      <xsl:attribute name="referencetype" select="."/>
   </xsl:template>
   <!--<xsl:template match="">

		<!-\-  Original Target XPath:  Avocats   -\->
		

	</xsl:template>

	<xsl:template match="Avocats :">

		<!-\-  Original Target XPath:  Avocats   -\->
		<Avocats>
			<xsl:apply-templates select="@* | node()"/>
		</Avocats>

	</xsl:template>

	<xsl:template match="Cases cited:">

		<!-\-  Original Target XPath:  Casescited   -\->
		<Casescited>
			<xsl:apply-templates select="@* | node()"/>
		</Casescited>

	</xsl:template>

	<xsl:template match="Cases Cited:">

		<!-\-  Original Target XPath:  CasesCited   -\->
		<CasesCited>
			<xsl:apply-templates select="@* | node()"/>
		</CasesCited>

	</xsl:template>

	<xsl:template match="Jurisprudence cite :">

		<!-\-  Original Target XPath:  Jurisprudencecite   -\->
		<Jurisprudencecite>
			<xsl:apply-templates select="@* | node()"/>
		</Jurisprudencecite>

	</xsl:template>

	<xsl:template match="Statutes, Regulations and Rules Cited:">

		<!-\-  Original Target XPath:  Statutes,RegulationsandRulesCited   -\->
		<!-\-  Could not determine target element or attribute name:  <Statutes,RegulationsandRulesCited>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Statutes,RegulationsandRulesCited>  -\->

	</xsl:template>

	<xsl:template match="Lgislation cite :">

		<!-\-  Original Target XPath:  Lgislationcite   -\->
		<!-\-  Could not determine target element or attribute name:  <Lgislationcite>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Lgislationcite>  -\->

	</xsl:template>

	<xsl:template match="Authors and Texts Cited:">

		<!-\-  Original Target XPath:  AuthorsandTextsCited   -\->
		<AuthorsandTextsCited>
			<xsl:apply-templates select="@* | node()"/>
		</AuthorsandTextsCited>

	</xsl:template>

	<xsl:template match="Texts Cited:">

		<!-\-  Original Target XPath:  TextsCited   -\->
		<TextsCited>
			<xsl:apply-templates select="@* | node()"/>
		</TextsCited>

	</xsl:template>

	<xsl:template match="Causes cites et consultes :">

		<!-\-  Original Target XPath:  Causescitesetconsultes   -\->
		<!-\-  Could not determine target element or attribute name:  <Causescitesetconsultes>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Causescitesetconsultes>  -\->

	</xsl:template>

	<xsl:template match="Jurisprudence et doctrine cites et consultes :">

		<!-\-  Original Target XPath:  Jurisprudenceetdoctrinecitesetconsultes   -\->
		<!-\-  Could not determine target element or attribute name:  <Jurisprudenceetdoctrinecitesetconsultes>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Jurisprudenceetdoctrinecitesetconsultes>  -\->

	</xsl:template>

	<xsl:template match="Doctrine et jurisprudence cites :">

		<!-\-  Original Target XPath:  Doctrineetjurisprudencecites   -\->
		<!-\-  Could not determine target element or attribute name:  <Doctrineetjurisprudencecites>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Doctrineetjurisprudencecites>  -\->

	</xsl:template>

	<xsl:template match="Doctrine cite :">

		<!-\-  Original Target XPath:  Doctrinecite   -\->
		<!-\-  Could not determine target element or attribute name:  <Doctrinecite>  -\->			<xsl:apply-templates select="@* | node()"/>
		<!-\-  Could not determine target element or attribute name:  </Doctrinecite>  -\->

	</xsl:template>

	<xsl:template match="Counsel:">

		<!-\-  Original Target XPath:  Counsel   -\->
		<Counsel>
			<xsl:apply-templates select="@* | node()"/>
		</Counsel>

	</xsl:template>-->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.citations-LxAdv_ref.relatedrefs.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li>
               <xd:i>case:citations</xd:i> becomes <xd:b>ref:relatedrefs</xd:b> with
          an attribute 'referencetype' set to <xd:b>@referencetype="case-citations"</xd:b>
          which contains <xd:i>case:citetext</xd:i> becomes
            <xd:b>ref:relatedrefs/bodytext/p/text</xd:b>
               <xd:pre>

&lt;case:citations&gt;
  &lt;heading&gt;
    &lt;title&gt;C&lt;emph typestyle="smcaps"&gt;ASES&lt;/emph&gt; C&lt;emph typestyle="smcaps"&gt;ITED&lt;/emph&gt;&lt;/title&gt;
  &lt;/heading&gt;
  &lt;case:citetext&gt;The following cases are cited in the judgment:&lt;nl/&gt;
    &lt;ci:cite searchtype="CASE-REF"&gt;
      &lt;ci:content&gt;
        &lt;citefragment searchtype="CASE-NAME-REF"&gt;&lt;emph typestyle="it"&gt;Allgood v Blake&lt;/emph&gt;&lt;/citefragment&gt; 
        &lt;citefragment searchtype="CASE-CITE-REF"&gt;(1873) LR 8 Exch 160&lt;/citefragment&gt;.
      &lt;/ci:content&gt;
    &lt;/ci:cite&gt;&lt;nl/&gt;
    &lt;ci:cite searchtype="CASE-REF"&gt;
      &lt;ci:content&gt;
        &lt;citefragment searchtype="CASE-NAME-REF"&gt;&lt;emph typestyle="it"&gt;Amber Holdings (Aust) Pty Ltd v Polona Pty Ltd&lt;/emph&gt;&lt;/citefragment&gt; 
        &lt;citefragment searchtype="CASE-CITE-REF"&gt;[1982] 2 NSWLR 470&lt;/citefragment&gt;.
      &lt;/ci:content&gt;
    &lt;/ci:cite&gt;&lt;nl/&gt;
  &lt;/case:citetext&gt;
&lt;/case:citations&gt;
<xd:b>Becomes:</xd:b>

&lt;ref:relatedrefs referencetype="case-citations"&gt;
  &lt;heading&gt;
    &lt;title&gt;C&lt;emph typestyle="smcaps"&gt;ASES&lt;/emph&gt; C&lt;emph typestyle="smcaps"&gt;ITED&lt;/emph&gt;&lt;/title&gt;
  &lt;/heading&gt;
  &lt;bodytext&gt;
    &lt;p&gt;
      &lt;text&gt;The following cases are cited in the judgment:&lt;proc:nl/&gt;
        &lt;lnci:cite type="case"&gt;
          &lt;lnci:content&gt;
            &lt;emph typestyle="it"&gt;Allgood v Blake&lt;/emph&gt; (1873) LR 8 Exch 160
          &lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;&lt;proc:nl/&gt;
        &lt;lnci:cite type="case"&gt;
          &lt;lnci:content&gt;
            &lt;emph typestyle="it"&gt;Amber Holdings (Aust) Pty Ltd v Polona Pty Ltd&lt;/emph&gt; [1982] 2 NSWLR 470
          &lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;&lt;proc:nl/&gt;
      &lt;/text&gt;
    &lt;/p&gt;
  &lt;/bodytext&gt;
&lt;/ref:relatedrefs&gt;
</xd:pre>
            </xd:li>
         </xd:ul>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.citations-LxAdv_ref.relatedrefs.dita  -->
   <xsl:template match="case:citations">
      <ref:relatedrefs>
         <xsl:attribute name="referencetype">
            <xsl:text>case-citations</xsl:text>
         </xsl:attribute>
         <xsl:apply-templates select="@* | node()"/>
      </ref:relatedrefs>
   </xsl:template>
   <!--  <xsl:template match="case:citations/case:citetext">
    
      <bodytext>
        <p>
          <text>
            <xsl:apply-templates select="@* | node() except heading"/>
          </text>
        </p>
      </bodytext>
    
  </xsl:template>-->
   <xsl:template match="case:citations/case:citetext">
      <xsl:variable name="name" select="local-name()"/>
      <xsl:if test="local-name(preceding-sibling::*[position()=1]) != $name">
         <bodytext>
            <p>
               <text>
                  <xsl:apply-templates/>
               </text>
            </p>
            <!-- Match the next sibling if it has the same name -->
            <xsl:apply-templates select="following-sibling::*[1][local-name()=$name]" mode="next"/>
         </bodytext>
      </xsl:if>
   </xsl:template>

   <xsl:template match="case:citations/case:citetext" mode="next">
      <xsl:variable name="name" select="local-name()"/>
      <p>
         <text>
            <xsl:apply-templates/>
         </text>
      </p>
      <xsl:apply-templates select="following-sibling::*[1][local-name()=$name]" mode="next"/>
   </xsl:template>
   <!-- <xsl:template match="case:citations" mode="summaries">
	  <ref:relatedrefs>		
	    <xsl:attribute name="referencetype">
	      <xsl:text>case-citations</xsl:text>
	    </xsl:attribute>
	    <xsl:if test="child::heading">
	      <xsl:apply-templates select="heading"/>                   
	    </xsl:if>
	    <xsl:if test="node() except heading">
	      <bodytext>
	        <xsl:choose>
	          <xsl:when test="child::case:citetext">
	            <p>
	              <text>
	                <xsl:apply-templates select="@* | node() except heading"/>
	              </text>
	            </p>
	          </xsl:when>
	          <xsl:otherwise>
	            <xsl:apply-templates select="@* | node() except heading"/>
	          </xsl:otherwise>
	        </xsl:choose>
	      </bodytext>
	    </xsl:if>
	  </ref:relatedrefs>
	</xsl:template>-->   <!-- Awantika: Completed -->   <!-- <topicref href="AU01_Rosetta_case.disposition-LxAdv_casesum.disposition.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>The attributes of <xd:i>case:disposition</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>case:disposition/@subdoc</xd:i> becomes
              <xd:b>casesum:disposition/@includeintoc</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:disposition/@toc-caption</xd:i> becomes
              <xd:b>casesum:disposition/@alternatetoccaption</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:i>case:disposition</xd:i> occurs in two contexts. The full mappings from
        Rosetta to NL are as follows:<xd:ul>
               <xd:li>
                  <xd:i>CASEDOC/case:body/case:headnote/case:disposition</xd:i> becomes
              <xd:b>courtcase:head/casesum:summaries/casesum:disposition</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>CASEDOC/case:body/case:content/case:judgments/case:disposition</xd:i>
            becomes
            <xd:b>courtcase:body/courtcase:opinions/casesum:disposition</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>casesum:summaries</xd:b>
        elements. When 2 or more consecutive sibling source elements map to
          <xd:b>casesum:summaries</xd:b>, target data should be merged to a single
          <xd:b>casesum:summaries</xd:b> element unless this would hamper content
        ordering.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>For information on how to process the attribute @ln.user-displayed. Refer
          common_rosetta_ln.user_displayed for handling of
          <xd:b>@ln.user-displayed</xd:b>
            </xd:p>
         </xd:p>
         <xd:pre>
&lt;case:disposition&gt;Appeal dismissed.&lt;/case:disposition&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:disposition&gt;
    &lt;p&gt;
      &lt;text&gt;Appeal dismissed.&lt;/text&gt;
    &lt;/p&gt;
&lt;/casesum:disposition&gt;
       </xd:pre>
         <!--<section
      conref="../../common_caselaw/conref_content/Rosetta_case.disposition-LxAdv_casesum.disposition.dita#Rosetta_case.disposition-LxAdv_casesum.disposition/changes"/>-->
         <!--<section>
      <title>Changes Specific to AU01</title>
      </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.disposition-LxAdv_casesum.disposition.dita  -->
   <!-- Awantika: 2017-10-30-Added <text> after <p>-->
   <xsl:template match="case:disposition[parent::case:headnote]" mode="summaries"><!--  Original Target XPath:  casesum:disposition/@includeintoc   -->
      <xsl:choose>
         <xsl:when test="@ln.user-displayed='false'"/>
         <xsl:otherwise>
            <casesum:disposition>
               <p>
                  <text>
                     <xsl:if test="@subdoc">
                        <xsl:attribute name="includeintoc">
                           <xsl:value-of select="@subdoc"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:if test="@toc-caption">
                        <xsl:attribute name="alternatetoccaption">
                           <xsl:value-of select="@toc-caption"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:apply-templates select="@* | node()"/>
                  </text>
               </p>
            </casesum:disposition>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="case:disposition[parent::case:judgments]"><!--  Original Target XPath:  casesum:disposition/@includeintoc   -->
      <xsl:choose>
         <xsl:when test="@ln.user-displayed='false'"/>
         <xsl:otherwise>
            <casesum:disposition>
               <p>
                  <text>
                     <xsl:if test="@subdoc">
                        <xsl:attribute name="includeintoc">
                           <xsl:value-of select="@subdoc"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:if test="@toc-caption">
                        <xsl:attribute name="alternatetoccaption">
                           <xsl:value-of select="@toc-caption"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:apply-templates select="@* | node()"/>
                  </text>
               </p>
            </casesum:disposition>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--<xsl:include href="../../modules/case/case.citations_case.citetext.xsl"/>-->   <!-- end topichead  Headnote  -->   <!-- <topicref href="../../common_caselaw/Rosetta_case.body-LxAdv_courtcase.body.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:body</xd:i> becomes
      <xd:b>courtcase:body</xd:b>.</xd:p>
         <!--<section>
      <title>Changes</title>
      </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.body-LxAdv_courtcase.body.dita  -->
   <!--<xsl:message>Rosetta_case.body-LxAdv_courtcase.body.xsl requires manual development!</xsl:message> -->
   <!--WSS: Done - case:bdoy -->
   <xsl:template match="case:body"><!--  Original Target XPath:  courtcase:body   -->
      <courtcase:body><!-- Vikas Rohilla : added for the streamID = CA01			-->
         <xsl:apply-templates select="//case:info/case:constituents[not(ancestor::case:appendix)][$streamID='CA01']"/>
         <!--Satbir: Define these element "case:typeofcase and case:judgement" as a optional for maintain order of elements-->
         <xsl:apply-templates select="case:content/case:typeofcase | case:content/case:judgments"/>
         <!--<xsl:apply-templates select="case:content/case:judgments"/>-->
         <!--<xsl:apply-templates select="case:content/case:judgments/case:judgment/case:courtinfo/case:judges[ancestor::case:content]"/>-->
         <!--<xsl:apply-templates select="case:content/case:judgments/case:constituents"/>-->
         <!--<xsl:apply-templates select="case:content/case:judgments/case:disposition"/>-->
         <!--<xsl:apply-templates select="case:content/case:judgments/case:appendix"/>-->
         <xsl:apply-templates select="case:courtinfo"/>
         <xsl:apply-templates select="case:content/case:author"/>
         <xsl:apply-templates select="case:content/case:appendix[not(parent::case:judgments)]|case:content/case:appendix[$streamID='CA01']"/>
         <xsl:apply-templates select="case:content/page"/>
         <!-- JD: 2017-12-01: supporting dropped <note> content per email from Chuck 2017-12-01/10:41AM.
			Rather than specifically process just <note>, process anything not handled above.  Limit to UK01 for now.  
			-->
         <xsl:if test="$streamID='UK01'">
            <xsl:apply-templates select="case:content/* except(case:content/case:typeofcase,case:content/case:judgments,case:content/case:author,case:content/case:appendix,case:content/page)"/>
         </xsl:if>
         <!--			<xsl:apply-templates select="case:content/case:author"/>-->
         <!--<xsl:apply-templates select="case:content/case:judgments"/>
			<xsl:apply-templates select="case:content/page"/>
			<xsl:apply-templates select="case:content/case:typeofcase"/>
			<xsl:apply-templates select="case:content/case:appendix[not(parent::case:judgments)]"/>
			
			<xsl:apply-templates select="case:content/case:judgments/case:constituents"/>
			<xsl:apply-templates select="case:content/case:author"/>
			<xsl:apply-templates select="@* | node() except case:info[parent::case:headnote]"/>-->
      </courtcase:body>
   </xsl:template>

   <xsl:template match="inlineobject" mode="citator-ref">
      <xsl:if test="contains(@alttext , 'Click for CaseBase entry')">
         <xsl:attribute name="referencedresourcesentiment">
            <xsl:choose>
               <xsl:when test="starts-with(@alttext , 'Citation')">
                  <xsl:text>none</xsl:text>
               </xsl:when>
               <xsl:when test="starts-with(@alttext , 'Positive')">
                  <xsl:text>positive</xsl:text>
               </xsl:when>
               <xsl:when test="starts-with(@alttext , 'Neutral')">
                  <xsl:text>neutral</xsl:text>
               </xsl:when>
               <xsl:when test="starts-with(@alttext , 'Negative')">
                  <xsl:text>negative</xsl:text>
               </xsl:when>
               <xsl:when test="starts-with(@alttext , 'Cautionary')">
                  <xsl:text>cautionary</xsl:text>
               </xsl:when>
               <xsl:when test="starts-with(@alttext , 'Click')">
                  <xsl:text>none</xsl:text>
               </xsl:when>
            </xsl:choose>
         </xsl:attribute>
      </xsl:if>
   </xsl:template>
   <!-- start topichead  CaseContent  -->   <!-- <topicref href="AU01_Rosetta_case.content.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>page</xd:i> element occurs as direct child of <xd:i>case:content</xd:i> then conversion need to move
            <xd:b>ref:page</xd:b> as direct child of <xd:b>courtcase:body</xd:b>, i.e,
            <xd:i>case:content/page</xd:i> becomes <xd:b>courtcase:body/ref:page</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>case:appendix</xd:i> element occurs as direct child of <xd:i>case:content</xd:i> then conversion
            need to move <xd:b>attachments/appendix</xd:b> as direct child of <xd:b>courtcase:body</xd:b>, i.e,
            <xd:i>case:content/case:appendix</xd:i> becomes <xd:b>courtcase:body/attachments/appendix</xd:b>.</xd:p>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.content.dita#Rosetta_case.content/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.content.dita  -->
   <!--<xsl:message>AU01_Rosetta_case.content.xsl requires manual development!</xsl:message>-->
   <!--SS: Working-->
   <!--<xsl:template match="case:content/child::page"/>
    <xsl:template match="case:content/child::appendix"/>
    <xsl:template match="case:content/child::case:typeofcase"/>-->
   <!-- <topicref href="../../common_caselaw/Rosetta_case.typeofcase-LxAdv_casesum.overview.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:typeofcase</xd:i> becomes
                    <xd:b>courtcase:body/casesum:summaries/casesum:editorialsummary/casesum:overview</xd:b>.</xd:p>
         <xd:p>With the exception of <xd:i>heading</xd:i>, all children of
                    <xd:i>case:typeofcase</xd:i> should be mapped to children of
                    <xd:b>casesum:overview/bodytext</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>casesum:summaries</xd:b>
                elements. When 2 or more consecutive sibling source elements map to
                    <xd:b>casesum:summaries</xd:b>, target data should be merged to a
                single <xd:b>casesum:summaries</xd:b> element unless this would hamper
                content ordering.</xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:typeofcase&gt;
    &lt;heading&gt;
        &lt;title&gt;Application&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
        &lt;text&gt;This was an application by notice of motion to amend an application to the tribunal for the restoration of credit charges to certain contracts.&lt;/text&gt;
    &lt;/p&gt;
&lt;/case:typeofcase&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:overview&gt;
    &lt;heading&gt;
        &lt;title&gt;Application&lt;/title&gt;
    &lt;/heading&gt;
    &lt;bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;This was an application by notice of motion to amend an application to the tribunal for the restoration of credit charges to certain contracts.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/bodytext&gt;
&lt;/casesum:overview&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:typeofcase&gt;
    &lt;heading&gt;
        &lt;title&gt;ACTION&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
        &lt;text&gt;claiming writs of certiorari and prohibition and a declaration.&lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;text&gt;Early in the month of September 1959, Mrs Kettle (the second defendant) became the licensee under a wholesale licence in respect of certain premises situated at Waite Street, Greymouth. Shortly afterwards she filed applications (1) for a temporary transfer of the licence pursuant to s. 120 of the Licensing Act 1908 to a limited company called Kettle Bros. Ltd. (the third defendant) and (2) for a permanent transfer of the licence pursuant to ss. 118 and 119 of the Act to the same company. The temporary transfer was granted on 29 September 1959 with the effect set out in s. 120 (3) of the Act &amp;#x2014; namely, to authorise Kettle Bros. Ltd. to carry on the business specified in the licence at the Waite Street premises until the next quarterly licensing meeting to be held by the Westland District Licensing Committee (the first defendant, hereinafter called &amp;quot;the Licensing Committee&amp;#x0022;).&lt;/text&gt;
    &lt;/p&gt;
&lt;/case:typeofcase&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:overview&gt;
    &lt;heading&gt;
        &lt;title&gt;ACTION&lt;/title&gt;
    &lt;/heading&gt;
    &lt;bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;claiming writs of certiorari and prohibition and a declaration.&lt;/text&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;text&gt;Early in the month of September 1959, Mrs Kettle (the second defendant) became the licensee under a wholesale licence in respect of certain premises situated at Waite Street, Greymouth. Shortly afterwards she filed applications (1) for a temporary transfer of the licence pursuant to s. 120 of the Licensing Act 1908 to a limited company called Kettle Bros. Ltd. (the third defendant) and (2) for a permanent transfer of the licence pursuant to ss. 118 and 119 of the Act to the same company. The temporary transfer was granted on 29 September 1959 with the effect set out in s. 120 (3) of the Act &amp;#x2014; namely, to authorise Kettle Bros. Ltd. to carry on the business specified in the licence at the Waite Street premises until the next quarterly licensing meeting to be held by the Westland District Licensing Committee (the first defendant, hereinafter called &amp;quot;the Licensing Committee&amp;#x0022;).&lt;/text&gt;
        &lt;/p&gt;
    &lt;/bodytext&gt;
&lt;/casesum:overview&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:typeofcase&gt;
    &lt;pgrp&gt;
        &lt;heading&gt;
            &lt;title&gt;Appeal&lt;/title&gt;
        &lt;/heading&gt;
        &lt;p&gt;
            &lt;text&gt;This was an appeal by the one of the defendants against a decision of Mandie&amp;#160;J in the Trial Division awarding the plaintiffs damages in a claim brought against the defendant investment advisers pursuant to s&amp;#160;819 of the Corporations Law. The facts are stated in the judgment.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/pgrp&gt;
&lt;/case:typeofcase&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:overview&gt;
    &lt;bodytext&gt;
        &lt;pgrp&gt;
            &lt;heading&gt;
                &lt;title&gt;Appeal&lt;/title&gt;
            &lt;/heading&gt;
            &lt;p&gt;
                &lt;text&gt;This was an appeal by the one of the defendants against a decision of Mandie J in the Trial Division awarding the plaintiffs damages in a claim brought against the defendant investment advisers pursuant to s 819 of the Corporations Law. The facts are stated in the judgment.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/pgrp&gt;
    &lt;/bodytext&gt;
&lt;/casesum:overview&gt;
       </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:typeofcase&gt;
    &lt;p&gt;
        &lt;text&gt;MOTION for argument of questions of law on the pleadings in the action.&lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;text&gt;The statement of claim alleged&amp;mdash;&lt;/text&gt;
    &lt;/p&gt;
    &lt;l&gt;
        &lt;li&gt;
            &lt;lilabel&gt;&amp;#160;&lt;/lilabel&gt;
            &lt;p&gt;
                &lt;text&gt;1. That the plaintiff was a member of the Church of England and a parishioner of the Parish of Avonside, and the defendant was the incumbent of the said parish.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/li&gt;
    &lt;/l&gt;
    &lt;l&gt;
        &lt;li&gt;
            &lt;lilabel&gt;&amp;#160;&lt;/lilabel&gt;
            &lt;p&gt;
                &lt;text&gt;2. That on Sunday, the 23rd of September, 1889, the defendant as such incumbent held the service of the Holy Communion, and that the plaintiff attended the service and duly presented herself to receive the Sacrament of the Holy Communion.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/li&gt;
    &lt;/l&gt;
&lt;/case:typeofcase&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;casesum:overview&gt;
    &lt;bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;MOTION for argument of questions of law on the pleadings in the action.&lt;/text&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;text&gt;The statement of claim alleged&amp;#x2014;&lt;/text&gt;
        &lt;/p&gt;
        &lt;list&gt;
            &lt;listitem&gt;
                &lt;label&gt; &lt;/label&gt;
                &lt;p&gt;
                    &lt;text&gt;1. That the plaintiff was a member of the Church of England and a parishioner of the Parish of Avonside, and the defendant was the incumbent of the said parish.&lt;/text&gt;
                &lt;/p&gt;
            &lt;/listitem&gt;
        &lt;/list&gt;
        &lt;list&gt;
            &lt;listitem&gt;
                &lt;label&gt; &lt;/label&gt;
                &lt;p&gt;
                    &lt;text&gt;2. That on Sunday, the 23rd of September, 1889, the defendant as such incumbent held the service of the Holy Communion, and that the plaintiff attended the service and duly presented herself to receive the Sacrament of the Holy Communion.&lt;/text&gt;
                &lt;/p&gt;
            &lt;/listitem&gt;
        &lt;/list&gt;
    &lt;/bodytext&gt;
&lt;/casesum:overview&gt;
       </xd:pre>
         <!--<section>
            <title>Changes</title>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.typeofcase-LxAdv_casesum.overview.dita  -->
   <!--<xsl:message>Rosetta_case.typeofcase-LxAdv_casesum.overview.xsl requires manual development!</xsl:message>-->
   <!--WSS: Done case:typeofcase-->
   <!--Satbir: Correct ordering of case:typeofcase-->
   <xsl:template match="case:typeofcase">
      <casesum:summaries>
         <casesum:editorialsummary>
            <casesum:overview>
               <xsl:apply-templates select="heading"/>
               <bodytext>
                  <xsl:apply-templates select="@* | node() except heading"/>
               </bodytext>
            </casesum:overview>
         </casesum:editorialsummary>
      </casesum:summaries>
      <!--  <xsl:choose>
	        <xsl:when test="./parent::case:content">
	           
	                <casesum:editorialsummary>
	                    <casesum:overview>
	                        <xsl:apply-templates select="heading"/>
	                        <bodytext>
	                           <xsl:apply-templates select="@* | node() except heading"/>
	                        </bodytext>
	                    </casesum:overview>
	                </casesum:editorialsummary>
	            
	        </xsl:when>
	        <xsl:otherwise>
	            <casesum:overview>
	                <xsl:apply-templates select="heading"/>
	                <bodytext>
	                    <xsl:apply-templates select="@* | node() except heading"/>
	                </bodytext>
	            </casesum:overview>
	        </xsl:otherwise>
	    </xsl:choose>-->
   </xsl:template>
   <!-- <topicref href="AU01_Rosetta_case.judgments-LxAdv_courtcase.opinions.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>The optional attributes of <xd:i>case:judgments</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>case:judgments/@subdoc</xd:i> becomes
                            <xd:b>courtcase:opinions/@includeintoc</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:judgments/@toc-caption</xd:i> becomes
                            <xd:b>courtcase:opinions/@alternatetoccaption</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>The child element <xd:b>attachments</xd:b> is used to house
                    <xd:i>inlineobject</xd:i> information in the opinions. The LBU
                indicated that this use case is for attachments.</xd:p>
         <xd:pre>
&lt;case:judgments&gt;
    ...
    &lt;inlineobject filename="g0607831d.gif" attachment="ln-server" type="image"/&gt;
    ...
&lt;/case:judgments&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    ...
    &lt;attchments&gt;
        &lt;appendix&gt;
            &lt;bodytext&gt;
                &lt;figure&gt;
                    &lt;ref:inlineobject&gt;
                        &lt;ref:locator&gt;
                            &lt;ref:locator-key&gt;
                                &lt;ref:key-name name="object-key"/&gt;
                                &lt;ref:key-value value="X-Y-g0607831d"/&gt;
                            &lt;/ref:locator-key&gt;
                            &lt;ref:locator-params&gt;
								&lt;proc:param name="componentseq" value="1"/&gt;
                                &lt;proc:param name="object-type" value="image"/&gt;
								&lt;proc:param name="object-smi" value=""/&gt;
                            &lt;/ref:locator-params&gt;
                        &lt;/ref:locator&gt;
                    &lt;/ref:inlineobject&gt;
                &lt;/figure&gt;
            &lt;/bodytext&gt;
        &lt;/appendix&gt;
    &lt;/attchments&gt;
    ...
&lt;/courtcase:opinions&gt;
       </xd:pre>
         <xd:p>When <xd:i>case:dates</xd:i> appears as direct of
                    <xd:i>case:judgments</xd:i> then conversion need to omit tag
                    (<xd:i>case:dates</xd:i>) and retain content in this particular
                context and create <xd:b>decision:decisiondate</xd:b> as direct child of
                    <xd:b>courtcase:opinions</xd:b>, i.e.,
                    <xd:i>case:judgments/case:dates/case:decisiondate</xd:i> becomes
                    <xd:b>courtcase:opinions/decision:decisiondate</xd:b>.</xd:p>
         <xd:p>The attribute <xd:b>decision:decisiondate/@normdate</xd:b> should be
                populated with the values of <xd:i>case:decisiondate/date/@year</xd:i>,
                    <xd:i>case:decisiondate/date/@month</xd:i> and
                    <xd:i>case:decisiondate/date/@day</xd:i> concatenated and separated by
                a single hyphen. The values of <xd:i>case:decisiondate/date/@month</xd:i>
                and <xd:i>case:decisiondate/date/@day</xd:i> should be padded with zeroes
                so that they are 2 digits.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If one or more of the three date values (year, month or day) are absent, then
                    <xd:b>decision:decisiondate/@normdate</xd:b> should <xd:b>not</xd:b> be
                populated.</xd:p>
         <xd:pre>
&lt;case:judgments&gt;
    &lt;case:dates&gt;
        &lt;case:decisiondate&gt;
            &lt;date year="1986" month="07" day="01"&gt;1 July 1986&lt;/date&gt; 
        &lt;/case:decisiondate&gt;
    &lt;/case:dates&gt;
    ...
&lt;/case:judgments&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    &lt;decision:decisiondate day="01" month="07" year="1986" normdate="1986-07-01"&gt;
        &lt;date-text&gt;1 July 1986&lt;/date-text&gt; 
    &lt;/decision:decisiondate&gt;
    ...
&lt;/courtcase:opinions&gt;
       </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.judgments-LxAdv_courtcase.opinions.dita#Rosetta_case.judgments-LxAdv_courtcase.opinions/changes"/>-->
         <xd:p>
            <xd:b>Changes Specific to AU01</xd:b>
         </xd:p>
         <xd:p>2013-05-02: Updated target example to reflect changes per
                    latest Apollo markup.</xd:p>
         <xd:p>2013-05-02: Created.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.judgments-LxAdv_courtcase.opinions.dita  -->
   <!--SS: Done "AU01_Rosetta_case.judgments-LxAdv_courtcase.opinions"-->
   <xsl:template match="case:judgments">
      <courtcase:opinions>
         <xsl:choose>
            <xsl:when test="./@subdoc">
               <xsl:attribute name="includeintoc">
                  <xsl:value-of select="."/>
               </xsl:attribute>
            </xsl:when>
            <xsl:when test="./@toc-caption">
               <xsl:attribute name="alternatetoccaption">
                  <xsl:value-of select="."/>
               </xsl:attribute>
            </xsl:when>
            <xsl:when test="./@searchtype"/>
            <xsl:when test="child::inlineoject">
               <attchments>
                  <appendix>
                     <bodytext>
                        <figure>
                           <xsl:apply-templates select="inlineobject"/>
                        </figure>
                     </bodytext>
                  </appendix>
               </attchments>
            </xsl:when>
            <xsl:when test="child::case:dates and descendant::case:decisiondate">
               <xsl:apply-templates select="case:decisiondate"/>
            </xsl:when>
         </xsl:choose>
         <xsl:apply-templates select="@* | node() except inlineobject except case:decisiondate"/>
      </courtcase:opinions>
   </xsl:template>
   <!-- <topicref href="AU01_Rosetta_case.judgment-LxAdv_courtcase.opinion.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>The optional attributes of <xd:i>case:judgment</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>case:judgment/@subdoc</xd:i> becomes
              <xd:b>courtcase:opinion/@includeintoc</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:judgment/@toc-caption</xd:i> becomes
              <xd:b>courtcase:opinion/@alternatetoccaption</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:judgment/@searchtype</xd:i> should be suppressed.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:pre>
&lt;case:judgment subdoc="true" toc-caption="Perram J."&gt;
  &lt;case:judgmentbody&gt;
    &lt;pgrp&gt;
      &lt;heading&gt;
        &lt;title&gt;Background&lt;/title&gt;
      &lt;/heading&gt;
      &lt;p&gt;
        &lt;pnum count="1"&gt;[1]&lt;/pnum&gt;
        &lt;text&gt;The present applicants are five individuals who at one time or another were engaged by
          Combined Insurance Company of America (Combined) as insurance agents. In recent times, the
          five have sued Combined in the Chief Industrial Magistrates&amp;#x2019; Court of New South
          Wales claiming entitlements both to annual leave and long service leave. One of the
          principal issues to be resolved in those proceedings is the question of whether the agents
          were employees of Combined, as they contend, or rather independent contractors, as
          Combined contends. Nodoubt the resolution of that issue will involve a close
          consideration of a broad range of indicia. One of the matters to which Combined points is
          a term in its contract with each agent by which each agreed, or appears to have agreed,
          that his relationship with Combined was not one of employment.&lt;/text&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
  &lt;/case:judgmentbody&gt;
&lt;/case:judgment&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinion includeintoc="true" alternatetoccaption="Perram J."&gt;
  &lt;bodytext&gt;
    &lt;pgrp&gt;
      &lt;heading&gt;
        &lt;title&gt;Background&lt;/title&gt;
      &lt;/heading&gt;
      &lt;p&gt;
        &lt;desig value="1"&gt;[1]&lt;/desig&gt;
        &lt;text&gt;The present applicants are five individuals who at one time or another were engaged by
          Combined Insurance Company of America (Combined) as insurance agents. In recent times, the
          five have sued Combined in the Chief Industrial Magistrates&amp;#x2019; Court of New South
          Wales claiming entitlements both to annual leave and long service leave. One of the
          principal issues to be resolved in those proceedings is the question of whether the agents
          were employees of Combined, as they contend, or rather independent contractors, as
          Combined contends. Nodoubt the resolution of that issue will involve a close
          consideration of a broad range of indicia. One of the matters to which Combined points is
          a term in its contract with each agent by which each agreed, or appears to have agreed,
          that his relationship with Combined was not one of employment.&lt;/text&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
  &lt;/bodytext&gt;
&lt;/courtcase:opinion&gt;
       </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.judgment-LxAdv_courtcase.opinion.dita#Rosetta_case.judgment-LxAdv_courtcase.opinion/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
            </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.judgment-LxAdv_courtcase.opinion.dita  -->
   <!--SS: Done "AU01_Rosetta_case.judgment-LxAdv_courtcase.opinion"-->
   <xsl:template match="case:judgment">
      <courtcase:opinion>
         <xsl:if test="./@subdoc">
            <xsl:attribute name="includeintoc">
               <xsl:value-of select="./@subdoc"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="./@toc-caption">
            <xsl:attribute name="alternatetoccaption">
               <xsl:value-of select="./@toc-caption"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="./@searchtype"/>
         <xsl:apply-templates select="case:courtinfo/case:judges[ancestor::case:content]"/>
         <xsl:apply-templates select="@* | node() except case:courtinfo"/>
      </courtcase:opinion>
   </xsl:template>

   <xsl:template match="@toc-caption | @subdoc | @searchtype"/>
   <!-- <topicref href="AU01_Rosetta_case.judges.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:ul>
            <xd:li> There are two contexts for
                        <xd:i>/case:judges/case:judge</xd:i> in Standard Rosetta along
                    with NL Xpath: <xd:ol>
                  <xd:li>
                            /CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:judges/case:judge,
                                <xd:b>NL Xpath:</xd:b>
                            /courtcase:courtcase/courtcase:head/caseinfo:caseinfo/courtcase:panel/courtcase:judges/person:judge </xd:li>
                  <xd:li>
                            /CASEDOC/case:body/case:content/case:judgments/case:judgment/case:courtinfo/case:judges/case:judge,
                                <xd:b>NL Xpath:</xd:b>
                            /courtcase:courtcase/courtcase:body/courtcase:opinions/courtcase:opinion/courtcase:opinionby/person:judge
                        </xd:li>
               </xd:ol>
               <xd:p>
                  <xd:b>Note: </xd:b>Conversion should not create consecutive
                            <xd:b>caseinfo:caseinfo</xd:b> elements. When 2 or more
                        consecutive sibling source elements map to
                            <xd:b>caseinfo:caseinfo</xd:b>, data should be merged to a
                        single <xd:b>caseinfo:caseinfo</xd:b> element unless this would
                        hamper content ordering.</xd:p>
               <xd:p>
                  <xd:b>Note: </xd:b>Any <xd:i>nl</xd:i> elements inside
                            <xd:i>case:judges</xd:i> should be suppressed.</xd:p>
               <xd:i>case:judge</xd:i> becomes <xd:b>person:judge</xd:b>
               <xd:pre>

&lt;case:judges&gt;
    &lt;case:judge&gt;Perram&lt;/case:judge&gt; J
&lt;/case:judges&gt;
<xd:b>Becomes</xd:b>

&lt;courtcase:opinionby&gt;
    &lt;person:judge&gt;Perram&lt;/person:judge&gt; J
&lt;/courtcase:opinionby&gt;

OR

&lt;courtcase:panel&gt;
    &lt;courtcase:judges&gt;
        &lt;person:judge&gt;Perram&lt;/person:judge&gt; J
    &lt;/courtcase:judges&gt;
&lt;courtcase:panel&gt;
</xd:pre>
               <xd:p>
                  <xd:b>Note: </xd:b> Capture PCData for judges markup as is in New Lexis
                        and always create <xd:b>person:judge</xd:b> as an immediate child
                        of <xd:b>courtcase:judges</xd:b> or
                            <xd:b>courtcase:opinionby</xd:b>. For example: if there is a
                        Rosetta <xd:i>case:judges</xd:i> element and it just contains text
                        then conversion need to create <xd:b>person:judge</xd:b> as a
                        child of <xd:b>courtcase:judges</xd:b> or
                            <xd:b>courtcase:opinionby</xd:b>.</xd:p>
               <xd:pre>

&lt;case:judges&gt;
    Glazebrook, ORegan and Baragwanath JJ
&lt;/case:judges&gt;
<xd:b>Becomes</xd:b>

&lt;courtcase:opinionby&gt;
    &lt;person:judge&gt;Glazebrook, ORegan and Baragwanath JJ&lt;/person:judge&gt;
&lt;/courtcase:opinionby&gt;

OR

&lt;courtcase:panel&gt;
    &lt;courtcase:judges&gt;
        &lt;person:judge&gt;Glazebrook, ORegan and Baragwanath JJ&lt;/person:judge&gt;
    &lt;/courtcase:judges&gt;
&lt;courtcase:panel&gt;
</xd:pre>
               <xd:p>
                  <xd:b>Note: </xd:b>When <xd:i>emph</xd:i> is inside
                            <xd:i>case:judges</xd:i> and
                            <xd:i>@typestyle="smcaps"</xd:i> then conversion need to omit
                        tag (<xd:i>emph</xd:i>) and retain content.</xd:p>
               <xd:pre>

&lt;case:judgment&gt;
  &lt;case:courtinfo&gt;
      &lt;case:judges&gt;
          JUDGE M 
          &lt;emph typestyle="smcaps"&gt;c&lt;/emph&gt; 
          ELREA. 
      &lt;/case:judges&gt;
  &lt;/case:courtinfo&gt;
  ...
&lt;/case:judgment&gt;

<xd:b>Becomes</xd:b>

&lt;courtcase:opinion&gt;
  &lt;courtcase:opinionby&gt;
    JUDGE M 
    c
    ELREA. 
  &lt;/courtcase:opinion&gt;
&lt;/courtcase:opinion&gt;

</xd:pre>
               <xd:p>
                  <xd:b>Note: </xd:b>Connecting punctuation and newlines or label text
                            ending with a colon preceding judges can be accomodated in the
                        judges markup. The colon should not be copied into the target xml however.</xd:p>
               <xd:p>
                  <xd:b>Note: </xd:b>A colon is inserted before case:judges in rosetta
                        xml. In rosetta this colon is used as a separator, that will be handled in
                        presentation spec for New Lexis for all cases.</xd:p>
               <xd:pre>

&lt;case:info&gt;
    ...
    &lt;case:courtinfo&gt;
        &lt;case:juris&gt;NSW&lt;/case:juris&gt; 
        &lt;case:courtname&gt;Equity Division&lt;/case:courtname&gt; 
        &lt;case:courtcode&gt;NSWSC&lt;/case:courtcode&gt; 
        &lt;nl/&gt;
        -
        &lt;case:judges&gt;
            &lt;case:judge&gt;Young J&lt;/case:judge&gt; 
        &lt;/case:judges&gt;
        &lt;case:dates&gt;
            &lt;case:hearingdates&gt;10 June; 1 July 1986&lt;/case:hearingdates&gt; 
        &lt;/case:dates&gt;
    &lt;/case:courtinfo&gt;
&lt;/case:info&gt;

<xd:b>Becomes</xd:b>

&lt;caseinfo:caseinfo&gt;
    ...
    &lt;courtcase:panel&gt;
        &lt;courtcase:judges&gt;
            &lt;proc:nl/&gt;
            -
            &lt;person:judge&gt;Young J&lt;/person:judge&gt; 
        &lt;/courtcase:judges&gt;
    &lt;/courtcase:panel&gt;
    ...
&lt;/caseinfo:caseinfo&gt;

</xd:pre>
               <xd:pre>
&lt;case:info&gt;
    ...
    &lt;case:courtinfo&gt;
        &lt;case:juris&gt;NSW&lt;/case:juris&gt; 
        &lt;case:courtname&gt;Equity Division&lt;/case:courtname&gt; 
        &lt;case:courtcode&gt;NSWSC&lt;/case:courtcode&gt;:
        &lt;case:judges&gt;
            &lt;case:judge&gt;Young J&lt;/case:judge&gt; 
        &lt;/case:judges&gt;
        &lt;case:dates&gt;
            &lt;case:hearingdates&gt;10 June; 1 July 1986&lt;/case:hearingdates&gt; 
        &lt;/case:dates&gt;
    &lt;/case:courtinfo&gt;
&lt;/case:info&gt;

<xd:b>Becomes</xd:b>

&lt;caseinfo:caseinfo&gt;
    ...
    &lt;courtcase:panel&gt;
        &lt;courtcase:judges&gt;
            &lt;person:judge&gt;Young J&lt;/person:judge&gt; 
        &lt;/courtcase:judges&gt;
    &lt;/courtcase:panel&gt;
    ...
&lt;/caseinfo:caseinfo&gt;    
    
</xd:pre>
               <xd:pre>
 &lt;case:info&gt;
 ...
   &lt;case:courtinfo&gt;
     &lt;case:juris&gt;NSW&lt;/case:juris&gt;
     &lt;case:courtname&gt;Common Law Division&lt;/case:courtname&gt;
     &lt;case:courtcode&gt;NSWSC&lt;/case:courtcode&gt;Commercial List:
       &lt;case:judges&gt;
         &lt;case:judge&gt;Young J&lt;/case:judge&gt;
       &lt;/case:judges&gt;

       &lt;case:dates&gt;
          &lt;case:hearingdates&gt;June 19; July 14, 1981&lt;/case:hearingdates&gt;
       &lt;/case:dates&gt;
    &lt;/case:courtinfo&gt;
&lt;/case:info&gt;

Becomes
 &lt;caseinfo:caseinfo&gt;
  ...
   &lt;courtcase:panel&gt;
      &lt;courtcase:judges&gt;Commercial List
         &lt;person:judge&gt;Young J&lt;/person:judge&gt;
      &lt;/courtcase:judges&gt;
   &lt;/courtcase:panel&gt;
  ...
 &lt;/caseinfo:caseinfo&gt;

</xd:pre>
            </xd:li>
         </xd:ul>
         <!--Changes2015-03-24: Modified handling of any occurence of a colon in the source within the judges label text.2015-02-26: Added clarification information to note for handling mixed content labels which precede judge lists.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.judges.dita  -->
   <!--SS: Done "AU01_Rosetta_case.judges"-->
   <xsl:template match="case:judges[ancestor::case:headnote]">
      <xsl:choose>
         <xsl:when test="@ln.user-displayed='false'"/>
         <xsl:otherwise>
            <courtcase:panel>
               <courtcase:judges><!--SS: Added below condition for moving text() of case:courtinfo under target element courtcase:judges-->
                  <xsl:if test="preceding-sibling::text()[preceding-sibling::case:courtcode and following-sibling::case:judges and parent::case:courtinfo]">
                     <xsl:value-of select="ancestor::case:courtinfo/text()[preceding-sibling::case:courtcode and following-sibling::case:judges]"/>
                  </xsl:if>
                  <!--RS: 2018-01-04: Added below condition for moving text() of case:courtinfo under target element courtcase:judges Webstar number #7078814 -->
                  <xsl:if test="normalize-space(preceding-sibling::text()[1]) = ':' and $streamID='AU01'">
                     <xsl:value-of select="preceding-sibling::text()[1]"/>
                  </xsl:if>
                  <xsl:apply-templates select="@* | node()"/>
               </courtcase:judges>
            </courtcase:panel>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="case:judges[ancestor::case:content]">
      <xsl:choose>
         <xsl:when test="@ln.user-displayed='false'"/>
         <xsl:otherwise>
            <courtcase:opinionby>
               <xsl:apply-templates select="@* | node()"/>
            </courtcase:opinionby>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="nl[parent::case:judges]"/>

   <xsl:template match="case:judge">
      <person:judge>
         <xsl:apply-templates select="@* | node()"/>
      </person:judge>
   </xsl:template>

   <xsl:template match="case:judges/emph[@typestyle='smcaps'][parent::case:judges]">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- <topicref href="../../common_caselaw/Rosetta_case.judgmentbody-LxAdv_courtcase.opinion_bodytext.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:judgmentbody</xd:i> becomes
          <xd:b>courtcase:opinion/bodytext</xd:b>.</xd:p>
         <xd:p>With the exception of <xd:i>heading</xd:i>, every child of
          <xd:i>case:judgmentbody</xd:i> should be mapped to
          <xd:b>courtcase:opinion/bodytext</xd:b>.
          <xd:i>case:judgmentbody/heading</xd:i> becomes
          <xd:b>courtcase:opinion/heading</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Example: CA content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:judgments&gt;
  &lt;case:judgment&gt;
    &lt;case:judgmentbody&gt;
      &lt;p&gt;
        &lt;text&gt;&lt;emph typestyle="bf"&gt;MITCHELL, J.&lt;/emph&gt; (for the Court, allowing the appeal): This
          case concerns the interpretation of municipal bylaws and the availability of injunctive
          relief to restrain their violation.&lt;/text&gt;
      &lt;/p&gt;
      ...
    &lt;/case:judgmentbody&gt;
  &lt;/case:judgment&gt;
&lt;/case:judgments&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
  &lt;courtcase:opinion&gt;
    &lt;bodytext&gt;
      &lt;p&gt;
        &lt;text&gt;&lt;emph typestyle="bf"&gt;MITCHELL, J.&lt;/emph&gt; (for the Court, allowing the appeal): This
          case concerns the interpretation of municipal bylaws and the availability of injunctive
          relief to restrain their violation.&lt;/text&gt;
      &lt;/p&gt;
      ...
    &lt;/bodytext&gt;
  &lt;/courtcase:opinion&gt;
&lt;/courtcase:opinions&gt;
    </xd:pre>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:judgmentbody&gt;
  &lt;pgrp&gt;
    &lt;heading&gt;&lt;title&gt;Background&lt;/title&gt;&lt;/heading&gt;
    &lt;p&gt;
      &lt;pnum count="1"&gt;[1]&lt;/pnum&gt;
      &lt;text&gt;The present applicants are five individuals who at one time or another were engaged by
        Combined Insurance Company of America (Combined) as insurance agents. In recent times, the
        five have sued Combined in the Chief Industrial Magistrates&amp;#x2019; Court of New South Wales
        claiming entitlements both to annual leave and long service leave. One of the principal
        issues to be resolved in those proceedings is the question of whether the agents were
        employees of Combined, as they contend, or rather independent contractors, as Combined
        contends. Nodoubt the resolution of that issue will involve a close consideration of a
        broad range of indicia. One of the matters to which Combined points is a term in its
        contract with each agent by which each agreed, or appears to have agreed, that his
        relationship with Combined was not one of employment.&lt;/text&gt;
    &lt;/p&gt;
  &lt;/pgrp&gt;
  ...
&lt;/case:judgmentbody&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinion&gt;
  &lt;bodytext&gt;
    &lt;pgrp&gt;
      &lt;heading&gt;&lt;title&gt;Background&lt;/title&gt;&lt;/heading&gt;
      &lt;p&gt;
        &lt;desig value="1"&gt;[1]&lt;/desig&gt;
        &lt;text&gt;The present applicants are five individuals who at one time or another were engaged by
          Combined Insurance Company of America (Combined) as insurance agents. In recent times, the
          five have sued Combined in the Chief Industrial Magistrates&amp;#x2019; Court of New South
          Wales claiming entitlements both to annual leave and long service leave. One of the
          principal issues to be resolved in those proceedings is the question of whether the agents
          were employees of Combined, as they contend, or rather independent contractors, as
          Combined contends. Nodoubt the resolution of that issue will involve a close
          consideration of a broad range of indicia. One of the matters to which Combined points is
          a term in its contract with each agent by which each agreed, or appears to have agreed,
          that his relationship with Combined was not one of employment.&lt;/text&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
    ...
  &lt;/bodytext&gt;
&lt;/courtcase:opinion&gt;
    </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:judgmentbody&gt;
  &lt;p&gt;
    &lt;text&gt;[After stating the facts, as above:] Section 127 (10) of the Act provides that no order
      for the removal of any wholesale licence shall be made without the prior approval of the
      Licensing Control Commission. On 22 March 1960 a formal order of the Licensing Control
      Commission approving the removal was issued by the Commission. The Licensing Committee did not
      itself hold any further meeting to consider the application made by Mrs Kettle for a removal
        &lt;page count="37" reporter="NZLR" text="[1961] NZLR 35 page "/&gt;of the licence to the
      Blackmore Street premises. On receipt of the approval by the Licensing Control Commission the
      chairman and clerk of the Licensing Committee completed the endorsement upon the licence
      required by s. 129 (2) of the Act. This was done on 31 March 1960. &lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
    &lt;text&gt;A few days later Mrs Kettle lodged applications for temporary and permanent transfers of
      the licence to Grogan and Blackmores Cordials Ltd. (the fourth defendant &amp;#x2014; hereinafter
      referred to as &amp;quot;Grogan and Blackmores&amp;#x0022;). The temporary transfer was granted on 5
      April 1960. &lt;/text&gt;
  &lt;/p&gt;
&lt;/case:judgmentbody&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinion&gt;
  &lt;bodytext&gt;
    &lt;p&gt;
      &lt;text&gt;[After stating the facts, as above:] Section 127 (10) of the Act provides that no order
        for the removal of any wholesale licence shall be made without the prior approval of the
        Licensing Control Commission. On 22 March 1960 a formal order of the Licensing Control
        Commission approving the removal was issued by the Commission. The Licensing Committee did
        not itself hold any further meeting to consider the application made by Mrs Kettle for a
        removal &lt;ref:page num="37" page-scheme="NZLR" page-scheme-type="reporter-abbreviation"/&gt; of
        the licence to the Blackmore Street premises. On receipt of the approval by the Licensing
        Control Commission the chairman and clerk of the Licensing Committee completed the
        endorsement upon the licence required by s. 129 (2) of the Act. This was done on 31 March
        1960. &lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
      &lt;text&gt;A few days later Mrs Kettle lodged applications for temporary and permanent transfers of
        the licence to Grogan and Blackmores Cordials Ltd. (the fourth defendant &amp;#x2014;
        hereinafter referred to as &amp;quot;Grogan and Blackmores&amp;#x0022;). The temporary transfer was
        granted on 5 April 1960. &lt;/text&gt;
    &lt;/p&gt;
  &lt;/bodytext&gt;
&lt;/courtcase:opinion&gt;
    </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:judgment&gt;
  &lt;case:judgmentbody&gt;
    &lt;pgrp&gt;
      &lt;p&gt;
        &lt;pnum&gt;1&lt;/pnum&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
    &lt;pgrp&gt;
      &lt;p&gt;
        &lt;text&gt;&amp;#x201c;The applicant had been in the employ of the respondent company from 31st
          August 1953, when he started as an apprentice, until his employment terminated on 4th May
          1972. Over that period of time Mr Middlemass had worked in all sorts of capacities for the
          company. However, the capacity about which we are concerned is that relating to either
          sales manager or technical representative on behalf of the company.&lt;/text&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
  &lt;/case:judgmentbody&gt;
&lt;/case:judgment&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinion&gt;
  &lt;bodytext&gt;
    &lt;pgrp&gt;
      &lt;p&gt;
        &lt;desig&gt;1&lt;/desig&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
    &lt;pgrp&gt;
      &lt;p&gt;
        &lt;text&gt;&amp;#x201C;The applicant had been in the employ of the respondent company from 31st
          August 1953, when he started as an apprentice, until his employment terminated on 4th May
          1972. Over that period of time Mr Middlemass had worked in all sorts of capacities for the
          company. However, the capacity about which we are concerned is that relating to either
          sales manager or technical representative on behalf of the company.&lt;/text&gt;
      &lt;/p&gt;
    &lt;/pgrp&gt;
  &lt;/bodytext&gt;
&lt;/courtcase:opinion&gt;
    </xd:pre>
         <!--<section>
      <title>Changes</title>
      </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.judgmentbody-LxAdv_courtcase.opinion_bodytext.dita  -->
   <!-- JL: refactored template to address issue in webstar -->
   <xsl:template match="case:judgmentbody[$streamID='CA01']" priority="2"><!--    <xsl:variable name="caseJudgmentBody">
      <xsl:copy-of select="."/>
    </xsl:variable>-->
      <xsl:variable name="caseJudgmentBodyFirstText">
         <xsl:for-each select="child::*[1]//text[not(ancestor::text)]">
            <xsl:value-of select="string-join(. , '')"/>
         </xsl:for-each>
      </xsl:variable>
      <!-- dumping content into a variable so we can access it later to find the first node -->
      <xsl:apply-templates select="heading"/>
      <xsl:for-each-group select="child::*"
                          group-starting-with="       *[(matches(.,':') and (string-length(substring-before(normalize-space(.),':')) &lt; 75))       or        (matches(. , ':--') and  (string-length(substring-before(normalize-space(.),':--')) &lt; 75))       or        (matches(. , ':') and (string-length(substring-before(normalize-space(.),':')) &lt; 75))]       [self::p/pnum or self::p[@indent ='1st-line'] or self::l]"><!-- group-starting-with="*[matches(.,':|:-\-|:&#x2014;')][(string-length(substring-before(normalize-space(.),':')) &lt; 75) or (string-length(substring-before(normalize-space(.),':-\-')) &lt; 75) or (string-length(substring-before(normalize-space(.),':&#x2014;')) &lt; 75)][self::p/pnum or self::p[@indent ='1st-line'] or self::l] -->
         <xsl:variable name="opinionbytext">
            <xsl:for-each select=".//text[not(ancestor::text)]">
               <xsl:choose>
                  <xsl:when test="matches(. ,':') and string-length(substring-before(normalize-space(.),':')) &lt; 75">
                     <xsl:value-of select="substring-before(. , ':')"/>
                  </xsl:when>
                  <xsl:when test="matches(. ,':--') and string-length(substring-before(normalize-space(.),':--')) &lt; 75">
                     <xsl:value-of select="substring-before(. , ':--')"/>
                  </xsl:when>
                  <xsl:when test="matches(. ,':') and string-length(substring-before(normalize-space(.),':')) &lt; 75">
                     <xsl:value-of select="substring-before(. , ':')"/>
                  </xsl:when>
               </xsl:choose>
            </xsl:for-each>
         </xsl:variable>
         <!--select="if(contains(.//text[not(descendant::text)],':-\-')) then substring-before(.//text[not(descendant::text)],':-\-') else if (contains(.,':&#x2014;')) then substring-before(.//text[not(descendant::text)],':&#x2014;') else substring-before(.//text[not(descendant::text)],':')"-->
         <!--<xsl:variable name="opinionbytext" select="if(contains(.,':-\-')) then substring-before(.,':-\-') else if (contains(.,':&#x2014;')) then substring-before(.,':&#x2014;') else substring-before(.,':')"/>-->
         <!--<xsl:variable name="mdash">
        <xsl:for-each select=".">
          <xsl:value-of select="if (matches(.,':|:-\-|:&#x2014;') and ((string-length(substring-before(normalize-space(.),':|:-\-|:&#x2014;')) &lt; 75) or (string-length(substring-before(normalize-space(.),':-\-')) &lt; 75) or (string-length(substring-before(normalize-space(.),':&#x2014;')) &lt; 75))) then '1' else '0'"/>
        </xsl:for-each>
      </xsl:variable>-->
         <xsl:choose>
            <xsl:when test="(not($opinionbytext) or $opinionbytext='') and position()=1">
               <xsl:if test="position()=last()">
                  <courtcase:opinion>
                     <bodytext>
                        <xsl:apply-templates select="current-group()"/>
                     </bodytext>
                  </courtcase:opinion>
               </xsl:if>
            </xsl:when>
            <xsl:otherwise>
               <courtcase:opinion><!--needed the variable for this info, for some reason grouping made the parent element impossible to find -->
                  <xsl:if test="position() = 2 and not(matches($caseJudgmentBodyFirstText , ':|:--|:'))">
                     <bodytext>
                        <xsl:apply-templates select="preceding-sibling::*[not(self::heading)]"/>
                     </bodytext>
                  </xsl:if>
                  <xsl:if test="$opinionbytext != ''">
                     <courtcase:opinionby>
                        <person:judge>
                           <xsl:variable name="judgetext" select="replace($opinionbytext, '^[\[]\d+[\]]', '')"/>
                           <!-- <xsl:analyze-string select="normalize-space($opinionbytext)" regex="([\[]?[0-9]+[\]]?)\s(.+)">
                     <xsl:matching-substring>
                       <xsl:value-of select="regex-group(2)"/>
                     </xsl:matching-substring>
                     <xsl:non-matching-substring>
                       <xsl:value-of select="."/>
                     </xsl:non-matching-substring>
                   </xsl:analyze-string>
                 </xsl:variable>-->
                           <xsl:value-of select="normalize-space($judgetext)"/>
                        </person:judge>
                     </courtcase:opinionby>
                  </xsl:if>
                  <bodytext>
                     <xsl:for-each select="current-group()">
                        <xsl:choose>
                           <xsl:when test="position()=1 and self::l"/>
                           <xsl:otherwise>
                              <xsl:apply-templates select="."/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:for-each>
                  </bodytext>
               </courtcase:opinion>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each-group>
      <xsl:apply-templates select="parent::case:judgement/following-sibling::case:appendix/p|               parent::case:judgement/following-sibling::case:appendix/case:headnote/case:priorhist[not(preceding-sibling::case:info or following-sibling::case:info)]"/>
   </xsl:template>

   <xsl:template match="case:judgmentbody"><!-- Awantika: added instruction for heading -->
      <xsl:apply-templates select="heading"/>
      <xsl:element name="bodytext">
         <xsl:apply-templates select="@* | node() except heading"/>
      </xsl:element>
   </xsl:template>
   <!-- <topicref href="../../common_caselaw/Rosetta_case.constituents-LxAdv_courtcase.opinions_courtcase.representation.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:constituents</xd:i> becomes
                    <xd:b>courtcase:opinions/courtcase:representation</xd:b> with child
                elements handled as described below.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>There can be multiple <xd:i>case:constituents</xd:i> elements at different
                locations in a file (generally before and after the
                    <xd:i>case:judgment</xd:i>). These elements need to be maintained in the same
                locations. The general rule remains that the content order should be maintained from
                input to output.</xd:p>
         <xd:p>
            <xd:i>case:constituent</xd:i> becomes
                    <xd:b>courtcase:opinions/courtcase:representation/courtcase:counsel</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>person</xd:i> occurs inside
                    <xd:i>case:constituent</xd:i>, kindly refer to the instructions for
                    <xd:i>person</xd:i> in the General Markup section for guidance on
                handling of this scenario.</xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:constituents&gt;
    &lt;case:constituent&gt;
        &lt;emph typestyle="it"&gt;A Leopold SC&lt;/emph&gt; and 
        &lt;emph typestyle="it"&gt;T Saunders&lt;/emph&gt; instructed by 
        &lt;emph typestyle="it"&gt;Allens Arthur Robinson&lt;/emph&gt; for theapplicant (Combined Insurance Company of America t/as Combined Insurance Company of Australia).
    &lt;/case:constituent&gt;
&lt;/case:constituents&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:representation&gt;
    &lt;courtcase:counsel&gt;
        &lt;emph typestyle="it"&gt;A Leopold SC&lt;/emph&gt; and 
        &lt;emph typestyle="it"&gt;T Saunders&lt;/emph&gt; instructed by 
        &lt;emph typestyle="it"&gt;Allens Arthur Robinson&lt;/emph&gt; for theapplicant (Combined Insurance Company of America t/as Combined Insurance Company of Australia).
    &lt;/courtcase:counsel&gt;
&lt;/courtcase:representation&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: NZ content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:constituents&gt;
    &lt;case:constituent constituenttype="counsel"&gt;J. K. Patterson, for the plaintiffs.&lt;/case:constituent&gt;
    &lt;case:constituent constituenttype="counsel"&gt;Tucker, for the first defendant.&lt;/case:constituent&gt;
    &lt;case:constituent constituenttype="counsel"&gt;R. E. Wylie, for the second, third and fourth defendants.&lt;/case:constituent&gt;
&lt;/case:constituents&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:representation&gt;
    &lt;courtcase:counsel&gt;J. K. Patterson, for the plaintiffs.&lt;/courtcase:counsel&gt;
    &lt;courtcase:counsel&gt;Tucker, for the first defendant.&lt;/courtcase:counsel&gt;
    &lt;courtcase:counsel&gt;R. E. Wylie, for the second, third and fourth defendants.&lt;/courtcase:counsel&gt;
&lt;/courtcase:representation&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:constituents&gt;
    &lt;case:constituent&gt;
        &lt;person&gt;
            &lt;name.text&gt;P Shepherd for the Appellant&lt;/name.text&gt;
        &lt;/person&gt;
    &lt;/case:constituent&gt;
    &lt;case:constituent&gt;
        &lt;person&gt;
            &lt;name.text&gt;R Wood for the Respondents&lt;/name.text&gt;
        &lt;/person&gt;
    &lt;/case:constituent&gt;
    &lt;case:constituent&gt;
        &lt;person&gt;
            &lt;name.text&gt;Clyde &amp;amp; Co; Hill Dickinson&lt;/name.text&gt;
        &lt;/person&gt;
    &lt;/case:constituent&gt;
&lt;/case:constituents&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    &lt;courtcase:representation&gt;
        &lt;courtcase:counsel&gt;
            &lt;person:counselor&gt;
                &lt;person:person&gt;
                    &lt;person:name.text&gt;
                        P Shepherd for the Appellant
                    &lt;/person:name.text&gt;
                &lt;/person:person&gt;
            &lt;/person:counselor&gt;
        &lt;/courtcase:counsel&gt;
        &lt;courtcase:counsel&gt;
            &lt;person:counselor&gt;
                &lt;person:person&gt;
                    &lt;person:name.text&gt;
                        R Wood for the Respondents
                    &lt;/person:name.text&gt;
                &lt;/person:person&gt;
            &lt;/person:counselor&gt;
        &lt;/courtcase:counsel&gt;
        &lt;courtcase:counsel&gt;
            &lt;person:counselor&gt;
                &lt;person:person&gt;
                    &lt;person:name.text&gt;
                        Clyde &amp;#x0026; Co; Hill Dickinson
                    &lt;/person:name.text&gt;
                &lt;/person:person&gt;
            &lt;/person:counselor&gt;
        &lt;/courtcase:counsel&gt;
    &lt;/courtcase:representation&gt;
&lt;/courtcase:opinions&gt;
           </xd:pre>
         <xd:p>Any other elements under <xd:i>case:constituents</xd:i> should be
                placed under
                    <xd:b>courtcase:opinions/courtcase:representation/courtcase:arguments/bodytext</xd:b>.
                For example,<xd:ul>
               <xd:li>
                  <xd:i>case:constituents/p</xd:i> becomes
                            <xd:b>courtcase:representation/courtcase:arguments/bodytext/p</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>case:constituents/pgrp</xd:i> becomes <xd:b>
                            courtcase:opinions/courtcase:representation/courtcase:arguments/bodytext/pgrp</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:constituents&gt;
    &lt;p&gt;
        &lt;text&gt;Solicitors: Anderssen Lawyers for the Appellants; McInnes Wilson Lawyers for the Respondent; King &amp;amp; Co Solicitors for the Second to Twelfth Respondents.  MGMW&lt;/text&gt;
    &lt;/p&gt;
&lt;/case:constituents&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:representation&gt;
    &lt;courtcase:arguments&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;Solicitors: Anderssen Lawyers for the Appellants; McInnes Wilson Lawyers for the Respondent; King &amp;amp; Co Solicitors for the Second to Twelfth Respondents.  MGMW&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/courtcase:arguments&gt;
&lt;/courtcase:representation&gt;
           </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:constituents&gt;
    &lt;pgrp&gt;
        &lt;p&gt;
            &lt;text&gt;The course of business was, to the knowledge of all the directors,
                to supply agents with laudatory prospectuses and other documents,
                mostly prepared by &lt;emph typestyle="it"&gt;Feigan&lt;/emph&gt;, to be used
                for the purpose of inducing persons to take shares, and it is no
                defence for a director to say that he allowed this to go on without
                examining the papers to see whether they were honest or
                fraudulent.&lt;/text&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;text&gt;In &lt;emph typestyle="it"&gt;Peek v. Gurney&lt;/emph&gt; the House of Lords,
                though they held that the bill must be dismissed because the
                Plaintiff was not an original allottee of shares, yet expressed an
                opinion that &lt;emph typestyle="it"&gt;Barclay&lt;/emph&gt;, one of the
                directors of &lt;emph typestyle="it"&gt;Overend, Gurney, &amp;amp; Co&lt;/emph&gt;.,
                was liable for the misrepresentations contained in a prospectus, in
                the preparation and issuing of which he had taken no part, and which
                he had never read. As against the company the Plaintiff is entitled,
                upon the pleadings as they stand, to claim rescission of the
                contract to take shares. But, if necessary, we ask leave to
                amend&lt;/text&gt;
        &lt;/p&gt;
        &lt;footnotegrp&gt;
            &lt;footnote fntoken="0"&gt;
                &lt;fnbody&gt;
                    &lt;p&gt;
                        &lt;text&gt;(1) Law Rep. 6 H. L. 377.&lt;/text&gt;
                    &lt;/p&gt;
                &lt;/fnbody&gt;
            &lt;/footnote&gt;
            ...
        &lt;/footnotegrp&gt;
        ...
    &lt;/pgrp&gt;
&lt;/case:constituents&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    &lt;courtcase:representation&gt;
        &lt;courtcase:arguments&gt;
            &lt;bodytext&gt;
                &lt;pgrp&gt;
                    &lt;p&gt;
                        &lt;text&gt;The course of business was, to the knowledge of all the directors,
                            to supply agents with laudatory prospectuses and other documents,
                            mostly prepared by &lt;emph typestyle="it"&gt;Feigan&lt;/emph&gt;, to be used
                            for the purpose of inducing persons to take shares, and it is no
                            defence for a director to say that he allowed this to go on without
                            examining the papers to see whether they were honest or
                            fraudulent.&lt;/text&gt;
                    &lt;/p&gt;
                    &lt;p&gt;
                        &lt;text&gt;In &lt;emph typestyle="it"&gt;Peek v. Gurney&lt;/emph&gt; the House of Lords,
                            though they held that the bill must be dismissed because the
                            Plaintiff was not an original allottee of shares, yet expressed an
                            opinion that &lt;emph typestyle="it"&gt;Barclay&lt;/emph&gt;, one of the
                            directors of &lt;emph typestyle="it"&gt;Overend, Gurney, &amp;#x0026; Co&lt;/emph&gt;.,
                            was liable for the misrepresentations contained in a prospectus, in
                            the preparation and issuing of which he had taken no part, and which
                            he had never read. As against the company the Plaintiff is entitled,
                            upon the pleadings as they stand, to claim rescission of the
                            contract to take shares. But, if necessary, we ask leave to
                            amend&lt;/text&gt;
                    &lt;/p&gt;
                    &lt;p&gt;
                        &lt;text&gt;
                            &lt;footnotegroup&gt;
                                &lt;footnote&gt;
                                    &lt;ref:anchor id="_1234"/&gt;
                                    &lt;bodytext&gt;
                                        &lt;p&gt;
                                            &lt;text&gt;(1) Law Rep. 6 H. L. 377.&lt;/text&gt;
                                        &lt;/p&gt;
                                    &lt;/bodytext&gt;
                                &lt;/footnote&gt;
                                ...
                            &lt;/footnotegroup&gt;
                        &lt;/text&gt;
                    &lt;/p&gt;        
                    ...
                &lt;/pgrp&gt;
            &lt;/bodytext&gt;
        &lt;/courtcase:arguments&gt;
    &lt;/courtcase:representation&gt;
&lt;/courtcase:opinions&gt;
           </xd:pre>
         <!--<section>
            <title>Changes</title>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_case.constituents-LxAdv_courtcase.opinions_courtcase.representation.dita  -->
   <!--  Original Target XPath:  courtcase:opinions/courtcase:representation   -->
   <xsl:template match="case:constituents">
      <courtcase:representation>
         <xsl:for-each select="child::*">
            <xsl:choose>
               <xsl:when test="self::case:constituent">
                  <xsl:apply-templates select="."/>
               </xsl:when>
               <xsl:otherwise>
                  <courtcase:arguments>
                     <bodytext>
                        <xsl:apply-templates select="."/>
                     </bodytext>
                  </courtcase:arguments>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each>
      </courtcase:representation>
   </xsl:template>
   <xd:doc>
      <xd:desc>
         <xd:p>heading not allowed within bodytext; map to h</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="heading[parent::case:constituents]">
      <h>
         <xsl:apply-templates select="@* | node()"/>
      </h>
   </xsl:template>
   <xd:doc>
      <xd:desc>
         <xd:p>Output the children of title within the 'h' created above.</xd:p>
      </xd:desc>
   </xd:doc>
   <xsl:template match="title[not( normalize-space( . ) = '' ) and parent::heading/parent::case:constituents]"
                 priority="1">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="case:constituent"><!--  Original Target XPath:  courtcase:opinions/courtcase:representation/courtcase:counsel   --><!--<xsl:choose>
		    <xsl:when test="child::person">		       
		        <courtcase:counsel>
		        	<!-\- JD: 2017-06-16: removing <person:counselor> wrapper, added by Rosetta_case.constituent_person-LxAdv-person.counselor_person.person.xsl -\->
		            <!-\-<person:counselor>-\->
		                <xsl:apply-templates select="@* | node()"/>
		            <!-\-</person:counselor>-\->		            
		        </courtcase:counsel>
		    </xsl:when>
		    <xsl:otherwise>-->
      <courtcase:counsel>
         <xsl:apply-templates select="@* except @constituenttype | node()"/>
      </courtcase:counsel>
      <!--</xsl:otherwise>
		</xsl:choose>-->
   </xsl:template>
   <!-- <xsl:template match="case:constituents[child::p | child::pgrp]">
       <!-\- <courtcase:opinions>-\->
        <courtcase:representation>
	        <courtcase:arguments>
	            <bodytext>
	                <xsl:apply-templates select="@* | node()"/>
	            </bodytext>
	        </courtcase:arguments>
        </courtcase:representation>
        <!-\-</courtcase:opinions>-\->
    </xsl:template>-->   <!--<xsl:template match="case:judgment">
        
		<!-\-  Original Target XPath:  courtcase:opinions/courtcase:representation/courtcase:counsel   -\->
		<courtcase:opinions>
			<courtcase:representation>
				<courtcase:counsel>
					<xsl:apply-templates select="@* | node()"/>
				</courtcase:counsel>
			</courtcase:representation>
		</courtcase:opinions>
		
	</xsl:template>-->   <!--
	<xsl:template match="person">

		<!-\-  Original Target XPath:  courtcase:opinions/courtcase:representation/courtcase:arguments/bodytext   -\->
		<courtcase:opinions>
			<courtcase:representation>
				<courtcase:arguments>
					<bodytext>
						<xsl:apply-templates select="@* | node()"/>
					</bodytext>
				</courtcase:arguments>
			</courtcase:representation>
		</courtcase:opinions>

	</xsl:template>-->   <!--<xsl:template match="case:constituents/p">

		<!-\-  Original Target XPath:  courtcase:representation/courtcase:arguments/bodytext/p   -\->
		<courtcase:representation>
			<courtcase:arguments>
				<bodytext>
					<p>
						<xsl:apply-templates select="@* | node()"/>
					</p>
				</bodytext>
			</courtcase:arguments>
		</courtcase:representation>

	</xsl:template>

	<xsl:template match="case:constituents/pgrp">

		<!-\-  Original Target XPath:  courtcase:opinions/courtcase:representation/courtcase:arguments/bodytext/pgrp   -\->
		<courtcase:opinions>
			<courtcase:representation>
				<courtcase:arguments>
					<bodytext>
						<pgrp>
							<xsl:apply-templates select="@* | node()"/>
						</pgrp>
					</bodytext>
				</courtcase:arguments>
			</courtcase:representation>
		</courtcase:opinions>

	</xsl:template>-->   <!-- <topicref href="AU01_Rosetta_case.filenum-LxAdv_caseinfo.docketnum.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:courtinfo&gt;
    ...
    &lt;case:filenum&gt;N2003/810&lt;/case:filenum&gt;
    ...
&lt;/case:courtinfo&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;caseinfo:caseinfo&gt;
    ...
    &lt;caseinfo:docketnum&gt;N2003/810&lt;/caseinfo:docketnum&gt;
    ...
&lt;/caseinfo:caseinfo&gt;
       </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.filenum-LxAdv_caseinfo.docketnum.dita#Rosetta_case.filenum-LxAdv_caseinfo.docketnum/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
            </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.filenum-LxAdv_caseinfo.docketnum.dita  -->
   <!--<xsl:message>AU01_Rosetta_case.filenum-LxAdv_caseinfo.docketnum.xsl requires manual development!</xsl:message>-->
   <!--SS: Done "AU01_Rosetta_case.filenum-LxAdv_caseinfo.docketnum"-->
   <xsl:template match="case:filenum">
      <caseinfo:docketnum>
         <xsl:apply-templates select="@* | node()"/>
      </caseinfo:docketnum>
   </xsl:template>
   <!-- <topicref href="../../common_caselaw/Rosetta_prelim-LxAdv_courtcase.prelim.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>prelim</xd:i> becomes <xd:b>courtcase:prelim</xd:b>.</xd:p>
         <xd:p>All children of <xd:i>prelim</xd:i> should be mapped to children of
                    <xd:b>courtcase:prelim/bodytext</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Example: AU content</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:judgments&gt;
    ...
    &lt;prelim&gt;
        &lt;p&gt;
            &lt;text align="right"&gt;&lt;emph typestyle="it"&gt;Cur adv vult&lt;/emph&gt;&lt;/text&gt;
        &lt;/p&gt;
    &lt;/prelim&gt;
    ...
&lt;/case:judgments&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    ...
    &lt;courtcase:prelim&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text align="right"&gt;&lt;emph typestyle="it"&gt;Cur adv vult&lt;/emph&gt;&lt;/text&gt;
            &lt;/p&gt;
        &lt;bodytext&gt;
    &lt;/courtcase:prelim&gt;
    ...
&lt;/courtcase:opinions&gt;
    </xd:pre>
         <xd:p>
            <xd:b>Example: UK content</xd:b>
         </xd:p>
         <xd:pre>
&lt;prelim&gt;
    &lt;pgrp&gt;
        &lt;p&gt;
            &lt;text&gt;3. The factual background to the three claims is set out in
                [17]&amp;#x2013;[29], below. The issues raised on this application are
                described in detail in [30], below. The admissibility and value of
                statements contained in witness statements made by officials is
                considered in [32]&amp;#x2013;[36], below. The admissibility and
                significance of the report of the Parliamentary Joint Committee on
                Human Rights on the new regime is discussed in [37], below.
                Paragraphs [38] and [39], below, explain why it is the current
                effect of the new regime which has to be considered rather than when
                it was enacted.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/pgrp&gt;
&lt;/prelim&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:prelim&gt;
    &lt;bodytext&gt;
        &lt;pgrp&gt;
            &lt;p&gt;
                &lt;text&gt;3. The factual background to the three claims is set out in
                    [17]&amp;#x2013;[29], below. The issues raised on this application are
                    described in detail in [30], below. The admissibility and value of
                    statements contained in witness statements made by officials is
                    considered in [32]&amp;#x2013;[36], below. The admissibility and
                    significance of the report of the Parliamentary Joint Committee on
                    Human Rights on the new regime is discussed in [37], below.
                    Paragraphs [38] and [39], below, explain why it is the current
                    effect of the new regime which has to be considered rather than when
                    it was enacted.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/pgrp&gt;
    &lt;/bodytext&gt;
&lt;/courtcase:prelim&gt;
    </xd:pre>
         <!--<section>
            <title>Changes</title>
            </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_caselaw\Rosetta_prelim-LxAdv_courtcase.prelim.dita  -->
   <xsl:template match="prelim"><!--  Original Target XPath:  courtcase:prelim   -->
      <courtcase:prelim>
         <bodytext>
            <xsl:apply-templates select="@* | node()"/>
         </bodytext>
      </courtcase:prelim>
   </xsl:template>
   <!-- <topicref href="AU01_Rosetta_case.order-LxAdv_courtcase.order.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:order subdoc="true" toc-caption="Orders"&gt;
    &lt;heading&gt;
        &lt;title&gt;Orders&lt;/title&gt;
    &lt;/heading&gt;
    &lt;l&gt;
        &lt;li&gt;
            &lt;lilabel&gt;&lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;&lt;/lilabel&gt;
            &lt;p&gt;
                &lt;text&gt;The plaintiffs&amp;#x2019; application is dismissed.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;lilabel&gt;&lt;emph typestyle="ro"&gt;(2)&lt;/emph&gt;&lt;/lilabel&gt;
            &lt;p&gt;
                &lt;text&gt;The plaintiffs pay the defendant&amp;#x2019;s costs, including each appearance in the court, as taxed, if not agreed.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/li&gt;
    &lt;/l&gt;
&lt;/case:order&gt;
       </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:orders&gt;
    &lt;courtcase:order includeintoc="true" alternatetoccaption="Orders"&gt;
        &lt;heading&gt;
            &lt;title&gt;Orders&lt;/title&gt;
        &lt;/heading&gt;
        &lt;bodytext&gt;
            &lt;list&gt;
                &lt;listitem&gt;
                    &lt;label&gt;&lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;&lt;/label&gt;
                    &lt;bodytext&gt;
                        &lt;p&gt;
                            &lt;text&gt;The plaintiffs&amp;#x2019; application is dismissed.&lt;/text&gt;
                        &lt;/p&gt;
                    &lt;/bodytext&gt;
                &lt;/listitem&gt;
                &lt;listitem&gt;
                    &lt;label&gt;&lt;emph typestyle="ro"&gt;(2)&lt;/emph&gt;&lt;/label&gt;
                    &lt;bodytext&gt;
                        &lt;p&gt;
                            &lt;text&gt;The plaintiffs pay the defendant&amp;#x2019;s costs, including each appearance in the court, as taxed, if not agreed.&lt;/text&gt;
                        &lt;/p&gt;
                    &lt;/bodytext&gt;
                &lt;/listitem&gt;
            &lt;/list&gt;
        &lt;/bodytext&gt;    
    &lt;/courtcase:order&gt;
&lt;/courtcase:orders&gt;
       </xd:pre>
         <!--<section
      conref="../../common_caselaw/conref_content/Rosetta_case.order-LxAdv_courtcase.order.dita#Rosetta_case.order-LxAdv_courtcase.order/changes"/>-->
         <!--<section>
      <title>Changes Specific to AU01</title>
      </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.order-LxAdv_courtcase.order.dita  -->
   <!--<xsl:message>AU01_Rosetta_case.order-LxAdv_courtcase.order.xsl requires manual development!</xsl:message>-->
   <!-- SS: Done - Added instruction for case:order -->
   <xsl:template match="case:order">
      <courtcase:orders>
         <courtcase:order>
            <xsl:choose>
               <xsl:when test="./@subdoc">
                  <xsl:attribute name="includeintoc">
                     <xsl:value-of select="@subdoc"/>
                  </xsl:attribute>
               </xsl:when>
               <xsl:when test="./@toc-caption">
                  <xsl:attribute name="alternatetoccaption">
                     <xsl:value-of select="@toc-caption"/>
                  </xsl:attribute>
               </xsl:when>
            </xsl:choose>
            <xsl:apply-templates select="heading"/>
            <bodytext>
               <xsl:apply-templates select="@* | node() except heading"/>
            </bodytext>
         </courtcase:order>
      </courtcase:orders>
   </xsl:template>
   <!-- <topicref href="AU01_Rosetta_case.appendix-LxAdv_attachments_appendix.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:judgments&gt;
    ...
    &lt;case:appendix&gt;
        &lt;p&gt;
            &lt;text&gt;Attached is a copy of the relevant portion of the judgment of the Supreme&lt;nl/&gt;Court Equity Division in 
                &lt;ci:cite searchtype="CASE-REF"&gt;
                    &lt;ci:content&gt;
                        &lt;citefragment searchtype="CASE-NAME-REF"&gt;&lt;emph typestyle="it"&gt;Massoud v NRMA Insurance Ltd&lt;/emph&gt;&lt;/citefragment&gt;
                    &lt;/ci:content&gt;
                &lt;/ci:cite&gt; referred to at 655
                &lt;ci:cite searchtype="CASE-REF"&gt;
                    &lt;ci:case&gt;
                        &lt;ci:caseinfo&gt;
                            &lt;ci:decisiondate year="2005"/&gt;
                        &lt;/ci:caseinfo&gt;
                        &lt;ci:caseref ID="cr002"&gt;
                            &lt;ci:reporter value="nswlr"/&gt;
                            &lt;ci:volume num="62"/&gt;
                            &lt;ci:page num="653"/&gt;
                        &lt;/ci:caseref&gt;
                        &lt;ci:caseref anaphref="cr002" spanref="cr002-01"&gt;
                            &lt;ci:pinpoint targettype="para" num="7"/&gt;
                        &lt;/ci:caseref&gt;
                    &lt;/ci:case&gt;
                    &lt;ci:content&gt;
                        &lt;citefragment searchtype="CASE-CITE-REF"&gt;
                            &lt;ci:span spanid="cr002-01"&gt;[7]&lt;/ci:span&gt;
                        &lt;/citefragment&gt;
                    &lt;/ci:content&gt;
                &lt;/ci:cite&gt;.
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/case:appendix&gt;
&lt;/case:judgments&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:opinions&gt;
    ...
    &lt;attachments&gt;
        &lt;appendix&gt;
            &lt;bodytext&gt;
                &lt;p&gt;
                    &lt;text&gt;Attached is a copy of the relevant portion of the judgment of the Supreme&lt;proc:nl/&gt;Court Equity Division in 
                        &lt;lnci:cite type="case"&gt;
                            &lt;lnci:content&gt;
                                &lt;emph typestyle="it"&gt;Massoud v NRMA Insurance Ltd&lt;/emph&gt;
                            &lt;/lnci:content&gt;
                        &lt;/lnci:cite&gt; referred to at 655
                        &lt;lnci:cite&gt;
                            &lt;lnci:case&gt;
                                &lt;lnci:caseinfo&gt;
                                    &lt;lnci:decisiondate year="2005"/&gt;
                                &lt;/lnci:caseinfo&gt;
                                &lt;lnci:caseref ID="cr002"&gt;
                                    &lt;lnci:reporter value="nswlr"/&gt;
                                    &lt;lnci:volume num="62"/&gt;
                                    &lt;lnci:page num="653"/&gt;
                                &lt;/lnci:caseref&gt;
                                &lt;lnci:caseref anaphref="cr002"&gt;
                                    &lt;lnci:pinpoint targettype="para" num="7"/&gt;
                                &lt;/lnci:caseref&gt;
                            &lt;/lnci:case&gt;
                            &lt;lnci:content&gt;[7]&lt;/lnci:content&gt;
                        &lt;/lnci:cite&gt;.
                    &lt;/text&gt;
                &lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/appendix&gt;
    &lt;/attachments&gt;
&lt;/courtcase:opinions&gt;
           </xd:pre>
         <xd:p>If <xd:i>case:embeddedcase</xd:i> occurs within
                    <xd:i>case:appendix</xd:i> then conversion need to handle
                    <xd:b>courtcase:caseexcerpt</xd:b> by using
                    <xd:b>bodytext</xd:b> under <xd:b>appendix</xd:b> i.e,
                    <xd:i>case:appendix/case:embeddedcase</xd:i> becomes
                    <xd:b>attachments/appendix/bodytext/courtcase:caseexcerpt</xd:b>
         </xd:p>
         <xd:pre>
&lt;case:appendix&gt;
    &lt;case:embeddedcase id="1980_QD_R_411"&gt;
        &lt;case:content&gt;
            &lt;case:judgments&gt;
                &lt;case:judgment subdoc="true" toc-caption="Judgment 1"&gt;
                    &lt;case:judgmentbody&gt;
                        &lt;p&gt;
                            &lt;text&gt;This was an action...&lt;/text&gt;
                        &lt;/p&gt;
                    &lt;/case:judgmentbody&gt;
                &lt;/case:judgment&gt;
            &lt;/case:judgments&gt;
        &lt;/case:content&gt;
    &lt;/case:embeddedcase&gt;
&lt;/case:appendix&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;attachments&gt;
    &lt;appendix&gt;
        &lt;bodytext&gt;
            &lt;courtcase:caseexcerpt xml:id="_1980_QD_R_411"&gt;
                &lt;courtcase:body&gt;
                    &lt;courtcase:opinions&gt;
                        &lt;courtcase:opinion includeintoc="true" alternatetoccaption="Judgment 1"&gt;
                            &lt;bodytext&gt;
                                &lt;p&gt;
                                    &lt;text&gt;This was an action...&lt;/text&gt;
                                &lt;/p&gt;
                            &lt;/bodytext&gt;
                        &lt;/courtcase:opinion&gt;
                    &lt;/courtcase:opinions&gt;
                &lt;/courtcase:body&gt;    
            &lt;/courtcase:caseexcerpt&gt;
        &lt;/bodytext&gt;
    &lt;/appendix&gt;
&lt;/attachments&gt;
           </xd:pre>
         <xd:p>When <xd:i>sigblock</xd:i> is a child of <xd:i>case:appendix</xd:i> then <xd:i>case:appendix/sigblock/p/text/person/name.text</xd:i> becomes <xd:b>attachments/appendix/bodytext/note/byline/person:person/person:name.text</xd:b>.</xd:p>
         <xd:pre>
&lt;case:appendix&gt;
    &lt;sigblock&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;person&gt;
                    &lt;name.text&gt;David Ritter&lt;/name.text&gt;
                &lt;/person&gt;
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/sigblock&gt;
&lt;/case:appendix&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;attachments&gt;
    &lt;appendix&gt;
        &lt;bodytext&gt;
            &lt;note&gt;
                &lt;byline&gt;
                    &lt;person:person&gt;
                        &lt;person:name.text&gt;David Ritter&lt;/person:name.text&gt;
                    &lt;/person:person&gt;
                &lt;/byline&gt;
            &lt;/note&gt;
        &lt;/bodytext&gt;
    &lt;/appendix&gt;
&lt;/attachments&gt;
           </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.appendix-LxAdv_attachments_appendix.dita#Rosetta_case.appendix-LxAdv_attachments_appendix/changes"/>-->
         <xd:p>
            <xd:b>Changes Specific to AU01</xd:b>
         </xd:p>
         <xd:p>2013-11-12: Added Instruction and example when <xd:i>sigblock</xd:i> is a child of <xd:i>case:appendix</xd:i>: Webstar #: 5093906. This change immediately applies to AU01 Caselaw.</xd:p>
         <xd:p>2012-08-23: Modified example to use an underscore instead of the two digit country
                code for <xd:b>xml:id</xd:b>.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.appendix-LxAdv_attachments_appendix.dita -->
   <!-- SS: Done - case:appendix -->
   <!-- <xsl:template match="case:appendix">
        <attachments>
            <appendix> 
                <xsl:if test="child::heading">
                    <xsl:apply-templates select="heading"/>                   
                </xsl:if>
                <xsl:if test="node() except heading">
                    <bodytext>
                        <xsl:if test="child::case:appendix">
                            <xsl:apply-templates select="case:embeddedcase"/>
                        </xsl:if>
                        <xsl:apply-templates select="@* | node() except heading"/>
                    </bodytext>
                </xsl:if>
            </appendix>
        </attachments>
    </xsl:template>-->
   <!-- Awantika: Updated template for embededcase and sigblock -->
   <xsl:template match="case:appendix">
      <attachments>
         <appendix>
            <xsl:if test="child::heading">
               <xsl:apply-templates select="heading"/>
            </xsl:if>
            <xsl:if test="node() except heading">
               <bodytext>
                  <xsl:if test="child::case:embeddedcase">
                     <xsl:apply-templates select="case:appendix/case:embeddedcase"/>
                  </xsl:if>
                  <xsl:if test="child::sigblock">
                     <note>
                        <byline>
                           <xsl:apply-templates select="descendant::person"/>
                        </byline>
                     </note>
                  </xsl:if>
                  <xsl:apply-templates select="@* | node() except heading except sigblock except case:embeddedcase"/>
               </bodytext>
            </xsl:if>
         </appendix>
      </attachments>
   </xsl:template>
   <!--<xsl:template match="case:appendix[not(child::case:embeddedcase or child::sigblock)]">
		<attachments>
			<appendix>
				<xsl:apply-templates/>
			</appendix>
		</attachments>
	</xsl:template>

	<xsl:template match="case:appendix[child::case:embeddedcase]">
		<attachments>
			<appendix>
				<bodytext>
					<xsl:apply-templates select="@* | node()"/>
				</bodytext>
			</appendix>
		</attachments>
	</xsl:template>


	<xsl:template match="case:appendix[child::sigblock]">
		<attachments>
			<appendix>
				<bodytext>
					<note>
						<byline>
							<person:person xmlns:person="http://www.lexisnexis.com/xmlschemas/content/shared/person/1/">
								<person:name.text>
									<xsl:apply-templates select="@* | node()"/>
								</person:name.text>
							</person:person>
						</byline>
					</note>
				</bodytext>
			</appendix>
		</attachments>
	</xsl:template>-->   <!-- <topicref href="AU01_Rosetta_case.author-LxAdv_courtcase.body_note_byline.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:pre>
&lt;case:author&gt;
    &lt;person&gt;
        &lt;name.text&gt;SAM ROSEWARNE&lt;/name.text&gt;&lt;role&gt;BARRISTER&lt;/role&gt;
    &lt;/person&gt;
&lt;/case:author&gt;
           </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>
&lt;courtcase:body&gt;
    &lt;note&gt;
        &lt;byline&gt;
            &lt;person:contributor contributor-type="author"&gt;
                &lt;person:person&gt;
                    &lt;person:name.text&gt;SAM ROSEWARNE&lt;/person:name.text&gt;
                    &lt;role&gt;BARRISTER&lt;/role&gt;
                &lt;/person:person&gt;
            &lt;/person:contributor&gt;
        &lt;/byline&gt;
    &lt;/note&gt;
&lt;/courtcase:body&gt;
           </xd:pre>
         <!--<section
            conref="../../common_caselaw/conref_content/Rosetta_case.author-LxAdv_courtcase.body_note_byline.dita#Rosetta_case.author-LxAdv_courtcase.body_note_byline/changes"/>-->
         <!--<section>
            <title>Changes Specific to AU01</title>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\AU01_CaseLaw\AU01_Rosetta_case.author-LxAdv_courtcase.body_note_byline.dita  -->
   <!--<xsl:message>AU01_Rosetta_case.author-LxAdv_courtcase.body_note_byline.xsl requires manual development!</xsl:message>-->
   <!--SS: Done - case:author-->
   <!-- Awantika: 2018-03-12- Added <person:contributer>. Updated for webstar  #7137100 -->
   <xsl:template match="case:author">
      <xsl:choose>
         <xsl:when test="child::person">
            <note>
               <byline>
                  <person:contributor>
                     <xsl:attribute name="contributor-type">author</xsl:attribute>
                     <xsl:apply-templates select="@* | node()"/>
                  </person:contributor>
               </byline>
            </note>
         </xsl:when>
         <xsl:otherwise>
            <note>
               <byline>
                  <xsl:apply-templates select="@* | node()"/>
               </byline>
            </note>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_desig-LxAdv-desig_ref.para.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Applicable only on AU01, AU13, NZ03, CA01, CA04 and CA10.</xd:b>
         </xd:p>
         <xd:p>When source document is having <xd:i>desig</xd:i> then
                    <xd:i>desig</xd:i> becomes <xd:b>desig/ref:para</xd:b>.</xd:p>
         <xd:p>Value of <xd:i>desig@value</xd:i> becomes both <xd:b>desig@value</xd:b> and <xd:b>desig/ref:para@num</xd:b>.</xd:p>
         <xd:p>Value of <xd:b>ref:para/@para-scheme</xd:b> is
                    <xd:i>ci:reporter</xd:i> value from (<xd:b>
               <xd:i>first</xd:i>
            </xd:b>)
                    <xd:i>ci:cite/[@type=cite4thisdoc]/ci:case/ci:caseref/ci:reporter</xd:i>.</xd:p>
         <xd:p>
            <xd:b>ref:para/@para-scheme-type="reporter-abbrev"</xd:b> is hardcoded
                value.</xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;desig value="5"&gt;5&lt;/desig&gt;
    &lt;text&gt;...&lt;/text&gt;
&lt;/p&gt;

<xd:b>and</xd:b>

&lt;case:reportercite&gt;
    &lt;ci:cite type="cite4thisdoc"&gt;
        &lt;ci:case&gt;
            &lt;ci:caseinfo&gt;
                &lt;ci:decisiondate year="1974" /&gt;
            &lt;/ci:caseinfo&gt;
            &lt;ci:caseref&gt;
                &lt;ci:reporter value="IPR" /&gt;
                &lt;ci:volume num="1a"&gt;&lt;/ci:volume&gt;
                &lt;ci:edition&gt;
                    &lt;ci:date year="1974" /&gt;
                &lt;/ci:edition&gt;
                &lt;ci:page num="511" /&gt;
            &lt;/ci:caseref&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;
            &lt;citefragment searchtype="CASE-CITE-REF"&gt;(1974) 1a IPR 511&lt;/citefragment&gt;
        &lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:reportercite&gt;

<xd:b>Becomes</xd:b>

&lt;p&gt;
    &lt;desig value="5"&gt;&lt;ref:para num="5" para-scheme="IPR" para-scheme-type="reporter-abbrev"&gt;5&lt;/ref:para&gt;&lt;/desig&gt;
    &lt;text&gt;...&lt;/text&gt;
&lt;/p&gt;
</xd:pre>
         <!--Changes2014-09-03: The same rule is applicable on CA10.2014-09-03: The same rule is applicable on CA01 and CA04.2014-08-29: Updated instruction and example for handling
                        desig/@value and it's mapped with
                        desig@value/ref:para@num (means
                        ref:para should be placed inside of
                        desig markup).2014-08-04: Updated instruction for @para-scheme and @para-scheme-type attribute.2014-08-01: Created, this immediately applies to AU01, AU13 and NZ03.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_desig-LxAdv-desig_ref.para.dita  -->
   <xsl:template match="desig"><!--  Original Target XPath:  desig/ref:para   -->
      <xsl:choose>
         <xsl:when test="$streamID=('AU01', 'NZ03', 'CA01','CA04')">
            <desig>
               <xsl:attribute name="value">
                  <xsl:value-of select="@value"/>
               </xsl:attribute>
               <ref:para>
                  <xsl:attribute name="num">
                     <xsl:value-of select="@value"/>
                  </xsl:attribute>
                  <xsl:attribute name="para-scheme">
                     <xsl:value-of select="(//ci:cite/ci:case/ci:caseref/ci:reporter/@value)[1]"/>
                  </xsl:attribute>
                  <xsl:attribute name="para-scheme-type">
                     <xsl:text>reporter-abbrev</xsl:text>
                  </xsl:attribute>
                  <xsl:apply-templates select="@* | node()"/>
               </ref:para>
               <!-- Awantika: Duplicate ref:para if case:courtcite/ci:cite/@type="cite4thisdoc" in AU01 -->
               <xsl:if test="$streamID='AU01' and //case:courtcite[ci:cite[@type='cite4thisdoc']]">
                  <ref:para>
                     <xsl:attribute name="num">
                        <xsl:value-of select="@value"/>
                     </xsl:attribute>
                     <xsl:attribute name="para-scheme">
                        <xsl:value-of select="(//ci:au/@courtcode)[1]"/>
                     </xsl:attribute>
                     <xsl:attribute name="para-scheme-type">
                        <xsl:text>reporter-abbrev</xsl:text>
                     </xsl:attribute>
                  </ref:para>
               </xsl:if>
            </desig>
         </xsl:when>
         <xsl:when test="$streamID=('AU13','HK09')">
            <xsl:choose>
               <xsl:when test="parent::heading[parent::case:body]">
                  <desig>
                     <xsl:value-of select="."/>
                  </desig>
               </xsl:when>
               <xsl:otherwise>
                  <desig>
                     <xsl:attribute name="value">
                        <xsl:value-of select="@value"/>
                     </xsl:attribute>
                     <ref:para>
                        <xsl:attribute name="num">
                           <xsl:value-of select="@value"/>
                        </xsl:attribute>
                        <xsl:attribute name="para-scheme">
                           <xsl:value-of select="(//ci:cite/ci:case/ci:caseref/ci:reporter/@value)[1]"/>
                        </xsl:attribute>
                        <xsl:attribute name="para-scheme-type">
                           <xsl:text>reporter-abbrev</xsl:text>
                        </xsl:attribute>
                        <xsl:apply-templates select="@* | node()"/>
                     </ref:para>
                  </desig>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
      </xsl:choose>
   </xsl:template>
   <!-- end topichead  CaseContent  -->   <!-- start topichead  Metadata  -->   <!-- rosetta element: docinfo -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo-LxAdv-doc.metadata_doc.docinfo.dita"/> -->   <!-- *****************************************************************************
	this template uses a global $dpsi parameter that should be placed in the 
	stream driver file as:
	
		<xsl:param name="dpsi" as="xs:string" select=" 'From LBU Manifest File' "/>
	
    this parameter can be used in any module in your stream.  Do not add 
    it as a variable or parameter in this file to avoid conflicts.
	*******************************************************************************	
	
	-->   <!--<xsl:variable name="dpsi"/>-->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>docinfo</xd:i> becomes <xd:b>doc:metadata/doc:docinfo</xd:b>.
								<xd:i>docinfo:dpsi[@id-string]</xd:i>, <xd:i>docinfo[@browseprev]</xd:i>,
								<xd:i>docinfo[@browsenext]</xd:i>, <xd:i>docinfo[@partitionnum]</xd:i>,
								<xd:i>docinfo[@majorrevision]</xd:i>, and <xd:i>docinfo[@excludefromalerts]</xd:i>
							become <xd:b>doc:metadata/doc:docinfo/doc:legacy-metadata</xd:b> with attribute
								<xd:b>doc:legacy-metadata[@metadatasource="lbu-meta"]</xd:b> with child elements: <xd:ul>
                     <xd:li>Create <xd:b>meta</xd:b> and <xd:b>metaitem</xd:b> with attributes
										<xd:b>@name</xd:b> and <xd:b>@value</xd:b>. </xd:li>
                     <xd:li>If document also contains an element <xd:i>docinfo:lbu-meta</xd:i> with child elements
									that are not explicitly dropped, include each metaitem after all of the <xd:i>docinfo</xd:i>
									attributes are placed here. See Example <xd:i>docinfo</xd:i> and
										<xd:i>docinfo:lbu-meta</xd:i> below. </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo partitionnum="2"&gt; &lt;docinfo:dpsi id-string="006F"&gt; .................
					................. &lt;/docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:metadata&gt; &lt;doc:docinfo doc-content-country="AU"&gt; &lt;dc:metadata&gt; ...... ......
					&lt;/dc:metadata&gt; &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; &lt;metaitem
					name="partitionnum" value="2"/&gt; &lt;metaitem name="dpsi" value="006F"/&gt; &lt;/meta&gt;
					&lt;/doc:legacy-metadata&gt; &lt;/doc:docinfo&gt; &lt;/doc:metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo browseprev="true" browsenext="true" majorrevision="false" excludefromalerts="true"&gt;
					................. ................. &lt;/docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:metadata&gt; &lt;doc:docinfo doc-content-country="AU"&gt; &lt;dc:metadata&gt; ...... ......
					&lt;/dc:metadata&gt; &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; &lt;metaitem
					name="browseprev" value="true"/&gt; &lt;metaitem name="browsenext" value="true"/&gt; &lt;metaitem
					name="majorrevision" value="false"/&gt; &lt;metaitem name="excludefromalerts" value="true"/&gt; &lt;/meta&gt;
					&lt;/doc:legacy-metadata&gt; &lt;/doc:docinfo&gt; &lt;/doc:metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo partitionnum="1"&gt; ................. ................. &lt;/docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:metadata&gt; &lt;doc:docinfo doc-content-country="CA"&gt; &lt;dc:metadata&gt; ...... ......
					&lt;/dc:metadata&gt; &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; &lt;metaitem
					name="partitionnum" value="1"/&gt; &lt;/meta&gt; &lt;/doc:legacy-metadata&gt; &lt;/doc:docinfo&gt;
					&lt;/doc:metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Example docinfo and docinfo:lbu-meta - Target</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt; &lt;meta&gt; &lt;metaitem name="browsenext"
					value="false"/&gt; &lt;metaitem name="browseprev" value="false"/&gt; &lt;metaitem name="majorrevision"
					value="false"/&gt; &lt;metaitem name="excludefromalerts" value="true"/&gt; &lt;metaitem name="partitionnum"
					value="COMM1"/&gt; &lt;metaitem name="lbu-sourcename" value="Business Law Emerging Issues"/&gt; &lt;metaitem
					name="document-type" value="Emerging Issue"/&gt; &lt;metaitem name="filename" value="BusLaw_EI_1850.xml"/&gt;
					&lt;/meta&gt; &lt;/doc:legacy-metadata&gt; </xd:pre>
         <xd:p>
            <xd:b>Create Required <xd:b>dc:metadata</xd:b> Element</xd:b>
         </xd:p>
         <xd:p>The element <xd:b>dc:metadata</xd:b> is the first required child element of
						<xd:b>doc:metadata/doc:docinfo</xd:b>. As such, <xd:b>dc:metadata</xd:b> should be
					created immediately after creating <xd:b>doc:metadata/doc:docinfo</xd:b>.</xd:p>
         <xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>
               <xd:p>In addition, as part of workflow processing , ICCE will provide LNI values for each document. This PCDATA
							value will be mapped to the following:</xd:p>
               <xd:ul>
                  <xd:li>
                     <xd:b>dc:identifier[@lnmeta:identifier-scheme="LNI"]</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:b>dc:identifier[@lnmeta:identifier-scheme="PGUID"]</xd:b>
                  </xd:li>
               </xd:ul>
               <xd:p>The LNI value for <xd:b>dc:identifier[@lnmeta:identifier-scheme="PGUID"]</xd:b>will include the
							"urn:contentItem" namespace prefix.</xd:p>
            </xd:p>
         </xd:p>
         <xd:ul>
            <xd:li>
               <xd:p>Create <xd:b>dc:date[@lnmeta:datetype="conversion-date"]</xd:b>. This element will contain the
							date the output file was created during conversion. </xd:p>
               <xd:p>
                  <xd:b>Note: </xd:b>The format of the content of all <xd:b>dc:date</xd:b> elements must be in
							'YYYY-MM-DD'.</xd:p>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>LNI Values from ICCE</xd:b>
         </xd:p>
         <xd:pre> &lt;dc:identifier
					lnmeta:identifier-scheme="LNI"&gt;5617-TBH1-67MJ-64K7-00000-00&lt;/dc:identifier&gt; &lt;dc:identifier
					lnmeta:identifier-scheme="PGUID"&gt;urn:contentItem:5617-TBH1-67MJ-64K7-00000-00&lt;/dc:identifier&gt;
				</xd:pre>
         <xd:p>
            <xd:b>dc:date[@lnmeta:datetype="conversion-date"]</xd:b>
         </xd:p>
         <xd:pre> &lt;dc:metadata&gt; ... &lt;dc:date lnmeta:datetype="conversion-date"&gt;2013-08-07&lt;/dc:date&gt;
					... &lt;/dc:metadata&gt; </xd:pre>
         <!--Changes2017-03-15: Added dc:identifier[@lnmeta:identifier-scheme =
							"LNI"] and dc:identifier[@lnmeta:identifier-scheme = "PGUID"] to
						XSLT.2015-04-14: Remove bullet icon in sub nested list for handling Indentation
						isssue.2013-08-09: Added instruction for creating
							dc:date[@lnmeta:datetype="conversion-date"]. Previously, "conversion-date" was
						created only if "load-date" was not present. Going forward, conversion should always create
						"conversion-date". This is not a retroactive change. It should be applied only to streams developed after
						Aug. 9 2013.2013-07-18: Added @excludefromalerts as one of the
							docinfo attributes to carry through. Also added
						@majorrevision to the narrative; already present in a target sample.2013-05-16: Fixed typo updating urn:contentitem to
					urn:contentItem2013-04-08: Removed instructions for 3.5 conversion as no longer applicable and to avoid confusion.2012-11-28: Added instructions for 3.5 conversion and 4.0 conversion.2012-10-05: Added instructions for consolidation of attributes from docinfo and content from lbu-meta from
					source into a single doc:legacy-metadata grouping.2012-09-06: Created. -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo-LxAdv-doc.metadata_doc.docinfo.dita  -->
   <!-- CSN: Created docinfo and children from base.xsl -->
   <!-- this template processes all the content that goes into doc:docinfo. -->
   <xsl:template match="docinfo">
      <doc:docinfo><!--   add attribute doc-content-country   --><!--Satbir: Added hardcore value inside attribute @doc-country-code only for HK-->
         <xsl:choose>
            <xsl:when test="starts-with($streamID, 'HK')">
               <xsl:attribute name="doc-content-country" select="'HK'"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:call-template name="doc_content_country"/>
            </xsl:otherwise>
         </xsl:choose>
         <dc:metadata>
            <dc:identifier lnmeta:identifier-scheme="LNI">0000-0000-0000-0000-00000-00</dc:identifier>
            <dc:identifier lnmeta:identifier-scheme="PGUID">urn:contentItem:0000-0000-0000-0000-00000-00</dc:identifier>
            <xsl:apply-templates select="docinfo:load-date"/>
            <dc:date lnmeta:datetype="conversion-date">
               <xsl:value-of select="format-date(current-date(), '[Y0001]-[M01]-[D01]')"/>
            </dc:date>
            <xsl:apply-templates select="/COMMENTARYDOC/comm:info/pubdate" mode="dc.metadata"/>
            <!-- PLEASE DO NOT REMOVE UK-SPECIFIC CONDITIONS  -->
            <xsl:if test="starts-with($streamID, 'UK')">
               <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name = ('editorialPublishedDate', 'createdDate', 'updatedDate')]"/>
            </xsl:if>
            <!-- 20170623:  MCJ:  Removed AU06 from this list in preference to using modules/docinfo/Rosetta_docinfo.doc-id-LxAdv-dcidentifier_lnmetaidentifier-scheme.xsl. -->
            <!--  WPK 2017-11-06.  Due to webstar, all of the following streams must now use modules\docinfo\Rosetta_docinfo.doc-id-LxAdv-dcidentifier_lnmetaidentifier-scheme.xsl
				http://webstar.reedelsevier.com/WebStarWebApp/incident/viewIncident.do?incTktNum=7041473
				Also, streams need to remove any stream empty template that would conflict, i.e. <xsl:template match=docinfo:doc=id/>.  
				<xsl:if test="$streamID = ('AU10', 'AU13', 'AU16', 'AU17', 'AU19-CA', 'NZ14', 'NZ02', 'AU09', 'NZ10','HK09','AU19_CC')">
					<xsl:if test="docinfo:doc-id">
						<dc:identifier lnmeta:identifier-scheme="DOC-ID">
							<xsl:value-of select="docinfo:doc-id"/>
						</dc:identifier>
					</xsl:if>
				</xsl:if>
				
				<xsl:if test="$streamID=('NZ07-DN', 'NZ07DC','AU14','NZ08')">
					<xsl:if test="docinfo:doc-id">
						<dc:identifier lnmeta:identifier-scheme="DOC-ID">
							<xsl:value-of select="docinfo:dpsi/@id-string"/>
							<xsl:text>-</xsl:text>
							<xsl:value-of select="docinfo:doc-id"/>
						</dc:identifier>
					</xsl:if>
				</xsl:if>
				-->
            <!-- Sudhanshu Srivastava: Added condition for CA03 to convert leg:officialname,leg:num to dc:title -->
            <xsl:if test="$streamID = 'CA03'">
               <xsl:choose>
                  <xsl:when test="following-sibling::source_cttr:body/leg:info/leg:officialname">
                     <xsl:apply-templates select="following-sibling::source_cttr:body/leg:info/leg:officialname"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:apply-templates select="following-sibling::source_cttr:body/case:headnote/case:info/case:casename"
                                          mode="dc.title"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:if>
            <xsl:apply-templates select="docinfo:doc-heading | docinfo:doc-id"/>
            <!-- JD: 2017-10-10: VSTS Bug 352379: use docinfo:doc-heading for dc:title for UK01 -->
            <!-- CN: 2017-10-13: VSTS Bug 352379: use docinfo:doc-heading for dc:title added UK02 and UK04 -->
            <xsl:if test="$streamID = ('UK01','UK02','UK04')">
               <dc:title>
                  <xsl:value-of select="/CASEDOC/docinfo/docinfo:doc-heading"/>
               </dc:title>
            </xsl:if>
            <!-- JD: UK01-UK04: case:casename to dc:title (id-CCCC-10531) -->
            <!--
				<xsl:if test="$streamID = ('UK02','UK04')">
				  <dc:title>
  				  <xsl:value-of select="concat(/CASEDOC/case:body/case:headnote/case:info/case:casename, ' ',/CASEDOC/case:body/case:headnote/case:info/case:reportercite/ci:cite[@type='cite4thisdoc']/ci:content)"/>
				  </dc:title>
				</xsl:if>
				-->
            <!-- CN: 2017-10-13: VSTS Bug 352379: use docinfo:doc-heading for dc:title for UK03 -->
            <xsl:if test="$streamID='UK03'">
               <dc:title>
                  <xsl:value-of select="/DIGESTDOC/docinfo/docinfo:doc-heading"/>
               </dc:title>
            </xsl:if>
            <!-- same as above, but different mode name -->
            <!--<xsl:if test="$streamID = ('UK04')">
					<xsl:apply-templates select="/CASEDOC/case:body/case:headnote/case:info/case:casename[$streamID='UK04']" mode="title"/>
				</xsl:if>-->
            <!-- JD: UK05: case:casename to dc:title (id-UK05-27824) -->
            <xsl:if test="$streamID = 'UK05'">
               <xsl:apply-templates select="/CITATORDOC/source_cttr:body/case:headnote/case:info/case:casename | /CITATORDOC/source_cttr:body/case2:headnote/case2:info/case2:casename"
                                    mode="dc.metadata"/>
            </xsl:if>
            <xsl:apply-templates select="docinfo:authorattribution"/>
            <!--  @@@ TODO:  update DITA to match this code!!!  -->
            <!-- Awantika: Removed /CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:juris from apply templates as this was creating unnecessary content(hkhk) mapping needs to be converted to <dc:coverage> in HK03 -->
            <xsl:choose>
               <xsl:when test="starts-with($streamID, 'CA08')">
                  <xsl:apply-templates select="         /CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:juris |         /CITATORDOC/source_cttr:body/case:headnote/case:info/case:courtinfo/case:juris"
                                       mode="metadata"/>
               </xsl:when>
               <xsl:when test="$streamID = ('CA01', 'CA03', 'CA02CC','CA02DC', 'CA06', 'CA05', 'CA04', 'CA07','UK03','UK07','UK06', 'NZ07DN','NZ13')"/>
               <xsl:when test="$streamID='AU12'">
                  <xsl:apply-templates select="/DIGESTDOC/dig:body/dig:info/leg:info/leg:juris"
                                       mode="metadata"/>
               </xsl:when>
               <xsl:when test="$streamID='NZ10'">
                  <xsl:apply-templates select="/LEGDOC/leg:body/leg:info/leg:juris" mode="metadata"/>
               </xsl:when>
               <xsl:when test="$streamID='CA19'">
                  <xsl:apply-templates select="/CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:juris"
                                       mode="metadata"/>
               </xsl:when>
               <xsl:otherwise><!--*********************
							Paul:  for AU08 this otherwise clause is applicable as is unedited.
							It creates dc:coverage/location:state because I have a stream specific "metadata" mode template for leg:juris.
							I've changed nothing here.  just noting that i'm leveraging this for AU08 court orders too.
							***************************--><!-- Awantika: added xpath /CITATORDOC/source_cttr:body/leg:info/leg:juris for AU20 --><!--Satbir: Added Xpath "/DIGESTDOC/dig:body/dig:info/case:info/case:courtinfo/case:juris" for NZ07DC--><!--Satbir: Mentioned first position for jursi handling "case:courtinfo[1]/case:juris" because juris comes twicely--><!-- Awantika:2017-10-17- Added not(streamID='AU01') to /CASEDOC/case:body/case:headnote/case:info/case:courtinfo[1]/case:juris as this was creating data outside identifier. --><!-- Awantika:2017-10-31- Removed not(streamID='AU01') to /CASEDOC/case:body/case:headnote/case:info/case:courtinfo[1]/case:juris data given was for NZ so changed back for AU01 -->
                  <xsl:apply-templates select="         /CASEDOC/case:body/case:headnote/case:info/case:courtinfo[1]/case:juris |         /LEGDOC/leg:body/leg:info/leg:juris | /CITATORDOC/source_cttr:body/leg:info/leg:juris |         /CITATORDOC/source_cttr:body/case:headnote/case:info/case:courtinfo/case:juris |         /CITATORDOC/source_cttr:body/case2:headnote/case2:info/case2:courtinfo/case2:juris | /DIGESTDOC/dig:body/dig:info/case:info/case:courtinfo/case:juris"
                                       mode="metadata"/>
               </xsl:otherwise>
            </xsl:choose>
            <!-- Awantika: case:juris will also be converted to <dc:coverage> in HK03  -->
            <!--<xsl:if test="/CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:juris and $streamID = 'HK03'">
					<dc:coverage>
						<location:country>
							<xsl:attribute name="codescheme">
								<xsl:text>ISO-3166-1</xsl:text>
							</xsl:attribute>
							<xsl:attribute name="countrycode">
								<xsl:text>HK</xsl:text>
							</xsl:attribute>
						</location:country>
					</dc:coverage>
				</xsl:if>-->
            <xsl:apply-templates select="/COMMENTARYDOC/comm:info [$streamID='USLPA']"
                                 mode="person_contributor"/>
            <xsl:if test="$streamID=('UK06','UK07')">
               <dc:coverage>
                  <location:country>
                     <xsl:attribute name="codescheme">
                        <xsl:text>ISO-3166-1</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="countrycode">
                        <xsl:text>GB</xsl:text>
                     </xsl:attribute>
                  </location:country>
               </dc:coverage>
            </xsl:if>
         </dc:metadata>
         <xsl:apply-templates select="docinfo:versioninfo[@hasotherversions='true'][$streamID='CA05']"
                              mode="doc_version"/>
         <xsl:apply-templates select="/LEGDOC/docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name = 'actFirstDoc'][contains(upper-case(.), 'TRUE')][$streamID='CA05']"
                              mode="firstActDoc"/>
         <xsl:apply-templates select="/COMMENTARYDOC/comm:info/classification [$streamID='USLPA']"
                              mode="metadata_classification"/>
         <xsl:apply-templates select="docinfo:custom-metafields [$streamID='USLPA']"
                              mode="metadata_custom"/>
         <!-- Sudhanshu Srivastava:
			     Created on - 28-06-2017.
			     Comments : The below condition will create classify:classification inside doc:docinfo based on if input source having (docinfo:custom-metafield name="is-first-document-in-enactment") or (docinfo:custom-metafield name="is-last-document-in-enactment").
			-->
         <xsl:if test="($streamID=('UK06','UK07')) and (docinfo:custom-metafields/docinfo:custom-metafield[@name='is-first-document-in-enactment'] or docinfo:custom-metafields/docinfo:custom-metafield[@name='is-last-document-in-enactment'])">
            <classify:classification classscheme="actDocumentOrder">
               <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name='is-first-document-in-enactment']"
                                    mode="isfirstdocumentinenactment"/>
               <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name='is-last-document-in-enactment']"
                                    mode="islastdocumentinenactment"/>
            </classify:classification>
         </xsl:if>
         <!-- MDS - 2017-06-27 - For NZ07DN -->
         <xsl:if test="$streamID='NZ07-DN'">
            <xsl:apply-templates select="/DIGESTDOC/dig:body/dig:info/jrnl:articleinfo/pubnote[remotelink]"/>
         </xsl:if>
         <!-- process that belong in doc:docinfo -->
         <!--  @@@ TODO:  update DITA to match this code!!!  -->
         <!-- Sudhanshu Srivastava: in CA13 stream , i have no need to transform here 'docinfo:hier', so i am making changes for sequencing of 
			docinfo:heir-->
         <xsl:if test="not($streamID = 'CA13')">
            <xsl:apply-templates select="docinfo:hier"/>
         </xsl:if>
         <!-- Priya Kaushal : Added below for the stream UK15 -->
         <xsl:apply-templates select="classification[$streamID='UK15']"/>
         <!--	<xsl:if test = "$streamID='UK15'">
				<xsl:if test="./classification">
					<classify:classification>
						<xsl:attribute name="classscheme">
							<xsl:value-of select="./classification/@classscheme"/>
						</xsl:attribute>
						<xsl:for-each select="./classification/classitem">
							<classify:classitem>
								<xsl:attribute name="classscheme">
									<xsl:value-of select="./classification/classitem/@classscheme"/>
								</xsl:attribute>
								<meta>
									<metaitem name="appliedby" value="human"/>
								</meta>
								<topic:topicReference xmlns:topic="urn:x-lexisnexis:content:topic:global:1"
									xmlns:guid="urn:x-lexisnexis:content:guid:global:1">
									<xsl:attribute name="guid:guid">
									<xsl:value-of select="./classitem-identifier/classcode/@normval"/>
								</xsl:attribute>
								</topic:topicReference>
							</classify:classitem>
						</xsl:for-each>
						
						</classify:classification>	
				</xsl:if>				
			</xsl:if>
			-->
         <xsl:apply-templates select="//case:reportercite[$streamID=('CA01','CA04')]"
                              mode="docrelated-content"/>
         <!-- Vikas Rohilla : Added for the stream CA01 -->
         <xsl:apply-templates select="//refnum[@refnumtype = 'UCN'][$streamID = ('CA01', 'CA02CC', 'CA02DC', 'CA19', 'CA02DS','CA04')]"
                              mode="docinfoMember"/>
         <xsl:apply-templates select="docinfo:doc-id[$streamID='CA03']" mode="membership"/>
         <xsl:apply-templates select="docinfo:bookseqnum"/>
         <xsl:apply-templates select="docinfo:alt-renditions"/>
         <!-- Awantika: Added for UK11 -->
         <xsl:choose>
            <xsl:when test="$streamID='UK11DA'">
               <xsl:apply-templates select="following-sibling::dig:body/dig:info/dig:subject[@display-name='Jurisdiction']"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="//dig:body/dig:info/dig:subject"/>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:call-template name="legacy-metadata"/>
         <!-- Sudhanshu Srivastava : transforming 'docinfo:hier' here for making sequence correct for CA13 stream. -->
         <xsl:if test="$streamID = 'CA13'">
            <xsl:apply-templates select="docinfo:hier"/>
         </xsl:if>
         <xsl:if test="$streamID = 'CA03' and following-sibling::source_cttr:body/leg:info/leg:relatedleg">
            <xsl:apply-templates select="following-sibling::source_cttr:body/leg:info/leg:relatedleg"
                                 mode="relatedcon"/>
         </xsl:if>
         <xsl:apply-templates select="docinfo:topiccodes"/>
         <xsl:apply-templates select="//case:headnote/case:length"/>
         <xsl:apply-templates select="docinfo:assoc-links"/>
         <!-- Sudhanshu added an applied template for  -->
         <xsl:apply-templates select="docinfo:changemanagementcode"/>
         <!-- process all docinfo:selector elements in the same wrapper -->
         <xsl:if test="docinfo:selector">
            <classify:classification classscheme="selector">
               <xsl:apply-templates select="docinfo:selector"/>
            </classify:classification>
         </xsl:if>
         <!-- CSN - 2017/09/26 - added parenthesis so this classification does not show up in every stream -->
         <xsl:if test="$streamID='AU18' and (parent::LEGDOC[@legtype='misc-inst'] or contains(child::docinfo:selector/text(), 'misc-inst'))">
            <classify:classification classscheme="au.admindoctype">
               <classify:classitem>
                  <classify:classitem-identifier>
                     <classify:classname>
                        <xsl:text>miscellaneous-instrument</xsl:text>
                     </classify:classname>
                  </classify:classitem-identifier>
               </classify:classitem>
            </classify:classification>
         </xsl:if>
         <!-- CSN 2017-11-15 Added UK18 to accomodate docinfo/classification needed for Quantum Stub documents. VSTS Bug 402801. -->
         <xsl:apply-templates select="classification[$streamID=('UK13','UK18')]"/>
         <xsl:apply-templates select="docinfo:topiccodes[$streamID='NZ10']"/>
         <xsl:apply-templates select="/LEGDOC/@legtype[$streamID='NZ12']" mode="NZClassify"/>
         <xsl:if test="/COMMENTARYDOC/docinfo/docinfo:lbu-meta/docinfo:metaitem[@name = 'PA-PGUID' or @name = 'TOPIC-PGUID' or @name = 'SUB-TOPIC-PGUID']">
            <classify:classification-grp classscheme="ln.indexing-terms">
               <classify:classification classscheme="ln.legal">
                  <xsl:apply-templates select="/COMMENTARYDOC/docinfo/docinfo:lbu-meta/docinfo:metaitem[@name = 'PA-PGUID' or @name = 'TOPIC-PGUID' or @name = 'SUB-TOPIC-PGUID']"
                                       mode="classify"/>
               </classify:classification>
            </classify:classification-grp>
         </xsl:if>
         <!-- PLEASE DO NOT REMOVE UK-SPECIFIC CONDITIONS  -->
         <xsl:if test="starts-with($streamID, 'UK') and (@majorrevision or @excludefromalerts or docinfo:custom-metafields/docinfo:custom-metafield[@name = ('important', 'highlightFrequency', 'inEditorialReview', 'resultType', 'word-toc', 'isDocBuilderAvailable', 'isCorePrecedent')])">
            <xsl:apply-templates select="." mode="UKClassify"/>
         </xsl:if>
         <xsl:if test="//page">
            <xsl:variable name="pageList" select="//page"/>
            <doc:pagination>
               <xsl:for-each-group select="$pageList" group-by="@reporter">
                  <doc:pagination-scheme>
                     <xsl:if test="@reporter!=''">
                        <xsl:attribute name="page-scheme">
                           <xsl:value-of select="translate(@reporter,' ','_')"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:attribute name="page-scheme-type">reporter-abbreviation</xsl:attribute>
                  </doc:pagination-scheme>
               </xsl:for-each-group>
            </doc:pagination>
         </xsl:if>
         <xsl:apply-templates select="/LEGDOC/@legtype[$streamID = ('AU19LA', 'AU15')]"
                              mode="AUClassify"/>
         <xsl:apply-templates select="docinfo:currencystatement"/>
         <xsl:apply-templates select="docinfo:keywords[$streamID = 'UK15_DS']"/>
         <!--pawan: added to create  classify:classification[@classscheme="keywords"] from docinfo:keywords-->
         <xsl:apply-templates select="docinfo:lbu-indexing-terms"/>
         <xsl:apply-templates select="docinfo:lbu-subj"/>
         <xsl:apply-templates select="docinfo:lbu-juris"/>
         <xsl:apply-templates select="docinfo:overview"/>
         <xsl:apply-templates select="docinfo:versioninfo[$streamID != 'CA05']"/>
         <!-- Vikas Rohilla : Apply template for the streamID UK11DA					-->
         <!-- Awantika: Apply template for UK11DN -->
         <xsl:apply-templates select="classification[$streamID=('UK11DA','UK11DN','UK03')]"/>
         <!-- Vikas Rohilla : Updated the template for the highlight becomes doc:overview -->
         <xsl:apply-templates select="//dig:info/highlight[not(preceding-sibling::highlight)][$streamID = 'CA14']"
                              mode="doc-overview"/>
         <xsl:apply-templates select="//row/entry[@colname = 'col1'][matches(., 'SUBJECTS/SUJETS:') or matches(., 'Subjects\\Sujets:')][$streamID = 'CA11']"
                              mode="highlights"/>
         <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name = 'actFirstDoc'][contains(., 'true')][($streamID = 'CA06') or ($streamID = 'CA07')or ($streamID = 'CA08')]"
                              mode="classify"/>
         <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name='act-id' or @searchtype='act-id'][($streamID = 'CA08') or ($streamID = 'CA07')]"
                              mode="doc_membership"/>
         <xsl:apply-templates select="docinfo:versioninfo/docinfo:versionbranch[$streamID = ('CA05', 'CA06', 'CA08')]"
                              mode="member"/>
         <xsl:apply-templates select="docinfo:custom-metafields/docinfo:custom-metafield[@name = 'act-id'][$streamID = ('CA06')]"
                              mode="membership"/>
         <xsl:apply-templates select="following::ci:content[$streamID = ('CA06', 'CA07')]"
                              mode="doc-related"/>
         <xsl:apply-templates select="following::leg:num[not(starts-with(.,'solsak'))][$streamID = ('CA08')]"
                              mode="doc_related_content-alt-lang"/>
         <xsl:apply-templates select="following::leg:num[1][$streamID=('CA05', 'CA07')]"
                              mode="doc-related-content-alt-lang"/>
         <xsl:apply-templates select="following::leg:officialnum[1][not(child::ci:cite)][not(preceding-sibling::leg:num[child::ci:cite])][$streamID = ('CA06')]"
                              mode="doc_related_content_officialnum"/>
         <xsl:apply-templates select="/LEGDOC/leg:body[child::leg:level][$streamID = ('CA06', 'CA07', 'CA08')]"
                              mode="metadata"/>
         <xsl:apply-templates select="/LEGDOC/leg:body[$streamID = ('CA05')]"
                              mode="doc_overview_bills"/>
         <xsl:apply-templates select="/COMMENTARYDOC/comm:body[$streamID = 'CA10']"
                              mode="overviewmeta"/>
         <xsl:apply-templates select="/COMMENTARYDOC/comm:body[$streamID = 'CA09']"
                              mode="doc_overview"/>
         <xsl:apply-templates select="/COMMENTARYDOC/docinfo/relationshipmetadata[$streamID='UK14']"/>
         <xsl:apply-templates select="//note[@notetype = 'other']/remotelink[contains(., '[version anglaise]') or contains(., '[French Version]')][$streamID = 'CA02DS']"
                              mode="doc-related_content"/>
         <xsl:apply-templates select="//jrnl:body[$streamID = 'CA15']" mode="doc_overview"/>
         <!-- Awantika: Applied template for note scnario in AU20 -->
         <xsl:apply-templates select="//CITATORDOC/source_cttr:body/leg:info/note[@notetype = 'xref' and (@id = 'SCAP4' or 'SCAI4')]"/>
         <xsl:apply-templates select="docinfo:leginclude[$streamID = ('UK06','UK07')]"/>
      </doc:docinfo>
   </xsl:template>

   <xsl:template name="legacy-metadata"><!-- don't create doc:legacy-metadata unless at least one of the following is present -->
      <xsl:if test="docinfo:dpsi | /CITATORDOC/@citatordoctype | /CITATORDOC/@fullcourt | /CITATORDOC/@notannotated | /CITATORDOC/@shortannot | /CITATORDOC/@unreported | @browseprev | @browsenext | @partitionnum | @majorrevision | @excludefromalerts | @excludefromtoc | @id-string | docinfo:custom-metafields | //leg:info/leg:hier | docinfo:lbu-meta | docinfo:subtype | perjudge">
         <doc:legacy-metadata metadatasource="lbu-meta">
            <meta>
               <xsl:for-each select="/*[1]/docinfo[1]/@excludefromtoc">
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>excludefromtoc</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:value-of select="."/>
                     </xsl:attribute>
                  </metaitem>
               </xsl:for-each>
               <xsl:choose><!--			Vikas Rohilla : updated the and condition			-->
                  <xsl:when test="docinfo:dpsi[@id-string] and not(./docinfo:lbu-meta/docinfo:metaitem[upper-case(@name) = 'DPSI'])">
                     <xsl:apply-templates select="docinfo:dpsi"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:call-template name="findDPSI"/>
                  </xsl:otherwise>
               </xsl:choose>
               <!-- Awantika: metaitem mapping for case:courtcode in HK03. SP: also using this for CA19. Sudhanshu : Added  -->
               <!-- Ravikant: 2018-03-09 Added the streamID MY01 for case:courtcode, metaitem mapping in MY01. -->
               <xsl:if test="//case:courtcode[$streamID = ('HK03', 'CA19', 'CA02CC', 'CA01' ,'NZ03', 'AU13', 'UK01', 'UK03', 'NZ07-DN', 'NZ07DC' , 'AU07' , 'NZ17CC', 'AU09','HK09','MY01')]">
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>case:courtcode</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:value-of select="//case:courtcode/text()"/>
                     </xsl:attribute>
                  </metaitem>
                  <!-- Awantika: instruction ends -->
               </xsl:if>
               <!-- Awantika: Added metaitem for UK11DN for alert:alertReference and topic:topicReference-->
               <!-- BRT 10/3/17: commented this out in favor of the code on line 680 -->
               <!--xsl:if test="/DIGESTDOC/docinfo/classification[child::classitem[@classscheme='alert:alertReference']/classitem-identifier/classname['ModuleID']][$streamID = ('UK11DN','UK03','UK11DA')]">
						<metaitem>
							<xsl:attribute name="name">
								<xsl:text>MODULE-CURRENTNESS-ALERT</xsl:text>
							</xsl:attribute>
							<xsl:attribute name="value">
								<xsl:value-of select="/DIGESTDOC/docinfo/classification/classitem[@classscheme='alert:alertReference']/classitem-identifier[child::classname['ModuleID']]/classcode/@normval"/>
							</xsl:attribute>
						</metaitem>
					</xsl:if-->
               <!-- BRT 10/3/17 commented out, use alert code as model for @classscheme='topic:topicReference' further down -->
               <!--xsl:if test="/DIGESTDOC/docinfo/classification[child::classitem[@classscheme='topic:topicReference']/classitem-identifier/classname['ModuleID']][$streamID = 'UK11DN']">
						<metaitem>
							<xsl:attribute name="name">
								<xsl:text>MODULE-PGUID</xsl:text>
							</xsl:attribute>
							<xsl:attribute name="value">
								<xsl:value-of select="/DIGESTDOC/docinfo/classification/classitem[@classscheme='topic:topicReference']/classitem-identifier[child::classname['ModuleID']]/classcode/@normval"/>
							</xsl:attribute>
						</metaitem>
					</xsl:if-->
               <!-- JD: 20170526: added for UK05
					"PLEASE NOTE that the element doc:legacy-metadata needs to be created only for case:courtcode occurring within
					case:headnote/case:info/case:courtinfo. There is NO NEED to create doc:legacy-metadata for all other occurrences, eg.,
					cttr:annot/case:info/case:courtinfo."
					-->
               <xsl:if test="/CITATORDOC/source_cttr:body/case:headnote/case:info/case:courtinfo/case:courtcode[$streamID = 'UK05']">
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>case:courtcode</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:value-of select="/CITATORDOC/source_cttr:body/case:headnote/case:info/case:courtinfo/case:courtcode/text()"/>
                     </xsl:attribute>
                  </metaitem>
               </xsl:if>
               <xsl:apply-templates select="//case:info/case:reportercite/@ln.user-displayed[$streamID='AU07']"
                                    mode="metadata"/>
               <!-- JD: end add for UK05 -->
               <xsl:apply-templates select="/CITATORDOC/@citatordoctype | /CITATORDOC/@fullcourt | /CITATORDOC/@notannotated | /CITATORDOC/@shortannot | /CITATORDOC/@unreported | @browseprev | @browsenext | @partitionnum | @majorrevision | @excludefromalerts | @id-string"/>
               <xsl:apply-templates select="docinfo:custom-metafields [not($streamID='USLPA')]"/>
               <xsl:if test="not($streamID = 'CA05')">
                  <xsl:apply-templates select="//leg:info/leg:hier"/>
               </xsl:if>
               <xsl:apply-templates select="docinfo:lbu-meta"/>
               <xsl:apply-templates select="docinfo:subtype"/>
               <!-- Vikas Rohilla	: Apply templates added for the streamID CA02DC -->
               <xsl:apply-templates select="//case:courtcode[$streamID = ('CA02DC', 'CA02DS')]"
                                    mode="meta_item"/>
               <xsl:apply-templates select="//classification[@rendition and @classscheme][$streamID = 'CA02DC']"
                                    mode="meta-item"/>
               <xsl:call-template name="perjudge"/>
               <!--<xsl:apply-templates select="//case:courtinfo/case:courtcode" mode="metadata"/>-->
               <xsl:if test="$streamID = ('HK08', 'AU02')">
                  <xsl:apply-templates select="//case:headnote/case:info/case:courtinfo/case:courtcode"
                                       mode="metadata"/>
               </xsl:if>
            </meta>
         </doc:legacy-metadata>
         <xsl:if test="$streamID='USLPA'">
            <xsl:apply-templates select="docinfo:custom-metafields"/>
         </xsl:if>
         <!-- Awantika: Need to create two legacy metadata one isdefault one is with @metadatasource="tracking-timestamp". 
				1. For all documents, the conversion should add a date-timestamp in the format YYYYMMDDHHMMSS using doc:legacymetadata@
metadatasource="tracking-timestamp"/meta containing meta/metaitem@name="conversiontimestamp"@
value="YYYYMMDDHHMMSS"
				2. If optional docinfo:custom-metafields/docinfo:custom-metafield[@name="lbu-publish-timestamp"] exists, create doc:legacymetadata[@
metadatasource="tracking-timestamp"] and add child meta/metaitem[@name="lbu-publish-timestamp"]
[@value="YYYYMMDDHHMMSS"] -->
         <xsl:if test="$streamID='AU20'">
            <doc:legacy-metadata metadatasource="tracking-timestamp">
               <meta>
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>conversion-timestamp</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:choose>
                           <xsl:when test="docinfo:custom-metafields/docinfo:custom-metafield[@name='lbu-publish-timestamp']">
                              <xsl:value-of select="concat(docinfo:custom-metafields/docinfo:custom-metafield[@name='lbu-publish-timestamp'],format-dateTime(current-dateTime(),'[H01][m01][s]'))"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:value-of select="format-dateTime(current-dateTime(),'[Y0001][M01][D01][H01][m01][s]')"/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                  </metaitem>
                  <xsl:if test="docinfo:custom-metafields/docinfo:custom-metafield[@name='lbu-publish-timestamp']">
                     <metaitem>
                        <xsl:attribute name="name">
                           <xsl:text>lbu-publish-timestamp</xsl:text>
                        </xsl:attribute>
                        <xsl:attribute name="value">
                           <xsl:value-of select="docinfo:custom-metafields/docinfo:custom-metafield[@name='lbu-publish-timestamp']"/>
                        </xsl:attribute>
                     </metaitem>
                  </xsl:if>
               </meta>
            </doc:legacy-metadata>
         </xsl:if>
      </xsl:if>
      <!-- Brad Thacker: corrected metaitem for classitem[@classscheme='topic:topicReference'] UK15CS, UK15ds, UK12cs, UK11dn -->
      <xsl:for-each select="/*/docinfo/classification/classitem[@classscheme='topic:topicReference'][classitem-identifier/classname['ModuleID']]">
         <xsl:if test="$streamID=('UK11DN','UK12', 'UK15')">
            <doc:legacy-metadata metadatasource="lbu-meta">
               <meta>
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>MODULE-PGUID</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:value-of select="./classitem-identifier[child::classname['ModuleID']]/classcode/@normval"/>
                     </xsl:attribute>
                  </metaitem>
                  <!-- BRT: comment out for now - don't need topic pguids in shared services (yet) -->
                  <!--xsl:for-each select="./classitem-identifier/classcode">
							<xsl:if test="contains(./@normval, 'urn:topic:')">
								<metaitem>
									<xsl:attribute name="name">
										<xsl:text>TOPIC-CURRENTNESS-ALERT</xsl:text>
									</xsl:attribute>
									<xsl:attribute name="value">
										<xsl:value-of select="./@normval"/>
									</xsl:attribute>
								</metaitem>
							</xsl:if>
						</xsl:for-each-->
               </meta>
            </doc:legacy-metadata>
         </xsl:if>
      </xsl:for-each>
      <!-- Rohan Borkar: modifications end-->
      <!-- Rohan Borkar: corrected metaitem for UK11DA for alert:alertReference -->
      <xsl:for-each select="/DIGESTDOC/docinfo/classification/classitem[@classscheme='alert:alertReference']">
         <xsl:if test="$streamID=('UK11DN','UK03','UK11DA')">
            <doc:legacy-metadata metadatasource="lbu-meta">
               <meta>
                  <metaitem>
                     <xsl:attribute name="name">
                        <xsl:text>MODULE-CURRENTNESS-ALERT</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:value-of select="./classitem-identifier[child::classname['ModuleID']]/classcode/@normval"/>
                     </xsl:attribute>
                  </metaitem>
                  <xsl:for-each select="./classitem-identifier/classcode">
                     <xsl:if test="contains(./@normval, 'urn:topic:')">
                        <metaitem>
                           <xsl:attribute name="name">
                              <xsl:text>TOPIC-CURRENTNESS-ALERT</xsl:text>
                           </xsl:attribute>
                           <xsl:attribute name="value">
                              <xsl:value-of select="./@normval"/>
                           </xsl:attribute>
                        </metaitem>
                     </xsl:if>
                  </xsl:for-each>
               </meta>
            </doc:legacy-metadata>
         </xsl:if>
      </xsl:for-each>
      <!-- Rohan Borkar: modifications end-->
      <xsl:if test="$streamID=('AU13','HK09')">
         <doc:legacy-metadata metadatasource="rosetta">
            <meta>
               <xsl:for-each select="/CASEDOC/case:body/case:headnote/case:info/case:courtinfo/case:courtcode">
                  <metaitem>
                     <xsl:attribute name="name">case:courtcode</xsl:attribute>
                     <xsl:attribute name="value" select="."/>
                  </metaitem>
               </xsl:for-each>
            </meta>
         </doc:legacy-metadata>
      </xsl:if>
   </xsl:template>
   <!-- JD: 20170524: adding this template (called above) -->
   <xsl:template match="docinfo:dpsi">
      <metaitem name="dpsi" value="{@id-string}"/>
   </xsl:template>
   <!-- person[@searchtype="JUDGES"] -->
   <xsl:template name="perjudge"><!-- JD: 2017-07-14: added 'judge'; probably a data error from UK XSLT development -->
      <xsl:if test="//person[@searchtype = ('JUDGES','judge')]">
         <metaitem name="JUDGES"
                   value="{//person[ @searchtype = ('JUDGES','judge') ]/name.text}"/>
      </xsl:if>
   </xsl:template>

   <xsl:template match="/CITATORDOC/@citatordoctype | /CITATORDOC/@fullcourt | /CITATORDOC/@notannotated | /CITATORDOC/@shortannot | /CITATORDOC/@unreported | @browseprev | @browsenext | @partitionnum | @majorrevision | @excludefromalerts | @id-string">
      <metaitem name="{name()}" value="{.}"/>
   </xsl:template>

   <xsl:template name="findDPSI">
      <xsl:choose><!--	**************************************************************  
		Vikas Rohilla : Commented this part because findDPSI templete called in the docinfo
		template and after using the double dot (..) current element becomes
		the CASEDOC and the docinfo:lbu-meta never find in the CASEDOC. 
		and after match the conversion is skip becauese it is created by the 
		docinfo:metaitem template.
		**************************************************************--><!--	<xsl:when test="../docinfo:lbu-meta/docinfo:metaitem[@name='DPSI']">
				<metaitem xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
					<xsl:attribute name="name">dpsi</xsl:attribute>
					<xsl:attribute name="value" select="../docinfo:lbu-meta/docinfo:metaitem[@name='DPSI']/@value"/>
				</metaitem>
			</xsl:when>--><!-- Vikas Rohilla : replaced double dot(..) with the single dot (.)  -->
         <xsl:when test="./docinfo:lbu-meta/docinfo:metaitem[upper-case(@name) = 'DPSI']"/>
         <xsl:otherwise>
            <metaitem>
               <xsl:attribute name="name">dpsi</xsl:attribute>
               <xsl:attribute name="value" select="$dpsi"/>
            </metaitem>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="comm:info/pubdate" mode="dc.metadata">
      <xsl:apply-templates mode="dc.metadata"/>
   </xsl:template>

   <xsl:template match="case:headnote/case:info/case:casename | case2:headnote/case2:info/case2:casename"
                 mode="dc.metadata"><!--  Original Target XPath:  dc:metadata/dc:title   -->
      <dc:title>
         <xsl:apply-templates select="@* | node()" mode="dc.metadata"/>
      </dc:title>
   </xsl:template>

   <xsl:template match="comm:info/pubdate/date" mode="dc.metadata">
      <dc:date lnmeta:datetype="pubdate">
         <xsl:value-of select="@year"/>
         <xsl:text>-</xsl:text>
         <xsl:value-of select="@month"/>
         <xsl:text>-</xsl:text>
         <xsl:value-of select="@day"/>
      </dc:date>
   </xsl:template>

   <xsl:template match="docinfo:lbu-meta/docinfo:metaitem[@name = 'PA-PGUID' or @name = 'TOPIC-PGUID' or @name = 'SUB-TOPIC-PGUID']"
                 priority="2"
                 mode="classify">
      <classify:classitem>
         <meta>
            <metaitem name="appliedby" value="human"/>
         </meta>
         <topic:topicReference guid:guid="{@value}"/>
      </classify:classitem>
   </xsl:template>

   <xsl:template match="docinfo:versionbranch" priority="2" mode="member">
      <doc:membership>
         <ref:groupid group-type="variants-1">
            <ref:resourceid>
               <xsl:attribute name="ref:resourcekey">
                  <xsl:text>urn:cldi-1:</xsl:text>
                  <xsl:value-of select="translate(translate(translate(translate(@value,' (&#x9; ',''),' &#x9;) ',''),' ,&#x9; ',''),' ''&#x9; ','')"/>
               </xsl:attribute>
            </ref:resourceid>
         </ref:groupid>
      </doc:membership>
   </xsl:template>
   <!-- rosetta element: docinfo:alt-renditions -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.alt-renditions-LxAdv-doc.alt-renditions.dita"/> -->   <!--   docinfo:alt-renditions/docinfo:alt-rendition to
            doc:alt-renditions/doc:alt-rendition
        id-CCCC-10283
    
        
            Instructions [common element]
            This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.
                    lnlink[@service="ATTACHMENT"] to
                            ref:lnlink[@service="ATTACHMENT"] for BLOBSTORE
                        images (id-CCCC-10542)
                    inlineobject to
                            ref:inlineobject for BLOBSTORE images
                        (id-CCCC-10540)
                    link[@filename] to
                            ref:lnlink[@service="ATTACHMENT"] for BLOBSTORE
                        images (id-CCCC-10541)
                
            docinfo:alt-renditions becomes
                    doc:alt-renditions with these children: 
                    docinfo:alt-renditions/docinfo:alt-rendition becomes
                            doc:alt-renditions/doc:alt-rendition with
                            @key and child as follows: 
                            docinfo:alt-renditions/docinfo:alt-rendition/link
                                becomes
                                    doc:alt-renditions/doc:alt-rendition/ref:lnlink[@service="ATTACHMENT"].
                                    For conversion of link, please see
                                    the topic "link to
                                            ref.lnlink/@service="ATTACHMENT"".
                            
                            docinfo:alt-renditions/docinfo:alt-rendition/lnlink
                                becomes
                                    doc:alt-renditions/doc:alt-rendition/ref:lnlink[@service="ATTACHMENT"].
                                    For conversion of lnlink, please
                                    see the topic .
                            
                        
                    
                
                For UK06 Laws/Acts/Bills/Measures and UK07 Regulation place the text of
                        leg:officialname in
                        doc:alt-renditions/doc:alt-rendition/ref:lnlink/ref:marker
                    instead of the source text as used within
                        docinfo:alt-renditions/docinfo:alt-rendition/link
            
        
        
            Source XML 1
            
            
&lt;docinfo:alt-renditions&gt;
 &lt;docinfo:alt-rendition key="fulltext"&gt;
  &lt;link alttext="pdf version" filename="VIC_ACT_1998-25.pdf" type="pdf"&gt;PDF version of this Act&lt;/link&gt;
 &lt;/docinfo:alt-rendition&gt;
&lt;/docinfo:alt-renditions&gt;

            
        
        
            Target XML 1
            
            
&lt;doc:alt-renditions&gt;
 &lt;doc:alt-rendition key="fulltext"&gt;
  &lt;ref:lnlink service="ATTACHMENT"&gt;
   &lt;ref:marker role="label"&gt;PDF version of this Act&lt;/ref:marker&gt;
   &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
     &lt;ref:key-name name="attachment-key"/&gt;
     &lt;ref:key-value value="X-Y-VIC-ACT-1998-25"/&gt; 
     &lt;!-\- X and Y are LNI and SMI values obtained from CSSM -\-&gt;
    &lt;/ref:locator-key&gt;
    &lt;ref:locator-params&gt;
     &lt;proc:param name="componentseq" value="1"/&gt;
     &lt;proc:param name="attachment-type" value="PDF"/&gt;
     &lt;proc:param name="attachment-smi" value=""/&gt;
     &lt;!-\- @value populated with SMI obtained from CSSM -\-&gt;
     &lt;!-\- This @value assignment is done by conversion program -\-&gt;
    &lt;/ref:locator-params&gt;
   &lt;/ref:locator&gt;
  &lt;/ref:lnlink&gt;
 &lt;/doc:alt-rendition&gt;
&lt;/doc:alt-renditions&gt;

            
        
        
            Source XML 2
            
            
&lt;docinfo:alt-renditions&gt;
 &lt;docinfo:alt-rendition key="fulltext"&gt;
  &lt;link alttext="pdf version" filename="VIC_ACT_1998-25.pdf" type="pdf"&gt;PDF version of this Act&lt;/link&gt;
 &lt;/docinfo:alt-rendition&gt;
&lt;/docinfo:alt-renditions&gt;
&lt;!-\- ETC. -\-&gt;
&lt;leg:officialname&gt;&lt;emph typestyle="bf"&gt;Commons Act 1236&lt;/emph&gt;&lt;/leg:officialname&gt;
                
            
        
        
            Target XML 2
            
            
&lt;legisinfo:officialtitle&gt;Commons Act 1236&lt;/legisinfo:officialtitle&gt;
&lt;!-\- ETC. -\-&gt;
&lt;doc:alt-renditions&gt;
 &lt;doc:alt-rendition key="fulltext"&gt;
  &lt;ref:lnlink service="ATTACHMENT"&gt;
   &lt;ref:marker role="label"&gt;Commons Act 1236&lt;/ref:marker&gt;
    &lt;ref:locator&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="attachment-key"/&gt;
      &lt;ref:key-value value="X-Y-VIC-ACT-1998-25"/&gt;
      &lt;!-\- X and Y are LNI and SMI values obtained from CSSM -\-&gt;
     &lt;/ref:locator-key&gt;
     &lt;ref:locator-params&gt;
      &lt;proc:param name="componentseq" value="1"/&gt;
      &lt;proc:param name="attachment-type" value="PDF"/&gt;
      &lt;proc:param name="attachment-smi" value=""/&gt;
      &lt;!-\- @value populated with SMI obtained from CSSM -\-&gt;
      &lt;!-\- This @value assignment is done by conversion program -\-&gt;
     &lt;/ref:locator-params&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:lnlink&gt;
  &lt;/doc:alt-rendition&gt;
&lt;/doc:alt-renditions&gt;
                
            
        
        
            Source XML 3
            
            
&lt;docinfo:alt-renditions&gt;
  &lt;docinfo:alt-rendition key="fulltext"&gt;
    &lt;lnlink service="ATTACHMENT" status="valid"&gt;
      &lt;marker role="content"&gt;PDF Format&lt;/marker&gt;
      &lt;api-params&gt;
        &lt;param name="attachment-key" value="application_for_apportionment-xxxx-xxxx-xxxxx-xx"/&gt;
        &lt;param name="attachment-type" value="pdf"/&gt;
        &lt;param name="attachment-smi" value="4364"/&gt;
        &lt;param name="componentseq" value="1"/&gt;
      &lt;/api-params&gt;
    &lt;/lnlink&gt;
  &lt;/docinfo:alt-rendition&gt;
&lt;/docinfo:alt-renditions&gt;
                
            
        
        
            Target XML 3
            
            
&lt;doc:alt-renditions&gt;
 &lt;doc:alt-rendition key="fulltext"&gt;
  &lt;ref:lnlink service="ATTACHMENT"&gt;
   &lt;ref:marker role="content"&gt;PDF Format&lt;/ref:marker&gt;
    &lt;ref:locator&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="attachment-key"/&gt;
      &lt;ref:key-value value="application_for_apportionment-xxxx-xxxx-xxxxx-xx"/&gt;
     &lt;/ref:locator-key&gt;
     &lt;ref:locator-params&gt;
      &lt;proc:param name="componentseq" value="1"/&gt;
      &lt;proc:param name="attachment-type" value="PDF"/&gt;
      &lt;proc:param name="attachment-smi" value="4364"/&gt;
     &lt;/ref:locator-params&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:lnlink&gt;
  &lt;/doc:alt-rendition&gt;
&lt;/doc:alt-renditions&gt;
                
            
        
        
        
            Changes
            2016-07-29: Added Note about xml snippets that illustrate
                    image handling. Note summarizes move from Apollo to Blobstore application. UK is
                    first LBU to move to Blobstore.
            2013-12-17: Added instruction and example for
                        docinfo:alt-rendition/lnlink. (Webteam
                #247307)
            2013-05-01: Updated instructions and target example per
                    latest Apollo markup.
            2013-02-26: Updated target example per project
                    requirement.
            2012-10-29: Added instruction and example for UK06
                    Laws/Acts/Bills/Measures and UK07 Regulation place the text of
                        leg:officialname in
                        doc:alt-renditions/doc:alt-rendition/ref:lnlink/ref:marker
                    (Webteam #243521)
            2012-10-26: Changed to reflect recent requirements for attachment-type links.
            2012-09-06: Created.-->   <!--Vikas Rohilla : Template to match docinfo:alt-renditions and create doc:alt-renditions  -->
   <xsl:template match="docinfo:alt-renditions">
      <xsl:element name="doc:alt-renditions">
         <xsl:apply-templates select="@* | node()"/>
      </xsl:element>
   </xsl:template>
   <!--Vikas Rohilla : Template to match docinfo:alt-rendition and create doc:alt-rendition  -->
   <xsl:template match="docinfo:alt-rendition">
      <xsl:element name="doc:alt-rendition">
         <xsl:apply-templates select="@* | node()"/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="docinfo:alt-rendition/@key">
      <xsl:attribute name="key" select="."/>
   </xsl:template>
   <!-- rosetta element: docinfo:assoc-links related content-->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.assoc-links-LxAdv-doc.related-content.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a shared
        topic rather than duplicated to ensure consistency and accuracy. The xml snippets contained
        in this topic reflect markup needed for the Apollo image handling application. The UK is the
        first LBU to move from Apollo to the Blobstore application for image handling. Therefore, if
        this is a UK conversion instruction document, please refer to the following topics for
        correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
              <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
            (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to <xd:b>ref:inlineobject</xd:b> for
            BLOBSTORE images (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
              <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
            (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:assoc-links</xd:i> becomes
          <xd:b>doc:related-content</xd:b>. Attribute
          <xd:i>@assoc-content</xd:i> is suppressed.</xd:p>
         <xd:p>
            <xd:i>docinfo:assoc-links-grp</xd:i> becomes
          <xd:b>doc:related-content-grp</xd:b>, and its descendents are processed as
        follows: <xd:ul>
               <xd:li>If present, <xd:i>docinfo:assoc-resource</xd:i> becomes
              <xd:b>ref:relatedresourceref/ref:relatedresourceid</xd:b>. Copy the value of
              <xd:i>@assoc-resourceid</xd:i> to
            <xd:b>@ref:resourcekey</xd:b>
               </xd:li>
               <xd:li>The target value of <xd:b>doc:related-content-grp/@grptype</xd:b> depends on
            the existing attrribute in the source: <xd:ul>
                     <xd:li>If <xd:i>docinfo:assoc-links-grp/@assoc-content</xd:i> exists, it
                becomes <xd:b>@grptype</xd:b>.</xd:li>
                     <xd:li>Otherwise, <xd:i>docinfo:assoc-links-grp/@display-name</xd:i> becomes
                  <xd:b>@grptype</xd:b>.</xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>heading/title</xd:i> becomes
            <xd:b>heading/title</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>The children below may occur within either level,
          <xd:i>docinfo:assoc-links</xd:i> or
          <xd:i>docinfo:assoc-links-grp</xd:i>, and convert as follows:</xd:p>
         <xd:p>
            <xd:ul>
               <xd:li>With one exception, <xd:i>text</xd:i> becomes
              <xd:b>doc:related-content-item/doc:related-content-desc/p/text</xd:b>. The
            exception to this rule is if and only if the only children of
              <xd:i>text</xd:i> are one or more <xd:i>link</xd:i> elements; in
            this case see the rule for <xd:i>link</xd:i> below and example #4.</xd:li>
               <xd:li>
                  <xd:p>
                     <xd:i>link</xd:i> becomes
                <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="ATTACHMENT"]</xd:b>.</xd:p>
                  <xd:p>In addtion to this conversion being performed if the <xd:i>link</xd:i>
              element is a child of <xd:i>docinfo:assoc-links</xd:i> or
                <xd:i>docinfo:assoc-links-grp</xd:i>, it is also done when the only
              children of <xd:i>text</xd:i> are one or more
              <xd:i>link</xd:i>elements. That is, if and only if <xd:b>all</xd:b> of a
                <xd:i>text/link</xd:i> element's other siblings are also
                <xd:i>link</xd:i> elements. In the <xd:i>text</xd:i> scenario,
              the start-tag and end-tag (but not the content) of <xd:i>text</xd:i> are
              dropped (see example #4). If there are multiple <xd:i>link</xd:i> elements,
              then multiple <xd:b>doc:related-content-item</xd:b> and children are
              created, one for each <xd:i>link</xd:i> element.</xd:p>
                  <xd:p>For details about converting <xd:i>link</xd:i> to
                <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> see
                <xd:i>link</xd:i> rules in the General Markup section.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:i>remotelink[@service="QUERY"]</xd:i> is suppressed. If nothing else is
            present then also suppress the parent. <xd:p>
                     <xd:b>Note: </xd:b>
                     <xd:p>
                        <xd:b>This Note is applicable to CA03, and
                  CA05-CA08 only</xd:b> If we have XPath
                  <xd:i>docinfo:assoc-links-grp/remotelink[@service="QUERY"]</xd:i> or
                  <xd:i>docinfo:assoc-links/remotelink[@service="QUERY"]</xd:i>then we
                don't need to suppress it from target but in certain condition for that
                stream-wise.</xd:p>
                     <xd:ul>
                        <xd:li>
                           <xd:b>For CA06 and CA07</xd:b> If document is having
                    <xd:i>remotelink[@service="QUERY"]</xd:i> under the
                    <xd:i>docinfo:assoc-links-grp[assoc-content="enabling"] </xd:i>and
                    <xd:i>remotelink</xd:i> comes with attributes
                    <xd:i>@remotekey1</xd:i> with the start value <xd:b>"DOCINFO(XXXX)"</xd:b>
                  and <xd:i>@remotekey2</xd:i> comes with value <xd:b>All Canadian
                    Statutes</xd:b> then it should be mapped with
                    <xd:b>doc:related-content/doc:related-content-grp/doc:related-content-item[@content-type="enablingLeg"]/ref:relatedresourceref/ref:relatedresourceid/ref:resourcekey="urn:leg-id-1:XXXX"</xd:b>
                  where <xd:b>XXXX</xd:b> will be taken from source attribute
                    <xd:i>remotekey1</xd:i> Refer Example 7.</xd:li>
                        <xd:li>
                           <xd:b>For CA05 and CA08</xd:b> If document is having
                    <xd:i>remotelink[@service="QUERY"]</xd:i> under the
                    <xd:i>docinfo:assoc-links</xd:i> or
                    <xd:i>docinfo:assoc-links-grp</xd:i> and
                    <xd:i>remotelink</xd:i> comes with attributes
                    <xd:i>@remotekey2="All Canadian Regulations"</xd:i> then it should be
                  mapped with
                    <xd:b>doc:related-content/doc:related-content-grp[@grptype="subordinateLeg"]/doc:related-content-item[@content-type="subordinateLeg"]/ref:relatedresourceref/ref:relatedresourceid/ref:resourcekey="urn:leg-id-1:XXXX"</xd:b>
                  where <xd:b>XXXX</xd:b> will be taken from source attribute
                    <xd:i>remotekey1</xd:i> Refer Example 8.</xd:li>
                        <xd:li>
                           <xd:b>For CA05 - CA08</xd:b> Conversion Needs to split multiple <xd:b>ORs</xd:b> into a
                  separate <xd:b>doc:related-content-item</xd:b>. Refer <xd:b>Example 9</xd:b>
                  for CA06-CA07 streams. </xd:li>
                        <xd:li>
                           <xd:b>For CA06 and CA07</xd:b>
                           <xd:i>docinfo:assoc-links-grp/@assoc-content="enabling"</xd:i> should
                  map with <xd:b>doc:related-content-grp/@grptype="enablingLeg"</xd:b>.
                  Any heading found inside
                    "<xd:i>docinfo:assoc-links-grp/remotelink</xd:i>" then it should be
                  mapped with <xd:b>@doc:related-content-grp/heading/title</xd:b>. Refer
                  Example 9.</xd:li>
                        <xd:li>
                           <xd:b>For CA03</xd:b> If document is having
                    <xd:i>remotelink[@service="QUERY"]</xd:i> and
                    <xd:i>remotelink</xd:i> comes with attributes
                    <xd:i>@remotekey1</xd:i> with the value <xd:b>"REFNUM(XXXX)"</xd:b> and
                    <xd:i>@remotekey2</xd:i> contains <xd:b>"All Canadian Summaries"</xd:b> then
                  it should be mapped with
                    <xd:b>doc:related-content/doc:related-content-grp/doc:related-content-item[@content-type="caseSummaries"]/ref:relatedresourceref/ref:relatedresourceid/ref:resourcekey="urn:ucn-1:XXXX"</xd:b>
                  where <xd:b>XXXX</xd:b> will be taken from source attribute
                    <xd:i>remotekey1</xd:i>. Any bilingual headings should be retained
                  along with their associated <xd:b>@xml:lang</xd:b>. Refer Example 10.
                </xd:li>
                     </xd:ul>
                  </xd:p>
               </xd:li>
               <xd:li>
                  <xd:i>remotelink[@service="DOC-ID"]</xd:i> becomes
              <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="DOCUMENT"]</xd:b>.
            If the parent <xd:i>docinfo:assoc-links</xd:i> contains
              <xd:i>@assoc-content="external-content-location"</xd:i>, then add
              <xd:b>@content-type="external-content-location"]</xd:b> to
              <xd:b>doc:related-content-item</xd:b>. Create the following child elements: <xd:ul>
                     <xd:li>Create <xd:b>ref:marker</xd:b> to capture the PCDATA of
                  <xd:i>remotelink</xd:i>.</xd:li>
                     <xd:li>Create <xd:b>ref:locator</xd:b> and populate it as follows: <xd:ul>
                           <xd:li>Create <xd:b>ref:locator-key</xd:b> and populate it as follows: <xd:ul>
                                 <xd:li>If <xd:i>@remotekey1="DOC-ID"</xd:i> then <xd:ul>
                                       <xd:li>
                                          <xd:b>ref:key-name/@name</xd:b> will have the value
                            "DOC-ID".</xd:li>
                                       <xd:li>
                                          <xd:b>key-value/@value</xd:b> will be the value of
                              <xd:i>@dpsi</xd:i> followed by hyphen and concatenated with
                              <xd:i>@refpt</xd:i> or <xd:i>@remotekey2</xd:i>,
                            which ever is present (if both are present, use
                              <xd:i>@remotekey2</xd:i>).</xd:li>
                                    </xd:ul>
                                 </xd:li>
                                 <xd:li>If <xd:i>@remotekey1="REFPTID"</xd:i> then <xd:ul>
                                       <xd:li>
                                          <xd:b>ref:key-name/@name</xd:b> will have the value
                            "DOC-ID".</xd:li>
                                       <xd:li>
                                          <xd:b>ref:key-value/@value</xd:b> will be the value of
                              <xd:i>@dpsi</xd:i> followed by hyphen and concatenated with
                              <xd:i>@docidref</xd:i>.</xd:li>
                                       <xd:li>Create <xd:b>ref:locator/@anchoridref</xd:b> with value from
                              <xd:i>@refpt</xd:i> or <xd:i>@remotekey2</xd:i>,
                            which ever is present (if both are present, use
                            <xd:i>@refpt</xd:i>).</xd:li>
                                    </xd:ul>
                                 </xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                        <xd:p>
                           <xd:b>Note: </xd:b>If <xd:i>remotelink/@dpsi</xd:i> is not present, use value from
                    <xd:i>docinfo:dpsi/@id-string</xd:i> or capture value from the LBU
                  manifest file.</xd:p>
                        <xd:p>
                           <xd:b>Note: </xd:b>
                           <xd:b>ref:locator/@anchoridref</xd:b> that begins with a number must
                  have an underscore added at start. Also apply other identifier data type format as
                  used for <xd:b>xml:id</xd:b> and <xd:b>ref:anchor/@id</xd:b>
                  (e.g. change colon to underscore). Refer to the section titled "Identifiers to ID Data Type - 
                  Handling Pattern Restrictions", if that section exists in this CI.</xd:p>
                     </xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>remotelink[@href]</xd:i> becomes
              <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="URL"]</xd:b>.
            If the parent <xd:i>docinfo:assoc-links</xd:i> contains
              <xd:i>@assoc-content="external-content-location"</xd:i>, then add
              <xd:b>@content-type="external-content-location"]</xd:b> to
              <xd:b>doc:related-content-item</xd:b>. <xd:p>For details on converting
                <xd:i>remotelink[@href]</xd:i> to <xd:b>ref:lnlink</xd:b> see
                <xd:i>remotelink</xd:i> rules in General Markup section.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>
                     <xd:i>lnlink[@service="QUERYLINK"]</xd:i> becomes
                <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink</xd:b>
              which is populated as follows: <xd:ul>
                        <xd:li>
                           <xd:i>lnlink[@service="QUERYLINK"]</xd:i> becomes
                    <xd:b>ref:lnlink[@service="QUERYLINK"]</xd:b>
                        </xd:li>
                        <xd:li>
                           <xd:i>lnlink/marker</xd:i> becomes
                    <xd:b>ref:lnlink/ref:marker</xd:b>
                        </xd:li>
                        <xd:li>Create <xd:b>ref:locator</xd:b> and populate it as follows: <xd:ul>
                              <xd:li>Create <xd:b>ref:locator-key</xd:b> and populate it as follows: <xd:ul>
                                    <xd:li>
                                       <xd:i>lnlink/key-name[@name="queryTemplatePGUID"]</xd:i>
                          becomes
                            <xd:b>ref:locator/ref:locator-key/ref:key-name[@name="queryTemplatePGUID"].</xd:b>
                                    </xd:li>
                                    <xd:li>
                                       <xd:i>lnlink/key-value/@value</xd:i> becomes
                            <xd:b>ref:locator/ref:locator-key/ref:key-value/@value</xd:b>
                                    </xd:li>
                                 </xd:ul>
                              </xd:li>
                              <xd:li>
                                 <xd:i>lnlink/api-params</xd:i> becomes
                        <xd:b>ref:locator/ref:locator-params</xd:b>, and the children are
                      mapped as follows: <xd:ul>
                                    <xd:li>For each <xd:i>api-params/param</xd:i> element, create a
                          corresponding <xd:b>proc:param</xd:b> and populate the
                          attributes: <xd:ul>
                                          <xd:li>
                                             <xd:i>param/@name</xd:i> becomes
                                <xd:b>proc:param/@name</xd:b>
                                          </xd:li>
                                          <xd:li>
                                             <xd:i>param/@value</xd:i> becomes
                                <xd:b>proc:param/@value</xd:b>
                                          </xd:li>
                                       </xd:ul>
                                    </xd:li>
                                 </xd:ul>
                              </xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                  </xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>
                     <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> becomes
                <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink</xd:b>
              which is populated as follows: See example 6 for more clarification.<xd:ul>
                        <xd:li>
                           <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> becomes
                    <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b>
                        </xd:li>
                        <xd:li>
                           <xd:i>lnlink/marker</xd:i> becomes
                    <xd:b>ref:lnlink/ref:marker</xd:b>
                        </xd:li>
                        <xd:li>Create <xd:b>ref:locator</xd:b> and populate it as follows: <xd:ul>
                              <xd:li>Create <xd:b>ref:locator-key</xd:b> and populate it as follows: <xd:ul>
                                    <xd:li>
                                       <xd:i>lnlink/api-params/param/@name="attachment-key"</xd:i>
                          becomes
                            <xd:b>ref:locator/ref:locator-key/ref:key-name/@name="attachment-key"</xd:b>.</xd:li>
                                    <xd:li>
                                       <xd:i>lnlink/api-params/param/@value</xd:i> becomes
                            <xd:b>ref:locator/ref:locator-key/ref:key-value/@value</xd:b>
                                       <xd:p>
                                          <xd:b>Note: </xd:b>Conversion final output will be
                              <xd:b>ref:key-value/@value="{LNI}-{SMI}-{X}"</xd:b> where as
                            {X} is the <xd:i>lnlink/api-params/param/@value</xd:i> as
                            described above and prepend {LNI} and {SMI} are not literal values, they
                            show where the LNI and SMI values obtained from CSSM should be output.
                            See the Example 6</xd:p>
                                    </xd:li>
                                 </xd:ul>
                              </xd:li>
                              <xd:li>
                                 <xd:i>lnlink/api-params</xd:i> becomes
                        <xd:b>ref:locator/ref:locator-params</xd:b>, and the children are
                      mapped as follows: <xd:ul>
                                    <xd:li>For each <xd:i>api-params/param</xd:i> element, create a
                          corresponding <xd:b>proc:param</xd:b> and populate the
                          attributes: <xd:ul>
                                          <xd:li>
                                             <xd:i>param/@name</xd:i> becomes
                                <xd:b>proc:param/@name</xd:b>
                                          </xd:li>
                                          <xd:li>
                                             <xd:i>param/@value</xd:i> becomes
                                <xd:b>proc:param/@value</xd:b>
                                          </xd:li>
                                       </xd:ul>
                                       <xd:p>
                                          <xd:b>Note: </xd:b>Also create the below markup in the target document while
                            conversion</xd:p>
                                       <xd:ul>
                                          <xd:li>
                                             <xd:b>proc:param/@name="attachment-smi"</xd:b> and
                                <xd:b>proc:param/@value="{SMI}"</xd:b>
                                             <xd:p>
                                                <xd:b>Note: </xd:b>@value populated with SMI obtained from CSSM. This @value
                                assignment is done by conversion program</xd:p>
                                          </xd:li>
                                       </xd:ul>
                                    </xd:li>
                                 </xd:ul>
                              </xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                  </xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>
                     <xd:i>lnlink[@service="TRAVERSE"]</xd:i> becomes
                <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="TRAVERSE"]</xd:b>.
              If the parent <xd:i>docinfo:assoc-links</xd:i> contains
                <xd:i>@assoc-content="external-content-location"</xd:i>, then add
                <xd:b>@content-type="external-content-location"]</xd:b> to
                <xd:b>doc:related-content-item</xd:b>.</xd:p>
                  <xd:p>For details on converting <xd:i>lnlink[@service="TRAVERSE"]</xd:i> to
                <xd:b>ref:lnlink[@service="TRAVERSE"] </xd:b> see
                <xd:i>lnlink[@service="TRAVERSE"]</xd:i> rules in General Markup
              section.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>
                     <xd:i>lnlink[@service="URL"]</xd:i> becomes
                <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="URL"]</xd:b>.
              If the parent <xd:i>docinfo:assoc-links</xd:i> contains
                <xd:i>@assoc-content="external-content-location"</xd:i>, then add
                <xd:b>@content-type="external-content-location"]</xd:b> to
                <xd:b>doc:related-content-item</xd:b>.</xd:p>
                  <xd:p>For details on converting <xd:i>lnlink[@service="URL"]</xd:i> to
                <xd:b>ref:lnlink[@service="URL"] </xd:b> see
                <xd:i>lnlink[@service="URL"]</xd:i> rules in General Markup section.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:i>ci:cite</xd:i> becomes
              <xd:b>doc:related-content-item/doc:related-content-link/ref:lnlink[@service="TRAVERSE"]</xd:b>.
            If the parent <xd:i>docinfo:assoc-links</xd:i> contains
              <xd:i>@assoc-content="external-content-location"</xd:i>, then add
              <xd:b>@content-type="external-content-location"]</xd:b> to
              <xd:b>doc:related-content-item</xd:b>. Create the following child elements: <xd:ul>
                     <xd:li> Create <xd:b>ref:marker</xd:b> to capture the PCDATA of
                  <xd:i>ci:cite/ci:content</xd:i>.</xd:li>
                     <xd:li>
                        <xd:b>ref:locator/ref:locator-key/ref:key-name/@name</xd:b> will have
                the value "normcite".</xd:li>
                     <xd:li>
                        <xd:b>ref:locator/ref:locator-key/key-value/@value</xd:b> will be the
                value of <xd:i>ci:cite/ci:content</xd:i>.</xd:li>
                     <xd:li>Create
                  <xd:b>ref:locator/ref:locator-params/proc:param[@name="normprotocol"]</xd:b>.
                If <xd:i>ci:cite/@normprotocol</xd:i> is present, create the attribute
                  <xd:b>proc:param/@value</xd:b> and copy the value of
                  <xd:i>normprotocol</xd:i>; otherwise, add
                  <xd:b>@value="lexsee"</xd:b>. This line is hard coded.</xd:li>
                     <xd:li>If <xd:i>docinfo:doc-country/@iso-cc</xd:i> exists, create
                  <xd:b>ref:locator/ref:locator-params/proc:param[@name="countrycode"]</xd:b>
                with the attribute <xd:b>@value</xd:b>. The <xd:b>@value</xd:b>
                value is from <xd:i>docinfo:doc-country/@iso-cc</xd:i>.</xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <!-- McNally Apr 3 2014. The following special rule is moved to separate AU-NZ module. Commenting-out for now; can delete when we want -->
         <!--<section>
   <p><b><u>Special Rule for AU and NZ</u></b></p>
   <p>Usual rule is that each rosetta child (<sourcexml>text</sourcexml>,
     <sourcexml>remotelink</sourcexml>, <sourcexml>ci:cite</sourcexml>) maps to its own
     <targetxml>doc:related-content-item</targetxml>, as described above. For AU and NZ streams, a
    special merge is required, as follows: If rosetta linking element
     (<sourcexml>remotelink</sourcexml> or <sourcexml>ci:cite</sourcexml>) is immediately followed
    by <sourcexml>text</sourcexml>, then map the linking element (<sourcexml>remotelink</sourcexml>
    or <sourcexml>ci:cite</sourcexml>) and <sourcexml>text</sourcexml> to a single
     <targetxml>doc:related-content-item</targetxml>. See Example 4.</p>
  </section>-->
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:assoc-links&gt;
 &lt;remotelink alttext="Find related journals" cmd="f:exp" remotekey1="LEG-REF(Flood and Water Management Act 2010 OR FWMA 2010 w/3 s 48 OR ss 48 OR section 48 OR sections 48) OR &amp;quot;Flood and Water Management Act 2010&amp;quot; OR FWMA 2010 w/3 LEG-REF(s 48 OR ss 48 OR section 48 OR sections 48)" remotekey2="All Subscribed Journals Sources" service="QUERY"&gt;Find related journals&lt;/remotelink&gt;
 &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="786617_SL" dpsi="02o0" docidref="ABC123"&gt;Find related subordinate legislation&lt;/remotelink&gt;
&lt;/docinfo:assoc-links&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:related-content&gt;
 &lt;doc:related-content-item&gt;
  &lt;doc:related-content-link&gt;
   &lt;ref:lnlink service="DOCUMENT"&gt;
    &lt;ref:marker&gt; Find related subordinate legislation &lt;/ref:marker&gt;
    &lt;ref:locator anchoridref="_786617_SL "&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="02o0-ABC123"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;    
   &lt;/ref:lnlink&gt;
  &lt;/doc:related-content-link&gt;
 &lt;/doc:related-content-item&gt;
&lt;/doc:related-content&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:assoc-links assoc-content="related-content-pod"&gt;
 &lt;docinfo:assoc-links-grp assoc-content="related-documents"&gt;
  &lt;heading&gt;
   &lt;title&gt;Related Documents&lt;/title&gt;
  &lt;/heading&gt;
  &lt;remotelink service="DOC-ID" remotekey1="DOC-ID" remotekey2="0ONJ_151450"  dpsi="0ONJ"&gt;Transferring patent rights&lt;/remotelink&gt;
 &lt;/docinfo:assoc-links-grp&gt;
 &lt;docinfo:assoc-links-grp assoc-content="related-legislation"&gt;
  &lt;heading&gt;
   &lt;title&gt;Related Legislation&lt;/title&gt;
  &lt;/heading&gt;
  &lt;text&gt;Primary statute: 
   &lt;ci:cite searchtype="LEG-REF" status="valid"&gt;
    &lt;ci:sesslaw&gt;
     &lt;ci:sesslawinfo&gt;
      &lt;ci:sesslawnum num="1977_37a_Title"/&gt;
     &lt;/ci:sesslawinfo&gt;
     &lt;ci:sesslawref&gt;
      &lt;ci:standardname normpubcode="UK_ACTS"/&gt;
     &lt;/ci:sesslawref&gt;
    &lt;/ci:sesslaw&gt;
    &lt;ci:content&gt;Patents Act 1977&lt;/ci:content&gt;
   &lt;/ci:cite&gt;
  &lt;/text&gt;
 &lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:related-content&gt;
 &lt;doc:related-content-grp grptype="related-documents"&gt;
  &lt;heading&gt;
   &lt;title&gt;Related Documents&lt;/title&gt;
  &lt;/heading&gt;
  &lt;doc:related-content-item&gt;
   &lt;doc:related-content-link&gt;
    &lt;ref:lnlink service="DOCUMENT"&gt;
     &lt;ref:marker&gt;Transferring patent rights&lt;/ref:marker&gt;
     &lt;ref:locator&gt;
      &lt;ref:locator-key&gt;
       &lt;ref:key-name name="DOC-ID"/&gt;
       &lt;ref:key-value value="0ONJ-0ONJ_151450"/&gt;
      &lt;/ref:locator-key&gt;
     &lt;/ref:locator&gt;
    &lt;/ref:lnlink&gt;
   &lt;/doc:related-content-link&gt;
  &lt;/doc:related-content-item&gt;
 &lt;/doc:related-content-grp&gt;
 &lt;doc:related-content-grp grptype="related-legislation"&gt;
  &lt;heading&gt;
   &lt;title&gt;Related Legislation&lt;/title&gt;
  &lt;/heading&gt;
  &lt;doc:related-content-item&gt;
   &lt;doc:related-content-desc&gt;
    &lt;p&gt;
     &lt;text&gt;Primary statute: 
      &lt;lnci:cite status="valid"&gt;
       &lt;lnci:sesslaw&gt;
        &lt;lnci:sesslawinfo&gt;
         &lt;lnci:sesslawnum num="1977_37a_Title"/&gt;
        &lt;/lnci:sesslawinfo&gt;
        &lt;lnci:sesslawref&gt;
         &lt;lnci:standardname normpubcode="UK_ACTS"/&gt;
        &lt;/lnci:sesslawref&gt;
       &lt;/lnci:sesslaw&gt;
       &lt;lnci:content&gt;Patents Act 1977&lt;/lnci:content&gt;
      &lt;/lnci:cite&gt;
     &lt;/text&gt;
    &lt;/p&gt;
   &lt;/doc:related-content-desc&gt;
  &lt;/doc:related-content-item&gt;
 &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;

            </xd:pre>
         <!-- McNally Apr 3 2014. Example 3 expanded to include ci:cite.  Done to illustrate general mapping; avoid confusion with separate module for AU-NZ use case.  -->
         <xd:p>
            <xd:b>Source XML 3</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:assoc-links&gt;
 &lt;remotelink alttext="Latest Times Law Reports" href="www.timesonline.co.uk/TGD/lexisDisplay/0,,,00.html" hrefclass="http"&gt;Latest Times Law Reports&lt;/remotelink&gt;
  &lt;ci:cite searchtype="BOOK-REF"&gt;
   &lt;ci:content&gt;Data technologies and patents (2012) 18 MCN 5&lt;/ci:content&gt;
  &lt;/ci:cite&gt;
&lt;/docinfo:assoc-links&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:related-content&gt;
 &lt;doc:related-content-item&gt;
  &lt;doc:related-content-link&gt;
   &lt;ref:lnlink service="URL"&gt;
    &lt;ref:marker&gt;Latest Times Law Reports&lt;/ref:marker&gt;
    &lt;ref:locator&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.timesonline.co.uk/TGD/lexisDisplay/0,,,00.html"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:lnlink&gt;
  &lt;/doc:related-content-link&gt;
 &lt;/doc:related-content-item&gt;
 &lt;doc:related-content-item&gt;
  &lt;doc:related-content-link&gt;
   &lt;ref:lnlink service="TRAVERSE"&gt;
    &lt;ref:marker role="label"&gt;Data technologies and patents (2012) 18 MCN 5&lt;/ref:marker&gt;
    &lt;ref:locator&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="normcite"/&gt;
      &lt;ref:key-value value="Data technologies and patents (2012) 18 MCN 5"/&gt;
     &lt;/ref:locator-key&gt;
     &lt;ref:locator-params&gt;
      &lt;proc:param name="normprotocol" value="lexsee"/&gt;
      &lt;proc:param name="countrycode" value="GB"/&gt;
     &lt;/ref:locator-params&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:lnlink&gt;
  &lt;/doc:related-content-link&gt;
 &lt;/doc:related-content-item&gt;
&lt;/doc:related-content&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Source XML 4, showing a <xd:i>text</xd:i> element containing only a
          <xd:i>link</xd:i> child element</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:assoc-links-grp assoc-content="related-documents"&gt;
  &lt;heading&gt;
    &lt;title&gt;Related documents&lt;/title&gt;
  &lt;/heading&gt;
  &lt;remotelink service="DOC-ID" remotekey1="REFPTID" newwindow="YES" refpt="0OLB_258264"
    dpsi="0OLB" status="invalid" docidref="e60348a7-cc9b-4d43-468b-55a207cd7f00"&gt;Serving the claim formmethod, address, deemed service and dispensing with service&lt;/remotelink&gt;
  &lt;text searchtype="figure"&gt;
    &lt;link filename="EXT_DR_List of authorised government departments for service.pdf"
      alttext="EXT_DR_List of authorised government departments for service.pdf" type="pdf"
      &gt;List of authorised government departments for service&lt;/link&gt;
  &lt;/text&gt;
&lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;

     </xd:pre>
         <xd:p>
            <xd:b>Target XML 4</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:related-content&gt;
  &lt;doc:related-content-grp grptype="related-documents"&gt;
    &lt;heading&gt;
      &lt;title&gt;Related documents&lt;/title&gt;
    &lt;/heading&gt;
    &lt;doc:related-content-item&gt;
      &lt;doc:related-content-link&gt;
        &lt;ref:lnlink service="DOCUMENT"&gt;
          &lt;ref:marker&gt;Serving the claim formmethod, address, deemed service and
    dispensing with service&lt;/ref:marker&gt;
          &lt;ref:locator anchoridref="0OLB_258264"&gt;
            &lt;ref:locator-key&gt;
              &lt;ref:key-name name="DOC-ID"/&gt;
              &lt;ref:key-value value="0OLB-e60348a7-cc9b-4d43-468b-55a207cd7f00"/&gt;
            &lt;/ref:locator-key&gt;
          &lt;/ref:locator&gt;
        &lt;/ref:lnlink&gt;
      &lt;/doc:related-content-link&gt;
    &lt;/doc:related-content-item&gt;
    &lt;doc:related-content-item&gt;
      &lt;doc:related-content-link&gt;
        &lt;ref:lnlink service="ATTACHMENT"&gt;
          &lt;ref:marker role="label"&gt;List of authorised government departments for service&lt;/ref:marker&gt;
          &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
              &lt;ref:key-name name="attachment-key"/&gt;
              &lt;ref:key-value value="{LNI}-{SMI}-EXT_DR_List of authorised government departments for service"/&gt;
              &lt;!-- 
                  The {LNI} and {SMI} are not literal values, 
                  they show where the LNI and SMI values 
                  obtained from CSSM should be output. 
              --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
              &lt;proc:param name="componentseq" value="1"/&gt;
              &lt;proc:param name="attachment-type" value="PDF"/&gt;
              &lt;proc:param name="attachment-smi" value=""/&gt;
              &lt;!-- proc:param/@value is set to the SMI value obtained from CSSM. --&gt;
              &lt;!-- This @value assignment is done by the conversion program. --&gt;
            &lt;/ref:locator-params&gt;
          &lt;/ref:locator&gt;
        &lt;/ref:lnlink&gt;
      &lt;/doc:related-content-link&gt;
    &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;

     </xd:pre>
         <xd:p>
            <xd:b>Source XML 5 - <xd:i>lnlink[@service="QUERYLINK"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:assoc-links&gt;
&lt;docinfo:assoc-links-grp display-name="VALUE_PROVIDED_BY_CONTENTEDITOR"&gt;
  &lt;heading&gt;
    &lt;title&gt;Query Links&lt;/title&gt;
  &lt;/heading&gt;
 &lt;lnlink service="QUERYLINK"&gt;
    &lt;key-name name="queryTemplatePGUID"/&gt;
    &lt;key-value value="urn:queryTemplate:1119"/&gt;    
    &lt;marker&gt;Other Tax documents&lt;/marker&gt;
    &lt;api-params&gt;
        &lt;param name="queryParameter1" value="CA $#$ US"/&gt; 
        &lt;param name="queryParameter2" value="MA"/&gt; 
        &lt;param name="queryParameter3" value="-60"/&gt; 
    &lt;/api-params&gt;
&lt;/lnlink&gt;
&lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;

     </xd:pre>
         <xd:p>
            <xd:b>Target XML 5</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:related-content&gt;
  &lt;doc:related-content-grp grptype="VALUE_PROVIDED_BY_CONTENTEDITOR"&gt;
    &lt;heading&gt;
      &lt;title&gt;Query Links&lt;/title&gt;
    &lt;/heading&gt;
    &lt;doc:related-content-item&gt;
      &lt;doc:related-content-link&gt;
         &lt;ref:lnlink service="QUERYLINK"&gt;
                &lt;ref:marker&gt;Other Tax documents&lt;/ref:marker&gt;
                &lt;ref:locator&gt;
                  &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="queryTemplatePGUID"/&gt;
                    &lt;ref:key-value value="urn:queryTemplate:1119"/&gt;
                  &lt;/ref:locator-key&gt;
                  &lt;ref:locator-params&gt;
                    &lt;proc:param name="queryParameter1" value="CA $#$ US"/&gt;
                    &lt;proc:param name="queryParameter2" value="MA"/&gt;
                    &lt;proc:param name="queryParameter3" value="-60"/&gt;
                  &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
              &lt;/ref:lnlink&gt;
      &lt;/doc:related-content-link&gt;
    &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;

     </xd:pre>
         <xd:p>
            <xd:b>Source XML 6 - <xd:i>lnlink[@service="ATTACHMENT"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo:assoc-links&gt;
    &lt;docinfo:assoc-links-grp assoc-content="related-documents"&gt;
        &lt;heading&gt;
            &lt;title&gt;Related Documents&lt;/title&gt;
        &lt;/heading&gt;
        &lt;lnlink service="ATTACHMENT"&gt;
            &lt;marker&gt;See PDF rendition&lt;/marker&gt;
            &lt;api-params&gt;
                &lt;param name="attachment-key" value="RSCS_14905_CURRENT-0001"/&gt;
                &lt;param name="attachment-type" value="PDF"/&gt;
                &lt;param name="componentseq" value="1"/&gt;
            &lt;/api-params&gt;
        &lt;/lnlink&gt;
    &lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;
     </xd:pre>
         <xd:p>
            <xd:b>Target XML 6</xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:related-content-grp grptype="related-documents"&gt;
    &lt;heading&gt;
        &lt;title&gt;Related documents&lt;/title&gt;
    &lt;/heading&gt;
    &lt;doc:related-content-item&gt;
        &lt;doc:related-content-link&gt;
            &lt;ref:lnlink service="ATTACHMENT"&gt;
                &lt;ref:marker role="label"&gt;See PDF rendition&lt;/ref:marker&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="attachment-key"/&gt;
                        &lt;ref:key-value value="{LNI}-{SMI}-RSCS_14905_CURRENT-0001"/&gt;
                        &lt;!-- 
                  The {LNI} and {SMI} are not literal values, 
                  they show where the LNI and SMI values 
                  obtained from CSSM should be output. 
              --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="attachment-type" value="PDF"/&gt;
                        &lt;proc:param name="attachment-smi" value="{SMI}"/&gt;
                        &lt;!-- proc:param/@value is set to the SMI value obtained from CSSM. --&gt;
                        &lt;!-- This @value assignment is done by the conversion program. --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:lnlink&gt;
        &lt;/doc:related-content-link&gt;
    &lt;/doc:related-content-item&gt;
&lt;/doc:related-content-grp&gt;
     </xd:pre>
         <xd:p>
            <xd:b>Source XML 7 - CA06-CA07
          <xd:i>docinfo:assoc-links-grp/remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
        
&lt;docinfo:assoc-links&gt;
  &lt;docinfo:assoc-links-grp assoc-content="enabling"&gt;
      &lt;heading&gt;
        &lt;title&gt;Enabling Act&lt;/title&gt;
      &lt;/heading&gt;
      &lt;remotelink remotekey1="DOCINFO(2cb2cdcca9bdd55a897d897ac67f7e39)" remotekey2="All Canadian Statutes" service="QUERY"&gt;Enabling Act&lt;/remotelink&gt;
  &lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;

        
      </xd:pre>
         <xd:p>
            <xd:b>Target XML 7 -
          CA06-CA07<xd:i>docinfo:assoc-links-grp/remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
    
&lt;doc:related-content&gt;
  &lt;doc:related-content-grp grptype="enablingLeg"&gt;
     &lt;heading&gt;
       &lt;title&gt;Enabling Act&lt;/title&gt;
     &lt;/heading&gt;
     &lt;doc:related-content-item content-type="enablingLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:2cb2cdcca9bdd55a897d897ac67f7e39"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;
    
 </xd:pre>
         <xd:p>
            <xd:b>Source XML 8 - CA05
          <xd:i>docinfo:assoc-links/remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo:assoc-links&gt;
    &lt;remotelink remotekey1="DOCINFO(5eff46c7fc603910e15eb944d97c13c0)"
        remotekey2="All Canadian Regulations" service="QUERY"&gt;Link to regulations enabled by this
        act&lt;/remotelink&gt;
&lt;/docinfo:assoc-links&gt;
      </xd:pre>
         <xd:p>
            <xd:b>Target XML 8 - CA05
          <xd:i>docinfo:assoc-links/remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:related-content&gt;
    &lt;doc:related-content-grp grptype="subordinateLeg"&gt;
      &lt;doc:related-content-item content-type="subordinateLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:5eff46c7fc603910e15eb944d97c13c0"/&gt;
        &lt;/ref:relatedresourceref&gt;
    &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;
 </xd:pre>
         <xd:p>
            <xd:b>Source XML 9 (CA06-CA07)</xd:b>
         </xd:p>
         <xd:pre>
        
&lt;docinfo:assoc-links&gt;
            &lt;docinfo:assoc-links-grp assoc-content="enabling"&gt;
                &lt;heading/&gt;
                &lt;remotelink
                    remotekey1="DOCINFO(2ccc2826b445aebac6f6b3f8013e7931) 
                    OR DOCINFO(2ccc2826b445aebac6f6b3f8013e7932) 
                    OR DOCINFO(2ccc2826b445aebac6f6b3f8013e7933) 
                    ....
                    OR DOCINFO(2ccc2826b445aebac6f6b3f8013e7939)"
                    remotekey2="All Canadian Statutes" service="QUERY"&gt;Enabling Act&lt;/remotelink&gt;
          &lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;
        
      </xd:pre>
         <xd:p>
            <xd:b>Target XML 9 (CA06-CA07)</xd:b>
         </xd:p>
         <xd:pre>
        
&lt;doc:related-content&gt;
  &lt;doc:related-content-grp grptype="enablingLeg"&gt;
         &lt;heading&gt;
		  &lt;title&gt;Enabling Act&lt;/title&gt;
	  &lt;/heading&gt;
     &lt;doc:related-content-item content-type="enablingLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:2ccc2826b445aebac6f6b3f8013e7931"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
     &lt;doc:related-content-item content-type="enablingLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:2ccc2826b445aebac6f6b3f8013e7932"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
          &lt;doc:related-content-item content-type="enablingLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:2ccc2826b445aebac6f6b3f8013e7933"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
     ....
     &lt;doc:related-content-item content-type="enablingLeg"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:leg-id-1:2ccc2826b445aebac6f6b3f8013e7939"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;
        
      </xd:pre>
         <xd:p>
            <xd:b>Source XML 10 (CA03)</xd:b>
         </xd:p>
         <xd:pre>
        
    &lt;docinfo:assoc-links&gt;
      &lt;remotelink service="QUERY" remotekey1="REFNUM(01704997)" remotekey2="All Canadian Summaries (Netletters, Digests, Summaries)" xml:lang="en-CA"&gt;Find case digests&lt;/remotelink&gt;
      &lt;remotelink service="QUERY" remotekey1="REFNUM(01704997)" remotekey2="All Canadian Summaries (Netletters, Digests, Summaries)" xml:lang="fr-CA"&gt;Rsums jurisprudentiels&lt;/remotelink&gt;
    &lt;/docinfo:assoc-links&gt;
        
      </xd:pre>
         <!--CA03 note: doc:related-content-grp/@grptype we set to the same as doc:related-content-item@content-type: enablingLeg | subordinateLeg | caseSummaries | quantums-->
         <xd:p>
            <xd:b>Target XML 10 (CA03)</xd:b>
         </xd:p>
         <xd:pre>
        
&lt;doc:related-content&gt;
  &lt;doc:related-content-grp grptype="caseSummaries"&gt;
	  &lt;heading&gt;
		  &lt;title xml:lang="en-CA"&gt;Find case digests&lt;/title&gt;
		  &lt;title xml:lang="fr-CA"&gt;Rsums jurisprudentiels&lt;/title&gt;
	  &lt;/heading&gt;
     &lt;doc:related-content-item content-type="caseSummaries"&gt;
        &lt;ref:relatedresourceref&gt;
            &lt;ref:relatedresourceid ref:resourcekey="urn:ucn-1:01704997"/&gt;
        &lt;/ref:relatedresourceref&gt;
     &lt;/doc:related-content-item&gt;
  &lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;
        
      </xd:pre>
         <xd:p>
            <xd:b>Source XML 11 (LPA)</xd:b>
         </xd:p>
         <xd:pre>
        
&lt;docinfo:assoc-links&gt;
	&lt;docinfo:assoc-links-grp assoc-content="related-documents" content-type="form"&gt;
		&lt;docinfo:assoc-resource assoc-resourcename="BusLaw" assoc-resourceid="urn:krm:ABCDEABCDEABCDEABCDEABCDE3ABCDE1"/&gt;
		&lt;lnlink service="TRAVERSE"&gt;
			&lt;key-name name="normcite"/&gt;
			&lt;key-value value="LexisNexis Forms Form 219-8.22-7"/&gt;
			&lt;marker role="label"&gt;Notice of Commencement Of Case Under Chapter 11 of the Bankruptcy Code, Meeting of Creditors, and Deadlines--Chapter 11 Corporation/Partnership Case; Official Form 9F &lt;/marker&gt;
		&lt;/lnlink&gt;
		&lt;remotelink dpsi="0N5M" remotekey1="DOC-ID" remotekey2="0N5M_157408" service="DOC-ID"&gt;Exhibit A to Official Form 1&lt;/remotelink&gt;
		&lt;remotelink href="http://www.justice.gov/ust/index.htm" newwindow="YES" service="SEARCH" status="valid"&gt;Official Website of the U.S. Trustee Program&lt;/remotelink&gt;
	&lt;/docinfo:assoc-links-grp&gt;
	&lt;docinfo:assoc-links-grp assoc-content="related-documents" content-type="case"&gt;
		&lt;docinfo:assoc-resource assoc-resourcename="IP" assoc-resourceid="urn:krm:ABCDEABCDEABCDEABCDEABCDE3ABCDE2"/&gt;
		&lt;lnlink service="TRAVERSE"&gt;
			&lt;key-name name="normcite"/&gt;
			&lt;key-value value="2012 U.S. Bankr. Ct. Motions LEXIS 1246"/&gt;
			&lt;marker role="label"&gt;2012 U.S. Bankr. Ct. Motions LEXIS 1246 (Bankr. N.D. Ill.)&lt;/marker&gt;
		&lt;/lnlink&gt;
		&lt;remotelink dpsi="0N5N" remotekey1="DOC-ID" remotekey2="0N5N-0N5N_157355" service="DOC-ID"&gt;Emergency Motion for Joint Administration of Chapter 11 Cases&lt;/remotelink&gt;
		&lt;remotelink href="http://www.uscourts.gov/RulesAndPolicies/FederalRulemaking/LocalCourtRules/USBankruptcyCourts.htm" newwindow="YES" service="SEARCH" status="valid"&gt;Official Website of the Federal Judiciary&lt;/remotelink&gt;
	&lt;/docinfo:assoc-links-grp&gt;
&lt;/docinfo:assoc-links&gt;
        
      </xd:pre>
         <xd:p>
            <xd:b>Target XML 11 (LPA)</xd:b>
         </xd:p>
         <xd:pre>
        
&lt;doc:related-content&gt;
	&lt;doc:related-content-grp grptype="related-documents"&gt;
		&lt;ref:relatedresourceref&gt;
			&lt;ref:relatedresourceid ref:resourcekey="urn:krm:ABCDEABCDEABCDEABCDEABCDE3ABCDE1"/&gt;
		&lt;/ref:relatedresourceref&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="TRAVERSE"&gt;
					&lt;ref:marker role="label"&gt;Notice of Commencement Of Case Under Chapter 11 of the Bankruptcy Code, Meeting of Creditors, and Deadlines--Chapter 11 Corporation/Partnership Case; Official Form 9F &lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="normcite"/&gt;
							&lt;ref:key-value value="LexisNexis Forms Form 219-8.22-7"/&gt;
						&lt;/ref:locator-key&gt;
						&lt;ref:locator-params&gt;
							&lt;proc:param name="normprotocol" value="lexsee"/&gt;
						&lt;/ref:locator-params&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="DOCUMENT"&gt;
					&lt;ref:marker&gt;Exhibit A to Official Form 1&lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="DOC-ID"/&gt;
							&lt;ref:key-value value="0N5M-0N5M_157408"/&gt;
						&lt;/ref:locator-key&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="URL"&gt;
					&lt;ref:marker&gt;Official Website of the U.S. Trustee Program&lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="URL"/&gt;
							&lt;ref:key-value value="http://www.justice.gov/ust/index.htm"/&gt;
						&lt;/ref:locator-key&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
	&lt;/doc:related-content-grp&gt;
	&lt;doc:related-content-grp grptype="related-documents"&gt;
		&lt;ref:relatedresourceref&gt;
			&lt;ref:relatedresourceid ref:resourcekey="urn:krm:ABCDEABCDEABCDEABCDEABCDE3ABCDE2"/&gt;
		&lt;/ref:relatedresourceref&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="TRAVERSE"&gt;
					&lt;ref:marker role="label"&gt;2012 U.S. Bankr. Ct. Motions LEXIS 1246 (Bankr. N.D. Ill.)&lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="normcite"/&gt;
							&lt;ref:key-value value="2012 U.S. Bankr. Ct. Motions LEXIS 1246"/&gt;
						&lt;/ref:locator-key&gt;
						&lt;ref:locator-params&gt;
							&lt;proc:param name="normprotocol" value="lexsee"/&gt;
						&lt;/ref:locator-params&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="DOCUMENT"&gt;
					&lt;ref:marker&gt;Emergency Motion for Joint Administration of Chapter 11 Cases&lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="DOC-ID"/&gt;
							&lt;ref:key-value value="0N5N-0N5N_157355"/&gt;
						&lt;/ref:locator-key&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
		&lt;doc:related-content-item&gt;
			&lt;doc:related-content-link&gt;
				&lt;ref:lnlink service="URL"&gt;
					&lt;ref:marker&gt;Official Website of the Federal Judiciary&lt;/ref:marker&gt;
					&lt;ref:locator&gt;
						&lt;ref:locator-key&gt;
							&lt;ref:key-name name="URL"/&gt;
							&lt;ref:key-value value="http://www.uscourts.gov/RulesAndPolicies/FederalRulemaking/LocalCourtRules/USBankruptcyCourts.htm"/&gt;
						&lt;/ref:locator-key&gt;
					&lt;/ref:locator&gt;
				&lt;/ref:lnlink&gt;
			&lt;/doc:related-content-link&gt;
		&lt;/doc:related-content-item&gt;
	&lt;/doc:related-content-grp&gt;
&lt;/doc:related-content&gt;
        
      </xd:pre>
         <!-- McNally Apr 3 2014. Removing Example 4 to avoid confusion with separate module for AU-NZ use case. -->
         <!--        <example>
            <title>Source XML 4</title>
            <codeblock>
            <![CDATA[
                <docinfo:assoc-links>
                    <docinfo:assoc-links-grp>
                        <heading>
                            <title>Related Content</title>
                        </heading>
                        <remotelink dpsi="0084" remotekey1="REFPTID" service="DOC-ID" refpt="PCL.C19">Chapter 19
                            Debt Finance</remotelink>
                            <text>Ford's Principles of Corporations Law</text>
                        <remotelink dpsi="0KKU" remotekey1="REFPTID" service="DOC-ID" refpt="0KKU_72492">Overall
                            results and consequences of the PPSA</remotelink>
                        <text>LexisNexis Practical Guidance, Family module</text>
                        <remotelink href="www.familycourt.gov.au" hrefclass="http" newwindow="YES">Family Court of
                            Australia</remotelink>
                    </docinfo:assoc-links-grp>
                </docinfo:assoc-links>
             ]]>
	   </codeblock>
        </example>

        <example>
            <title>Target XML 4</title>
            <codeblock>
<![CDATA[
 <doc:related-content>
                 <doc:related-content-grp grptype="related-content">
                     <heading><title>Related Content</title></heading>
                     <doc:related-content-item>
                     <doc:related-content-link>
                         <ref:lnlink service="DOCUMENT">
                             <ref:marker>Chapter 19 Debt Finance</ref:marker>
                             <ref:locator>
                                 <ref:locator-key>
                                     <ref:key-name name="DOC-ID"/>
                                     <ref:key-value value="0084-PCL.C19"/>
                                 </ref:locator-key>
                             </ref:locator>
                         </ref:lnlink>
                     </doc:related-content-link>
                     </doc:related-content-item>
                     <doc:related-content-item>
                         <doc:related-content-desc>
                             <p><text>Ford's Principles of Corporations Law</text></p>
                         </doc:related-content-desc>
                     </doc:related-content-item>
                     <doc:related-content-item>
                         <doc:related-content-link>
                             <ref:lnlink service="DOCUMENT">
                                 <ref:marker>Overall
                                 results and consequences of the PPSA</ref:marker>
                                 <ref:locator>
                                     <ref:locator-key>
                                         <ref:key-name name="DOC-ID"/>
                                         <ref:key-value value="0KKU-0KKU_72492"/>
                                     </ref:locator-key>
                                 </ref:locator>
                             </ref:lnlink>
                         </doc:related-content-link>
                     </doc:related-content-item>
                     <doc:related-content-item>
                         <doc:related-content-desc>
                             <p><text>LexisNexis Practical Guidance, Family module</text></p>
                         </doc:related-content-desc>
                     </doc:related-content-item>
                     <doc:related-content-item>
                         <doc:related-content-link>
                             <ref:lnlink service="URL">
                                 <ref:marker>Family Court of Australia</ref:marker>
                                 <ref:locator>
                                     <ref:locator-key>
                                       <ref:key-name name="URL"/>
                                       <ref:key-value value="http://www.familycourt.gov.au"/>
                                     </ref:locator-key>
                                 </ref:locator>
                             </ref:lnlink>
                         </doc:related-content-link>
                     </doc:related-content-item>
                </doc:related-content-grp>
                ]]>
	   </codeblock>
	   </example>-->
         <!-- McNally Apr 3 2014. Removing Example 5 to avoid confusion with separate module for AU-NZ use case. -->
         <!--  <example>
   <title>Source XML 5 :
    <sourcexml>docinfo:assoc-links/docinfo:assoc-links-grp/ci:cite</sourcexml></title>
   <codeblock>
<![CDATA[
<docinfo:assoc-links>
 <docinfo:assoc-links-grp>  
  <heading><title>Related Content</title></heading>
  <remotelink dpsi="008D" remotekey1="DOC-ID" service="DOC-ID" refpt="PIL.OV">Overview of Insurance</remotelink>
  <text>Kelly &amp; Ball Principles of Insurance Law</text>
  <remotelink dpsi="0384" remotekey1="DOC-ID" service="DOC-ID" refpt="PFI.ICA.ICA">Insurance Contracts Act 1984</remotelink>
  <text>Australian Insurance Law Annotated</text>
  <ci:cite searchtype="BOOK-REF">
   <ci:content>The central role of insurance in modern society and in the development of the law (2013) 24 ILJ 1</ci:content>
  </ci:cite>
  <text>Insurance Law Journal</text>
 </docinfo:assoc-links-grp>
</docinfo:assoc-links>]]>
            </codeblock>
  </example>
  <example>
   <title>Target XML 5 :
    <sourcexml>docinfo:assoc-links/docinfo:assoc-links-grp/ci:cite</sourcexml></title>
   <codeblock>
<![CDATA[
<doc:related-content>
 <doc:related-content-grp> 
  <heading><title>Related Content</title></heading>
  <doc:related-content-item>
    <doc:related-content-link>
     <ref:lnlink service="DOCUMENT">
      <ref:marker>Overview of Insurance</ref:marker>
      <ref:locator>
       <ref:locator-key>
        <ref:key-name name="DOC-ID"/>
        <ref:key-value value="008D-PIL.OV"/>
       </ref:locator-key>
      </ref:locator>
     </ref:lnlink>
    </doc:related-content-link>
    <doc:related-content-desc>
     <p><text>Kelly &amp; Ball Principles of Insurance Law</text></p>
    </doc:related-content-desc>
  </doc:related-content-item>
  <doc:related-content-item>
    <doc:related-content-link>
     <ref:lnlink service="DOCUMENT">
      <ref:marker>Insurance Contracts Act 1984</ref:marker>
      <ref:locator>
       <ref:locator-key>
        <ref:key-name name="DOC-ID"/>
        <ref:key-value value="0384-PFI.ICA.ICA"/>
       </ref:locator-key>
      </ref:locator>
     </ref:lnlink>
    </doc:related-content-link>
    <doc:related-content-desc>
     <p><text>Australian Insurance Law Annotated</text></p>
    </doc:related-content-desc>
  </doc:related-content-item>
  <doc:related-content-item>
    <doc:related-content-link>
     <ref:lnlink service="TRAVERSE">
      <ref:marker role="label">The central role of insurance in modern society and in the development of the law (2013) 24 ILJ 1</ref:marker>
      <ref:locator>
       <ref:locator-key>
        <ref:key-name name="normcite"/>
        <ref:key-value value="The central role of insurance in modern society and in the development of the law (2013) 24 ILJ 1"/>
       </ref:locator-key>
       <ref:locator-params>
        <proc:param name="normprotocol" value="lexsee"/>
        <proc:param name="countrycode" value="AU"/>
       </ref:locator-params>
      </ref:locator>
     </ref:lnlink>
    </doc:related-content-link>
    <doc:related-content-desc>
     <p><text>Insurance Law Journal</text></p>
    </doc:related-content-desc>
  </doc:related-content-item>
 </doc:related-content-grp>
</doc:related-content>]]>                
            </codeblock>
  </example>-->
         <!--Changes2016-11-16: Added to note regarding applying any rules related to 
        @anchoridref, referring specifically to section for "Identifiers to ID Data Type - 
        Handling Pattern Restrictions".2016-07-29: Added Note about xml snippets that illustrate image
          handling. Note summarizes move from Apollo to Blobstore application. UK is first LBU to
          move to Blobstore.2015-09-11: Added instruction for handling of
            lnlink[@service="URL"] inside
            docinfo:assoc-links or
            docinfo:assoc-links-grp.2015-09-11: Correction to target XPATHs for
            lnlink[@service="QUERYLINK"],
            lnlink[@service="ATTACHMENT"], and
            lnlink[@service="TRAVERSE"] to add
            doc:related-content-item/doc:related-content-link before the
          existing ref:lnlink element in the XPATH.2015-09-03: Added instruction for handling of
            lnlink[@service="TRAVERSE"] inside
            docinfo:assoc-links or
            docinfo:assoc-links-grp.2015-09-03: Added
            doc:related-content-item/@content-type="external-content-location"
          when the parent
            docinfo:assoc-links[@assoc-content="external-content-location"]
          exists, for children: remotelink[@service="DOC-ID"],
            remotelink[@href],
            lnlink[@service="TRAVERSE"] and
          ci:cite.2015-09-03: Minor correction to bullet heading text for
          children of docinfo:assoc-links or
            docinfo:assoc-links-grp to change from
            lnlink/@service="QUERYLINK" to be
            lnlink[@service="QUERYLINK"] and
            lnlink/@service="ATTACHMENT" to be
            lnlink[@service="ATTACHMENT"].2015-07-16: Updated conversion for handling of
            ci:cite/@normprotocol,
            proc:param[@name="countrycode"]; added instructions for
            docinfo:assoc-resource.2015-05-22: Clarification. Not a new rule or target. Within
          rules handling remotelink[@service="DOC-ID"], added statement to
          create containing elements ref:locator/ref:locator-key which hold
            ref:key-name and ref:key-value. The xpath
          is controlled by schema and so conversions have been correct. CI examples were correct.
          The narrative rule is now explicit. R4.5 Content Issue 2326.2015-01-19: For CA05 - CA08- Updated Instruction and
          included "related-content-grp" markup inside the target Example
            8 for conversion of QUERY link to doc:related-content.2015-01-15: For CA03- Convert the QUERY link to
          doc:related-content. Refer Example 10. R4.5 RFA #2099.2015-01-13: For CA05 - CA08 Conversion Needs to split
          multiple ORs into a separate doc:related-content-item. Refer
          Example 92015-01-02: Added
            docinfo:assoc-links/remotelink[@service="QUERY"] and
            docinfo:assoc-links-grp/remotelink[@service="QUERY"] to generate
            doc:related-content markup. Applicable on CA05.2014-12-19: Updated target mapping for CA05 for handling
            docinfo:assoc-links/remotelink[@service="QUERY"]. Applicable on
          CA05.2014-12-17: Added a Note for CA05, CA06, CA07 and CA08
          for handling docinfo:assoc-links-grp/remotelink[@service="QUERY"]
           R4.5 issue #2088 and #2068.2014-09-16: Added a note to create
            proc:param/@name="attachment-smi" and
            proc:param/@value as these was there in the snippet but was
          missing in instruction and also added a note in to simplify in output
            ref:key-value/@value2014-08-21: Added instructions and an example for converting
            lnlink[@service="ATTACHMENT"] to
            ref:lnlink. Applicable on CA05-CA08.2014-06-18: Corrected minor typos in
            lnlink[@service="QUERYLINK"] instructions.2014-06-13: Added instructions and an example for converting
            lnlink[@service="QUERYLINK"] to
          ref:lnlink.2014-04-28: Clarified instructions regarding
            link elements and added an example (#4) illustrating the special
            text/link conversion. No mapping rules where changed or
          added.2014-04-21: Added an instruction to handle
            link elements. These can potentially occur in any future UK data
          and will be present in stream UK21fl when those documents become available later in
          2014.2014-04-03: Illustrative changes. Examples modified. Mapping
          for ci:cite added to Example 3. Former Examples 4 and 5 removed to
          avoid confusion with special AU-NZ use case described in a separate module. R4.5 Content
          issue #1125, for AU-NZ, has prompted the changes for this general module.2014-03-25: Added rule and example for
            docinfo:assoc-links/docinfo:assoc-links-grp/ci:cite. R4.5 Content
          issue #11252013-07-19: Added rule mapping attribute
            remotelink[@service="DOC-ID"] to
            ref:lnlink[@service="DOCUMENT"].2013-04-12: This module was changed from UK specific to
          applicable to all LBUs2013-04-10: An example for related content Source and Target
          XML 42013-03-28:  Added rules for
            docinfo:assoc-links-grp and for child
          text.2013-01-22:  Added mapping instruction for
            docinfo:assoc-links/remotelink @href.2012-12-05:  Example added for Canada content stream.2012-10-15:  Made some Kraken related changes.2012-10-08: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.assoc-links-LxAdv-doc.related-content.dita  -->
   <!-- begin debug code -->
   <!--<xsl:param name="streamID" select="'CA07'"/>
  
  <xsl:include href="../../modules/nonamespace/Rosetta_identifier-LxAdv-ID_data_type-HandlingPatternRestrictions.xsl"/> 
  
  <xsl:template match="heading">
    <xsl:copy-of select="."/>
  </xsl:template>-->
   <!-- end debug code -->
   <!-- Awantika:use of variable for AU20 -->
   <xsl:template match="docinfo:assoc-links">
      <xsl:if test="child::*[not(self::remotelink[@service='QUERY'])] or $streamID=('CA03', 'CA05', 'CA06', 'CA07', 'CA08')">
         <doc:related-content>
            <xsl:apply-templates select="@* | node()"/>
         </doc:related-content>
      </xsl:if>
   </xsl:template>

   <xsl:template match="docinfo:assoc-links/@assoc-content"/>
   <!-- JL: to match DT, suppressing docinfo:assoc-links/@display-name -->
   <xsl:template match="docinfo:assoc-links/@display-name"/>

   <xsl:template match="docinfo:assoc-links-grp">
      <doc:related-content-grp>
         <xsl:apply-templates select="@* | node()"/>
         <!-- Awantika-2017-10-13: creating empty doc:related-content-item which is required child element for docinfo:assoc-links-grp
      Input data is coming with empty text the module created for docinfo:assoc-links-grp/text is not recognising the empty text and therefore 
      making the file invalid-->
         <!-- 2017-10-24 - MDS: Added 'UK11DA' streamID to test. -->
         <xsl:if test="$streamID=('UK11DN' , 'UK11DA') and child::text[not(preceding-sibling::* except heading and following-sibling::*)]=''">
            <doc:related-content-item/>
         </xsl:if>
         <xsl:if test="$streamID=('CA05' , 'CA06') and child::remotelink[@service='QUERY'][not(following-sibling::*) and preceding-sibling::heading='']">
            <doc:related-content-item/>
         </xsl:if>
      </doc:related-content-grp>
   </xsl:template>

   <xsl:template match="docinfo:assoc-links-grp/@assoc-content">
      <xsl:attribute name="grptype">
         <xsl:choose>
            <xsl:when test="(starts-with($streamID,'CA06') or starts-with($streamID ,'CA07')) and .='enabling'            and parent::docinfo:assoc-links-grp/remotelink[@service='QUERY'][starts-with(@remotekey1 , 'DOCINFO(')][@remotekey2[.='All Canadian Statutes']]">
               <xsl:text>enablingLeg</xsl:text>
            </xsl:when>
            <xsl:when test="(starts-with($streamID , 'CA05') or starts-with($streamID , 'CA08')) and parent::docinfo:assoc-links-grp/remotelink[@service='QUERY'][starts-with(@remotekey1 , 'DOCINFO(')][@remotekey2[.='All Canadian Regulations']]">
               <xsl:text>subordinateLeg</xsl:text>
            </xsl:when>
            <xsl:when test="starts-with($streamID , 'CA03') and parent::docinfo:assoc-links-grp/remotelink[@service='QUERY'][starts-with(@remotekey1 , 'REFNUM(')][@remotekey2='All Canadian Summaries']">
               <xsl:text>caseSummaries</xsl:text>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="."/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="docinfo:assoc-links-grp/@display-name">
      <xsl:if test="not(parent::docinfo:assoc-links-grp[@assoc-content])">
         <xsl:attribute name="grptype">
            <xsl:value-of select="."/>
         </xsl:attribute>
      </xsl:if>
   </xsl:template>

   <xsl:template match="docinfo:assoc-links-grp/@content-type"/>

   <xsl:template match="docinfo:assoc-resource"><!--  Original Target XPath:  ref:relatedresourceref/ref:relatedresourceid   -->
      <ref:relatedresourceref>
         <ref:relatedresourceid>
            <xsl:apply-templates select="@* | node()"/>
         </ref:relatedresourceid>
      </ref:relatedresourceref>
   </xsl:template>

   <xsl:template match="docinfo:assoc-resource/@assoc-resourceid">
      <xsl:attribute name="ref:resourcekey">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="docinfo:assoc-resource/@assoc-resourcename"/>
   <!-- <xsl:template match="docinfo:assoc-links/text | docinfo:assoc-links-grp/text">
    <xsl:choose>
      <xsl:when test="child::link and not(child::*[not(self::link)]) and not(text())">
        <xsl:apply-templates select="link"/>
      </xsl:when>
        <xsl:otherwise>
          <doc:related-content-item>
            <doc:related-content-desc>
              <p xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                <text xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                  <xsl:apply-templates select="@* | node()"/>
                </text>
              </p>
            </doc:related-content-desc>
          </doc:related-content-item>
        </xsl:otherwise>     
    </xsl:choose>    
  </xsl:template>-->   <!-- 12/12/17 backed out 'priority="5" -->   <!-- BRT 12/7/17 W*7065778 added priority='5' docinfo:assoc-links-grp/text was getting triggered somewhere else (couldn't find the template)-->
   <xsl:template match="docinfo:assoc-links/text | docinfo:assoc-links-grp/text"><!-- BRT 12/12/17 backed out code to normalize the text --><!-- BRT 11/27/17 added processing to normlize the space in text nodes to avoid false positives --><!-- xsl:variable name="text">
      <xsl:for-each select="text()">
        <xsl:value-of select="normalize-space(.)"/>
      </xsl:for-each>
    </xsl:variable-->
      <xsl:choose><!-- BRT 12/12/17 backed out change: 'and not(text())' to  and $text =''" --><!-- BRT change 'and not(text())' to  and $text =''" -->
         <xsl:when test="child::link and not(child::*[not(self::link)]) and not(text())">
            <xsl:apply-templates select="link"/>
         </xsl:when>
         <!-- Awantika: remotelink[@service="DOC-ID"] becomes doc:related-content-item/doc:related-content-link/
ref:lnlink[@service="DOCUMENT"]. Added this for UK11DN -->
         <xsl:when test="(./remotelink or ./url/remotelink)and $streamID=('UK11DN','UK11DA')">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:when>
         <!-- Priya Kaushal: Added below code for UK 15 -->
         <xsl:when test="(./remotelink or ./url/remotelink) and $streamID=('UK15')">
            <doc:related-content-item>
               <doc:related-content-desc>
                  <p>
                     <text>
                        <xsl:apply-templates select="remotelink | url/remotelink"/>
                     </text>
                  </p>
               </doc:related-content-desc>
            </doc:related-content-item>
         </xsl:when>
         <!-- Awantika: when condition for UK11DN -->
         <xsl:when test="$streamID='UK11DN' and child::link">
            <xsl:apply-templates select="node() except emph"/>
         </xsl:when>
         <xsl:otherwise>
            <doc:related-content-item>
               <doc:related-content-desc>
                  <p>
                     <text>
                        <xsl:apply-templates select="@* | node()"/>
                     </text>
                  </p>
               </doc:related-content-desc>
            </doc:related-content-item>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="link[parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp or parent::text[parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]]">
      <doc:related-content-item>
         <doc:related-content-link>
            <ref:lnlink service="ATTACHMENT">
               <ref:marker>
                  <xsl:apply-templates/>
               </ref:marker>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name name="attachment-key"/>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:choose>
                              <xsl:when test="@smi">
                                 <xsl:value-of select="substring-before(@filename, '.')"/>
                              </xsl:when>
                              <!-- BRT 2018-01-11 modified otherwise  to keep file extension. For UK15 determined the file extension is required for blobstore images; Rocel says it is required for other type images as well-->
                              <xsl:otherwise>
                                 <xsl:value-of select="@filename"/>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params><!-- 2017-10-04 - MDS: Added choose statement to test for stream ID to match modified monolithic in HK06 
            JL: 2017-10-06 added same for HK01--><!-- BRT 2018-01-02 added UK15 to choose statement. Note this template is almost exactly the same as in Rosetta_link-LxAdv-ref.lnlink_BLOBSTORE.xsl, which is commented out in UK15ds and is used by UK11dn. I don't know why both are present  -->
                     <xsl:choose>
                        <xsl:when test="$streamID=('HK06' , 'HK01', 'UK15')">
                           <proc:param name="attachment-type" value="IMG"/>
                           <proc:param name="external-or-local" value="external"/>
                           <proc:param name="attachment-server" value="BlobStore"/>
                           <proc:param name="attachment-pguid"
                                       value="urn:contentItem:0000-0000-0000-0000-00000-00"/>
                           <proc:param name="componentseq" value="1"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <proc:param name="componentseq" value="1"/>
                           <proc:param>
                              <xsl:attribute name="name">attachment-type</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:apply-templates select="@type"/>
                              </xsl:attribute>
                           </proc:param>
                           <proc:param>
                              <xsl:attribute name="name">attachment-smi</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="@smi"/>
                              </xsl:attribute>
                           </proc:param>
                        </xsl:otherwise>
                     </xsl:choose>
                  </ref:locator-params>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>
   <!-- MDS 2017-04-07 - Declared in Rosetta_link-LxAdv-ref.lnlink.xsl -->   <!--<xsl:template match="link/@type">
    <xsl:choose>
      <xsl:when test=".=('para','page', 'ed-pnum','refpt','logo')">
        <xsl:message>attachment-type is invalid, cannot be determined.</xsl:message>
      </xsl:when>
      <xsl:when test=".=('pdf' , 'pdf-fillable')">PDF</xsl:when>
      <xsl:when test=".='hotdoc-nonfillable'">hotdoc</xsl:when>
      <xsl:otherwise><xsl:value-of select="."/></xsl:otherwise>
    </xsl:choose>
  </xsl:template>-->
   <xsl:template match="remotelink[@service='QUERY'][ancestor::docinfo:assoc-links][$streamID=('CA03', 'CA05', 'CA06', 'CA07', 'CA08')]">
      <xsl:choose>
         <xsl:when test="(starts-with($streamID,'CA06') or starts-with($streamID ,'CA07')) and parent::docinfo:assoc-links-grp[@assoc-content='enabling']          and starts-with(@remotekey1 , 'DOCINFO(') and @remotekey2='All Canadian Statutes'">
            <xsl:call-template name="makeRelatedresourceref">
               <xsl:with-param name="contentType" select="'enablingLeg'"/>
            </xsl:call-template>
         </xsl:when>
         <xsl:when test="(starts-with($streamID , 'CA05') or starts-with($streamID , 'CA08')) and starts-with(@remotekey1 , 'DOCINFO(') and @remotekey2='All Canadian Regulations'">
            <xsl:call-template name="makeRelatedresourceref">
               <xsl:with-param name="contentType" select="'subordinateLeg'"/>
            </xsl:call-template>
         </xsl:when>
         <xsl:when test="starts-with(@remotekey1 , 'REFNUM(') and contains(@remotekey2,'All Canadian Summaries') and $streamID='CA03' and not(preceding-sibling::*[1][self::remotelink])">
            <doc:related-content-grp grptype="caseSummaries">
               <heading>
                  <title xml:lang="en-CA">
                     <xsl:value-of select="."/>
                  </title>
                  <title xml:lang="fr-CA">
                     <xsl:value-of select="following-sibling::remotelink"/>
                  </title>
               </heading>
               <doc:related-content-item content-type="caseSummaries">
                  <ref:relatedresourceref>
                     <ref:relatedresourceid>
                        <xsl:attribute name="ref:resourcekey">
                           <xsl:value-of select="concat('urn:ucn-1:' , substring-before(substring-after(@remotekey1 , 'REFNUM(') , ')'))"/>
                        </xsl:attribute>
                     </ref:relatedresourceid>
                  </ref:relatedresourceref>
               </doc:related-content-item>
            </doc:related-content-grp>
         </xsl:when>
         <!-- otherwise we do nothing for remotelink service QUERY -->
      </xsl:choose>
   </xsl:template>

   <xsl:template name="makeRelatedresourceref">
      <xsl:param name="contentType"/>
      <xsl:for-each select="tokenize(@remotekey1 , '\s+OR\s+')">
         <doc:related-content-item>
            <xsl:attribute name="content-type" select="$contentType"/>
            <ref:relatedresourceref>
               <ref:relatedresourceid>
                  <xsl:attribute name="ref:resourcekey">
                     <xsl:value-of select="concat('urn:leg-id-1:', substring-before(substring-after(. , 'DOCINFO(') , ')'))"/>
                  </xsl:attribute>
               </ref:relatedresourceid>
            </ref:relatedresourceref>
         </doc:related-content-item>
      </xsl:for-each>
   </xsl:template>

   <xsl:template match="remotelink[@service='DOC-ID'][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <xsl:if test="parent::docinfo:assoc-links[@assoc-content='external-content-location']">
            <xsl:attribute name="content-type">external-content-location</xsl:attribute>
         </xsl:if>
         <doc:related-content-link>
            <ref:lnlink>
               <xsl:attribute name="service">DOCUMENT</xsl:attribute>
               <ref:marker>
                  <xsl:apply-templates/>
               </ref:marker>
               <ref:locator>
                  <xsl:if test="@remotekey1='REFPTID' and (@refpt or @remotekey2)">
                     <xsl:attribute name="anchoridref">
                        <xsl:choose>
                           <xsl:when test="@refpt">
                              <xsl:for-each select="@refpt">
                                 <xsl:call-template name="normalizeIdString"/>
                              </xsl:for-each>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:for-each select="@remotekey2">
                                 <xsl:call-template name="normalizeIdString"/>
                              </xsl:for-each>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                  </xsl:if>
                  <ref:locator-key>
                     <xsl:choose>
                        <xsl:when test="@remotekey1='DOC-ID'">
                           <ref:key-name name="DOC-ID"/>
                           <ref:key-value>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="@dpsi"/>
                                 <xsl:text>-</xsl:text>
                                 <xsl:value-of select="if (@remotekey2) then @remotekey2 else @refpt"/>
                              </xsl:attribute>
                           </ref:key-value>
                        </xsl:when>
                        <xsl:when test="@remotekey1='REFPTID'">
                           <ref:key-name name="DOC-ID"/>
                           <ref:key-value>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="if (@dpsi) then @dpsi else //docinfo/docinfo:dpsi/@id-string"/>
                                 <xsl:text>-</xsl:text>
                                 <xsl:value-of select="@docidref"/>
                              </xsl:attribute>
                           </ref:key-value>
                        </xsl:when>
                     </xsl:choose>
                  </ref:locator-key>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>

   <xsl:template match="remotelink[@href][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]"
                 priority="25">
      <doc:related-content-item>
         <xsl:if test="parent::docinfo:assoc-links[@assoc-content='external-content-location']">
            <xsl:attribute name="content-type">external-content-location</xsl:attribute>
         </xsl:if>
         <doc:related-content-link>
            <ref:lnlink service="URL">
               <ref:marker>
                  <xsl:value-of select="."/>
               </ref:marker>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name name="URL"/>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="if (@hrefclass) then concat(@hrefclass, '://' , @href) else @href"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
         <xsl:apply-templates select="following-sibling::text[1][$streamID!='UK14']"/>
      </doc:related-content-item>
      <xsl:apply-templates select="following-sibling::*[1][self::text][$streamID='UK14']"/>
   </xsl:template>
   <!-- from other module: If the data content of the remotelink does not start with one of the previous listed
          text sequences, <sourcexml>remotelink</sourcexml> becomes
            <targetxml>ref:lnlink</targetxml> and is populated as follows:<ul>
            <li>The <targetxml>ref:lnlink/@service</targetxml> attribute is set to "URL".</li>
            <li>Element <targetxml>ref:lnlink/ref:marker</targetxml> is created and the content of
                <sourcexml>remotelink</sourcexml> becomes the content of child
                <targetxml>ref:lnlink/ref:marker</targetxml>. Any descendant element is converted
              according to instructions for that element in the section <i>General Mark-Up</i>.</li>
            <li>The child <targetxml>ref:lnlink/ref:locator</targetxml> is created, and within it
              the child <targetxml>ref:lnlink/ref:locator/ref:locator-key</targetxml> is created,
              and within it the children
                <targetxml>ref:lnlink/ref:locator/ref:locator-key/ref:key-name</targetxml> and
                <targetxml>ref:lnlink/ref:locator/ref:locator-key/ref:key-value</targetxml> are
              created.</li>
            <li>The <targetxml>ref:key-name/@name</targetxml> attribute is set to "URL".</li>
            <li>If the <sourcexml>remotelink/@hrefclass</sourcexml> attribute is present,
                <targetxml>ref:key-value/@value</targetxml> is set to the combined value of
                <sourcexml>remotelink/@hrefclass</sourcexml>, followed by "://", followed by the
              value of <sourcexml>remotelink/@href</sourcexml>.</li>
            <li>If the <sourcexml>remotelink/@hrefclass</sourcexml> attribute is <b>not</b> present,
                <targetxml>ref:key-value/@value</targetxml> is set to the value of
                <sourcexml>remotelink/@href</sourcexml>.</li> -->
   <xsl:template match="lnlink[@service='QUERYLINK'][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <doc:related-content-link>
            <ref:lnlink service="QUERYLINK">
               <xsl:apply-templates select="marker"/>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">
                           <xsl:value-of select="key-name[@name='queryTemplatePGUID']/@name"/>
                        </xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="key-value/@value"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <xsl:apply-templates select="api-params"/>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>

   <xsl:template match="lnlink/marker">
      <ref:marker>
         <xsl:apply-templates select="@*|node()"/>
      </ref:marker>
   </xsl:template>

   <xsl:template match="lnlink/marker/@role">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="api-params">
      <ref:locator-params>
         <xsl:apply-templates/>
         <xsl:if test="parent::lnlink[@service='ATTACHMENT']">
            <proc:param>
               <xsl:attribute name="name">attachment-smi</xsl:attribute>
               <xsl:attribute name="value"/>
               <xsl:message>need SMI from CSSM? Is this a parameter?</xsl:message>
            </proc:param>
         </xsl:if>
      </ref:locator-params>
   </xsl:template>

   <xsl:template match="param">
      <xsl:if test="@name!='attachment-key'">
         <xsl:choose><!-- Awantika: For AU20 one more param needs to be created with the name targetcontentType value practicalguidance -->
            <xsl:when test="$streamID='AU20'">
               <xsl:if test="not(following-sibling::param)">
                  <proc:param>
                     <xsl:attribute name="name">
                        <xsl:text>targetContentType</xsl:text>
                     </xsl:attribute>
                     <xsl:attribute name="value">
                        <xsl:text>practicalguidance</xsl:text>
                     </xsl:attribute>
                  </proc:param>
               </xsl:if>
               <xsl:variable name="docinfoidtext" select="/*/docinfo/docinfo:doc-id/text()"/>
               <!-- Awantika: Need to create only proc:param for topiccode in AU20 for the specific condition -->
               <xsl:if test="$streamID='AU20' and contains(lower-case($docinfoidtext),'analytics') and ancestor::source_cttr:annotations[@annotgroup='LPG']">
                  <xsl:choose>
                     <xsl:when test="@name[.='topiccode']">
                        <proc:param>
                           <xsl:attribute name="name">
                              <xsl:text>topiccode</xsl:text>
                           </xsl:attribute>
                           <xsl:attribute name="value">
                              <xsl:value-of select="@value"/>
                           </xsl:attribute>
                        </proc:param>
                     </xsl:when>
                     <xsl:otherwise/>
                  </xsl:choose>
               </xsl:if>
            </xsl:when>
            <xsl:otherwise>
               <proc:param>
                  <xsl:apply-templates select="@name | @value"/>
               </proc:param>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:if>
   </xsl:template>

   <xsl:template match="param/@name | param/@value">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT'][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <doc:related-content-link>
            <ref:lnlink service="ATTACHMENT">
               <xsl:apply-templates select="marker"/>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">attachment-key</xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="api-params/param[@name='attachment-key']/@value"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <xsl:apply-templates select="api-params"/>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>

   <xsl:template match="lnlink[@service='TRAVERSE'][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <xsl:if test="parent::docinfo:assoc-links[@assoc-content='external-content-location']">
            <xsl:attribute name="content-type">external-content-location</xsl:attribute>
         </xsl:if>
         <doc:related-content-link>
            <ref:lnlink service="TRAVERSE">
               <xsl:apply-templates select="marker"/>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">
                           <xsl:value-of select="key-name/@name"/>
                        </xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="key-value/@value"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params>
                     <xsl:choose>
                        <xsl:when test="api-params/param[@name='normprotocol']">
                           <xsl:apply-templates select="api-params/param[@name='normprotocol']"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <proc:param name="normprotocol" value="lexsee"/>
                        </xsl:otherwise>
                     </xsl:choose>
                     <xsl:apply-templates select="api-params/param[@name!='normprotocol']"/>
                  </ref:locator-params>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>

   <xsl:template match="lnlink/@status"/>

   <xsl:template match="lnlink[@service='URL'][parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <xsl:if test="parent::docinfo:assoc-links[@assoc-content='external-content-location']">
            <xsl:attribute name="content-type">external-content-location</xsl:attribute>
         </xsl:if>
         <doc:related-content-link>
            <ref:lnlink service="URL">
               <xsl:apply-templates select="marker"/>
               <ref:locator>
                  <xsl:choose>
                     <xsl:when test="api-params/param[@name='URL']">
                        <ref:locator-key>
                           <ref:key-name name="URL"/>
                           <ref:key-value>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="api-params/param[@name='URL']/@value"/>
                              </xsl:attribute>
                           </ref:key-value>
                        </ref:locator-key>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates select="api-params"/>
                     </xsl:otherwise>
                  </xsl:choose>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>

   <xsl:template match="ci:cite[parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp]">
      <doc:related-content-item>
         <xsl:if test="parent::docinfo:assoc-links[@assoc-content='external-content-location']">
            <xsl:attribute name="content-type">external-content-location</xsl:attribute>
         </xsl:if>
         <doc:related-content-link>
            <ref:lnlink service="TRAVERSE">
               <ref:marker role="label">
                  <xsl:value-of select="ci:content"/>
               </ref:marker>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">normcite</xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="ci:content"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params>
                     <xsl:choose>
                        <xsl:when test="api-params/param[@name='normprotocol']">
                           <xsl:apply-templates select="api-params/param[@name='normprotocol']"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <proc:param name="normprotocol" value="lexsee"/>
                        </xsl:otherwise>
                     </xsl:choose>
                     <xsl:if test="//docinfo/docinfo:doc-country/@iso-cc">
                        <proc:param>
                           <xsl:attribute name="name">countrycode</xsl:attribute>
                           <xsl:attribute name="value">
                              <xsl:value-of select="//docinfo/docinfo:doc-country/@iso-cc"/>
                           </xsl:attribute>
                        </proc:param>
                     </xsl:if>
                  </ref:locator-params>
               </ref:locator>
            </ref:lnlink>
         </doc:related-content-link>
      </doc:related-content-item>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_AU_NZ_docinfo.assoc-links-LxAdv-additional-rule.dita"/> -->   <!--<xsl:include href="../../modules/docinfo/Rosetta_AU_NZ_docinfo.assoc-links-LxAdv-additional-rule.xsl"/>-->   <!-- rosetta element: docinfo:bookseqnum -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.bookseqnum-LxAdv-doc.bookseqnum.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>This is an LBU-supplied, unsigned numeric value that indicates the relative position of a document and must be unique within a source. 
					<xd:i>docinfo:bookseqnum</xd:i> becomes <xd:b>doc:bookseqnum</xd:b>.
				</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
		
		&lt;docinfo:bookseqnum&gt;273181624&lt;/docinfo:bookseqnum&gt;
		
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
		
		&lt;doc:bookseqnum&gt;273181624&lt;/doc:bookseqnum&gt;
		
			</xd:pre>
         <!--Changes2012-09-06: Created.
				-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.bookseqnum-LxAdv-doc.bookseqnum.dita  -->
   <xsl:template match="docinfo:bookseqnum[not( normalize-space( . ) = '' )]"><!--  Original Target XPath:  doc:bookseqnum   -->
      <doc:bookseqnum>
         <xsl:apply-templates select="@* | node()"/>
      </doc:bookseqnum>
   </xsl:template>
   <!--    From Rosetta_Elements-LxAdv-Empty_Elements.dita / .xsl   -->
   <xsl:template match="docinfo:bookseqnum[ normalize-space( . ) = '' ]"/>
   <!-- rosetta element: docinfo:authorattribution -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.authorattribution-LxAdv-dc.contributor.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:authorattribution/contrib</xd:i> becomes
          <xd:b>dc:metadata/dc:contributor</xd:b>
         </xd:p>
         <xd:p>If the attribute <xd:i>@ln.user-displayed</xd:i> exists on the element
          <xd:i>contrib</xd:i>, then supress the attribute in the target xml as shown
          below.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion needs to suppress <xd:i>docinfo:authorattribution/contrib</xd:i> when it's the child of <xd:i>leg:levelinfo</xd:i> and 
            <xd:i>levelinfo</xd:i>.This will be applicable to all pacific content streams.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
       
        &lt;docinfo&gt;
            &lt;docinfo:authorattribution&gt;
              &lt;contrib ln.user-displayed="false"&gt;Ian Serisier&lt;/contrib&gt;
            &lt;/docinfo:authorattribution&gt;
         &lt;/docinfo&gt;
                   
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
      
      &lt;doc:metadata&gt;
        &lt;doc:docinfo&gt;
            &lt;dc:metadata&gt;
                &lt;dc:contributor&gt;Ian Serisier&lt;/dc:contributor&gt;
            &lt;/dc:metadata&gt;       
        &lt;/doc:docinfo&gt;
      &lt;/doc:metadata&gt;
      
			</xd:pre>
         <xd:p>When <xd:i>person</xd:i> is an child of <xd:i>docinfo:authorattribution/contrib</xd:i> then <xd:i>docinfo:authorattribution/contrib/person</xd:i> becomes
        <xd:b>dc:metadata/dc:contributor/person:contributor@contributor-type="author"/person:person</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>       
&lt;docinfo&gt;
    &lt;docinfo:authorattribution&gt;
        &lt;contrib&gt;
            &lt;person&gt;
                &lt;name.text&gt;Assistant Professor Bernard McCabe&lt;/name.text&gt;
            &lt;/person&gt;
        &lt;/contrib&gt;
    &lt;/docinfo:authorattribution&gt;
&lt;/docinfo&gt;
          		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:docinfo&gt;
    &lt;dc:contributor&gt;
        &lt;person:contributor contributor-type="author"&gt;
            &lt;person:person&gt;
                &lt;person:name.text&gt;Assistant Professor Bernard McCabe&lt;/person:name.text&gt;
            &lt;/person:person&gt;
        &lt;/person:contributor&gt;
    &lt;/dc:contributor&gt;
&lt;/doc:docinfo&gt;
</xd:pre>
         <xd:p>When <xd:i>docinfo:authorattribution</xd:i> element is having a running text
                then it becomes <xd:b>dc:metadata/dc:contributor</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
       
        &lt;docinfo&gt;
            &lt;docinfo:authorattribution&gt;D C Pearce AO LLB (Adel) LLM (ANU) PhD (ANU)&lt;/docinfo:authorattribution&gt;
         &lt;/docinfo&gt;
                   
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
      
      &lt;doc:metadata&gt;
        &lt;doc:docinfo&gt;
            &lt;dc:metadata&gt;
                &lt;dc:contributor&gt;D C Pearce AO LLB (Adel) LLM (ANU) PhD (ANU)&lt;/dc:contributor&gt;
            &lt;/dc:metadata&gt;       
        &lt;/doc:docinfo&gt;
      &lt;/doc:metadata&gt;
      
</xd:pre>
         <xd:p>Exceptio scenario for AU14-Journals/Newsletters/Bulletins - When <xd:i>docinfo:authorattribution/contrib</xd:i> contains <xd:i>remotelink</xd:i> as a child element then conversion need to omit the <xd:i>remotelink</xd:i> element from conversion and retain the text in <xd:b>dc:contributor</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
       
        &lt;docinfo&gt;
         &lt;docinfo:authorattribution&gt;
            &lt;contrib&gt;The following is an outline of the planned changes to the [#b#]&lt;remotelink
                dpsi="02IJ" remotekey1="REFPTID" service="DOC-ID" refpt="2000A24"
                docidref="2000A24.BODY"&gt;Employment Relations Act 2000&lt;/remotelink&gt;[#/b#] announced
            by Prime Minister John Key at the National Party conference on 18 July. It was added as
            a link from the press release of Minister of Labour Kate Wilkinson &amp;#x201C;90-Day Trial
            Period extended to all employees&amp;#x201D;, available at [#b#]&lt;remotelink
                href="www.beehive.govt.nz/release/90-day+trial+period+extended+all+employers"
                hrefclass="http" newwindow="YES"
                &gt;www.beehive.govt.nz/release/90-day+trial+period+extended+all+employers&lt;/remotelink&gt;[#/b#].
            The material is subject to Crown copyright protection.&lt;/contrib&gt;
         &lt;/docinfo:authorattribution&gt;
        &lt;/docinfo&gt;
                   
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
      
      &lt;doc:metadata&gt;
         &lt;doc:docinfo&gt;
            &lt;dc:metadata&gt;
             &lt;dc:contributor&gt;The following is an outline of the planned changes to the
                 Employment Relations Act 2000 announced by Prime Minister John Key at the National
                Party conference on 18 July. It was added as a link from the press release of
                Minister of Labour Kate Wilkinson &amp;#x201C;90-Day Trial Period extended to all
                employees&amp;#x201D;, available at www.beehive.govt.nz/release/90-day+trial+period+extended+all+employers.
                The material is subject to Crown copyright protection.&lt;/dc:contributor&gt;
            &lt;/dc:metadata&gt;
        &lt;/doc:docinfo&gt;
    &lt;/doc:metadata&gt;
      
</xd:pre>
         <!--Changes2013-04-10:  Created2013-06-25: added to AU and NZ ditamap for content enrichment2013-08-13: Added instruction and example when
            person is an child of
        docinfo:authorattribution/contrib and CR# DAAM2013080706295200 has been created to add person:person to the content model of dc:contributor.WebTeam # is 2295092013-08-22: Updated instruction and example when
            person is an child of
            docinfo:authorattribution/contrib and removed CR# DAAM2013080706295200. WebTeam # is 229509.2013-09-16: Instruction added for suppressing
                        docinfo:authorattribution/contrib when it is child of
                        leg:levelinfo and
                    levelinfo.Affects all Pacific content streams. WebTeam #
                    is 234193.2013-10-08: Instruction added for handling
                        docinfo:authorattribution when it is having a running
                        text. Affects all Pacific content streams. WebTeam # is 238798.2013-10-11: Instruction added when remotelink as a child of docinfo:authorattribution/contrib. WebTeam # is 240252.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="docinfo:authorattribution">
      <dc:contributor>
         <xsl:apply-templates select="@* | node()"/>
      </dc:contributor>
   </xsl:template>

   <xsl:template match="docinfo:authorattribution[$streamID='AU08'][contrib/@ln.user-displayed='false']"
                 priority="2"/>

   <xsl:template match="docinfo:authorattribution/contrib"><!--  Original Target XPath:  dc:metadata/dc:contributor   -->
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>

   <xsl:template match="docinfo:authorattribution/contrib/@ln.user-displayed"/>

   <xsl:template match="docinfo:authorattribution[parent::leg:levelinfo|parent::levelinfo]"/>

   <xsl:template match="docinfo:authorattribution/contrib/person"><!--  Original Target XPath:  dc:metadata/dc:contributor/person:contributor@contributor-type="author"/person:person   -->
      <person:contributor contributor-type="author">
         <person:person>
            <xsl:apply-templates select="@* | node()"/>
         </person:person>
      </person:contributor>
   </xsl:template>

   <xsl:template match="docinfo:authorattribution/contrib/remotelink">
      <xsl:apply-templates select="node()"/>
   </xsl:template>
   <!--	<xsl:template match="leg:levelinfo">

		<!-\-  Original Target XPath:  dc:metadata/dc:contributor/person:contributor@contributor-type="author"/person:person   -\->
		<dc:metadata>
			<dc:contributor>
				<person:contributor>
					<person:person>
						<xsl:apply-templates select="@* | node()"/>
					</person:person>
				</person:contributor>
			</dc:contributor>
		</dc:metadata>

	</xsl:template>-->   <!-- rosetta element: docinfo:currencystatement -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.currencystatement-LxAdv-currencystatement.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>The source element<xd:i>docinfo:currencystatement</xd:i> becomes <xd:b>doc:docinfo/currencystatment</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion needs to suppress <xd:i>docinfo:currencystatement</xd:i> when it's the child of <xd:i>leg:levelinfo</xd:i> and  <xd:i>levelinfo</xd:i>. This will be applicable to all <xd:b>Pacific Content Streams</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
            
                &lt;docinfo:currencystatement&gt;Consolidated as in force on &lt;date&gt;10 September 2012&lt;/date&gt;&lt;/docinfo:currencystatement&gt;
            
	       </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
            
                &lt;doc:docinfo&gt;
                    &lt;currencystatement&gt;Consolidated as in force on &lt;date&gt;10 September 2012&lt;/date&gt;&lt;/currencystatement&gt;
                &lt;/doc:docinfo&gt;
            
	      </xd:pre>
         <!--Changes2013-04-09: Created2013-06-25: added to AU and NZ ditamap for content enrichment2013-09-16: Instruction added for suppressing docinfo:currencystatement when it is child of leg:levelinfo and  levelinfo.Affects all Pacific content streams. WebTeam # is 234193.2013-09-16: WebTeam #233318 created for pacific content stream inorder to suppress docinfo:currencystatement with in leg:levelinfo and levelinfo.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="docinfo:currencystatement[not(parent::leg:levelinfo | parent::levelinfo)]"><!--  Original Target XPath:  doc:docinfo/currencystatement   -->
      <currencystatement>
         <xsl:apply-templates select="@* | node()"/>
      </currencystatement>
   </xsl:template>

   <xsl:template match="leg:levelinfo/docinfo:currencystatement | leg:levelinfo/docinfo:currencystatement/contrib | levelinfo/docinfo:currencystatement"/>
   <!-- rosetta element: docinfo:custom-metafields -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.custom-metafields-LxAdv-SUPPRESS.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>The only uses of <xd:i>docinfo:custom-metafield</xd:i> in Australian and
                New Zealand data all have <xd:i>@name="COURT-CLASSIFY"</xd:i>. Since
                metafields with this name should be suppressed, all occurrances of
                    <xd:i>docinfo:custom-metafield</xd:i> should be suppressed. Further,
                because <xd:i>docinfo:custom-metafield</xd:i> is the only child of
                    <xd:i>docinfo:custom-metafields</xd:i>, the entire
                    <xd:i>docinfo:custom-metafields</xd:i> can be suppressed. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:custom-metafields&gt;
    &lt;docinfo:custom-metafield name="date"&gt;20070919&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="country"&gt;1&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="juris"&gt;30&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="court"&gt;145&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="dpsi"&gt;03EX&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield searchtype="COURT-CLASSIFY"&gt;BCLabRelBd&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield searchtype="JURIS-CLASSIFY"&gt;BC&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield searchtype="CITED-COUNT"&gt;0&lt;/docinfo:custom-metafield&gt;
&lt;/docinfo:custom-metafields&gt;

            </xd:pre>
         <xd:p>The all above elements should be dropped except for
                    <xd:i>docinfo:custom-metafield[@searchtype="CITED-COUNT"]</xd:i> and
                    <xd:i>docinfo:custom-metafield[@name="dpsi"]</xd:i> .</xd:p>
         <xd:p>
            <xd:b>Source XML showing @name="COURT-CLASSIFY"</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:custom-metafields&gt;
    &lt;docinfo:custom-metafield name="COURT-CLASSIFY"&gt;FCA&lt;/docinfo:custom-metafield&gt;
&lt;/docinfo:custom-metafields&gt;

            </xd:pre>
         <xd:p>The above elements should be dropped.</xd:p>
         <xd:p>
            <xd:b>Source XML showing @searchtype="CITED-COUNT"</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:custom-metafields&gt;
    &lt;docinfo:custom-metafield searchtype="CITED-COUNT"&gt;0&lt;/docinfo:custom-metafield&gt;
&lt;/docinfo:custom-metafields&gt;

            </xd:pre>
         <xd:p>The above elements should be retained.</xd:p>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
    &lt;meta&gt;
        &lt;metaitem name="CITED-COUNT" value="0"/&gt;
    &lt;/meta&gt;
&lt;/doc:legacy-metadata&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Source XML showing @name="dpsi"</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:custom-metafields&gt;
    &lt;docinfo:custom-metafield name="dpsi"&gt;03EX&lt;/docinfo:custom-metafield&gt;
&lt;/docinfo:custom-metafields&gt;

            </xd:pre>
         <xd:p>The above elements should be retained.</xd:p>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
    &lt;meta&gt;
        &lt;metaitem name="dpsi" value="03EX"/&gt;
    &lt;/meta&gt;
&lt;/doc:legacy-metadata&gt;

            </xd:pre>
         <xd:p>For CA Dictionary only: <xd:i>docinfo:custom-metafield
                    name="JURIS-SORT"</xd:i>, <xd:i>docinfo:custom-metafield
                    name="COURT-SORT</xd:i>, and <xd:i>docinfo:custom-metafield
                    name="TERM-SORT</xd:i>, should be retained in the target.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:custom-metafields&gt;
    &lt;docinfo:custom-metafield name="JURIS-SORT"&gt;180&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="COURT-SORT"&gt;200&lt;/docinfo:custom-metafield&gt;
    &lt;docinfo:custom-metafield name="TERM-SORT"&gt;102840&lt;/docinfo:custom-metafield&gt;
&lt;/docinfo:custom-metafields&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
    &lt;meta&gt;
        &lt;metaitem name="JURIS-SORT" value="180"/&gt;
        &lt;metaitem name="COURT-SORT" value="200"/&gt;
        &lt;metaitem name="TERM-SORT" value="102840"/&gt;
    &lt;/meta&gt;
&lt;/doc:legacy-metadata&gt;

            </xd:pre>
         <!--Changes2013-04-16: Updated the instruction of handling
            docinfo:custom-metafield[@name="JURIS-SORT"], docinfo:custom-metafield[@name="COURT-SORT"], and docinfo:custom-metafield[@name="TERM-SORT"] markup in CA Dictionary content stream.2013-03-20: Updated the instruction of handling
                docinfo:custom-metafield[@name="dpsi"]
                markup in CA content stream.2013-01-07: Updated the instruction of handling
                docinfo:custom-metafield[@searchtype="CITED-COUNT"]
                markup in CA content stream.2012-09-06: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.custom-metafields-LxAdv-SUPPRESS.dita  -->
   <xsl:template match="docinfo:custom-metafields">
      <xsl:apply-templates select="docinfo:custom-metafield[@name='dpsi' or @searchtype='CITED-COUNT']"/>
      <xsl:if test="$streamID='CA12'">
         <xsl:apply-templates select="docinfo:custom-metafield[@name=('JURIS-SORT', 'COURT-SORT', 'TERM-SORT')]"/>
      </xsl:if>
   </xsl:template>

   <xsl:template match="docinfo:custom-metafield">
      <metaitem>
         <xsl:apply-templates select="@name"/>
         <xsl:apply-templates select="@searchtype"/>
         <xsl:attribute name="value">
            <xsl:apply-templates/>
         </xsl:attribute>
      </metaitem>
   </xsl:template>

   <xsl:template match="docinfo:custom-metafield/@name">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="docinfo:custom-metafield/@searchtype">
      <xsl:if test=".='CITED-COUNT'">
         <xsl:attribute name="name" select="."/>
      </xsl:if>
   </xsl:template>
   <!-- rosetta element: docinfo:doc-country -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.doc-country_iso-cc-LxAdv-doc.docinfo_doc-content-country.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:doc-country[@iso-cc]</xd:i> becomes <xd:b>doc:docinfo[@doc-content-country]</xd:b>. </xd:p>
         <xd:p>If <xd:i>docinfo:doc-country[@iso-cc="AU"]</xd:i>, check the value of <xd:i>case:headnote/case:info/case:courtinfo//case:juris</xd:i>. If
						<xd:i>case:juris="NZ"</xd:i>, set <xd:b>doc:docinfo[@doc-content-country="NZ"]</xd:b>.<xd:p>
               <xd:b>Note: </xd:b>@doc-content-country is required.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>
               <xd:i>docinfo:doc-country[@iso-cc]</xd:i> is used to specify the country in the source document and also becomes part of <xd:b>@xml:id</xd:b> as described in
						the instructions for <xd:a href="Rosetta_docinfo.doc-lang-and-doc-country-LxAdv-ROOT_xml.lang.dita">Target @xml:lang</xd:a>.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
	&lt;docinfo&gt;
			  ....
		   &lt;docinfo:doc-country iso-cc="AU"/&gt;
		   ....
		   &lt;/docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:docinfo doc-content-country="AU"&gt;
         ...
        &lt;/doc:docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Source XML - AU example with case:juris="NZ"</xd:b>
         </xd:p>
         <xd:pre>


&lt;CITATORDOC&gt;
 &lt;docinfo&gt;
   ....
   &lt;docinfo:doc-country iso-cc="AU"/&gt;
    ....
 &lt;/docinfo&gt;
 &lt;cttr:body&gt;
    &lt;case:headnote&gt;
        &lt;case:info&gt;
        ...........
            &lt;case:courtinfo&gt;
            .........
                 &lt;case:juris ln.user-displayed="false"&gt;NZ&lt;/case:juris&gt;
            &lt;/case:courtinfo&gt;
        &lt;/case:info&gt;
    &lt;/case:headnote&gt;
  &lt;/cttr:body&gt;
&lt;/CITATORDOC&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML - AU example with case:juris="NZ" </xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:docinfo doc-content-country="NZ"&gt;
         ...
        &lt;/doc:docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo&gt;
          ....
       &lt;docinfo:doc-country iso-cc="CA"/&gt;
       ....
       &lt;/docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:docinfo doc-content-country="CA"&gt;
         ...
        &lt;/doc:docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Source XML - Example for UK Content</xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo&gt;
          ....
       &lt;docinfo:doc-country iso-cc="GB"/&gt;
       ....
       &lt;/docinfo&gt;


		</xd:pre>
         <xd:p>
            <xd:b>Target XML - Example for UK Content</xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:docinfo doc-content-country="GB"&gt;
         ...
        &lt;/doc:docinfo&gt;


				</xd:pre>
         <!--Changes2014-11-13: Example added for AU content with case:juris="NZ".2012-10-05: Example added for UK content.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.doc-country_iso-cc-LxAdv-doc.docinfo_doc-content-country.dita  -->
   <xsl:template name="doc_content_country"><!-- This template creates @doc-content-country from doc-country 
                    however there is an NZ special case --><!-- 2017-10-03 - MDS: Added handling for $streamID starts with 'HK' --><!-- Awantika: 2017-10-11: added streamID HK in else to replace AU(which is given in input) -->
      <xsl:attribute name="doc-content-country"
                     select=" if (//docinfo:doc-country/@iso-cc = 'AU' or ($streamID='AU08')) then                       if (//case:headnote/case:info/case:courtinfo//case:juris = 'NZ') then                        'NZ'                       else                                             if(starts-with($streamID, 'HK'))then 'HK' else 'AU'                        else                         if(starts-with($streamID, 'HK')) then                           if (//docinfo:doc-country/@iso-cc) then //docinfo:doc-country/@iso-cc                          else 'HK'                         else                         //docinfo:doc-country/@iso-cc "/>
   </xsl:template>
   <!--  un-comment out the following template rule to perform unit testing via XSpec file   -->   <!--xsl:template match="docinfo">
		<test>
			<xsl:call-template name="doc_content_country"/>
		</test>
	</xsl:template-->   <!-- rosetta element: docinfo:doc-heading -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.doc-heading-LxAdv-dc.title.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:doc-heading</xd:i> becomes
						<xd:b>dc:metadata/dc:title</xd:b>. </xd:p>
         <xd:p>Exceptional scenario for CA Indices: When <xd:i>docinfo:doc-heading</xd:i>
					contains word <xd:b>TITLE: </xd:b> or <xd:b>NAME: </xd:b> or <xd:b>SITE: </xd:b> or <xd:b>SUBJECT: </xd:b>
					or <xd:b>RULE: </xd:b> or <xd:b>STATUTE: </xd:b> then conversion should drop the word <xd:b>TITLE:
					</xd:b> or <xd:b>NAME: </xd:b> or <xd:b>SITE: </xd:b> or <xd:b>SUBJECT: </xd:b> or <xd:b>RULE: </xd:b> or
					<xd:b>STATUTE: </xd:b> from conversion.</xd:p>
         <xd:p>Exceptional scenario for AU Legislative Citator: When <xd:i>docinfo:doc-heading</xd:i>
					contains text <xd:b>Overview Tab for </xd:b> then conversion should drop the this text 
					<xd:b>Overview Tab for </xd:b> from conversion.</xd:p>
         <xd:p>Exceptional scenario for US Lexis Practice Advisor (LPA): 
					In addition to the standard mapping above, perform the following mappings. An example has been added 
					below. With this addition, the target output document will always contain three 
					<xd:b>dc:title</xd:b> elements; the one created above without any attributes, as well as 
					the two below with a <xd:b>@lnmeta:titlepurpose</xd:b> attribute:
					<xd:ul>
               <xd:li>
                  <xd:i>docinfo:doc-heading</xd:i> also maps to become 
							<xd:b>dc:metadata/dc:title[@lnmeta:titlepurpose='resultDisplayList']</xd:b>.</xd:li>
               <xd:li>If <xd:i>docinfo:doc-heading</xd:i> ends with a string enclosed by parentheses 
							(e.g. "Patent License Agreement (Pro-Licensee)"), remove 
							the parentheses and the enclosed text, remove any trailing spaces in the remaining text, and 
							the remaining text becomes the content of a new  
							<xd:b>dc:metadata/dc:title[@lnmeta:titlepurpose='download']</xd:b> element. 
							If <xd:i>docinfo:doc-heading</xd:i> does not end with a string inside parentheses, 
							map <xd:i>docinfo:doc-heading</xd:i>, with all of its text content, to a new 
							<xd:b>dc:metadata/dc:title[@lnmeta:titlepurpose='download']</xd:b> element.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-heading&gt;PART1&amp;#x2014;PRELIMINARY&lt;/docinfo:doc-heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:title&gt;PART1&amp;#x2014;PRELIMINARY&lt;/dc:title&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-heading&gt;West Energy Ltd. (Re), [2007] A.E.U.B.D. No. 57&lt;/docinfo:doc-heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:title&gt;West Energy Ltd. (Re), [2007] A.E.U.B.D. No. 57&lt;/dc:title&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML - Example for UK Content</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-heading&gt;In re B (Children) (Care Proceedings: Standard of Proof) (CAFCASS intervening) - [2009] AC 11&lt;/docinfo:doc-heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML - Example for UK Content</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:title&gt;In re B (Children) (Care Proceedings: Standard of Proof) (CAFCASS intervening) - [2009] AC 11&lt;/dc:title&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>emph</xd:i> is child of <xd:i>docinfo:doc-heading</xd:i>
				then suppress <xd:i>emph</xd:i> element and retain its content in
					<xd:b>dc:title</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>For Canada Contents:</xd:b> if <xd:i>nl</xd:i> is child of
					<xd:i>docinfo:doc-heading</xd:i>, then replace it with single space
				character. For furter details please see the following example.</xd:p>
         <xd:p>
            <xd:b>Source XML- From CAN</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-heading&gt;90F32&lt;nl/&gt;Memorandum of Argument of the Applicant&lt;/docinfo:doc-heading&gt;
            
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:title&gt;90F32 Memorandum of Argument of the Applicant&lt;/dc:title&gt;
            
			</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>Exception Scenario for Canada CA14:</xd:b>
            <xd:p>Trademarks and related marks: When (TM)
					or (R) occur in <xd:i>docinfo:doc-heading</xd:i>, convert to unicode code
					point as follows:</xd:p>
            <xd:p>
               <xd:b>(TM)</xd:b> becomes &amp;#8482;
					<xd:b>(R)</xd:b> becomes &amp;#174;</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML- From CA14</xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo:doc-heading&gt;Alan D. Gold's NetLetter(TM), Monday, November 24, 2008 - Issue 615&lt;/docinfo:doc-heading&gt;            
			</xd:pre>
         <xd:p>
            <xd:b>Target XML for CA14</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:title&gt;Alan D. Gold's NetLetter&amp;#8482;, Monday, November 24, 2008 - Issue 615&lt;/dc:title&gt;
            
			</xd:pre>
         <xd:p>
            <xd:b>Source XML for US LPA Forms</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-heading&gt;Patent License Agreement (Pro-Licensee)&lt;/docinfo:doc-heading&gt;
          					
					 </xd:pre>
         <xd:p>
            <xd:b>Target XML for US LPA Forms</xd:b>
         </xd:p>
         <xd:pre>
   
&lt;dc:metadata&gt;
	&lt;dc:title&gt;Patent License Agreement (Pro-Licensee)&lt;/dc:title&gt;
	&lt;dc:title lnmeta:titlepurpose="resultDisplayList"&gt;Patent License Agreement (Pro-Licensee)&lt;/dc:title&gt;
	&lt;dc:title lnmeta:titlepurpose="download"&gt;Patent License Agreement&lt;/dc:title&gt;
	...
&lt;/dc:metadata&gt;
 
             </xd:pre>
         <!--Changes2017-04-03: US LPA 2016 enhancements: Changes for treatment of 
					parenthesis containing form types for Title Parenthetical feature requirements for Forms 
					Enhancements. Change is to support content in forms (PCTs 275 and 305), but should be implemented 
					for all US LPA conversions. Added additional mapping of docinfo:doc-heading to 
					dc:metadata/dc:title[@lnmeta:titlepurpose='resultDisplayList'] for search results, 
					and to dc:metadata/dc:title[@lnmeta:titlepurpose='download'] for form 
					download. Also added an example.2015-12-04: Added exception for AU Legislative Citator to 
					drop text Overview Tab for  from conversion.2015-09-06: Modified only the special rule for CA14
						trademarks. No longer mapping (MC) to entity, the unicode code point is not
						currently supported. The pcdata (MC) is retained instead. RFA 145. CA14
						only.2015-05-05: Added note to convert (TM), (R), and (MC) to
						unicode code points. DB # 45. Applicable to CA14.2014-02-11: Updated note when emph
						is child of docinfo:doc-heading then suppress
							emph element and retain its content in
							dc:title, These instructions apply immediately to
						CA12.2013-10-18: Updated Instruction when
							docinfo:doc-heading contains word RULE: " or
							STATUTE: .2013-09-03: Updated Instruction when
							docinfo:doc-heading contains word "TITLE: " or
							NAME:  or SITE:  or SUBJECT:.2013-08-01: For Canada Content streams: Added a
						note and examples, when docinfo:doc-heading contains
							nl as a child element.2013-07-30: Added Instruction when
							docinfo:doc-heading contains word "TITLE: " or
							NAME: .2012-12-06: Added note for emph with
						docinfo:doc-heading.2012-10-05: Added example for UK Content.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.doc-heading-LxAdv-dc.title.dita  -->
   <xsl:template match="docinfo:doc-heading"><!-- these are used as regexes  -->
      <xsl:param name="docHeadingStringsToRemove"
                 as="xs:string*"
                 select="if ($streamID = 'CA11') then ( 'TITLE:' , 'NAME:' , 'SITE:' , 'SUBJECT:' , 'RULE:' , 'STATUTE:' ) else if ($streamID = 'CA15') then ('TITLE/TITRE:' , 'TITRE/TITLE:','CITED/CIT:','CIT/CITED:','CITE/CITED:','CITED:','TITLE:' , 'TITRE:')  else  'Overview Tab for' "/>
      <xsl:variable name="outputText" as="xs:string*">
         <xsl:apply-templates/>
      </xsl:variable>
      <!--  Original Target XPath:  dc:title   -->
      <dc:title><!--  remove any occurrence of $docHeadingStringsToRemove strings but assume case sensitive; also replace (TM) and (R) with the trademark and copyright characters, respectively, all depending on streamID   -->
         <xsl:choose>
            <xsl:when test=" $streamID = ( 'CA11' , 'AU20', 'CA15' ) ">
               <xsl:sequence select=" lnf:removeSequenceOfStrings( string-join( $outputText , '' ) , $docHeadingStringsToRemove , false() ) "/>
            </xsl:when>
            <xsl:when test=" $streamID = 'CA14' ">
               <xsl:sequence select="replace( replace( string-join( $outputText , '' ) , '\(TM\)' , '' ) , '\(R\)' , '' )"/>
            </xsl:when>
            <xsl:when test="$streamID = 'CA06' or $streamID = 'CA12' or $streamID = 'CA10'or $streamID = 'CA09'">
               <xsl:value-of select="."/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@* | node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </dc:title>
      <xsl:if test="$streamID='USLPA'">
         <dc:title>
            <xsl:attribute name="lnmeta:titlepurpose">
               <xsl:text>resultDisplayList</xsl:text>
            </xsl:attribute>
            <xsl:apply-templates select="@* | node()"/>
         </dc:title>
         <dc:title>
            <xsl:attribute name="lnmeta:titlepurpose">
               <xsl:text>download</xsl:text>
            </xsl:attribute>
            <xsl:apply-templates select="@* | node()"/>
         </dc:title>
      </xsl:if>
   </xsl:template>

   <xsl:template match="docinfo:doc-heading/emph"><!--  Original Target XPath:  dc:title   --><!--  emph is pass-through when under doc-heading   -->
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>

   <xsl:template match="docinfo:doc-heading/nl"><!--  Original Target XPath:  dc:title   --><!--  @SBy:  nl becomes a space when under doc-heading; implemented for ***all*** streamIDs, not just Canada Contents...   -->
      <xsl:text> </xsl:text>
   </xsl:template>
   <!-- rosetta element: docinfo:doc-id -->   <!-- <topicref href="../../common_newest/Rosetta_PAC_docinfo.doc-id-LxAdv-dcidentifier_lnmetaidentifier-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>Identifies the normalization scheme (e.g. URI, LNI, ISSN, et al.) used for the
					identifier. <xd:i>docinfo:doc-id</xd:i> becomes
						<xd:b>dc:metadata/dc:identifier[@lnmeta:identifier-scheme]</xd:b>.
					Also capture <xd:i>docinfo:dpsi[@id-string]</xd:i> and prepend the
					value, followed by hyphen, to create globally unique identifier. </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>If <xd:i>docinfo:dpsi[@id-string]</xd:i> is not present, the dpsi value
					must be captured from one of the following sources:</xd:p>
            <xd:ul>
               <xd:li>The value in
								<xd:i>docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value</xd:i>
               </xd:li>
               <xd:li>The value in
							<xd:i>docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name="dpsi"]</xd:i>
               </xd:li>
               <xd:li>The LBU manifest file</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:dpsi id-string="008P"/&gt;
&lt;docinfo:doc-id&gt;VIC_ACT_1998-25_PT1&lt;/docinfo:doc-id&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:identifier lnmeta:identifier-scheme="DOC-ID"&gt;008P-VIC_ACT_1998-25_PT1&lt;/dc:identifier&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:dpsi id-string="0062"/&gt;
&lt;docinfo:doc-id&gt;CA00000005222733&lt;/docinfo:doc-id&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:identifier lnmeta:identifier-scheme="DOC-ID"&gt;0062-CA00000005222733&lt;/dc:identifier&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML - Example for UK content</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:doc-id&gt;5B323030395D2D312D41432E3131&lt;/docinfo:doc-id&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML - Example for UK content</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:identifier lnmeta:identifier-scheme="DOC-ID"&gt;0GNE-5B323030395D2D312D41432E3131&lt;/dc:identifier&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>In the above example <xd:b>0GNE</xd:b> is the dpsi value, which will be captured from LBU
				manifest file.</xd:p>
         <xd:p>
            <xd:b>Source XML - Example for CA content with the dpsi value in
						<xd:i>docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo&gt;
    ...
    &lt;docinfo:doc-id&gt;CA00000000450962&lt;/docinfo:doc-id&gt;
    ...
    &lt;docinfo:lbu-meta&gt;
        &lt;docinfo:metaitem name="SRCNAME" value="ACFH"/&gt;
        &lt;docinfo:metaitem name="SRCDOCNO" value="00018000"/&gt;
        &lt;docinfo:metaitem name="DPSI" value="03MN"/&gt;
    &lt;/docinfo:lbu-meta&gt;
    ...
&lt;/docinfo&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML - Example for CA content</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:identifier lnmeta:identifier-scheme="DOC-ID"&gt;03MN-CA00000000450962&lt;/dc:identifier&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML - Example for CA content with the dpsi value in
						<xd:i>docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name="dpsi"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo&gt;
    ...
    &lt;docinfo:doc-id&gt;474&lt;/docinfo:doc-id&gt;
    ...
    &lt;docinfo:custom-metafields&gt;
         &lt;docinfo:custom-metafield name="dpsi"&gt;03EX&lt;/docinfo:custom-metafield&gt;
    &lt;/docinfo:custom-metafields&gt;
    ...
&lt;/docinfo&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML - Example for CA content</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:identifier lnmeta:identifier-scheme="DOC-ID"&gt;03EX-474&lt;/dc:identifier&gt;

		</xd:pre>
         <!--Changes2014-06-23: Note and Example removed - For CA05 Acts and
						Bills- Mapping in dc:identifier for act-no and chunk-no. Db issue #14642014-05-21:For CA05 Acts and Bills- Mapping in dc:identifier for act-no and chunk-no.. Db issue #1464 2013-03-20: Updated the information on handling the
						situation when docinfo:dpsi[@id-string] is absent with
						instructions to get the dpsi from
							docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name="dpsi"].2012-10-05: Example added for UK content.2012-12-04: Added a note and updated target example for UK content.2012-12-20: Updated the information on handling the situation when
						docinfo:dpsi[@id-string] is absent with instructions to
					get the dpsi from
						docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value
					if possible. Added an example of CA content with the dpsi in
						docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.doc-id-LxAdv-dcidentifier_lnmetaidentifier-scheme.dita  -->
   <xsl:template match="docinfo:doc-id"><!--  Original Target XPath:  dc:identifier[@lnmeta:identifier-scheme]   -->
      <dc:identifier lnmeta:identifier-scheme="DOC-ID">
         <xsl:choose>
            <xsl:when test="../docinfo:dpsi/@id-string">
               <xsl:value-of select="../docinfo:dpsi/@id-string"/>
            </xsl:when>
            <xsl:when test="../docinfo:dpsi">
               <xsl:value-of select="../docinfo:dpsi"/>
            </xsl:when>
            <xsl:when test="..//docinfo:custom-metafield[ lower-case(@name) = 'dpsi' ]">
               <xsl:value-of select="..//docinfo:custom-metafield[ lower-case(@name) = 'dpsi' ]"/>
            </xsl:when>
            <!-- Vikas Rohilla : updated for the docinfo:metaitem dpsi				-->
            <xsl:when test="..//docinfo:metaitem[ lower-case(@name) = 'dpsi' ]">
               <xsl:value-of select="..//docinfo:metaitem[ lower-case(@name) = 'dpsi' ]/@value"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:value-of select="$dpsi"/>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:text>-</xsl:text>
         <xsl:apply-templates/>
      </dc:identifier>
      <xsl:if test="$streamID=('AU16', 'AU17', 'AU19CA', 'NZ02', 'NZ07-DN', 'NZ14')">
         <xsl:choose>
            <xsl:when test="ends-with(., 'CTHLEG_') or ends-with(., '_CTH') or starts-with(., 'CTHLEG_')">
               <dc:coverage>
                  <location:country codescheme="ISO-3166-1" countrycode="AU">AU</location:country>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'NSWLEG_') or ends-with(., '_NSW') or starts-with(., 'NSWLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-NS">NSW</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'QLDLEG_') or ends-with(., '_QLD') or starts-with(., 'QLDLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-QL">QLD</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'SALEG_') or ends-with(., '_SA') or starts-with(., 'SALEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-SA">SA</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'TASLEG_') or ends-with(., '_TAS') or starts-with(., 'TASLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-TS">TAS</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'VICLEG_') or ends-with(., '_VIC') or starts-with(., 'VICLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-VI">VIC</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'WALEG_') or ends-with(., '_WA') or starts-with(., 'WALEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-WA">WA</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'NTLEG_') or ends-with(., '_NT') or starts-with(., 'NTLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-NT">NT</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:when test="ends-with(., 'ACTLEG_') or ends-with(., '_ACT') or starts-with(., 'ACTLEG_')">
               <dc:coverage>
                  <location:state codescheme="ISO-3166-2" statecode="AU-CT">ACT</location:state>
               </dc:coverage>
            </xsl:when>
            <xsl:otherwise/>
         </xsl:choose>
      </xsl:if>
   </xsl:template>
   <!-- Awantika: Using common module -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/docinfo/Rosetta_PAC_docinfo.doc-id-LxAdv-dcidentifier_lnmetaidentifier-scheme.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- rosetta element: docinfo:doc-lang -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.doc-lang-LxAdv-ROOT_xmllang.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>Since <xd:b>dc:language</xd:b> is not used, <xd:i>docinfo:doc-lang[@lang]</xd:i> only becomes part of <xd:b>@xml:lang</xd:b> as described in <xd:a href="Rosetta_docinfo.doc-lang-and-doc-country-LxAdv-ROOT_xml.lang.dita">Target @xml:lang</xd:a> and is otherwise suppressed. </xd:p>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.doc-lang-LxAdv-ROOT_xmllang.dita  -->
   <xsl:template name="xml_lang"><!-- This template creates @xml:lang from doc-lang and doc-country 
                    however there is an NZ special case --><!-- 2017-10-03 - MDS: Added handling for $streamID starts with 'HK' -->
      <xsl:attribute name="xml:lang"
                     select=" concat(  //docinfo:doc-lang/@lang ,                     '-' ,                     if (//docinfo:doc-country/@iso-cc = 'AU' or ($streamID='AU08')) then                      if (//case:headnote/case:info/case:courtinfo//case:juris = 'NZ') then                       'NZ'                      else                       'AU'                     else                       if(starts-with($streamID, 'HK')) then                         if (//docinfo:doc-country/@iso-cc) then //docinfo:doc-country/@iso-cc                        else 'HK'                       else                      //docinfo:doc-country/@iso-cc                    ) "/>
   </xsl:template>
   <!--  un-comment out the following template rule to perform unit testing via XSpec file   -->   <!--xsl:template match="docinfo">
		<test>
			<xsl:call-template name="xml_lang"/>
		</test>
	</xsl:template-->   <!-- rosetta element: docinfo:dpsi -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.dpsi-LxAdv-doc.legacy-metadata_metadatasource_lbu-meta.meta.metaitem.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:dpsi[@id-string]</xd:i> becomes <xd:b>doc:metadata/doc:docinfo/doc:legacy-metadata[@metadatasource="lbu-meta"]/meta/metaitem</xd:b>
					with attributes <xd:b>@name="dpsi"</xd:b> and <xd:b>@value</xd:b> set to <xd:i>@id-string</xd:i>. Note that only one <xd:b>meta</xd:b> is created for the various <xd:b>metaitem</xd:b> child elements that are created
					while processing <xd:i>docinfo</xd:i> and <xd:i>docinfo:dpsi</xd:i>. For more information, see the
					instructions for <xd:a href="Rosetta_docinfo-LxAdv-doc.metadata_doc.docinfo.dita">docinfo</xd:a>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:i>@id-string</xd:i> value is also used in mapping
								for <xd:b>docinfo:doc-id</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>docinfo:dpsi[@id-string]</xd:i> is not present,
								the dpsi value must be captured from one of the following sources: <xd:ul>
               <xd:li>The value in <xd:i>docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value</xd:i>
               </xd:li>
               <xd:li>The LBU manifest file</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML with no attributes on docinfo</xd:b>
         </xd:p>
         <xd:pre>

	&lt;docinfo&gt;
		&lt;docinfo:dpsi id-string="008P"/&gt;
		.................
		.................
	&lt;/docinfo&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:docinfo doc-content-country="AU"&gt;
  &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
	&lt;meta&gt;
	  &lt;metaitem name="dpsi" value="008P"/&gt;
	&lt;/meta&gt;
  &lt;/doc:legacy-metadata&gt;
	.................
	.................
&lt;/docinfo&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML with an attribute on docinfo</xd:b>
         </xd:p>
         <xd:pre>

    &lt;docinfo partitionnum="2"&gt;
		&lt;docinfo:dpsi id-string="006F"&gt;
		.................
		.................
	&lt;/docinfo&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:docinfo doc-content-country="AU"&gt;
  &lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
	&lt;meta&gt;
		 &lt;metaitem name="partitionnum" value="2"/&gt; 
		&lt;metaitem name="dpsi" value="006F"/&gt;
	&lt;/meta&gt;
  &lt;/doc:legacy-metadata&gt;
	.................
	.................
&lt;/docinfo&gt;


	</xd:pre>
         <!--Changes2012-12-20: Updated the information on handling the situation when
					docinfo:dpsi[@id-string] is absent with
					instructions to get the dpsi from docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value if
					possible.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="docinfo:dpsi[@id-string]">
      <metaitem>
         <xsl:attribute name="name">dpsi</xsl:attribute>
         <xsl:attribute name="value" select="@id-string"/>
      </metaitem>
   </xsl:template>
   <!-- docinfo/docinfo:lbu-meta/docinfo:metaitem[@name="DPSI"]/@value -->
   <xsl:template match="docinfo:dpsi[not(@id-string) and ../docinfo:lbu-meta/docinfo:metaitem[@name='DPSI']]">
      <metaitem>
         <xsl:attribute name="name">dpsi</xsl:attribute>
         <xsl:attribute name="value"
                        select="../docinfo:lbu-meta/docinfo:metaitem[@name='DPSI']/@value"/>
      </metaitem>
   </xsl:template>
   <!-- rosetta element: docinfo:hier -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.hier-LxAdv-doc.hier.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:hier</xd:i> becomes <xd:b>doc:hier</xd:b>, with
					these children: <xd:ul>
               <xd:li>
                  <xd:i>docinfo:hier/docinfo:hierlev</xd:i> becomes
								<xd:b>doc:hier/doc:hierlev</xd:b>. </xd:li>
               <xd:li>
                  <xd:i>docinfo:hier/docinfo:hierlev/heading</xd:i> becomes
								<xd:b>doc:hier/doc:hierlev/heading</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>docinfo:hier/docinfo:hierlev/heading/title</xd:i>
							becomes <xd:b>doc:hier/doc:hierlev/heading/title</xd:b>
               </xd:li>
            </xd:ul>
            <xd:p>
               <xd:b>Note: </xd:b>The attribute <xd:i>@role</xd:i> is suppressed. The nesting
						level of a <xd:b>doc:hierlev</xd:b> determines its role in the
						hierarchy.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>if <xd:i>nl</xd:i> is coming as child of
							<xd:i>docinfo:hierlev/heading/title</xd:i> then it should be
						replaced by a white space in the target -<xd:b> Applicable for CA06-CA07 </xd:b>
            </xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>
               <xd:b> Applicable for CA05-CA08: </xd:b> Attribute
							<xd:i>docinfo:hierlev/@exclude-from-displayunits="true"</xd:i>
						should be converted into attribute
							<xd:b>doc:hier/@includeintoc="false"</xd:b>.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>
               <xd:b>Applicable for CA09:</xd:b>
               <xd:i>title</xd:i> may contain <xd:i>num</xd:i>.
						Suppress <xd:i>num</xd:i> tag but output content. For example:
							<xd:i>&lt;docinfo:hier&gt;&lt;docinfo:hierlev&gt;&lt;heading&gt;&lt;title&gt;&lt;num&gt;</xd:i>6F1<xd:i>&lt;/num&gt;</xd:i>
						Appellant Form
							(A1)<xd:i>&lt;/title&gt;&lt;/heading&gt;&lt;/docinfo:hierlev&gt;&lt;/docinfo:hier&gt;</xd:i>
						becomes
							<xd:b>&lt;doc:hier&gt;&lt;doc:hierlev&gt;&lt;heading&gt;&lt;title&gt;</xd:b>6F1
						Appellant Form
							(A1)<xd:b>&lt;/title&gt;&lt;/heading&gt;&lt;/doc:hierlev&gt;&lt;/doc:hier&gt;</xd:b>
            </xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>Suppress <xd:i>inlineobject</xd:i> if it's found within
							<xd:i>docinfo:hierlev</xd:i> element. i.e,
							<xd:i>/docinfo/docinfo:hier/docinfo:hierlev/docinfo:hierlev/docinfo:hierlev/heading/inlineobject</xd:i>,
							<xd:i>/docinfo/docinfo:hier/docinfo:hierlev/docinfo:hierlev/docinfo:hierlev/heading/subtitle/inlineobject</xd:i>
						and
							<xd:i>/docinfo/docinfo:hier/docinfo:hierlev/docinfo:hierlev/docinfo:hierlev/heading/title/inlineobject</xd:i>.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:hier&gt; &lt;docinfo:hierlev role="ancestor"&gt;
					&lt;heading&gt; &lt;title&gt;Victoria Acts&lt;/title&gt; &lt;/heading&gt;
					&lt;docinfo:hierlev role="ancestor"&gt; &lt;heading&gt;
					&lt;title&gt;E&lt;/title&gt; &lt;/heading&gt; &lt;docinfo:hierlev
					role="ancestor"&gt; &lt;heading&gt; &lt;title&gt;EL&lt;/title&gt;
					&lt;/heading&gt; &lt;docinfo:hierlev role="ancestor"&gt; &lt;heading&gt;
					&lt;title&gt;ELECTRICITY SAFETY ACT 1998&lt;/title&gt; &lt;/heading&gt;
					&lt;docinfo:hierlev role="me"&gt; &lt;heading&gt; &lt;title&gt;ELECTRICITY
					SAFETY ACT 1998&lt;/title&gt; &lt;/heading&gt; &lt;/docinfo:hierlev&gt;
					&lt;/docinfo:hierlev&gt; &lt;/docinfo:hierlev&gt; &lt;/docinfo:hierlev&gt;
					&lt;/docinfo:hierlev&gt; &lt;/docinfo:hier&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:hier&gt; &lt;doc:hierlev&gt; &lt;heading&gt;
					&lt;title&gt;Victoria Acts&lt;/title&gt; &lt;/heading&gt; &lt;doc:hierlev&gt;
					&lt;heading&gt; &lt;title&gt;E&lt;/title&gt; &lt;/heading&gt;
					&lt;doc:hierlev&gt; &lt;heading&gt; &lt;title&gt;EL&lt;/title&gt;
					&lt;/heading&gt; &lt;doc:hierlev&gt; &lt;heading&gt; &lt;title&gt;ELECTRICITY
					SAFETY ACT 1998&lt;/title&gt; &lt;/heading&gt; &lt;doc:hierlev&gt;
					&lt;heading&gt; &lt;title&gt;ELECTRICITY SAFETY ACT 1998&lt;/title&gt;
					&lt;/heading&gt; &lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt;
					&lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt; &lt;/doc:hier&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML <xd:i>nl</xd:i> as child of
						<xd:i>docinfo:hierlev/heading/title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:hier&gt; &lt;docinfo:hierlev role="ancestor"&gt;
					&lt;heading&gt; &lt;title&gt;Young Offenders Act (Canada)&lt;/title&gt;
					&lt;/heading&gt; &lt;docinfo:hierlev role="ancestor"&gt; &lt;heading&gt;
					&lt;title&gt;RULES OF YOUTH COURT REGULATION&lt;/title&gt; &lt;/heading&gt;
					&lt;docinfo:hierlev role="ancestor"&gt; &lt;heading&gt;
					&lt;title&gt;SCHEDULE&lt;/title&gt; &lt;/heading&gt; &lt;docinfo:hierlev
					role="me"&gt; &lt;heading&gt; &lt;title&gt;ROVINCIAL COURT OF
					ALBERTA&lt;nl/&gt;FORM 100&lt;nl/&gt;IN THE YOUTH DIVISION OF THE PROVINCIAL
					COURT OF ALBERTA&lt;nl/&gt;NOTICE OF APPLICATION &lt;/title&gt; &lt;/heading&gt;
					&lt;/docinfo:hierlev&gt; &lt;/docinfo:hierlev&gt; &lt;/docinfo:hierlev&gt;
					&lt;/docinfo:hierlev&gt; &lt;/docinfo:hier&gt; </xd:pre>
         <xd:p>
            <xd:b>
               <xd:b>Target XML</xd:b>
               <xd:i>nl</xd:i> as child of
						<xd:i>docinfo:hierlev/heading/title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;doc:hier&gt; &lt;doc:hierlev&gt; &lt;heading&gt; &lt;title&gt;Young
					Offenders Act (Canada)&lt;/title&gt; &lt;/heading&gt; &lt;doc:hierlev&gt;
					&lt;heading&gt; &lt;title&gt;RULES OF YOUTH COURT REGULATION&lt;/title&gt;
					&lt;/heading&gt; &lt;doc:hierlev&gt; &lt;heading&gt;
					&lt;title&gt;SCHEDULE&lt;/title&gt; &lt;/heading&gt; &lt;doc:hierlev&gt;
					&lt;heading&gt; &lt;title&gt;ROVINCIAL COURT OF ALBERTA FORM 100 IN THE YOUTH
					DIVISION OF THE PROVINCIAL COURT OF ALBERTA NOTICE OF APPLICATION &lt;/title&gt;
					&lt;/heading&gt; &lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt;
					&lt;/doc:hierlev&gt; &lt;/doc:hierlev&gt; </xd:pre>
         <!--Changes2015-03-25: Added note with rule for
							title/num. Suppress num
						tag but output content. Applicable for CA09 only. RFA 2249.2015-01-23: Added note to convert
							docinfo:hierlev/@exclude-from-displayunits="true"
						into doc:hier/@includeintoc="false". Applicable
					for CA05-CA08, RFA #21412015-01-13: Added a note to repalce
							nl to a white space when
							nl is coming as child of
							docinfo:hierlev/heading/title Applicable for
					CA06-CA07 , RFA #2108-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.hier-LxAdv-doc.hier.dita  -->
   <xsl:variable name="Title_Dpsi_Code_CA05">
      <codes>
         <code key="0U95" value="Statutes"/>
         <code key="0U9A" value="Former Statutes"/>
         <code key="0U9S" value="Statutes"/>
         <code key="0U9V" value="Statutes"/>
         <code key="0U9X" value="Former Statutes"/>
         <code key="0UA4" value="Statutes"/>
         <code key="0UA6" value="Former Statutes"/>
         <code key="0UAN" value="Statutes"/>
         <code key="0UAP" value="Former Statutes"/>
         <code key="0UCM" value="Statutes"/>
         <code key="0UCO" value="Former Statutes"/>
         <code key="0UCV" value="Statutes"/>
         <code key="0UCX" value="Former Statutes"/>
         <code key="0UD9" value="Statutes"/>
         <code key="0UDB" value="Former Statutes"/>
         <code key="0UDF" value="Employment Insurance Statutes"/>
         <code key="0UDL" value="Statutes"/>
         <code key="0UDM" value="Statutes"/>
         <code key="0UDT" value="Employment Standards Statutes"/>
         <code key="0UDV" value="Employment Standards Former Statutes"/>
         <code key="0UEE" value="Statutes"/>
         <code key="0UEF" value="Former Statutes"/>
         <code key="0UFB" value="Human Rights/Equity Issues"/> Statutes"/&gt;
			<code key="0UFD" value="Human Rights/Equity Issues"/> Former Statutes"/&gt;
			<code key="0UFT" value="Statutes"/>
         <code key="0UHJ" value="Statutes"/>
         <code key="0UHL" value="Former Statutes"/>
         <code key="0UI1" value="Labour Relations Statutes"/>
         <code key="0UI3" value="Labour Relations Former Statutes"/>
         <code key="0UJ2" value="Statutes"/>
         <code key="0UJ3" value="Former Statutes"/>
         <code key="0UJ8" value="Statutes"/>
         <code key="0UJ9" value="Former Statutes"/>
         <code key="0UN0" value="Lois"/>
         <code key="0UN5" value="Lois"/>
         <code key="0UNO" value="Lois"/>
         <code key="0UNZ" value="Lois"/>
         <code key="0UOD" value="Lois"/>
         <code key="0UOJ" value="Lois"/>
         <code key="0UOS" value="Lois"/>
         <code key="0UPV" value="Statutes"/>
         <code key="0UPX" value="Former Statutes"/>
         <code key="0US1" value="Former Statutes"/>
         <code key="0US6" value="Lois"/>
         <code key="0USC" value="Archives - Lois"/>
         <code key="0UTB" value="Lois"/>
         <code key="0UVY" value="Acts"/>
         <code key="0USN" value="Former Acts"/>
      </codes>
   </xsl:variable>
   <xsl:variable name="Title_Dpsi_Code_CA10">
      <codes>
         <code key="0U91" value="Commentary"/>
         <code key="0U9L" value="Commentary"/>
         <code key="0U9M" value="Commentary"/>
         <code key="0UA0" value="Commentary"/>
         <code key="0UAK" value="Commentary"/>
         <code key="0UB1" value="Employment Insurance Commentary"/>
         <code key="0UCG" value="Commentary"/>
         <code key="0UCI" value="Commentary"/>
         <code key="0UCS" value="Commentary"/>
         <code key="0UDE" value="Editorial Board &amp; Case Comments"/>
         <code key="0UDJ" value="Commentary"/>
         <code key="0UDQ" value="Topical Index to Summaries"/>
         <code key="0UEB" value="Commentary"/>
         <code key="0UFA" value="Human Rights/Equity Issues Commentary"/>
         <code key="0UFQ" value="Commentary"/>
         <code key="0UHE" value="Commentary"/>
         <code key="0UHG" value="Bulletins and Social Security Agreements"/>
         <code key="0UHU" value="Employment Standards Commentary"/>
         <code key="0UHZ" value="Labour Relations Commentary"/>
         <code key="0UJ0" value="Commentary"/>
         <code key="0UJ4" value="Commentary"/>
         <code key="0UMX" value="Commentaires, Index et Abrviations"/>
         <code key="0UN3" value="Commentaires, Index et Abrviations"/>
         <code key="0UNN" value="Commentaires, bibliographies et index"/>
         <code key="0UNY" value="Commentaires, Index et Abrviations"/>
         <code key="0UO5" value="Commentaires, Index et Tables"/>
         <code key="0UOI" value="Commentaires, Index et Abrviations"/>
         <code key="0UOM" value="Modles de procdures"/>
         <code key="0UOR" value="Commentaires, Index, Abrviations et Adresses"/>
         <code key="0UPT" value="Commentary"/>
         <code key="0US5" value="quipe de rdaction, tables, grilles et index"/>
         <code key="0USQ" value="Jurisprudence - Annotations de Dubois et Schneider"/>
         <code key="0UTA" value="Commentaires et Indexes"/>
         <code key="0V21" value="MFDA Staff Notices"/>
         <code key="0V2H" value="Montreal Stock Exchange Charter &amp; List of Fees"/>
         <code key="0V5X" value="Quantum of Damages Table"/>
         <code key="0V5Y" value="Code Citator"/>
         <code key="0VNX" value="Securities Commissions"/>
      </codes>
   </xsl:variable>
   <xsl:variable name="Title_Dpsi_Code">
      <codes>
         <code key="0U96" value="Regulations"/>
         <code key="0U9B" value="Former Regulations"/>
         <code key="0U9T" value="Regulations"/>
         <code key="0U9W" value="Regulations"/>
         <code key="0U9Y" value="Former Regulations"/>
         <code key="0UA5" value="Regulations"/>
         <code key="0UA7" value="Former Regulations"/>
         <code key="0UAO" value="Regulations"/>
         <code key="0UAQ" value="Former Regulations"/>
         <code key="0UCN" value="Regulations"/>
         <code key="0UCP" value="Former Regulations"/>
         <code key="0UCW" value="Regulations"/>
         <code key="0UCY" value="Former Regulations"/>
         <code key="0UDA" value="Regulations"/>
         <code key="0UDC" value="Former Regulations"/>
         <code key="0UDG" value="Employment Insurance Regulations"/>
         <code key="0UDN" value="Regulations"/>
         <code key="0UDO" value="Regulations"/>
         <code key="0UDU" value="Employment Standards Regulations"/>
         <code key="0UEG" value="Regulations"/>
         <code key="0UEJ" value="Employment Standards Former Regulations"/>
         <code key="0UFC" value="Human Rights/Equity Issues Regulations"/>
         <code key="0UFE" value="Human Rights/Equity Issues Former Regulations"/>
         <code key="0UFU" value="Regulations"/>
         <code key="0UHK" value="Regulations"/>
         <code key="0UHM" value="Former Regulations"/>
         <code key="0UI2" value="Labour Relations Regulations"/>
         <code key="0UI4" value="Labour Relations Former Regulations"/>
         <code key="0UJA" value="Regulations"/>
         <code key="0UJB" value="Former Regulations"/>
         <code key="0UN6" value="Rglements"/>
         <code key="0UNP" value="Rglements"/>
         <code key="0UOE" value="Rglements"/>
         <code key="0UOK" value="Rglements"/>
         <code key="0UOT" value="Rglements"/>
         <code key="0UOV" value="Archives - Rglements"/>
         <code key="0UPW" value="Regulations"/>
         <code key="0UPY" value="Former Regulations"/>
         <code key="0US7" value="Rglements"/>
         <code key="0USD" value="Archives - Rglements"/>
         <code key="0USP" value="Former Regulations"/>
         <code key="0UTC" value="Rglements"/>
         <code key="0UVZ" value="Regulations"/>
         <code key="0VNX" value="Securities Commissions"/>
         <code key="0U98" value="CSA Regulatory Documents"/>
         <code key="0USA" value="Rgles de pratique"/>
         <code key="0UW1" value="Codes of Practice"/>
         <code key="0V1Y" value="Universal Market Integrity Rules and Policies"/>
         <code key="0V22" value="MFDA By-laws, Rules and Policies"/>
         <code key="0V24" value="ICE Futures Canada Inc. Rules"/>
         <code key="0V26" value="NASDAQ Marketplace Rules"/>
         <code key="0V28" value="CNSX Rules, Policies and Notices"/>
         <code key="0V2A" value="TSX Rule Book and Policies"/>
         <code key="0V2B" value="TSX Venture Exchange Rules and Policies"/>
         <code key="0V2F" value="NEX Policies"/>
         <code key="0V2I"
               value="Montreal Stock Exchange Rules, Policies, Guidelines and Fees"/>
         <code key="0U9C" value="Forms"/>
         <code key="0U9R" value="Forms"/>
         <code key="0UAR" value="Forms"/>
         <code key="0UCU" value="Forms"/>
         <code key="0UCZ" value="Forms &amp; Precedents"/>
         <code key="0UDS" value="Employment Standards Forms"/>
         <code key="0UDW" value="Government and Agency Documents"/>
         <code key="0UEH" value="Forms"/>
         <code key="0UHF" value="Government and Agency Documents"/>
         <code key="0UI0" value="Labour Relations Forms"/>
         <code key="0UJC" value="Forms"/>
         <code key="0UOA" value="Formulaires"/>
         <code key="0UQ0" value="Forms"/>
         <code key="0USW" value="Formulaires"/>
         <code key="0V20"
               value="IIROC &amp; Market Integrity Notices, Guides, and Updates"/>
         <code key="0V23" value="MFDA Forms"/>
         <code key="0V25" value="ICE Futures Canada Inc. Annexes"/>
         <code key="0V29" value="CNSX Forms"/>
         <code key="0V2D"
               value="TSX Venture Exchange Corporate Finance Manual Appendices and Forms"/>
         <code key="0V2G" value="NEX Forms and Appendices"/>
         <code key="0V2J" value="Montreal Stock Exchange Forms"/>
         <!-- CA01 Start		-->
         <code key="0UW2" value="Cases"/>
         <code key="0UXQ" value="Cases"/>
         <code key="0UXS" value="Cases"/>
         <code key="0UXT" value="Summaries (Appeals &amp; Cases)"/>
         <code key="0UXU" value="Cases"/>
         <code key="0UXV" value="Cases"/>
         <code key="0UXW" value="Cases"/>
         <code key="0UXX" value="Cases"/>
         <code key="0UXZ" value="Cases"/>
         <code key="0UY0" value="Cases"/>
         <code key="0UY1" value="Cases"/>
         <code key="0UY3" value="Cases"/>
         <code key="0UY4" value="Jurisprudence - Texte intgraux et rsums archivs"/>
         <code key="0UY6" value="Jurisprudence"/>
         <code key="0UY7" value="Rsums de jurisprudence"/>
         <code key="0UY8" value="Jurisprudence slectionne"/>
         <code key="0UY9" value="Jurisprudence - Textes intgraux"/>
         <code key="0UYC" value="Cases"/>
         <code key="0V45" value="Cases"/>
         <code key="0V47" value="Cases"/>
         <code key="0V48" value="Cases"/>
         <code key="0V49" value="Cases"/>
         <!-- CA01 End		-->
      </codes>
   </xsl:variable>
   <xsl:key name="dpsititle" match="*:code" use="string(@key)"/>
   <xsl:template match="docinfo:hier"><!--  Original Target XPath:  doc:hier   -->
      <doc:hier>
         <xsl:if test="$streamID = ('CA05', 'CA06', 'CA07', 'CA08')">
            <xsl:if test="child::docinfo:hierlev/@exclude-from-displayunits = 'true'">
               <xsl:attribute name="includeintoc">
                  <xsl:text>false</xsl:text>
               </xsl:attribute>
            </xsl:if>
         </xsl:if>
         <!--  @SBy:  process the first descendant docinfo:hierlev/@exclude-from-displayunits where that attribute is true.  So if this attribute appears on any docinfo:hierlev and is true, then @includeintoc will be set to false  -->
         <!-- UK06 Requires indicators of first and last  -->
         <xsl:if test="$streamID = ('UK06','UK07')">
            <proc:processinginfo>
               <xsl:attribute name="process">LAToCBuilder</xsl:attribute>
               <xsl:choose>
                  <xsl:when test="/LEGDOC/docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name='is-first-document-in-enactment'] = 'true'">
                     <proc:param name="firstLegisItem" value="true"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <proc:param name="firstLegisItem" value="false"/>
                  </xsl:otherwise>
               </xsl:choose>
               <xsl:choose>
                  <xsl:when test="/LEGDOC/docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name='is-last-document-in-enactment'] = 'true'">
                     <proc:param name="lastLegisItem" value="true"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <proc:param name="lastLegisItem" value="false"/>
                  </xsl:otherwise>
               </xsl:choose>
            </proc:processinginfo>
         </xsl:if>
         <!--			<xsl:if test=" $streamID = ( 'CA06' , 'CA07' , 'CA08' ) ">
				<xsl:apply-templates select="descendant::docinfo:hierlev[ @exclude-from-displayunits = 'true' ][1]/@exclude-from-displayunits"/>
			</xsl:if>-->
         <xsl:apply-templates select="@* | node()"/>
      </doc:hier>
   </xsl:template>
   <!-- @Vikas Gupta: Template to match the docinfo:hier for the $streamID ='CA06','CA07','CA08' 	-->
   <xsl:template match="docinfo:hier[$streamID = ('CA05','CA06', 'CA07', 'CA08', 'CA10')]"><!--  Original Target XPath:  doc:hier   -->
      <xsl:variable name="dpsi_value">
         <xsl:value-of select="//docinfo:custom-metafield[@name = 'dpsi']"/>
      </xsl:variable>
      <xsl:variable name="dpsi_value_CA10">
         <xsl:value-of select="substring(/COMMENTARYDOC/docinfo/docinfo:doc-id,1,4)"/>
      </xsl:variable>
      <doc:hier><!--  @SBy:  process the first descendant docinfo:hierlev/@exclude-from-displayunits where that attribute is true.  So if this attribute appears on any docinfo:hierlev and is true, then @includeintoc will be set to false  -->
         <xsl:choose>
            <xsl:when test="($dpsi_value = $Title_Dpsi_Code//@key) and $streamID!=('CA06', 'CA07', 'CA08')">
               <doc:hierlev>
                  <heading>
                     <title>
                        <xsl:value-of select="key('dpsititle', //docinfo:custom-metafield[@name = 'dpsi'], $Title_Dpsi_Code)/@value"/>
                     </title>
                  </heading>
                  <xsl:apply-templates select="descendant::docinfo:hierlev[@exclude-from-displayunits = 'true'][1]/@exclude-from-displayunits"/>
                  <xsl:apply-templates select="@* | node()"/>
               </doc:hierlev>
            </xsl:when>
            <xsl:when test="($dpsi_value = $Title_Dpsi_Code_CA05//@key) and $streamID='CA05'">
               <doc:hierlev>
                  <heading>
                     <title>
                        <xsl:value-of select="key('dpsititle', //docinfo:custom-metafield[@name = 'dpsi'], $Title_Dpsi_Code_CA05)/@value"/>
                     </title>
                  </heading>
                  <xsl:apply-templates select="descendant::docinfo:hierlev[@exclude-from-displayunits = 'true'][1]/@exclude-from-displayunits"/>
                  <xsl:apply-templates select="@* | node()"/>
               </doc:hierlev>
            </xsl:when>
            <xsl:when test="($dpsi_value = $Title_Dpsi_Code_CA10//@key or $dpsi_value_CA10=$Title_Dpsi_Code_CA10//@key) and $streamID='CA10'">
               <doc:hierlev>
                  <heading>
                     <title>
                        <xsl:value-of select="key('dpsititle', substring(/COMMENTARYDOC/docinfo/docinfo:doc-id,1,4), $Title_Dpsi_Code_CA10)/@value"/>
                     </title>
                  </heading>
                  <xsl:apply-templates select="descendant::docinfo:hierlev[@exclude-from-displayunits = 'true'][1]/@exclude-from-displayunits"/>
                  <xsl:apply-templates select="@* | node()"/>
               </doc:hierlev>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="descendant::docinfo:hierlev[@exclude-from-displayunits = 'true'][1]/@exclude-from-displayunits"/>
               <xsl:apply-templates select="@* | node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </doc:hier>
   </xsl:template>
   <!-- @Vikas Rohilla: Template to match the docinfo:hier for the $streamID ='CA01' 	-->
   <xsl:template match="docinfo:hier[$streamID = 'CA01']">
      <xsl:variable name="dpsi_value">
         <xsl:value-of select="$dpsi"/>
      </xsl:variable>
      <doc:hier>
         <xsl:choose>
            <xsl:when test="$dpsi_value = $Title_Dpsi_Code//@key">
               <doc:hierlev>
                  <heading>
                     <title>
                        <xsl:value-of select="key('dpsititle', $dpsi_value, $Title_Dpsi_Code)/@value"/>
                     </title>
                  </heading>
                  <xsl:apply-templates select="node() | @*"/>
               </doc:hierlev>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="node() | @*"/>
            </xsl:otherwise>
         </xsl:choose>
      </doc:hier>
   </xsl:template>

   <xsl:template match="docinfo:hier[$streamID = 'CA09']">
      <xsl:variable name="dpsi_value">
         <xsl:value-of select="$dpsi"/>
      </xsl:variable>
      <doc:hier>
         <xsl:choose>
            <xsl:when test="$dpsi_value = $Title_Dpsi_Code//@key">
               <doc:hierlev>
                  <heading>
                     <title>
                        <xsl:value-of select="key('dpsititle', $dpsi_value, $Title_Dpsi_Code)/@value"/>
                     </title>
                  </heading>
                  <xsl:apply-templates select="@* | node()"/>
               </doc:hierlev>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@* | node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </doc:hier>
   </xsl:template>

   <xsl:template match="docinfo:hierlev"><!--  Original Target XPath:  doc:hier/doc:hierlev   -->
      <doc:hierlev><!--  @SBy:  @exclude-from-displayunits already taken care of in creating doc:hier/@includeintoc   -->
         <xsl:apply-templates select="@* except @exclude-from-displayunits"/>
         <xsl:apply-templates select="node()"/>
         <xsl:apply-templates select="following-sibling::*[1][self::docinfo:hierlev]"
                              mode="hierlevSibling"/>
      </doc:hierlev>
   </xsl:template>

   <xsl:template match="docinfo:hierlev[preceding-sibling::docinfo:hierlev]"
                 mode="hierlevSibling">
      <doc:hierlev>
         <xsl:apply-templates select="@* except @exclude-from-displayunits"/>
         <xsl:apply-templates select="node()"/>
         <xsl:apply-templates select="*[1][self::docinfo:hierlev]" mode="hierlevSibling"/>
      </doc:hierlev>
   </xsl:template>

   <xsl:template match="docinfo:hierlev[preceding-sibling::docinfo:hierlev]"/>
   <!-- Sudhanshu Srivastava : Handling attribute @display-name for UK06 -->
   <xsl:template match="docinfo:hierlev/@display-name[$streamID = ('UK06','UK07')]">
      <xsl:if test=". = 'act'">
         <xsl:attribute name="leveltype" select="'act'"/>
      </xsl:if>
      <xsl:if test=". = 'SI'">
         <xsl:attribute name="leveltype" select="'instrument'"/>
      </xsl:if>
      <xsl:if test=". = 'measure'">
         <xsl:attribute name="leveltype" select="'measure'"/>
      </xsl:if>
   </xsl:template>
   <!--			***		@SBy:  These requirements are covered via other modules:      ***

			<li><sourcexml>docinfo:hier/docinfo:hierlev/heading</sourcexml> becomes
					<targetxml>doc:hier/doc:hierlev/heading</targetxml>
			</li>
			<li><sourcexml>docinfo:hier/docinfo:hierlev/heading/title</sourcexml> becomes
					<targetxml>doc:hier/doc:hierlev/heading/title</targetxml>
			</li>  
	-->
   <xsl:template match="docinfo:hierlev/@role"/>

   <xsl:template match="docinfo:hierlev/heading/title/nl[$streamID = ('CA06', 'CA07')]"><!--  @SBy:  note that otherwise nl will become proc:nl which is permitted within title   -->
      <xsl:text> </xsl:text>
   </xsl:template>

   <xsl:template match="docinfo:hierlev/@exclude-from-displayunits[. = 'true']"><!--  Original Target XPath:  doc:hier/@includeintoc="false"   -->
      <xsl:attribute name="includeintoc" select="'false'"/>
   </xsl:template>
   <!--xsl:template match="docinfo:hierlev/@exclude-from-displayunits[ . != 'true' ]"/-->
   <xsl:template match="docinfo:hierlev/heading/title/num[$streamID = 'CA09']"><!--  @SBy:  note that otherwise num will become num which is permitted within title   --><!--  Original Target XPath:  doc:hierdoc:hierlevheadingtitle   -->
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>
   <!-- Sudhanshu Srivastava: create template for handling docinfo:hierlev for CA13. -->
   <xsl:template match="docinfo:hierlev[$streamID = 'CA13']/heading">
      <heading>
         <xsl:apply-templates select="@* | node()"/>
      </heading>
   </xsl:template>

   <xsl:template match="docinfo:hierlev[$streamID = 'CA13']/heading/title">
      <title>
         <xsl:apply-templates select="@* | node()"/>
      </title>
   </xsl:template>

   <xsl:template match="inlineobject[ancestor::docinfo:hierlev]"/>
   <!-- rosetta element: docinfo:lbu-indexing-terms -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.lbu-indexing-terms-LxAdv-classify.classification_classscheme_lbu-subj-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:lbu-indexing-terms/docinfo:lbu-subj</xd:i> becomes 
		    <xd:b>classify:classification[@classscheme="lbu-subj"]/classify:classitem/classify:classitem-identifier/classify:classcode[@normval]</xd:b>. 
		    The content of <xd:i>docinfo:lbu-subj</xd:i> becomes the value for <xd:b>classify:classcode[@normval]</xd:b>.
		</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:lbu-indexing-terms&gt;
    &lt;docinfo:lbu-subj&gt;lawnow160&lt;/docinfo:lbu-subj&gt;
&lt;/docinfo:lbu-indexing-terms            

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;classify:classification classscheme="lbu-subj"&gt;
    &lt;classify:classitem&gt;
        &lt;classify:classitem-identifier&gt;
            &lt;classify:classcode normval="lawnow160"/&gt;
        &lt;/classify:classitem-identifier&gt;
    &lt;/classify:classitem&gt;
&lt;/classify:classification&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If source document having multiple <xd:i>docinfo:lbu-subj</xd:i> within <xd:i>docinfo:lbu-indexing-terms</xd:i>, then each subsequent occurrence of the element  <xd:i>docinfo:lbu-subj</xd:i> will <xd:b>becomes</xd:b>
            <xd:b>classify:classitem/classify:classitem-identifier/classify:classcode[@normval]</xd:b> element.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:lbu-indexing-terms&gt;
    &lt;docinfo:lbu-subj&gt;lawnowl60&lt;/docinfo:lbu-subj&gt;
    &lt;docinfo:lbu-subj&gt;lawnow295&lt;/docinfo:lbu-subj&gt;
&lt;/docinfo:lbu-indexing-terms&gt;            

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;classify:classification classscheme="lbu-subj"&gt;
    &lt;classify:classitem&gt;
        &lt;classify:classitem-identifier&gt;
            &lt;classify:classcode normval="lawnow160"/&gt;
        &lt;/classify:classitem-identifier&gt;
    &lt;/classify:classitem&gt;
    &lt;classify:classitem&gt;
        &lt;classify:classitem-identifier&gt;
            &lt;classify:classcode normval="lawnow295"/&gt;
        &lt;/classify:classitem-identifier&gt;
    &lt;/classify:classitem&gt;
&lt;/classify:classification&gt;

	</xd:pre>
         <!--Changes2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.lbu-indexing-terms-LxAdv-classify.classification_classscheme_lbu-subj-scheme.dita  -->
   <!--<xsl:message>Rosetta_docinfo.lbu-indexing-terms-LxAdv-classify.classification_classscheme_lbu-subj-scheme.xsl requires manual development!</xsl:message> -->
   <!-- CSN: Added docinfo:lbu-indexing-terms from base.xsl. -->
   <xsl:template match="docinfo:lbu-indexing-terms">
      <xsl:if test="child::docinfo:lbu-juris">
         <xsl:element name="classify:classification">
            <xsl:attribute name="classscheme">docinfo:lbu-juris</xsl:attribute>
            <xsl:apply-templates select="child::docinfo:lbu-juris"/>
         </xsl:element>
      </xsl:if>
      <xsl:if test="child::docinfo:lbu-subj">
         <xsl:element name="classify:classification">
            <xsl:attribute name="classscheme">lbu-subj</xsl:attribute>
            <xsl:apply-templates select="child::docinfo:lbu-subj"/>
         </xsl:element>
      </xsl:if>
   </xsl:template>

   <xsl:template match="docinfo:lbu-subj">
      <xsl:element name="classify:classitem">
         <xsl:element name="classify:classitem-identifier">
            <xsl:element name="classify:classcode">
               <xsl:attribute name="normval">
                  <xsl:value-of select="."/>
               </xsl:attribute>
            </xsl:element>
         </xsl:element>
      </xsl:element>
   </xsl:template>

   <xsl:template match="docinfo:lbu-juris[not($streamID='CA01')]">
      <xsl:element name="classify:classitem">
         <xsl:element name="classify:classitem-identifier">
            <xsl:element name="classify:classcode">
               <xsl:attribute name="normval">
                  <xsl:value-of select="."/>
               </xsl:attribute>
            </xsl:element>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- Vikas Rohilla : Updated as per the $streamID CA01    -->
   <xsl:template match="docinfo:lbu-juris[$streamID='CA01'][.!='CA' or .!='UK' or .!='NZ']">
      <xsl:element name="classify:classitem">
         <xsl:element name="classify:classitem-identifier">
            <xsl:element name="classify:classname">
               <xsl:value-of select="."/>
            </xsl:element>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- rosetta element: docinfo:lbu-meta -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.lbu-meta-LxAdv-doc.legacy-metadata_metadatasource_lbu-meta-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:lbu-meta</xd:i> becomes
						<xd:b>doc:legacy-metadata[@metadatasource="lbu-meta"]</xd:b>.
						<xd:i>docinfo:metaitem</xd:i> becomes
						<xd:b>meta/metaitem</xd:b>. The source attribute
						<xd:i>@name</xd:i> becomes <xd:b>metaitem[@name]</xd:b> and
						<xd:i>@value</xd:i> becomes <xd:b>metaitem[@value]</xd:b>. </xd:p>
         <xd:p>
            <xd:i>docinfo:metaitem</xd:i> should be dropped if the attribute
						<xd:i>@name</xd:i> has any of the following drop list values: <xd:ul>
               <xd:li>
                  <xd:i>@name="date"</xd:i>
               </xd:li>
               <xd:li>
                  <xd:i>@name="juris"</xd:i>
               </xd:li>
               <xd:li>
                  <xd:i>@name="court"</xd:i>
               </xd:li>
               <xd:li>
                  <xd:i>@name="country"</xd:i>
               </xd:li>
               <xd:li>
                  <xd:i>@name="parent-filename"</xd:i>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre>
	&lt;docinfo&gt;
	&lt;docinfo:lbu-meta&gt;
		&lt;docinfo:metaitem name="date" value="18810104"/&gt;
		&lt;docinfo:metaitem name="country" value="2"/&gt;
		&lt;docinfo:metaitem name="court" value="2"/&gt;
		&lt;docinfo:metaitem name="date" value="18810104"/&gt;
		&lt;docinfo:metaitem name="juris" value="9"/&gt;
		&lt;docinfo:metaitem name="court" value="1"/&gt;
		&lt;docinfo:metaitem name="country" value="2"/&gt;
		&lt;docinfo:metaitem name="lbu-sourcename" value="New Zealand Law Reports"/&gt;
		&lt;docinfo:metaitem name="parent-docid" value="1NZLR_CA_1"/&gt;
		&lt;docinfo:metaitem name="parent-filename" value="1NZLR_CA_00001.xml"/&gt;
	&lt;/docinfo:lbu-meta&gt;&lt;/docinfo&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre>
	&lt;doc:metadata&gt;
	&lt;doc:docinfo&gt;
		&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
			&lt;meta&gt;
			   &lt;metaitem name="lbu-sourcename" value="New Zealand Law Reports"/&gt;
			   &lt;metaitem name="parent-docid" value="1NZLR_CA_1"/&gt;
			&lt;/meta&gt;
		&lt;/doc:legacy-metadata&gt;
	&lt;/doc:docinfo&gt;&lt;/doc:metadata&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:pre>
	&lt;docinfo&gt;
	&lt;docinfo:lbu-meta&gt;
	&lt;docinfo:metaitem name="SRCNAME" value="AGAA"&gt;&lt;/docinfo:metaitem&gt;
	&lt;docinfo:metaitem name="SRCDOCNO" value="00000008"&gt;&lt;/docinfo:metaitem&gt;
	&lt;docinfo:metaitem name="DPSI" value="03EN"&gt;&lt;/docinfo:metaitem&gt;
	&lt;/docinfo:lbu-meta&gt;
	&lt;/docinfo&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:pre>
	&lt;doc:metadata&gt;
	&lt;doc:docinfo&gt;
		&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
			&lt;meta&gt;
			   &lt;metaitem name="SRCNAME" value="AGAA"/&gt;
			   &lt;metaitem name="SRCDOCNO" value="00000008"/&gt;
			   &lt;metaitem name="DPSI" value="03EN"/&gt;
			&lt;/meta&gt;
		&lt;/doc:legacy-metadata&gt;
	&lt;/doc:docinfo&gt;&lt;/doc:metadata&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Source XML 3</xd:b>
         </xd:p>
         <xd:pre>
	&lt;docinfo&gt;
	&lt;docinfo:lbu-meta&gt;
	&lt;docinfo:metaitem name="QLDB" value="sb99"&gt;&lt;/docinfo:metaitem&gt;
	&lt;/docinfo:lbu-meta&gt;
	&lt;/docinfo&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre>
	&lt;doc:metadata&gt;
	&lt;doc:docinfo&gt;
		&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
			&lt;meta&gt;
			   &lt;metaitem name="QLDB" value="sb99"/&gt;	       
			&lt;/meta&gt;
		&lt;/doc:legacy-metadata&gt;
	&lt;/doc:docinfo&gt;&lt;/doc:metadata&gt;
	
		</xd:pre>
         <xd:p>
            <xd:b>Source XML 4</xd:b>
         </xd:p>
         <xd:pre>
	
	&lt;docinfo&gt;
	 &lt;!-- ETC. --&gt;
	 &lt;docinfo:lbu-meta&gt;
	  &lt;docinfo:metaitem name="selection_criteria_variant" value="PCT207_regulation_1" /&gt;
	  &lt;docinfo:metaitem name="lbu-sourcename" value="New Zealand Regulations" /&gt;
	  &lt;docinfo:metaitem name="parent-docid" value="GCG-REGULATIONS-D" /&gt;
	  &lt;docinfo:metaitem name="parent-filename" value="Regs-D.xml" /&gt;
	  &lt;docinfo:metaitem name="parent-docid" value="NZREGS_REGS-D.SGM_2001R326-FRONT-CONTENTS" /&gt;
	  &lt;docinfo:metaitem name="parent-filename" value="Regs-D1030.xml" /&gt;
	 &lt;/docinfo:lbu-meta&gt;
	 &lt;!-- ETC. --&gt;
	&lt;/docinfo&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Target XML 4</xd:b>
         </xd:p>
         <xd:pre>
					
	&lt;doc:metadata&gt;
	&lt;doc:docinfo&gt;
		&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
			&lt;meta&gt;
			   &lt;metaitem name="selection_criteria_variant" value="PCT207_regulation_1"/&gt;
			   &lt;metaitem name="lbu-sourcename" value="New Zealand Regulations"/&gt;
			   &lt;metaitem name="parent-docid" value="GCG-REGULATIONS-D"/&gt;
			   &lt;metaitem name="parent-docid" value="NZREGS_REGS-D.SGM_2001R326-FRONT-CONTENTS"/&gt;
			&lt;/meta&gt;
		&lt;/doc:legacy-metadata&gt;
	&lt;/doc:docinfo&gt;&lt;/doc:metadata&gt;
	
				</xd:pre>
         <!-- McNally July 28 2016.  I'm commenting-out the following section "Special rules for UK14". 
			Will investigate intent.  If truly UK14 only then probably want separate submodule. 
			Will need some work. Narrative describes custom-metafield which can't occur in docinfo:lbu-meta.
			Example shows docinfo:metaitem which would be ok. 
			Also commented-out the change entry and moved it out of the changelog section. -->
         <!--<section>
				<note><b>Special rules for UK14:</b> These are rules for mapping certain instances of
					the source element <sourcexml>docinfo:custom-metafield</sourcexml> and instances are
					identified through the <sourcexml>@name</sourcexml> attribute. If given source
					present then below rules apply. </note>
				<p><b><u>Mapping to <targetxml>classify:classification</targetxml></u></b></p>
				<p>Source: <ul>
						<li><sourcexml>docinfo:custom-metafield[@name="alternative-title-formal"]</sourcexml></li>
						<li><sourcexml>docinfo:custom-metafield[@name="alternative-title-acronym"]</sourcexml></li>
						<li><sourcexml>docinfo:custom-metafield[@name="alternative-title-popular"]</sourcexml></li>
					</ul></p>
				<p>Target: Each source item becomes <targetxml>metaitem[@name @value]</targetxml> within
						<targetxml>classify:classification</targetxml> markup. As follows:</p>
				<p>Within <targetxml>doc:metadata/doc:docinfo</targetxml> -<ul>
						<li>Create
								<targetxml>classify:classification[@classscheme="uk-functional-information"]/classify:classitem</targetxml>.
							The <targetxml>@classscheme</targetxml> value is hard coded.<ul>
								<li>Create <targetxml>meta</targetxml><ul>
										<li>For each <sourcexml>docinfo:custom-metafield</sourcexml>
											specified above, create <targetxml>metaitem[@name
												@value]</targetxml>. Where <sourcexml>@name</sourcexml>
											value becomes <targetxml>@name</targetxml> value. And
											content of source element becomes
												<targetxml>@value</targetxml> value.</li>
									</ul></li>
								<li>Create
										<targetxml>classify:classitem-identifier/classify:classcode[@normval="functional-parameters"]</targetxml>.
									The <targetxml>@normval</targetxml> value is hard coded.</li>
							</ul></li>
					</ul><note>Create only one container
							<targetxml>classify:classification[@classscheme="uk-functional-information"]/classify:classitem</targetxml>.
						The container holds the items described above and may also hold mappings from
						elsewhere in the same source file.</note></p>
			</section>
			<example>
				<title>Source XML 5</title>
				<codeblock>
	<![CDATA[<docinfo>
	<docinfo:lbu-meta>
		<docinfo:metaitem name="alternative-title-formal" value="Merger confidentiality agreement in letter form"/>
		<docinfo:metaitem name="alternative-title-acronym" value="NDA" />
		<docinfo:metaitem name="alternative-title-popular" value="Non-disclosure clause for a shareholders agreement"/>
	</docinfo:lbu-meta>
	</docinfo>
	]]>
		</codeblock>
			</example>
	
			<example>
				<title>Target XML 5</title>
				<codeblock>
	<![CDATA[
	<doc:metadata>
		<doc:docinfo>
			<classify:classification classscheme="uk-functional-information">
				<classify:classitem>
					<meta>
						<metaitem name="alternative-title-formal" value="Merger confidentiality agreement in letter form"/>
						<metaitem name="alternative-title-acronym" value="NDA"/>
						<metaitem name="alternative-title-popular" value="Non-disclosure clause for a shareholders agreement"/>
					</meta>
					<classify:classitem-identifier>
						<classify:classcode normval="functional-parameters"/>
					</classify:classitem-identifier>
				</classify:classitem>
			</classify:classification>
		</doc:docinfo>
	</doc:metadata>
	]]>
		</codeblock>
			</example>
			
				<p>2016-07-28: <ph id="change_20160728_ss">Added rules for handling of
							<sourcexml>@name="alternative-title-formal"</sourcexml>,
							<sourcexml>@name="alternative-title-acronym"</sourcexml> and
							<sourcexml>@name="alternative-title-popular"</sourcexml> with updated
						example.</ph></p> -->
         <!--Changes2013-08-12: We removed the docinfo:lbu-meta "include"
						list so now there is only a "drop" list. Anything not on the "drop" list should
						be passed through. Webteam 230557.2013-08-02: Added
							@name="selection_criteria_variant" to the list of
						values in docinfo:metaitem/@name that should be retained. And added a
						example.2013-05-31: Added "document-type" to the list of values
						in docinfo:metaitem/@name that should be retained.2013-04-09: Added the instruction for handling
							docinfo:metaitem[@name="QLDB"].2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="docinfo:lbu-meta">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="docinfo:metaitem">
      <xsl:choose>
         <xsl:when test="@name='date' or      @name='juris' or      @name='court' or      @name='country' or      @name='parent-filename' or      @name='PA-PGUID' or      @name='TOPIC-PGUID' or      @name='SUB-TOPIC-PGUID'         "/>
         <xsl:otherwise><!-- @name='parent-docid'and name='lbu-sourcename' are two values that need to be converted for court cases -->
            <metaitem>
               <xsl:attribute name="name">
                  <xsl:value-of select="@name"/>
               </xsl:attribute>
               <xsl:attribute name="value">
                  <xsl:value-of select="@value"/>
               </xsl:attribute>
            </metaitem>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- rosetta element: docinfo:load-date -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:load-date/date</xd:i> becomes
						<xd:b>dc:metadata/dc:date[@lnmeta:datetype="load-date"]</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>The format of the content of all <xd:b>dc:date</xd:b> elements must be
					in 'YYYY-MM-DD'.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:load-date&gt;
&lt;date day="01" month="01" year="2006"&gt;01 January 2006&lt;/date&gt;
&lt;/docinfo:load-date&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dc:date lnmeta:datetype="load-date"&gt;2006-01-01&lt;/dc:date&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>The below example encountered in CANADA contents which contains "00" value in
						<xd:i>@day="00"</xd:i> and <xd:i>@month="00"</xd:i>
					attributes.</xd:p>
            <xd:p>
               <xd:b>Per LBU-</xd:b> This was the format used for historical data in which only the year was given. We will remediate the content to have a valid month/day and will send the remediated data in a subsequent reload.</xd:p>
         </xd:p>
         <xd:pre>

&lt;docinfo:load-date&gt;
    &lt;date year="1959" month="00" day="00"&gt;19590000&lt;/date&gt;
&lt;/docinfo:load-date&gt;
                
				</xd:pre>
         <!--Changes2014-01-07:  Added a note along with example which contains "00" value in @day="00" and @month="00" attributes encountered in CANADA contents.2013-08-07: Removed instructions for creating
							dc:date[@lnmeta:datetype="conversion-date"].2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_date-Chof-docinfo.load-date-LxAdv-dc.date_lnmeta.datetype_load-date-scheme.dita  -->
   <xsl:template match="docinfo:load-date">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="docinfo:load-date/date">
      <dc:date lnmeta:datetype="load-date">
         <xsl:value-of select="@year"/>
         <xsl:text>-</xsl:text>
         <xsl:value-of select="@month"/>
         <xsl:text>-</xsl:text>
         <xsl:value-of select="@day"/>
      </dc:date>
   </xsl:template>
   <!-- rosetta element: docinfo:overview -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.overview-LxAdv-docinfo.overview.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:overview</xd:i> becomes <xd:b>doc:overview</xd:b>, with
          child <xd:b>doc:overview/bodytext</xd:b> created to hold the converted
            <xd:i>docinfo:overview</xd:i> content.</xd:p>
         <xd:p>If <xd:i>docinfo:overview</xd:i> has attribute <xd:i>@type</xd:i>
          then retain and carry into the target xml <xd:b>doc:overview/@type</xd:b> as
          shown below.</xd:p>
         <xd:p>(i.e <xd:i>docinfo:overview type="extracted"</xd:i> becomes
            <xd:b>doc:overview type="extracted"</xd:b>).</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion needs to suppress <xd:i>docinfo:overview</xd:i> when it's the
          child of <xd:i>leg:levelinfo</xd:i> and <xd:i>levelinfo</xd:i>. This
          will be applicable to all <xd:b>Pacific Content Streams</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo&gt; &lt;docinfo:overview type="editorial"&gt; &lt;p&gt;
          &lt;text&gt;This is a document transactional overview sample for AU05 Commentary Form
          content type/stream. It is indicative text only and not a sample of actual text that will
          be included but used here to identify the particular element used for this
          purpose.&lt;/text&gt; &lt;/p&gt; &lt;/docinfo:overview&gt; &lt;/docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:docinfo&gt; &lt;doc:overview type="editorial"&gt; &lt;bodytext&gt;
          &lt;p&gt; &lt;text&gt;This is a document transactional overview sample for AU05 Commentary
          Form content type/stream. It is indicative text only and not a sample of actual text that
          will be included but used here to identify the particular element used for this
          purpose.&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;/doc:overview&gt;
          &lt;/doc:docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>
               <xd:i>For UK streams</xd:i>
            </xd:b>: If input documents is having
          <xd:i>docinfo:overview@type</xd:i> markup with attribute value "<xd:i>abstract</xd:i>"
        then conversion needs to mapped <xd:b>doc:overview@type="abstract"</xd:b> in
        NewLexis target. Refer input and target examples;</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo&gt; &lt;docinfo:overview type="abstract"&gt; &lt;p&gt;
          &lt;text&gt;VAT  default surcharge  reasonable excuse  dismissal of key employee 
          reliance on another person&lt;/text&gt; &lt;/p&gt; &lt;/docinfo:overview&gt;
          &lt;/docinfo&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;doc:docinfo&gt; &lt;doc:overview type="abstract"&gt; &lt;bodytext&gt;
          &lt;p&gt; &lt;text&gt;VAT  default surcharge  reasonable excuse  dismissal of key
          employee  reliance on another person&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
          &lt;/doc:overview&gt; &lt;/doc:docinfo&gt; </xd:pre>
         <!--Changes2013-04-10:  Created2013-06-25: added to AU and NZ ditamap for content
            enrichment2013-09-16: Instruction added for suppressing
              docinfo:overview when it is child of
              leg:levelinfo and levelinfo.Affects all
            Pacific content streams. WebTeam # is 234193.2013-09-16: WebTeam #233318 created for pacific
            content stream inorder to suppress docinfo:overview with in
              leg:levelinfo and levelinfo.2014-08-04: added to UK05 ditamap.2014-10-21: added to UK09 ditamap.2014-11-04: Clarification only: added text to explicitly
            indicate that the child doc:overview/bodytext should be created.
            Not a change to instructions.2015-09-08: Added the handling of new attribute value
              "abstract" inside the docinfo:overview@type markup for
            UK streams and it should be mapped with
              doc:overview@type="abstract". R4.5 Content Issue List
            #2391.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.overview-LxAdv-docinfo.overview.dita  -->
   <!-- CSN: Added docinfo:overview from base.xsl. -->
   <xsl:template match="docinfo:overview">
      <xsl:choose>
         <xsl:when test="(parent::levelinfo or parent::leg:levelinfo) and (//docinfo:doc-country/@iso-cc = 'NZ' or //docinfo:doc-country/@iso-cc = 'AU')"/>
         <xsl:otherwise>
            <xsl:element name="doc:overview">
               <xsl:attribute name="type">
                  <xsl:value-of select="@type"/>
               </xsl:attribute>
               <xsl:choose>
                  <xsl:when test="bodytext">
                     <xsl:apply-templates select="node()"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <bodytext>
                        <xsl:apply-templates select="node()"/>
                     </bodytext>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- rosetta element: docinfo:selector -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.selector-LxAdv-classify.classification_classscheme_selector-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:selector</xd:i> becomes <xd:b>classify:classification[@classscheme="selector"]/classify:classitem/classify:classitem-identifier/classify:classname</xd:b>. Each subsequent occurrence of the element docinfo:selector adds a sibling /classify:classitem/classify:classitem-identifier/classify:classname element.
		</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:selector&gt;act&lt;/docinfo:selector&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;classify:classification classscheme="selector"&gt;
&lt;classify:classitem&gt;
&lt;classify:classitem-identifier&gt;
&lt;classify:classname&gt;act&lt;/classify:classname&gt;
&lt;/classify:classitem-identifier&gt;
&lt;/classify:classitem&gt;
&lt;/classify:classification&gt;

	</xd:pre>
         <!--Changes2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="docinfo:selector[preceding-sibling::docinfo:selector]"/>

   <xsl:template match="docinfo:selector">
      <classify:classitem>
         <classify:classitem-identifier>
            <classify:classname>
               <xsl:apply-templates/>
            </classify:classname>
         </classify:classitem-identifier>
      </classify:classitem>
      <xsl:for-each select="following-sibling::docinfo:selector">
         <classify:classitem>
            <classify:classitem-identifier>
               <classify:classname>
                  <xsl:apply-templates/>
               </classify:classname>
            </classify:classitem-identifier>
         </classify:classitem>
      </xsl:for-each>
   </xsl:template>
   <!-- CSN: Added docinfo:selector from base.xsl. -->   <!--<xsl:template xmlns="http://dita.oasis-open.org/architecture/2005/" xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" match="docinfo:selector">
				<xsl:element name="classify:classitem">
					<xsl:element name="classify:classitem-identifier">
						<xsl:element name="classify:classname">
							<xsl:apply-templates/>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:template>-->   <!-- rosetta element: docinfo:subtype -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.subtype-LxAdv-doc.legacy-metadata_metadatasource_lbu-meta-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:subtype</xd:i> becomes <xd:b>doc:legacy-metadata/meta/metaitem</xd:b> with attributes <xd:b>@name="docinfo:subtype"</xd:b> and value will be the data from <xd:i>docinfo:subtype</xd:i>.
      </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:subtype&gt;cait&lt;/docinfo:subtype&gt;
&lt;docinfo:subtype&gt;cait&lt;/docinfo:subtype&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:legacy-metadata metadatasource="lbu-meta"&gt;
&lt;meta&gt;
    &lt;metaitem name="docinfo:subtype" value="cait"/&gt;
    &lt;metaitem name="docinfo:subtype" value="cait"/&gt;
&lt;/meta&gt;
&lt;/doc:legacy-metadata&gt;

	</xd:pre>
         <!--Changes2012-11-30: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.subtype-LxAdv-doc.legacy-metadata_metadatasource_lbu-meta-scheme.dita  -->
   <!-- CSN: Added docinfo:subtype from base.xsl. -->
   <xsl:template match="docinfo:subtype">
      <xsl:element name="metaitem">
         <xsl:attribute name="name">
            <xsl:text>docinfo:subtype</xsl:text>
         </xsl:attribute>
         <xsl:attribute name="value">
            <xsl:value-of select="."/>
         </xsl:attribute>
      </xsl:element>
   </xsl:template>
   <!-- Old file: common_rosetta_docinfo.topiccodes.dita -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.topiccodes-to-LxAdv-classify.classification_classscheme_docinfo-topiccodes.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:topiccodes/docinfo:topiccode</xd:i> becomes
						<xd:b>classify:classification[@classscheme="docinfo:topiccodes"]/classify:classitem/classify:classitem-identifier/classify:classcode/@normval</xd:b>.
					The content of <xd:i>docinfo:topiccode</xd:i> becomes the value for
						<xd:b>classify:classcode/@normval</xd:b>. A single
						<xd:b>classify:classification[@classscheme="docinfo:topiccodes"]</xd:b>
					is created for each unique value of <xd:b>@classscheme</xd:b>. Within
					this single element, create multiple <xd:b>classify:classitem</xd:b>
					elements. Only create additional <xd:b>classify:classification</xd:b>
					wrapper elements when the
						<xd:b>classify:classification[@classscheme]</xd:b> has different
					values. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:topiccodes&gt;
					&lt;docinfo:topiccode&gt;#PA#CODE#&lt;/docinfo:topiccode&gt;
					&lt;docinfo:topiccode&gt;#PA#BUSM#&lt;/docinfo:topiccode&gt;
					&lt;/docinfo:topiccodes&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;classify:classification classscheme="docinfo:topiccodes"&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classcode normval="#PA#CODE#"/&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classcode normval="#PA#BUSM#"/&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;/classify:classification&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>Applied for UK07 Regulation contents only:</xd:b> When element
						<xd:i>docinfo:topiccode</xd:i> contains attribute
						<xd:i>@scheme="source-by-date"</xd:i>, then conversion will
					suppress it including its contents as well. Please see below input and output
					examples for more details:</xd:p>
         <xd:p>
            <xd:b>Source XML:</xd:b>
         </xd:p>
         <xd:pre> &lt;docinfo:topiccodes&gt; &lt;docinfo:topiccode
					scheme="source-by-date"&gt;2012-08-02&lt;/docinfo:topiccode&gt;
					&lt;docinfo:topiccode&gt;#PA#CODE#&lt;/docinfo:topiccode&gt;
					&lt;/docinfo:topiccodes&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML(Only second <xd:i>docinfo:topiccode</xd:i>)
					converted</xd:b>
         </xd:p>
         <xd:pre> &lt;classify:classification classscheme="docinfo:topiccodes"&gt;
					&lt;classify:classitem&gt; &lt;classify:classitem-identifier&gt;
					&lt;classify:classcode normval="#PA#CODE#"/&gt;
					&lt;/classify:classitem-identifier&gt; &lt;/classify:classitem&gt;
					&lt;/classify:classification&gt; </xd:pre>
         <!--Changes2014-02-03: Added a special rule for UK07 contents,
						When element docinfo:topiccode contains attribute
							@scheme="source-by-date", then conversion will
						suppress it including its contents as well. Phase 5 UK discussion-defect
						tracking: issue #156. 2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.topiccodes-to-LxAdv-classify.classification_classscheme_docinfo-topiccodes.dita  -->
   <!-- CSN: Added docinfo:topiccodes and docinfo:topiccode from base.xsl. -->
   <xsl:template match="docinfo:topiccodes">
      <xsl:element name="classify:classification">
         <xsl:attribute name="classscheme">docinfo:topiccodes</xsl:attribute>
         <xsl:apply-templates/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="docinfo:topiccode">
      <xsl:element name="classify:classitem">
         <xsl:element name="classify:classitem-identifier">
            <xsl:element name="classify:classcode">
               <xsl:attribute name="normval">
                  <xsl:value-of select="."/>
               </xsl:attribute>
            </xsl:element>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- rosetta element: docinfo:versioninfo -->   <!-- <topicref href="../../common_newest/Rosetta_docinfo.versioninfo-LxAdv-doc.versioninfo-scheme.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>docinfo:versioninfo/@hasotheversions</xd:i> becomes <xd:b>doc:versioninfo/@hasotherversions</xd:b> with these children:
                <xd:ul>
               <xd:li>
                  <xd:i>docinfo:versioninfo/docinfo:startdate[@day @month @year]</xd:i> becomes <xd:b>doc:versioninfo/doc:startdate[@day @month @year]</xd:b>.
                    </xd:li>
               <xd:li>
                  <xd:i>docinfo:versioninfo/docinfo:enddate[@day @month @year]</xd:i> becomes <xd:b>doc:versioninfo/doc:enddate[@day @month @year]</xd:b>.
                    </xd:li>
               <xd:li>
                  <xd:i>docinfo:versioninfo/docinfo:versionbranch[@value]</xd:i> becomes <xd:b>doc:versioninfo/doc:versionbranch[@value]</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>Added the attribute <xd:b>@normdate</xd:b> (value must be in '<xd:i>YYYY-MM-DD</xd:i>')
                    inside the target <xd:b>doc:startdate</xd:b> and
                        <xd:b>doc:enddate</xd:b> elements. <xd:ul>
                  <xd:li>If one or more of the three date values (year, month or day) are absent,
                            then attribute <xd:b>@normdate</xd:b> should not be
                            populated.</xd:li>
                  <xd:li>The <xd:b>@normdate</xd:b> attribute value shoud be generated
                            from target attributes (<xd:b>@year</xd:b>,
                                <xd:b>@month</xd:b> and <xd:b>@day</xd:b>),
                            which are comes under the <xd:b>doc:startdate</xd:b> and
                                <xd:b>doc:enddate</xd:b> elements within New Lexis.</xd:li>
               </xd:ul>
            </xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>Added the mapping of <xd:i>@startdate-tbd</xd:i>
                    attribute which is comes under <xd:i>docinfo:versioninfo</xd:i>
                    element in source then it should be mapped in target
                        <xd:b>doc:versioninfo@startdate-tbd</xd:b> (attribute value must
                    be in 'true' OR 'false', default value is 'false').</xd:p>
         </xd:p>
         <xd:p> For <xd:b>CA05 Acts&amp;Bills</xd:b> and <xd:b>CA08 Constitutions</xd:b>, suppress
                    <xd:i>docinfo:versioninfo</xd:i> from conversion if it has the
                following variations: <xd:ul>
               <xd:li>&lt;docinfo:versioninfo&gt;&lt;/docinfo:versioninfo&gt;</xd:li>
               <xd:li>&lt;docinfo:versioninfo hasotherversions="false"&gt;&lt;/docinfo:versioninfo&gt;</xd:li>
               <xd:li>&lt;docinfo:versioninfo hasotherversions="true"&gt;&lt;/docinfo:versioninfo&gt;</xd:li>
            </xd:ul> The above variations should be considered as "empty" and needs to be
                suppressed from conversion. </xd:p>
         <xd:p>When transforming the attribute values, enforce these constraints:
                <xd:ul>
               <xd:li>The <xd:b>@day</xd:b> value must be two digit number, i.e. from
                        '01' to '31'.</xd:li>
               <xd:li>The <xd:b>@month</xd:b> value must be transformed to a two digit number from '01' to '12', i.e. 'January' = '01' and 'December' = '12'.</xd:li>
               <xd:li>The <xd:b>@year</xd:b> value must be a four digit number, i.e. '2011'.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>Exception for Canada</xd:b>: Conversion should generate <xd:b>@day</xd:b> attribute
                    value in sequential digit. No need to add leading zero (0) to make the value in
                    two digits.</xd:p>
         <xd:p>
            <xd:b>Source XML based on Canada stream: </xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:versioninfo hasotherversions="true"&gt;
    &lt;docinfo:startdate day="01" month="01" year="2003"/&gt;
    &lt;docinfo:enddate day="30" month="06" year="2003"/&gt;
&lt;/docinfo:versioninfo&gt;
</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:versioninfo hasotherversions="true"&gt;
    &lt;doc:startdate day="1" month="01" year="2003"/&gt;
    &lt;doc:enddate day="30" month="06" year="2003"/&gt;
&lt;/doc:versioninfo&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;docinfo:versioninfo hasotherversions="true"&gt;
     &lt;docinfo:startdate year="2007" month="06" day="21"/&gt;
     &lt;docinfo:versionbranch value="1120669"/&gt;
&lt;/docinfo:versioninfo&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;doc:versioninfo hasotherversions="true"&gt;
    &lt;doc:startdate month="06" day="21" year="2007"/&gt;
    &lt;doc:versionbranch value="1120669"/&gt;
&lt;/doc:versioninfo&gt;

	</xd:pre>
         <!--Changes2016-10-17: Updated the instruction for handling the
                    target attribute @normdate.
                [Webstar#6676189]2016-09-14: Note added for handling the input markup 'docinfo:versioninfo@startdate-tbd'.2016-09-02: Special Rule for added
                        @normdate attribute inside the
                        doc:startdate and
                    doc:enddate.2014-07-02: Edit a note for Canada only to generate
                        @day attribute value must be in sequential digit
                    number. No need to add leading zero (0) to make the value in two digits. This
                    immediate applies to ALL Canada streams.2014-06-09: Added note for Canada only to generate
                        @day attribute value as per the source. No need to
                    add zero (0) to make the value in two digits. This immediate applies to ALL
                    Canada streams.2014-04-15: Added the content stream code "CA08
                        Constitutions" inside the Note for handling empty use cases of
                        docinfo:versioninfo for Canada streams.2013-05-24: Instructions added for handling empty use cases of docinfo:versioninfo for Canada content stream.2011-08-30: Created.2012-12-03: Instruction and example added for docinfo:versioninfo/docinfo:versionbranch[@value].-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_docinfo.versioninfo-LxAdv-doc.versioninfo-scheme.dita  -->
   <!-- CSN: Created docinfo:versioninfo, docinfo:startdate, docinfo:enddate. -->
   <xsl:template match="docinfo:versioninfo">
      <xsl:choose>
         <xsl:when test="$streamID=('CA05' , 'CA08') and not(child::*)"/>
         <xsl:otherwise>
            <xsl:element name="doc:versioninfo">
               <xsl:apply-templates select="@*|node()"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="docinfo:versioninfo/@hasotherversions | docinfo:versionbranch/@value | docinfo:versioninfo/@startdate-tbd">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="docinfo:startdate">
      <xsl:element name="doc:startdate">
         <xsl:call-template name="dateAtts"/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="docinfo:enddate">
      <xsl:element name="doc:enddate">
         <xsl:call-template name="dateAtts"/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="docinfo:versionbranch">
      <xsl:element name="doc:versionbranch">
         <xsl:apply-templates select="@*"/>
      </xsl:element>
   </xsl:template>

   <xsl:template name="dateAtts">
      <xsl:variable name="dayValue" as="xs:integer">
         <xsl:choose>
            <xsl:when test="@day">
               <xsl:value-of select="xs:integer(@day)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:text>0</xsl:text>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="monthValue" as="xs:integer">
         <xsl:choose>
            <xsl:when test="@month">
               <xsl:value-of select="xs:integer(@month)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:text>0</xsl:text>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="monthValueString"
                    as="xs:string"
                    select="if ($monthValue lt 10 and $monthValue gt 0) then concat( '0' , string($monthValue) ) else string($monthValue)"/>
      <xsl:variable name="yearValue" as="xs:integer" select="xs:integer(@year)"/>
      <xsl:variable name="current2digitYear"
                    as="xs:integer"
                    select="xs:integer(substring(string(current-date()),3,2))"/>
      <xsl:variable name="outputDay"
                    as="xs:boolean"
                    select="if ($dayValue gt 0 and $dayValue lt 32) then true() else false()"/>
      <xsl:variable name="outputMonth"
                    as="xs:boolean"
                    select="if ($monthValue gt 0 and $monthValue lt 13) then true() else false()"/>
      <xsl:variable name="outputYear"
                    as="xs:boolean"
                    select="if ($yearValue gt 0) then true() else false()"/>
      <xsl:variable name="dayNorm"
                    as="xs:string"
                    select="if ($dayValue lt 10) then concat( '0' , string($dayValue) ) else string($dayValue)"/>
      <xsl:variable name="yearNorm"
                    as="xs:string"
                    select="if ($yearValue lt 10) then concat( '200' , string($yearValue) ) else             if ($yearValue le $current2digitYear) then concat( '20' , string($yearValue) ) else             if ($yearValue lt 100) then concat( '19' , string($yearValue) ) else             if ($yearValue lt 1000) then concat( '0' , string($yearValue) ) else             string($yearValue)"/>
      <xsl:if test="$outputDay and $outputMonth and $outputYear">
         <xsl:attribute name="day" select="$dayValue"/>
         <xsl:attribute name="normdate"
                        select="concat($yearNorm,'-',$monthValueString,'-',$dayNorm)"/>
      </xsl:if>
      <xsl:if test="$outputMonth and $outputYear">
         <xsl:attribute name="month" select="$monthValueString"/>
      </xsl:if>
      <xsl:if test="$outputYear">
         <xsl:attribute name="year" select="$yearValue"/>
      </xsl:if>
   </xsl:template>
   <!-- end topichead  Metadata  -->   <!--<topichead navtitle="General Markup">
		<topicref href="../common/common_rosetta_pgrp.dita"/>
		<topicref href="../common/common_rosetta_p.dita"/>
		<topicref href="../common/common_rosetta_p-limited.dita"/>
		<topicref href="../common/common_rosetta_text.dita"/>
		<topicref href="../common/common_rosetta_form-chars.dita"/>
		<topicref href="../common/common_rosetta_char-line.dita"/>
		<topicref href="../common/common_rosetta_emph.dita"/>
		<topicref href="../common/common_rosetta_page.dita"/>
		<topicref href="../common/common_rosetta_l.dita"/>
		<topicref href="../common/common_rosetta_toc.dita"/>
		<topicref href="../common/common_rosetta_deflist.dita"/>	
		<topicref href="../common/common_rosetta_refpt.dita"/>
		<topicref href="../common/common_rosetta_blockquote.dita"/>
		<topicref href="../common/common_rosetta_legfragment.dita"/>
		<topicref href="../common/common_rosetta_link.dita"/>
		<topicref href="../common/common_rosetta_lnlink.dita"/>
		<topicref href="../common/common_rosetta_insert-line.dita"/>
		<topicref href="../common/common_rosetta_remotelink.dita"/>
		<topicref href="../common/common_rosetta_marker.dita"/>
		<topicref href="../common/common_rosetta_nl.dita"/>
		<topicref href="../common/common_rosetta_strike.dita"/>
		<topicref href="../common/common_rosetta_h.dita"/>
		<topicref href="../common/common_rosetta_heading.dita"/>
		<topicref href="../common/common_rosetta_title.dita"/>
		<topicref href="../common/common_rosetta_hrule.dita"/>
		<topicref href="../common/common_rosetta_inlineobject.dita"/>
		<topicref href="../common/common_rosetta_figure.dita"/>
		<topicref href="../common/common_rosetta_dispformula.dita"/>	
		<topicref href="../common/common_rosetta_pnum.dita"/>
		<topicref href="../common/common_rosetta_footnote.dita"/>
		<topicref href="../common/common_rosetta_ci.cite.dita"/>
		<topicref href="../common/common_rosetta_table.dita"/>
		<topicref href="../common/common_rosetta_desig.dita"/>
		<topicref href="../common/common_rosetta_edpnum.dita"/>
		<topicref href="../common/common_rosetta_subtitle.dita"/>
		<topicref href="../common/common_rosetta_sup.dita"/>
		<topicref href="../common/common_rosetta_sub.dita"/>
		<topicref href="../common/common_rosetta_num_frac.dita"/>
		<topicref href="../common/common_rosetta_glp.note.dita"/>
		<topicref href="../common/common_rosetta_sigblock.dita"/>
		<topicref href="../common/common_rosetta_person.dita"/>
    	<topicref href="../common/common_rosetta_ln.user_displayed.dita"/>
    	<topicref href="../common/common_rosetta_copyright.dita"/>
    	<topicref href="../common/common_rosetta_endnote.dita"/>
    	<topicref href="../common/common_rosetta_credit.dita"/>
    	</topichead>-->   <!-- start topichead  General Markup  -->   <!-- rosetta element: alttitle -->   <!-- <topicref href="../../common_newest/Rosetta_alttitle-LxAdv-alttitle.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>alttitle</xd:i> becomes <xd:b>alttitle</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:heading&gt;
    &lt;desig searchtype="CHAP-NUM"&gt;&lt;designum&gt;&lt;refpt id="CPSA.SDCR.SDCR.PT2" type="ext"/&gt;Part II&lt;/designum&gt;&lt;/desig&gt;
    &lt;title searchtype="CHAP-TITLE"&gt; &amp;#x2014; Application of Part I [&lt;emph typestyle="it"&gt;Supreme Court Only&lt;/emph&gt;]&lt;/title&gt;
    &lt;alttitle&gt;Part III &amp;#x2014; The Civil Division &amp;#x2014; Procedures under Special Acts [&lt;emph typestyle="it"&gt;District Court Only&lt;/emph&gt;]&lt;/alttitle&gt;
&lt;/leg:heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
    &lt;desig&gt;Part II&lt;/desig&gt;
    &lt;title&gt; &amp;#x2014; Application of Part I [&lt;emph typestyle="it"&gt;Supreme Court Only&lt;/emph&gt;]&lt;/title&gt;
    &lt;alttitle&gt;Part III &amp;#x2014; The Civil Division &amp;#x2014; Procedures under Special Acts [&lt;emph typestyle="it"&gt;District Court Only&lt;/emph&gt;]&lt;/alttitle&gt;
&lt;/heading&gt;

	</xd:pre>
         <!--Changes2012-09-06: -->
      </xd:desc>
   </xd:doc>
   <xsl:template match="alttitle"><!--  Original Target XPath:  alttitle   -->
      <alttitle>
         <xsl:apply-templates select="@* | node()"/>
      </alttitle>
   </xsl:template>
   <!-- start topichead  blockquote  -->   <!-- <topicref href="../../common_newest/Rosetta_blockquote-LxAdv-blockquote.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Please note that the conversion of <xd:i>blockquote</xd:i> must follow specific rules based on its location in the source document.</xd:b>
                These context sensitive aspects are not all discussed in detail in the general instructions given here. 
                Please see the specific document type instructions for more information regarding the context sensitive conversion details of this element. 
                If there is any contradiction between these general instructions and the document type specific instructions, the specific instructions should be given precedence.
            </xd:p>
         <xd:p>In general, <xd:i>blockquote</xd:i> becomes <xd:b>blockquote</xd:b>.</xd:p>
         <xd:p>If <xd:i>figure</xd:i> or <xd:i>legfragment</xd:i> occur within
                <xd:i>blockquote</xd:i> then drop <xd:i>blockquote</xd:i>
                element.</xd:p>
         <xd:p>
            <xd:b>If <xd:i>insert-line</xd:i> occurs as the only child within <xd:i>blockquote</xd:i> 
                then drop outer <xd:i>blockquote</xd:i> in NewLexis conversion.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
  &lt;p&gt;
	&lt;text&gt;
	  &lt;emph typestyle="it"&gt;Ordinary Resolution&lt;/emph&gt;
	&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;text&gt;
	  &lt;emph typestyle="it"&gt;Approval of new issue of Securities&lt;/emph&gt;
	&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;text&gt;To consider, and if thought fit, pass with or without amendment, the following resolution as an ordinary resolution:&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;blockquote&gt;
	  &lt;p&gt;
		&lt;text&gt;&amp;#x201c;That for the purposes of ASX Listing Rule 7.1 and for all other purposes, the Company approves and agrees to the issue of 35,000,000 ordinary fully paid shares in the capital of the Company to Greater Pacific Gold Limited as consideration for the variation of the Joint Venture Agreement entered into between the Company and Greater Pacific Gold Limited on the terms and conditions set out in the Explanatory Statement accompanying this Notice of Meeting.&amp;#x201d;
		&lt;/text&gt;
	  &lt;/p&gt;
	&lt;/blockquote&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
  &lt;p&gt;
	&lt;text&gt;
	  &lt;emph typestyle="it"&gt;Ordinary Resolution&lt;/emph&gt;
	&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;text&gt;
	  &lt;emph typestyle="it"&gt;Approval of new issue of Securities&lt;/emph&gt;
	&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;text&gt;To consider, and if thought fit, pass with or without amendment, the following resolution as an ordinary resolution:&lt;/text&gt;
  &lt;/p&gt;
  &lt;p&gt;
	&lt;blockquote&gt;
	  &lt;p&gt;
		&lt;text&gt;&amp;#x201c;That for the purposes of ASX Listing Rule 7.1 and for all other purposes, the Company approves and agrees to the issue of 35,000,000 ordinary fully paid shares in the capital of the Company to Greater Pacific Gold Limited as consideration for the variation of the Joint Venture Agreement entered into between the Company and Greater Pacific Gold Limited on the terms and conditions set out in the Explanatory Statement accompanying this Notice of Meeting.&amp;#x201d;
		&lt;/text&gt;
	  &lt;/p&gt;
	&lt;/blockquote&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>If source document having "2" or more <xd:i>blockquote</xd:i> elements in sibling,
            then convert all <xd:i>blockquote</xd:i> into only one
            <xd:b>blockquote</xd:b> element in NL conversion.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
            
            &lt;blockquote&gt;
            &lt;p&gt;&lt;text&gt;[24] Showing the jury what the appellant looked like when wearing the balaclava and overalls that were in evidence (with or without the addition of sunglasses that had not been received in evidence) could not &amp;ldquo;rationally affect (directly or indirectly) the assessment of the probability of the existence of a fact in issue in the proceeding&amp;rdquo;. &lt;fnr fnrtoken="ABCE.ACE.1002.ANT15-R" fntoken="ABCE.ACE.1002.ANT15"&gt;15&lt;/fnr&gt; The central issue at the appellant&amp;rsquo;s trial was whether he was the robber. There was no dispute that there had been a robbery. There was no dispute that the robber had been wearing a balaclava, overalls and sunglasses.&lt;/text&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
            &lt;blockquote&gt;
            &lt;p&gt;&lt;text&gt;[25] No one asserted, however, that the person wearing the disguise of balaclava, overalls and sunglasses could be identified by looking at that person during the robbery or could be identified by looking at the security photographs. None of the witnesses, not even the witness who had seen the robber without the balaclava pulled down over his face, said that they could recognise the man who was thus attired. None of the witnesses, and neither trial counsel, asserted that the person depicted in the security photographs could be identified.&lt;/text&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
            &lt;blockquote&gt;
            &lt;p&gt;&lt;text&gt;[26] Looking at the appellant wearing the balaclava and overalls (with or without sunglasses) enabled a comparison between no more than the items he put on and what was depicted in the security photographs. But that comparison could be drawn without the appellant being asked to put them on. Dressing the appellant in the items provided no information to the jury that could rationally affect, directly or indirectly, the determination of any fact in issue because it revealed nothing about the wearer and nothing about the appellant that was not already apparent to the jury observing him in the dock.&lt;/text&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
        </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
            
            &lt;blockquote&gt;
            &lt;p&gt;&lt;text&gt;&amp;#x005B;24&amp;#x005D; Showing the jury what the appellant looked like when wearing the balaclava and overalls that were in evidence &amp;#x0028;with or without the addition of sunglasses that had not been received in evidence&amp;#x0029; could not &amp;#x201C;rationally affect &amp;#x0028;directly or indirectly&amp;#x0029; the assessment of the probability of the existence of a fact in issue in the proceeding&amp;#x201D;. &lt;footnote/&gt; The central issue at the appellant&amp;#x2019;s trial was whether he was the robber. There was no dispute that there had been a robbery. There was no dispute that the robber had been wearing a balaclava, overalls and sunglasses.&lt;/text&gt;&lt;/p&gt;
            &lt;p&gt;&lt;text&gt;&amp;#x005B;25&amp;#x005D; No one asserted, however, that the person wearing the disguise of balaclava, overalls and sunglasses could be identified by looking at that person during the robbery or could be identified by looking at the security photographs. None of the witnesses, not even the witness who had seen the robber without the balaclava pulled down over his face, said that they could recognise the man who was thus attired. None of the witnesses, and neither trial counsel, asserted that the person depicted in the security photographs could be identified.&lt;/text&gt;&lt;/p&gt;
            &lt;p&gt;&lt;text&gt;&amp;#x005B;26&amp;#x005D; Looking at the appellant wearing the balaclava and overalls &amp;#x0028;with or without sunglasses&amp;#x0029; enabled a comparison between no more than the items he put on and what was depicted in the security photographs. But that comparison could be drawn without the appellant being asked to put them on. Dressing the appellant in the items provided no information to the jury that could rationally affect, directly or indirectly, the determination of any fact in issue because it revealed nothing about the wearer and nothing about the appellant that was not already apparent to the jury observing him in the dock.&lt;/text&gt;&lt;/p&gt;
            &lt;/blockquote&gt;
        </xd:pre>
         <xd:p>
            <xd:b>Source XML where blockquote contains a figure</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
    &lt;figure&gt;
        &lt;glp:note&gt;
            &lt;h&gt;(MAB PROGRAMME STRUCTURE)&lt;/h&gt;
        &lt;/glp:note&gt;
        &lt;inlineobject type="image" attachment="ln-server" filename="pbep-g00121.gif"/&gt;
    &lt;/figure&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML where blockquote contains a figure</xd:b>
         </xd:p>
         <xd:pre>

&lt;figure&gt;
    &lt;note&gt;
        &lt;bodytext&gt;
            &lt;h&gt;(MAB PROGRAMME STRUCTURE)&lt;/h&gt;
        &lt;/bodytext&gt;
    &lt;/note&gt;
    &lt;ref:inlineobject&gt;
        &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
                &lt;ref:key-name name="object-key"/&gt;
                &lt;ref:key-value value="X-Y-pbep-g00121"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
                &lt;proc:param name="componentseq" value="1"/&gt;
                &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
            &lt;/ref:locator-params&gt;
        &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
&lt;/figure&gt;

	</xd:pre>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate
                image handling. Note summarizes move from Apollo to Blobstore application. UK is
                first LBU to move to Blobstore. VSTS 761462013-05-08: Extended the list of allowable values for image handling.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-04-30: Updated target sample according to latest Apollo markup.2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-02-18: Updated target example where blockquote contains a figure. 2013-02-18: Removed CR number LBAM2011121607211100. 2012-10-26: Updated ref:locator markup in Target sample. 2011-09-12: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_blockquote-LxAdv-blockquote.dita  -->
   <!-- JL: refactored :
        1. if legfragment will end up being a child of bodytext if we strip away the paragraph and/or blockquote wrapper, we strip the 
        blockquote wrapper. This leads to an extensive list of potential input parents in the first condition.  PLEASE NOTE: this 
        condition works together with the generic Rosetta_p-LxAdv-p.xsl module.
        
        2. If blockquote has certain other children, such as figure, we remove the blockquote wrapper for those children.
        
        3. If blockquote doesn't meet conditions 1 and 2 above, and if it has adjacent sibling blockquotes that also don't meet the conditions 1 and 2 above, that 
        blockquote and its siblings are merged into one blockquote element.
        
    -->
   <!-- REFACTORED AGAIN!!!!!!
        ANY CONDITION OF COMPLEXITY SHOULD PREVENT MERGE.
        THESE CONDITIONS PREVENT MERGE:
        	    1. legfragment conditions - this is the case where there is no merge and the blockquote wrapper is dropped
        	    2. child bump-ups - this is the case some children become siblings of blockquote and blockquote wrappers
        	    will open and close as necessary until all children  are output properly
        	    3. blockquote is empty - nothing will be output and nothing will be merged
        	    4. blockquote will be wrapped in other elements such as bodytext.
        	    5. any other specific conditions that will make merging difficult or impossible.
        	    
        	    THESE CONDITIONS CAUSE A  MERGE to start:
        	    current blockquote does not have a prevent-merge condition
        	    first preceding sibling is not a blockquote with a merge condition
        	    
        	    THESE CONDITIONS CAUSE A MERGE TO continue on
        	     current blockquote does not have a prevent-merge condition
        	     first following sibling is a blockquote that does not have a prevent-merge condition.
        	     
        	    THESE CONDITIONS CAUSE A MERGE TO stop
        	    current blockquote does not have a prevent-merge condition
        	    first following sibling is not a blockquote with a merge condition.
        	    
        	    IF YOU ADD A NEW CONDITION TO PREVENT MERGE to this template: 
        	    make sure to add an xsl:when with the condition at the annotated place
        	    with the desired non-merged output; also add the condition as an xsl:when to 
        	    the named 'doImeetMergeConditions' template with the value 'false'.
        	    
        	    -->
   <xsl:template match="blockquote">
      <xsl:variable name="currentMergeConditions">
         <xsl:call-template name="doImeetMergeConditions"/>
      </xsl:variable>
      <xsl:variable name="precedingSibMergeConditions">
         <xsl:choose>
            <xsl:when test="not(preceding-sibling::*[1])">false</xsl:when>
            <xsl:otherwise>
               <xsl:for-each select="preceding-sibling::*[1]">
                  <xsl:call-template name="doImeetMergeConditions"/>
               </xsl:for-each>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:variable name="followingingSibMergeConditions">
         <xsl:choose>
            <xsl:when test="not(following-sibling::*[1])">false</xsl:when>
            <xsl:otherwise>
               <xsl:for-each select="following-sibling::*[1]">
                  <xsl:call-template name="doImeetMergeConditions"/>
               </xsl:for-each>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:choose><!-- THIS IS A PREVENT-MERGE CONDITION --><!-- JD: 2017-07-21: added trap for empty node to match DT output. (suppress <blockquote/> from output  -->
         <xsl:when test="not(node())"/>
         <!-- Vikas Rohilla : 2017-08-09 added parent is case:factsummary            -->
         <xsl:when test="legfragment and not(child::*[2]) and (parent::p[parent::*:bodytext or parent::pgrp or parent::li or parent::fnbody or parent::glp:note or parent::case:judgmentbody or parent::case:appendix] or parent::*:bodytext or parent::li or parent::pgrp or parent::fnbody or parent::glp:note or parent::case:judgmentbody or parent::case:appendix or parent::case:factsummary)"><!-- THIS IS A PREVENT-MERGE CONDITION -->
            <xsl:apply-templates/>
         </xsl:when>
         <!--<xsl:when test="ancestor::frm:divs[$streamID='UK12']">
                <xsl:apply-templates select="node()"/>
            </xsl:when>-->
         <xsl:when test="parent::case:decisionsummary and $streamID='UK03'"><!-- THIS IS A PREVENT-MERGE CONDITION -->
            <bodytext>
               <blockquote>
                  <xsl:apply-templates select="node()"/>
               </blockquote>
            </bodytext>
         </xsl:when>
         <xsl:when test="$streamID='AU09' and parent::case:decisionsummary and child::case:embeddedcase/child::case:content"><!-- THIS IS A PREVENT-MERGE CONDITION -->
            <xsl:apply-templates select="@* | node()"/>
         </xsl:when>
         <xsl:when test="figure or (insert-line and not(child::*[2]))                 or (parent::glp:note and descendant::inlineobject[@filename = 'leg1.gif' or @filename = 'leg1.png'])"><!-- THIS IS A PREVENT-MERGE CONDITION --><!-- do not group because it introduces too much complexity. These are your normal bump-ups.
                -->
            <xsl:for-each-group select="*"
                                group-adjacent="if (self::figure or (self::insert-line and not(parent::blockquote/child::*[2]))                     or (parent::blockquote[parent::glp:note] and descendant-or-self::inlineobject[@filename = 'leg1.gif' or @filename = 'leg1.png'])) then                     0                     else                     1">
               <xsl:choose>
                  <xsl:when test="current-grouping-key()=0">
                     <xsl:apply-templates select="current-group()"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <blockquote>
                        <xsl:apply-templates select="current-group()"/>
                     </blockquote>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:for-each-group>
         </xsl:when>
         <!-- IF YOU HAVE ANY OTHER CONDITION REQUIRING SPECIAL HANDLING AND OPTING OUT OF THE MERGE, ADD IT HERE
           AND IN THE  NAMED 'doImeetMergeConditions' TEMPLATE BELOW.  ASSIGN IT THE VALUE 'false' IN THAT NAMED TEMPLATE.-->
         <!-- THE FOLLOWING CONDITION IS A CONDITION THAT ALLOWS MERGE TO START
            IT MUST EXCLUDE ALL PREVENT-MERGE CONDITIONS - this can be done by placing prevent-merge conditions first
            IT MUST SPECIFICALLY INCLUDE ALL START-MERGE CONDITIONS 
            -->
         <xsl:when test="$currentMergeConditions='true' and $precedingSibMergeConditions='false'"><!-- this is a simple blockquote and  can be the start of a group  as long as all the simple blockquotes are consecutive-->
            <blockquote>
               <xsl:apply-templates/>
               <xsl:if test="$followingingSibMergeConditions='true'">
                  <xsl:apply-templates select="following-sibling::*[1][self::blockquote]" mode="next"/>
               </xsl:if>
            </blockquote>
         </xsl:when>
         <xsl:when test="$precedingSibMergeConditions='true' and $currentMergeConditions='true'"><!-- this becomes part of the merge so we don't want to hit it twice --></xsl:when>
         <xsl:otherwise>
            <blockquote>
               <xsl:apply-templates/>
            </blockquote>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="blockquote" mode="next"><!-- we do not need to test for current merge conditions because we have already tested for it in the condition where the template is called  -->
      <xsl:variable name="followingingSibMergeConditions">
         <xsl:choose>
            <xsl:when test="not(following-sibling::*[1])">false</xsl:when>
            <xsl:otherwise>
               <xsl:for-each select="following-sibling::*[1]">
                  <xsl:call-template name="doImeetMergeConditions"/>
               </xsl:for-each>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:variable>
      <xsl:apply-templates/>
      <xsl:if test="$followingingSibMergeConditions='true'">
         <xsl:apply-templates select="following-sibling::*[1][self::blockquote]" mode="next"/>
      </xsl:if>
   </xsl:template>

   <xsl:template name="doImeetMergeConditions"><!-- NOTE IF YOU ADD A NEW CONDITION TO THE NON-MERGE CONDITIONS ABOVE YOU NEED TO ADD IT HERE TOO! -->
      <xsl:choose>
         <xsl:when test="not(self::blockquote)">false</xsl:when>
         <xsl:when test="not(node())">false</xsl:when>
         <xsl:when test="legfragment and not(child::*[2]) and                  (parent::p[parent::*:bodytext or parent::pgrp or parent::li or parent::fnbody or parent::glp:note or parent::case:judgmentbody                  or parent::case:appendix] or parent::*:bodytext or parent::li or parent::pgrp or parent::fnbody or parent::glp:note or                  parent::case:judgmentbody or parent::case:appendix)">false</xsl:when>
         <xsl:when test="parent::case:decisionsummary and $streamID='UK03'">false</xsl:when>
         <xsl:when test="$streamID='AU09' and parent::case:decisionsummary and child::case:embeddedcase/child::case:content">false</xsl:when>
         <xsl:when test="figure or (insert-line and not(child::*[2]))                 or (parent::glp:note and descendant::inlineobject[@filename = 'leg1.gif' or @filename = 'leg1.png'])">false</xsl:when>
         <xsl:otherwise>true</xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--<topicref href="../../common_newest/Rosetta_Commentary_blockquote-LxAdv-blockquote.dita"/>-->   <!-- <topicref href="../../common_newest/Rosetta_pnum-Chof-blockquote-to-LexisAdvance_desig_inline_true.dita"/> -->   <xd:doc><!-- MDS 2017-05-15 - This module is not required since the handling is already in place in the Rosetta_pnum-LxAdv-desig.xsl module --><!--  This module does NOT apply to the following CIs   
            AU_NZ-Legis_Index_Landing_Pages
            AU-Citator
            AU-Journal_Citators
            AU-Bill_Tracking 
    --><!--  This module MAY  apply to these CI's please check with LBU to determine if this module should be in your CI
            AU/NZ Legislation Citators 	
            AU/NZ Legal Topic Summaries 
    -->
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>When the element <xd:i>pnum</xd:i> occurs within the
                structure <xd:i>blockquote/p/pnum</xd:i> convert by adding the attribute
                    <xd:b>@inline=true</xd:b> on the element
                    <xd:b>desig</xd:b> for all  occurrences  of
                    <xd:b>blockquote/p/desig</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
  &lt;p&gt;
	&lt;pnum count="39"&gt;[39]&lt;/pnum&gt;
	&lt;text&gt;
	 The case law reveals that there is a preferred approach to the determination of an application 
	 brough pursuant to the provisions of s 79. That approach involves four interrelated steps. Firstly,
	 the court should make findings as to the identity and value of the property, liabilities and financial resources
	 of the parties at the date of the hearing. 
	&lt;/text&gt;
  &lt;/p&gt;
&lt;/blockquote&gt;
  
  </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
  &lt;p&gt;
  &lt;desig value="39" inline="true"&gt;[39]&lt;/desig&gt;
	&lt;text&gt;
	 The case law reveals that there is a preferred approach to the determination of an application 
	 brough pursuant to the provisions of s 79. That approach involves four interrelated steps. Firstly,
	 the court should make findings as to the identity and value of the property, liabilities and financial resources
	 of the parties at the date of the hearing. 
	&lt;/text&gt;
  &lt;/p&gt;
   &lt;/blockquote&gt;      
   
</xd:pre>
         <!--Changes2012-09-11: Created.-->
      </xd:desc>
   </xd:doc>
   <!-- BRT: this rule seems unnecessary - it is already covered by the more generic rule in Rosetta_pnum-LxAdv-desig: 
                    create @inline='true' when no attribute value is present. The fact that the context is blockquote/p/pnum seems irrelevant to the conversion.-->
   <!-- <topicref href="../../common_newest/Rosetta_blockquote-link-LxAdv-blockquote-p-text-ref.lnlink.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a shared
                topic rather than duplicated to ensure consistency and accuracy. The xml snippets contained
                in this topic reflect markup needed for the Apollo image handling application. The UK is the
                first LBU to move from Apollo to the Blobstore application for image handling. Therefore, if
                this is a UK conversion instruction document, please refer to the following topics for
                correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
                        (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to <xd:b>ref:inlineobject</xd:b> for
                        BLOBSTORE images (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
                        (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p> If <xd:i>link</xd:i> element occurs as a child of
                <xd:i>blockquote</xd:i> then conversion need to move
                <xd:b>ref:lnlink</xd:b> as child of <xd:b>p/text</xd:b>,
                i.e, <xd:i>blockquote/link</xd:i> becomes
                <xd:b>blockquote/p/text/ref:lnlink</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Source XML : if element link is a child of blockquote</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
    &lt;h&gt;Notice to mortgagor of mortgaged land of exercise of powers by reason of default&lt;/h&gt;
    &lt;link filename="ada-09-lta52-plr-form.pdf" type="pdf"&gt;Download in PDF&lt;/link&gt;
&lt;/blockquote&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML : if element link is a child of blockquote</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
    &lt;h&gt;Notice to mortgagor of mortgaged land of exercise of powers by reason of default&lt;/h&gt;
    &lt;p&gt;
        &lt;text&gt;
            &lt;ref:lnlink service="ATTACHMENT"&gt;
                &lt;ref:marker role="label"&gt;Download in PDF&lt;/ref:marker&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="attachment-key"/&gt;
                        &lt;ref:key-value value="X-Y-ada-09-lta52-plr-form"/&gt;
                        &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="attachment-type" value="PDF"/&gt;
                        &lt;proc:param name="attachment-smi" value=""/&gt;
                        &lt;!-- @value populated with SMI obtained from CSSM --&gt;
                        &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:lnlink&gt;
        &lt;/text&gt;
    &lt;/p&gt; 
&lt;/blockquote&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>For handling of link to ref:lnlink, refer the general markup 
            <xd:a href="../common_newest/Rosetta_link-LxAdv-ref.lnlink.dita">ref:lnlink</xd:a> section in the CI.</xd:p>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate image
                handling. Note summarizes move from Apollo to Blobstore application. UK is first LBU to
                move to Blobstore.2013-05-01: Updated instructions and target example per latest Apollo markup.2013-02-26: Updated target example per project requirement.2012-10-26: Updated ref:locator markup in Target sample. -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_blockquote-link-LxAdv-blockquote-p-text-ref.lnlink.dita  -->
   <!-- Vikas Rohilla : Template to match the blockquote/link-->
   <xsl:template match="blockquote/link">
      <p>
         <text>
            <xsl:apply-templates select="@* | node()"/>
         </text>
      </p>
   </xsl:template>
   <!-- end topichead  blockquote  -->   <!-- start topichead  bodytext  -->   <!-- <topicref href="../../common_newest/Rosetta_bodytext-LxAdv-bodytext.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>bodytext</xd:i> becomes <xd:b>bodytext</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>@searchtype</xd:i> attribute should be suppressed.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext&gt; &lt;p&gt;&lt;text&gt;This is a judgment of some significance for daily conveyancing practice.&lt;/text&gt;&lt;/p&gt; &lt;/bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext&gt; &lt;p&gt;&lt;text&gt;This is a judgment of some significance for daily conveyancing practice.&lt;/text&gt;&lt;/p&gt; &lt;bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext searchtype="COMMENTARY"&gt; &lt;p&gt;&lt;text&gt;Final recommendation 5. Interim recommendations pp 19 and 22.&lt;/text&gt;&lt;/p&gt; &lt;/bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext&gt; &lt;p&gt;&lt;text&gt;Final recommendation 5. Interim recommendations pp 19 and 22.&lt;/text&gt;&lt;/p&gt; &lt;bodytext&gt; </xd:pre>
         <!--Changes2012-09-06: -->
      </xd:desc>
   </xd:doc>
   <!--Vikas Rohilla : Updated the template for the streamID CA02DC  -->
   <xsl:template match="bodytext">
      <xsl:choose><!-- JL: added the junk characters to get rid of bodytext elements in AU/NZ when there are nbsp and the junk character in them -->
         <xsl:when test="parent::leg:comntry and not(child::*[not(self::p[not(child::*[not(self::text[normalize-space(string-join(., '')) = ('', '', '')])])] or self::hrule)])"/>
         <!-- BRT 11/29/17  WS7053986 suppress this context for UK15cs -->
         <xsl:when test="references and name(preceding-sibling::*[1]) = 'level' and $streamID = 'UK15'"/>
         <xsl:when test="child::glp:note and parent::dig:body and $streamID = 'CA02DC'">
            <xsl:apply-templates select="node() | @*"/>
         </xsl:when>
         <xsl:when test="child::case:embeddedcase and $streamID = 'CA02DS'">
            <xsl:apply-templates select="node() | @*"/>
         </xsl:when>
         <xsl:when test="@searchtype = 'COMMENTARY' and $streamID = ('AU08') and parent::level/@leveltype = 'group'">
            <bodytext>
               <xsl:apply-templates select="@* | node()"/>
            </bodytext>
         </xsl:when>
         <xsl:when test="@searchtype = 'COMMENTARY' and $streamID = ('AU08') and parent::level">
            <bodytext><!-- use case AU08 PS2017050402162840900LNIAUCOURTRULES_input_fcr10081327.xml for bodytext
										PS2017042901112352335LNIAUCOURTRULES_input_voff10081099.xml for glp:note as preceding sibling
										-->
               <xsl:apply-templates select="preceding-sibling::glp:note"/>
               <xsl:apply-templates select="@* | node()"/>
            </bodytext>
         </xsl:when>
         <xsl:when test="parent::entry">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:when>
         <!-- Added instruction for UK15 by Priya Kaushal -->
         <xsl:when test="$streamID = 'UK15'">
            <xsl:if test="not(./child::references[1]) or ./child::references[1]/preceding-sibling::node()">
               <seclaw:bodytext>
                  <xsl:apply-templates select="@* | node()"/>
                  <xsl:for-each select="following-sibling::level">
                     <xsl:call-template name="bodytext-following-level"/>
                  </xsl:for-each>
                  <xsl:for-each select="following-sibling::bodytext/references">
                     <xsl:call-template name="bodytext-references"/>
                  </xsl:for-each>
               </seclaw:bodytext>
            </xsl:if>
            <!--<xsl:choose>
					<xsl:when test="not(./references)">
						<seclaw:bodytext>
							<xsl:apply-templates select="@* | node()"/>
							<xsl:for-each select="following-sibling::level">
								<xsl:call-template name="bodytext-following-level"/>
							</xsl:for-each>
							<xsl:for-each select="following-sibling::bodytext/references">
								
								<xsl:call-template name="bodytext-references"/>
							</xsl:for-each>
						</seclaw:bodytext>
					</xsl:when>
					<xsl:otherwise>
						
						
							<!-\-<xsl:for-each select="following-sibling::level">
								<xsl:call-template name="bodytext-following-level"/>
							</xsl:for-each>-\->
							
						
					</xsl:otherwise>
				</xsl:choose>-->
         </xsl:when>
         <!--Ravikant: 2018-03-09: added the when condition for the stream ID MY02 -->
         <xsl:when test="$streamID ='MY02'">
            <xsl:apply-templates select="node()"/>
         </xsl:when>
         <xsl:when test="$streamID='UK09'">
            <xsl:choose>
               <xsl:when test="footnotegrp/footnote">
                  <bodytext>
                     <xsl:apply-templates select="preceding-sibling::glp:note[parent::level]"/>
                     <xsl:apply-templates select="@* | node()"/>
                  </bodytext>
               </xsl:when>
               <xsl:otherwise>
                  <bodytext>
                     <xsl:apply-templates select="preceding-sibling::glp:note[parent::level]"/>
                     <xsl:apply-templates select="@* | node() except(footnotegrp)"/>
                  </bodytext>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise>
            <bodytext>
               <xsl:apply-templates select="preceding-sibling::glp:note[parent::level]"/>
               <xsl:apply-templates select="@* | node()"/>
            </bodytext>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="bodytext[ancestor::leg:comntry and (not(parent::level/@leveltype) and not(parent::level/parent::leg:comntry))][$streamID = ('UK06', 'UK07')]">
      <annot:bodytext>
         <xsl:apply-templates select="@* | node()"/>
      </annot:bodytext>
   </xsl:template>
   <!-- Added template for UK15 by Priya kaushal -->
   <xsl:template name="bodytext-following-level">
      <xsl:choose>
         <xsl:when test="child::heading/title/refpt">
            <seclaw:level>
               <xsl:attribute name="leveltype">
                  <xsl:value-of select="@leveltype"/>
               </xsl:attribute>
               <!--<xsl:apply-templates select="child::heading/title/refpt"/>-->
               <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
            </seclaw:level>
         </xsl:when>
         <xsl:when test="child::heading/title and (./child::heading/following-sibling::node())">
            <seclaw:level>
               <xsl:attribute name="leveltype">
                  <xsl:value-of select="@leveltype"/>
               </xsl:attribute>
               <!--<xsl:apply-templates select="child::heading/title"/>-->
               <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
            </seclaw:level>
         </xsl:when>
         <xsl:when test="child::heading/title and not(./child::heading/following-sibling::node())">
            <seclaw:level>
               <xsl:attribute name="leveltype">
                  <xsl:value-of select="@leveltype"/>
               </xsl:attribute>
               <!--<xsl:apply-templates select="child::heading/title"/>-->
               <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
               <seclaw:bodytext/>
            </seclaw:level>
         </xsl:when>
      </xsl:choose>
   </xsl:template>
   <!-- Added template for UK15 by Priya kaushal -->
   <xsl:template name="bodytext-references">
      <ref:relatedrefs>
         <xsl:apply-templates select="@* | node()"/>
      </ref:relatedrefs>
   </xsl:template>
   <!--***********
		
		BRT 11/26/17 the following template causes an ambiguity error with a more generic template - template match="level[1][parent::level]" 
	WS7051206. This template prevents duplicate seclaw:bodytext entries -->
   <xsl:template match="level[preceding-sibling::bodytext[not(./child::references[1]) or ./child::references[1]/preceding-sibling::node()]][$streamID = 'UK15']"/>

   <xsl:template match="bodytext/@searchtype"/>
   <!--<topicref href="../../common_newest/Rosetta_Commentary_bodytext-LxAdv-bodytext_note.dita"/>-->   <!-- end topichead  bodytext  -->   <!-- rosetta element: char-line -->   <!-- <topicref href="../../common_newest/Rosetta_char-line-LxAdv-proc.formchars.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>
               <xd:i>char-line</xd:i> becomes <xd:b>proc:formchars</xd:b> and
                    includes the attributes <xd:b>@formchar</xd:b> and
                        <xd:b>@formcharuse</xd:b>. Attributes
                        <xd:b>@formchar</xd:b> and <xd:b>@formcharuse</xd:b> are
                    required attributes in <xd:b>proc:formchars</xd:b> and the values for
                    these attributes are tokenized in the NewLexis Schema.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Attribute <xd:b>@formchar</xd:b> allows the tokenized values listed
                    below:</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="dot"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="dbl-rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="hypen"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>Below are the values for <xd:b>proc:formchars[@formchar]</xd:b> found
                    in the source documents and the corresponding mapping in NewLexis.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>char-line[@character="."]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="dot"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@character="_"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@character="-"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="hypen"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@character=" "]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@character="&amp;nbsp;"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Attribute <xd:b>@formcharuse</xd:b> values are listed below:</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="date"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="month"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="year"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="num"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="money"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="address"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="name"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="longname"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="leaderfill"]</xd:b>
                  <xd:b>@formcharuse="leaderfill"</xd:b> means fill the available
                        space with the formchar. Basically, push the text on each side out to the
                        margins if possible.</xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="other"]</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>The following are the widths (in points) used for this element in print for each
                    possible value of <xd:b>@formcharuse</xd:b>. To determine the number
                    of characters, divide the point value by 6.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="date"] 66 -&gt;11</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="day"] 36 -&gt;6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="month"] 48 -&gt; 8</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="year"] 36 -&gt; 6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="num"] 36 -&gt; 6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="money"] 42 -&gt; 7</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="address"] 72 -&gt; 12</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="name"] 66 -&gt; 11</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="longname"] 132 -&gt;
                        22</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="other"] 66 -&gt; 11</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>Below are the values for <xd:b>proc:formchars[@formcharuse]</xd:b>
                    found in the source documents and the corresponding mapping in NewLexis.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>char-line[@num-char="2"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@num-char="4"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@num-char="8"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="month"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@num-char="12"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="address"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>char-line[@num-char="16"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="longname"]</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>A CR is required to add attribute @align within
                    <xd:b>proc:formchars</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;blockquote&gt;
        &lt;char-line character="_" num-char="15" align="center"/&gt;
    &lt;/blockquote&gt;
&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;blockquote&gt;
        &lt;proc:formchars formchar="rule" formcharuse="longname" align="center"/&gt;
    &lt;/blockquote&gt;
&lt;/p&gt;

		</xd:pre>
         <!--Changes2013-02-08: Corrected the last mapping of char-line[@character="
                    "] to proc:formchars[@formchar="invisible"]
                so that the source element properly displays as
                    char-line[@character="&nbsp;"].2012-09-11: Removed CR number
                (LBAM2011121605552800).2011-09-11: Created.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_char-line-LxAdv-proc.formchars.dita  -->
   <!-- Vikas Rohilla : Template to match the char-line and create the proc:formchars	-->
   <xsl:template match="char-line">
      <xsl:choose>
         <xsl:when test="$streamID='AU01' and parent::case:judgmentbody">
            <p>
               <text>
                  <proc:formchars>
                     <xsl:attribute name="formchar">
                        <xsl:choose>
                           <xsl:when test="@character='_'">
                              <xsl:text>rule</xsl:text>
                           </xsl:when>
                           <xsl:when test="@character='.'">
                              <xsl:text>dot</xsl:text>
                           </xsl:when>
                           <xsl:when test="@character='-'">
                              <xsl:text>hypen</xsl:text>
                           </xsl:when>
                           <xsl:when test="@character=' '">
                              <xsl:text>invisible</xsl:text>
                           </xsl:when>
                           <xsl:when test="@character='&amp;nbsp;'">
                              <xsl:text>invisible</xsl:text>
                           </xsl:when>
                        </xsl:choose>
                     </xsl:attribute>
                     <xsl:attribute name="formcharuse">
                        <xsl:choose>
                           <xsl:when test="@num-char='2'">
                              <xsl:text>day</xsl:text>
                           </xsl:when>
                           <xsl:when test="@num-char='4'">
                              <xsl:text>day</xsl:text>
                           </xsl:when>
                           <xsl:when test="@num-char='8'">
                              <xsl:text>month</xsl:text>
                           </xsl:when>
                           <xsl:when test="@num-char='12'">
                              <xsl:text>address</xsl:text>
                           </xsl:when>
                           <xsl:when test="@num-char='16'">
                              <xsl:text>longname</xsl:text>
                           </xsl:when>
                           <!-- Awantika: 2017-10-31- Added @num-char='32' to formcharuse="other" coming in AU01 -->
                           <xsl:when test="@num-char='32'">
                              <xsl:text>other</xsl:text>
                           </xsl:when>
                        </xsl:choose>
                     </xsl:attribute>
                     <xsl:if test="@align[not($streamID='AU01')]">
                        <xsl:copy-of select="@align"/>
                     </xsl:if>
                  </proc:formchars>
               </text>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <proc:formchars>
               <xsl:attribute name="formchar">
                  <xsl:choose>
                     <xsl:when test="@character='_'">
                        <xsl:text>rule</xsl:text>
                     </xsl:when>
                     <xsl:when test="@character='.'">
                        <xsl:text>dot</xsl:text>
                     </xsl:when>
                     <xsl:when test="@character='-'">
                        <xsl:text>hypen</xsl:text>
                     </xsl:when>
                     <xsl:when test="@character=' '">
                        <xsl:text>invisible</xsl:text>
                     </xsl:when>
                     <xsl:when test="@character='&amp;nbsp;'">
                        <xsl:text>invisible</xsl:text>
                     </xsl:when>
                  </xsl:choose>
               </xsl:attribute>
               <xsl:attribute name="formcharuse">
                  <xsl:choose>
                     <xsl:when test="@num-char='2'">
                        <xsl:text>day</xsl:text>
                     </xsl:when>
                     <xsl:when test="@num-char='4'">
                        <xsl:text>day</xsl:text>
                     </xsl:when>
                     <xsl:when test="@num-char='8'">
                        <xsl:text>month</xsl:text>
                     </xsl:when>
                     <xsl:when test="@num-char='12'">
                        <xsl:text>address</xsl:text>
                     </xsl:when>
                     <xsl:when test="@num-char='16'">
                        <xsl:text>longname</xsl:text>
                     </xsl:when>
                  </xsl:choose>
               </xsl:attribute>
               <xsl:if test="@align">
                  <xsl:copy-of select="@align"/>
               </xsl:if>
            </proc:formchars>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- rosetta element: ci.cite -->   <!-- <topicref href="../../common_newest/Rosetta_ci.cite-LxAdv-lnci.cite.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>In the Fab Pipeline, JCite/CFE shall conduct a lookup based on the lnci:content
					or the @normcite (if populated) and populate the markup with the additional
					keywords needed for cite traversal. </xd:p>
         <xd:p>The only markup needed for JCite/CFE is
						<xd:b>lnci:cite/lnci:content</xd:b> and optionally
						<xd:b>lnci:cite/@normcite</xd:b>. In order to resolve the correct
					pile target for cite link traversal, either a semantic child content type
					element as described below <xd:b>or</xd:b> the <xd:b>lnci:cite/@type</xd:b>
					attribute (but not both) must also be present in the output markup.</xd:p>
         <xd:p>
            <xd:i>ci:cite</xd:i> becomes <xd:b>lnci:cite</xd:b>, with all
					attribute names and values copied as they occur in the source. Convert all
					descendant elements of <xd:i>ci:cite</xd:i> by copying the elements
					and their attribute names and values from the <xd:i>ci:</xd:i>
					namespace <xd:b>as is</xd:b> into the <xd:b>lnci:</xd:b> namespace. That is,
					every descendant of <xd:i>ci:cite</xd:i> that has the form
						<xd:i>ci:{element-name}</xd:i> is converted to
						<xd:b>lnci:{element-name}</xd:b>. As an example of converting the
					descendants of <xd:i>ci:cite</xd:i> into the
						<xd:b>lnci:</xd:b> namespace, here is a partial list of the child
					elements from Rosetta and what they should be converted to: <xd:ul>
               <xd:li>
                  <xd:i>ci:casename</xd:i> becomes
								<xd:b>lnci:casename</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:constref</xd:i> becomes
								<xd:b>lnci:constref</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:courtruleref</xd:i> becomes
								<xd:b>lnci:courtruleref</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:decisionref</xd:i> becomes
								<xd:b>lnci:decisionref</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:effdate</xd:i> becomes
								<xd:b>lnci:effdate</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:party1</xd:i> becomes
								<xd:b>lnci:party1</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:party2</xd:i> becomes
								<xd:b>lnci:party2</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:procphrase</xd:i> becomes
								<xd:b>lnci:procphrase</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:reglref</xd:i> becomes
								<xd:b>lnci:reglref</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:statinfo</xd:i> becomes
								<xd:b>lnci:statinfo</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:text</xd:i> becomes <xd:b>lnci:text</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>There are two important exceptions to the converstion instructions given in the
					preceding paragraph: <xd:ul>
               <xd:li>Do not convert any Rosetta-only markup that, if kept, would make the
							output invalid. </xd:li>
               <xd:li>Drop the start and end tags (the mark-up) for
								<xd:i>citefragment</xd:i> and
								<xd:i>ci:span</xd:i> but keep the content of these
							elements as part of what is converted to the content of
								<xd:b>lnci:content</xd:b>.</xd:li>
               <xd:li> Drop all instances of
							<xd:i>ci:{element-name}/@spanref</xd:i>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>The following are mappings for children of <xd:i>ci:cite</xd:i>: <xd:ul>
               <xd:li>
                  <xd:i>ci:case</xd:i> becomes
							<xd:b>lnci:case</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:stat</xd:i> becomes
							<xd:b>lnci:stat</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:juryinstr</xd:i> becomes
								<xd:b>lnci:juryinstr</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:reg</xd:i> becomes
							<xd:b>lnci:reg</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:courtrule</xd:i> becomes
								<xd:b>lnci:courtrule</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:sesslaw</xd:i> becomes
								<xd:b>lnci:sesslaw</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:patent</xd:i> becomes
								<xd:b>lnci:patent</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:tmark</xd:i> becomes
								<xd:b>lnci:tmark</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:copyright</xd:i> becomes
								<xd:b>lnci:copyright</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:lawrev</xd:i> becomes
								<xd:b>lnci:lawrev</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:periodical</xd:i> becomes
								<xd:b>lnci:periodical</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:pinpoint</xd:i> becomes
								<xd:b>lnci:pinpoint</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:book</xd:i> becomes
							<xd:b>lnci:book</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:oag</xd:i> becomes
							<xd:b>lnci:oag</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:agencydecision</xd:i> becomes
								<xd:b>lnci:agencydecision</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:constitution</xd:i> becomes
								<xd:b>lnci:constitution</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:annot</xd:i> becomes
								<xd:b>lnci:annot</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:execdoc</xd:i> becomes
								<xd:b>lnci:execdoc</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:admininterp</xd:i> becomes
								<xd:b>lnci:admininterp</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:misc</xd:i> becomes
							<xd:b>lnci:misc</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:form</xd:i> becomes
							<xd:b>lnci:form</xd:b>
               </xd:li>
            </xd:ul>Given one of the above mappings, the source
						<xd:i>ci:cite/@searchtype</xd:i> should be dropped and the target
						<xd:b>lnci:cite/@type</xd:b> should be <xd:b>omitted</xd:b>.</xd:p>
         <xd:p>In the absence of one of the possible children of <xd:i>ci:cite</xd:i>
					listed above, <xd:b>lnci:cite/@type</xd:b> should be populated as
					follows: <xd:ul>
               <xd:li>
                  <xd:i>ci:cite/@searchtype="LEG-REF"</xd:i> becomes
								<xd:b>lnci:cite/@type="legislation"</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:cite/@searchtype="CASE-REF"</xd:i> becomes
								<xd:b>lnci:cite/@type="case"</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:cite/@searchtype="BOOK-REF"</xd:i> becomes
								<xd:b>lnci:cite/@type="book"</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:cite/@searchtype="BODY-CASE-REF"</xd:i> becomes
								<xd:b>lnci:cite/@type="case"</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>ci:cite/@searchtype="SUMM-CASE-REF"</xd:i> becomes
								<xd:b>lnci:cite/@type="case"</xd:b>
               </xd:li>
            </xd:ul>This will ensure that the correct context clue (Product Content Type or
					PCT) is populated in the Fab Pipeline so that the resulting citation hyperlink
					targets the correct pile. </xd:p>
         <xd:p>
            <xd:b>Handling for AU Journals/Newsitem:</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>ci:cite</xd:i> with attribute
								<xd:i>@type="cite4thisdoc"</xd:i> becomes
								<xd:b>lnci:cite</xd:b> with attribute
								<xd:b>@type="cite4thisdoc"</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Handling for NZ Regulation and NZ Act from services:</xd:b>
            <xd:ul>
               <xd:li>If <xd:i>ci:cite@type</xd:i> comes with attribute value
									"<xd:b>
                     <xd:i>legref</xd:i>
                  </xd:b>" in source document then conversion needs
							to suppressed attribute value in target and convert
								<xd:i>ci:cite</xd:i> according to general rule. </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML: ci:cite/searchtype="CASE-REF"</xd:b>
         </xd:p>
         <xd:pre> &lt;ci:cite searchtype="CASE-REF"&gt; &lt;ci:case&gt;
					&lt;ci:caseinfo&gt; &lt;ci:decisiondate year="2001"/&gt; &lt;/ci:caseinfo&gt;
					&lt;ci:caseref ID="cr000366" spanref="cr000366-001" status="unval"&gt;
					&lt;ci:reporter value="NSWCCR"/&gt; &lt;ci:volume num="22"/&gt; &lt;ci:page
					num="238"/&gt; &lt;/ci:caseref&gt; &lt;/ci:case&gt; &lt;ci:content&gt;
					&lt;citefragment searchtype="CASE-NAME-REF"&gt; &lt;emph typestyle="it"&gt;Betts
					v Prisk Contractors Pty Ltd&lt;/emph&gt; &lt;/citefragment&gt; &lt;citefragment
					searchtype="CASE-CITE-REF"&gt; &lt;ci:span spanid="cr000366-001"
					status="unval"&gt;(2001) 22 NSWCCR 238&lt;/ci:span&gt;; [2001] NSWCC 146
					&lt;/citefragment&gt; &lt;/ci:content&gt; &lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;lnci:cite&gt; &lt;lnci:case&gt; &lt;lnci:caseinfo&gt;
					&lt;lnci:decisiondate year="2001"/&gt; &lt;/lnci:caseinfo&gt; &lt;lnci:caseref
					ID="cr000366" status="unval"&gt; &lt;lnci:reporter value="NSWCCR"/&gt;
					&lt;lnci:volume num="22"/&gt; &lt;lnci:page num="238"/&gt; &lt;/lnci:caseref&gt;
					&lt;/lnci:case&gt; &lt;lnci:content&gt; &lt;emph typestyle="it"&gt;Betts v Prisk
					Contractors Pty Ltd&lt;/emph&gt; (2001) 22 NSWCCR 238; [2001] NSWCC 146
					&lt;/lnci:content&gt; &lt;/lnci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>SOURCE XML: ci:cite/searchtype="BOOK-REF"</xd:b>
         </xd:p>
         <xd:pre> &lt;ci:cite searchtype="BOOK-REF"&gt; &lt;ci:lawrev&gt; &lt;ci:lawrevref
					ID="cr003268" spanref="cr003268-001"&gt; &lt;ci:lawrevlocator&gt;
					&lt;ci:publicationname normpubcode="BCB"/&gt; &lt;ci:volume num="3"/&gt;
					&lt;ci:issue&gt; &lt;ci:date year="1985"/&gt; &lt;/ci:issue&gt; &lt;ci:page
					num="86"/&gt; &lt;/ci:lawrevlocator&gt; &lt;/ci:lawrevref&gt; &lt;/ci:lawrev&gt;
					&lt;ci:content&gt; &lt;citefragment searchtype="BOOK-CITE-REF"&gt; &lt;ci:span
					spanid="cr003268-001"&gt;(1985) 3 BCB 86&lt;/ci:span&gt; &lt;/citefragment&gt;
					&lt;/ci:content&gt; &lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;lnci:cite&gt; &lt;lnci:lawrev&gt; &lt;lnci:lawrevref
					ID="cr003268"&gt; &lt;lnci:lawrevlocator&gt; &lt;lnci:publicationname
					normpubcode="BCB"/&gt; &lt;lnci:volume num="3"/&gt; &lt;lnci:issue&gt;
					&lt;lnci:date year="1985"/&gt; &lt;/lnci:issue&gt; &lt;lnci:page num="86"/&gt;
					&lt;/lnci:lawrevlocator&gt; &lt;/lnci:lawrevref&gt; &lt;/lnci:lawrev&gt;
					&lt;lnci:content&gt;(1985) 3 BCB 86&lt;/lnci:content&gt; &lt;/lnci:cite&gt;
				</xd:pre>
         <xd:p>
            <xd:b>SOURCE XML: ci:cite/searchtype="SUMM-CASE-REF"</xd:b>
         </xd:p>
         <xd:pre> &lt;ci:cite searchtype="SUMM-CASE-REF"&gt; &lt;ci:case&gt;
					&lt;ci:caseref ID="cref00000048" spanref="cspan00000048"&gt; &lt;ci:reporter
					value="FCR"/&gt; &lt;ci:volume num="1"/&gt; &lt;ci:edition&gt;&lt;ci:date
					year="1985"/&gt;&lt;/ci:edition&gt; &lt;ci:page num="856"/&gt;
					&lt;/ci:caseref&gt; &lt;/ci:case&gt; &lt;ci:content&gt;&lt;ci:span
					spanid="cspan00000048"&gt;[1985] 1 F.C. 856&lt;/ci:span&gt;&lt;/ci:content&gt;
					&lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;lnci:cite&gt; &lt;lnci:case&gt; &lt;lnci:caseref
					ID="cref00000048"&gt; &lt;lnci:reporter value="FCR"/&gt; &lt;lnci:volume
					num="1"/&gt; &lt;lnci:edition&gt;&lt;lnci:date
					year="1985"/&gt;&lt;/lnci:edition&gt; &lt;lnci:page num="856"/&gt;
					&lt;/lnci:caseref&gt; &lt;/lnci:case&gt; &lt;lnci:content&gt;[1985] 1 F.C.
					856&lt;/lnci:content&gt; &lt;/lnci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>SOURCE XML: ci:cite/searchtype="BODY-CASE-REF"</xd:b>
         </xd:p>
         <xd:pre> &lt;ci:cite searchtype="BODY-CASE-REF"&gt; &lt;ci:case&gt;
					&lt;ci:caseref ID="cref00000047" spanref="cspan00000047"&gt; &lt;ci:reporter
					value="OEAB"/&gt; &lt;ci:edition&gt;&lt;ci:date
					year="1993"/&gt;&lt;/ci:edition&gt; &lt;ci:refnum num="55"/&gt;
					&lt;/ci:caseref&gt; &lt;/ci:case&gt; &lt;ci:content&gt;&lt;ci:span
					spanid="cspan00000047"&gt;[1993] O.E.A.B. No. 55&lt;/ci:span&gt;
					&lt;/ci:content&gt; &lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;lnci:cite&gt; &lt;lnci:case&gt; &lt;lnci:caseref
					ID="cref00000047"&gt; &lt;lnci:reporter value="OEAB"/&gt;
					&lt;lnci:edition&gt;&lt;lnci:date year="1993"/&gt;&lt;/lnci:edition&gt;
					&lt;lnci:refnum num="55"/&gt; &lt;/lnci:caseref&gt; &lt;/lnci:case&gt;
					&lt;lnci:content&gt;[1993] O.E.A.B. No. 55&lt;/lnci:content&gt;
					&lt;/lnci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML: ci:pinpoint</xd:b>
         </xd:p>
         <xd:pre> &lt;ci:cite ID="I5DDT1GS2SF8P90080000400" normprotocol="lexsee"
					status="valid"&gt; &lt;ci:agencydecision&gt; &lt;ci:decisionref
					ID="I5DDT1GS2SF8P90070000400"&gt; &lt;ci:reporter normpubcode="4007"
					value=""/&gt; &lt;ci:ldi jumppage="1" kw="8197_1999_805*.1" page="805"
					pagesuffix="*" reporter="8197" volume="1999"/&gt; &lt;ci:volume num="1999"/&gt;
					&lt;ci:page num="805"/&gt; &lt;ci:pinpoint lastnum="2" num="1"/&gt;
					&lt;/ci:decisionref&gt; &lt;/ci:agencydecision&gt; &lt;ci:content&gt;1999 SEC
					No-Act. LEXIS 805, 1-2&lt;/ci:content&gt; &lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML: lnci:pinpoint</xd:b>
         </xd:p>
         <xd:pre> &lt;lnci:cite ID="I5DDT1GS2SF8P90080000400" normprotocol="lexsee"
					status="valid"&gt; &lt;lnci:agencydecision&gt; &lt;lnci:decisionref
					ID="I5DDT1GS2SF8P90070000400"&gt; &lt;lnci:reporter normpubcode="4007"
					value=""/&gt; &lt;lnci:ldi jumppage="1" kw="8197_1999_805*.1" page="805"
					pagesuffix="*" reporter="8197" volume="1999"/&gt; &lt;lnci:volume
					num="1999"/&gt; &lt;lnci:page num="805"/&gt; &lt;lnci:pinpoint lastnum="2"
					num="1"/&gt; &lt;/lnci:decisionref&gt; &lt;/lnci:agencydecision&gt;
					&lt;lnci:content&gt;1999 SEC No-Act. LEXIS 805, 1-2&lt;/lnci:content&gt;
					&lt;/lnci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Exception: When <xd:i>link</xd:i> is used as intra-document linking
					within <xd:i>ci:content</xd:i>
            </xd:b>.</xd:p>
         <xd:p>If the <xd:i>ci:content</xd:i> contains a <xd:i>link</xd:i>
				child, the <xd:i>link</xd:i> wrapper markup (not its content) shall be
				removed (omit tag and retain content) and the <xd:i>link/@refpt</xd:i>
				value shall be moved to <xd:b>lnci:cite/@citeref</xd:b>.</xd:p>
         <xd:p>
            <xd:b>SOURCE XML: ci:content/link</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;pnum count="5"&gt;[5]&lt;/pnum&gt; &lt;refpt
					id="20023NZLR_113_p5" type="ext" /&gt; &lt;text&gt;A number of issues were
					raised on Bs behalf but may be summarised as follows:&lt;/text&gt; ...
					&lt;/p&gt;  &lt;ci:cite searchtype="CASE-REF"&gt; &lt;ci:case&gt;
					&lt;ci:caseref ID="x20023NZLR_113-171" spanref="x20023NZLR_113-171-1"&gt;
					&lt;ci:reporter value="nzar" country="nz" /&gt; &lt;ci:edition&gt; &lt;ci:date
					year="2001" /&gt; &lt;/ci:edition&gt; &lt;ci:page num="598" /&gt;
					&lt;/ci:caseref&gt; &lt;/ci:case&gt; &lt;ci:content&gt; &lt;citefragment
					searchtype="CASE-NAME-REF"&gt; &lt;emph typestyle="it"&gt;Auckland District Law
					Society v Ford&lt;/emph&gt; &lt;/citefragment&gt; &lt;citefragment
					searchtype="CASE-CITE-REF"&gt; &lt;ci:span
					spanid="x20023NZLR_113-171-1"&gt;[2001] NZAR 598&lt;/ci:span&gt;
					&lt;/citefragment&gt; at para [ &lt;link
					refpt="20023NZLR_113_p5"&gt;5&lt;/link&gt; ] &lt;/ci:content&gt;
					&lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;ref:anchor id="nz_20023NZLR_113_p5" anchortype="global"
					/&gt; &lt;desig value="5" inline="true"&gt;[5]&lt;/desig&gt; &lt;text&gt;A
					number of issues were raised on Bs behalf but may be summarised as
					follows:&lt;/text&gt; ... &lt;/p&gt;  &lt;lnci:cite
					citeref="20023NZLR_113_p5"&gt; &lt;lnci:case&gt; &lt;lnci:caseref
					ID="x20023NZLR_113-171"&gt; &lt;lnci:reporter value="nzar" country="nz" /&gt;
					&lt;lnci:edition&gt; &lt;lnci:date year="2001" /&gt; &lt;/lnci:edition&gt;
					&lt;lnci:page num="598" /&gt; &lt;/lnci:caseref&gt; &lt;/lnci:case&gt;
					&lt;lnci:content&gt; &lt;emph typestyle="it"&gt;Auckland District Law Society v
					Ford&lt;/emph&gt; [2001] NZAR 598 at para [ 5 ] &lt;/lnci:content&gt;
					&lt;/lnci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML: ci:cite/@type="cite4thisdoc" (AU Journals/Newsitem)</xd:b>
         </xd:p>
         <xd:pre> &lt;jrnl:journalcite&gt; &lt;ci:cite type="cite4thisdoc"&gt;
					&lt;ci:lawrev&gt; &lt;ci:lawrevref&gt; &lt;ci:lawrevlocator&gt;
					&lt;ci:publicationname normpubcode="Aust Jnl of Corp Law"/&gt; &lt;ci:volume
					num="15"/&gt; &lt;ci:page num="185"/&gt; &lt;/ci:lawrevlocator&gt;
					&lt;/ci:lawrevref&gt; &lt;/ci:lawrev&gt; &lt;ci:content&gt;(2003) 15 Aust Jnl of
					Corp Law 185&lt;/ci:content&gt; &lt;/ci:cite&gt; &lt;/jrnl:journalcite&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Target XML: lnci:cite/@type="cite4thisdoc" (AU Journals/Newsitem)</xd:b>
         </xd:p>
         <xd:pre> &lt;ref:cite4thisresource&gt; &lt;lnci:cite type="cite4thisdoc"&gt;
					&lt;lnci:lawrev&gt; &lt;lnci:lawrevref&gt; &lt;lnci:lawrevlocator&gt;
					&lt;lnci:publicationname normpubcode="Aust Jnl of Corp Law"/&gt; &lt;lnci:volume
					num="15"/&gt; &lt;lnci:page num="185"/&gt; &lt;/lnci:lawrevlocator&gt;
					&lt;/lnci:lawrevref&gt; &lt;/lnci:lawrev&gt; &lt;lnci:content&gt;(2003) 15 Aust
					Jnl of Corp Law 185&lt;/lnci:content&gt; &lt;/lnci:cite&gt;
					&lt;/ref:cite4thisresource&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML: ci:cite/@type="legref" (NZ Regulation)</xd:b>
         </xd:p>
         <xd:pre> &lt;glp:note&gt; &lt;p&gt; &lt;text&gt; &lt;ci:cite searchtype="LEG-REF"
					type="legref"&gt; &lt;ci:content&gt;Compare: SR 1958/38 r 15Q&lt;/ci:content&gt;
					&lt;/ci:cite&gt; &lt;/text&gt; &lt;/p&gt; &lt;/glp:note&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;note&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt; &lt;lnci:cite&gt;
					&lt;lnci:content&gt;Compare: SR 1958/38 r 15Q&lt;/lnci:content&gt;
					&lt;/lnci:cite&gt; &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;/note&gt;
				</xd:pre>
         <!--Changes2016-03-23: Updated main instructions to
						clarify that descendants of ci:cite, and not just children, are to be
						processed.2015-09-15: Updated instruction to suppressed the
						attribute @type with value "legref" in target.
						Applicable on NZ Regulation and NZ Act from services [Webstar
						#6245139].2015-03-17: An attribute
							@inline get added with
							desig element even when the
							sourcepnum is not having that
							attribute@inline Applicable on CA12
					only.2015-02-24: Example updated as per new rule an
						attribute @inlineget added with
							desigelement when the
							sourcepnumis not having that
							attribute@inline2014-12-08: Addition of mapping for
							ci:pinpoint to
							lnci:pinpoint and example from US LPA
						content.2013-12-30: Minor illustrative change. Added "(AU
						Journals/Newsitem)" to headings for last example to clarify that retention
						of @type="cite4thisdoc" is an exception for that
						content, as already described in narrative rules.2013-05-01: Removed special rule for
							ci:cite/ci:content/remotelink which required
						suppression of ci:cite/ci:content tags. The elements
						are now retained and convert according to common rules.2013-04-24: Added a mapping for
							ci:procphrase to
							lnci:procphrase.2013-01-22: Instruction modified for the scenario
							ci:cite/ci:content/remotelink to indicate that
						the ci:cite and ci:content
						start-tags and end-tags (but not their content) are dropped.2012-11-29: Updated instructions to drop all
							@spanref.2012-09-18: Instruction and example added for
						handling of ci:cite/@type="cite4thisdoc" for AU
						Journals/Newsitem.2012-09-11: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="ci:cite">
      <xsl:choose>
         <xsl:when test="parent::leg:bodytext">
            <p>
               <text>
                  <lnci:cite>
                     <xsl:if test="ci:content/link">
                        <xsl:attribute name="citeref" select="ci:content/link/@refpt"/>
                     </xsl:if>
                     <!-- MDS 2017-05-01 - Added parameter 'childElementName' to match other call.  
				General ci:* module states to drop value of ci:cite/@searchtype if certain strings are found in first child element local-name.  
				Previously this first child element local-name value was not being passed.  The value is not invalid but it is a diff from the DT documents. -->
                     <xsl:apply-templates select="@*">
                        <xsl:with-param name="childElementName" select="local-name(child::*[1])"/>
                     </xsl:apply-templates>
                     <xsl:apply-templates select="node()"/>
                  </lnci:cite>
               </text>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <lnci:cite><!-- JD: 2017-08-31: added for VSTS Issue 342175.
				  If there is no @type, and no child element aside from <ci:content>, and the parent is case:parallelcite,
				  then set @type='case'
				  -->
               <xsl:if test="not(@type) and not(*[not(name()='ci:content')])         and parent::case:parallelcite and $streamID='UK05'">
                  <xsl:attribute name="type" select="'case'"/>
               </xsl:if>
               <!-- MDS - 2017-08-10 - added to address instructions in CI for AU13 -->
               <!-- Awantika: Added AU01 for normcite -->
               <xsl:if test="$streamID=('AU13','AU01','HK09','UK11DN')">
                  <xsl:if test="ci:case/ci:caseref[ci:reporter/@value and ci:volume/@num and         ci:edition/ci:date/@year and ci:pinpoint[@targettype='page']/@num] and        not(ci:case/ci:caseref/ci:page/@num)"><!-- Done simply to set the context node -->
                     <xsl:for-each select="ci:case[1]/ci:caseref">
                        <xsl:attribute name="normcite">
                           <xsl:text>(</xsl:text>
                           <xsl:value-of select="ci:edition/ci:date/@year"/>
                           <xsl:text>) </xsl:text>
                           <xsl:value-of select="ci:volume/@num"/>
                           <xsl:text> </xsl:text>
                           <xsl:value-of select="ci:reporter/@value"/>
                           <xsl:text> </xsl:text>
                           <xsl:value-of select="ci:pinpoint[@targettype='page']/@num"/>
                        </xsl:attribute>
                     </xsl:for-each>
                  </xsl:if>
               </xsl:if>
               <!-- Ankita Singh 12 June 2017: Introducted value of lnci:cite/@type to "cite4thisdoc under jrnl:journalcite as per latest CI of UK09 -->
               <xsl:if test="$streamID = ('UK09', 'NZ08','AU14') and parent::jrnl:journalcite">
                  <xsl:attribute name="type">cite4thisdoc</xsl:attribute>
               </xsl:if>
               <xsl:if test="ci:content/link">
                  <xsl:attribute name="citeref" select="ci:content/link/@refpt"/>
               </xsl:if>
               <xsl:if test="ci:content/remotelink and $streamID = ('NZ14', 'NZ02','AU11','NZ08','AU14')">
                  <xsl:attribute name="citeref" select="ci:content/remotelink[1]/@refpt"/>
                  <!-- CSN 8/4/17 added [1] in case there are multiple remotelinks -->
               </xsl:if>
               <!-- 20170721:  MCJ:  We originally grouped NZ15 into the code for NZ14 and NZ02 but found there are differences in how DT was
						                  handling colons and the leading underscore... so we kept NZ15 apart.  It is possibly (likely?) that something
						                  is going to need to change.  The NZ15 code attempts to follow the instructions about using a leading underscore
						                  and translating colons to underscores... however, it is not clear whether the target documents have had their
						                  "cite def" processed similarly.
					                      Also, note the added predicate that ensures that there is a remotelink that has @refpt.  It is not clear
					                      what should happen if cite:content/remotelink[not(@refpt)] exists... hoping data is good.
					-->
               <xsl:if test="ci:content/remotelink[@refpt] and $streamID = ('NZ15')"><!-- First replace any colons with underscores. -->
                  <xsl:variable name="translatedCiteRefValue"
                                select="translate(ci:content/remotelink[@refpt][1]/@refpt, ':', '_')"/>
                  <!-- Now, check if the value starts with a digit... if so, prepend an underscore.  There may be other offending first characters that need to be checked but digits should cover most. -->
                  <xsl:variable name="processedCiteRefValue"
                                select="if (matches($translatedCiteRefValue, '^\d')) then concat('_', $translatedCiteRefValue) else $translatedCiteRefValue"/>
                  <xsl:attribute name="citeref" select="$processedCiteRefValue"/>
               </xsl:if>
               <!-- MDS 2017-05-01 - Added parameter 'childElementName' to match other call.  
				General ci:* module states to drop value of ci:cite/@searchtype if certain strings are found in first child element local-name.  
				Previously this first child element local-name value was not being passed.  The value is not invalid but it is a diff from the DT documents. -->
               <xsl:apply-templates select="@*">
                  <xsl:with-param name="childElementName" select="local-name(child::*[1])"/>
               </xsl:apply-templates>
               <xsl:apply-templates select="node()"/>
            </lnci:cite>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="ci:*[not(local-name() = ('cite', 'fragment', 'span', 'volume', 'page'))] | ci:volume[normalize-space(@num) != ''] | ci:page[normalize-space(@num) != '']">
      <xsl:element name="{concat('lnci:', local-name())}">
         <xsl:apply-templates select="@*">
            <xsl:with-param name="childElementName" select="node()[1]/local-name()"/>
         </xsl:apply-templates>
         <!-- Sudhanshu Srivastava 7 June 2017 : Added condition for CA03 stream Only. condition for generating lnci:popname and lnci:hiertext.-->
         <xsl:if test="$streamID = 'CA03' and local-name() = 'statinfo'">
            <xsl:variable name="beforestring"
                          select="substring-before(ancestor::source_cttr:body/leg:info/leg:officialname, '/')"/>
            <xsl:variable name="afterstring"
                          select="substring-after(ancestor::source_cttr:body/leg:info/leg:officialname, '/')"/>
            <xsl:variable name="fullstring"
                          select="ancestor::source_cttr:body/leg:info/leg:officialname"/>
            <xsl:variable name="cicitecount"
                          select="count(ancestor::source_cttr:body/leg:info/leg:officialnum/ci:cite)"/>
            <xsl:variable name="legjuris"
                          select="ancestor::source_cttr:body/leg:info/leg:juris[1]"/>
            <xsl:variable name="legofnumchild"
                          select="ancestor::source_cttr:body/leg:info/leg:officialnum"/>
            <xsl:if test="ancestor::leg:officialnum/parent::leg:info/parent::source_cttr:body">
               <xsl:choose>
                  <xsl:when test="$cicitecount = 1">
                     <xsl:choose>
                        <xsl:when test="not(contains($fullstring, '/'))">
                           <xsl:if test="not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])">
                              <lnci:popname value="{$fullstring}"/>
                           </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                           <lnci:popname value="{$beforestring}"/>
                        </xsl:otherwise>
                     </xsl:choose>
                     <lnci:jurisinfo>
                        <lnci:can>
                           <xsl:attribute name="district">
                              <xsl:choose>
                                 <xsl:when test="$legjuris = 'PQ'">QC</xsl:when>
                                 <xsl:when test="$legjuris = ('CD', 'Canada', 'UK')">CA</xsl:when>
                                 <xsl:when test="$legjuris = ('NF')">NL</xsl:when>
                                 <xsl:when test="$legjuris = ('NU')"/>
                                 <xsl:otherwise>
                                    <xsl:value-of select="$legjuris"/>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </xsl:attribute>
                        </lnci:can>
                     </lnci:jurisinfo>
                  </xsl:when>
                  <xsl:when test="$cicitecount = 2">
                     <xsl:choose>
                        <xsl:when test="not(contains($fullstring, '/'))">
                           <xsl:if test="not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])">
                              <lnci:popname value="{$fullstring}"/>
                           </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                           <lnci:popname value="{if(not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])) then $beforestring else $afterstring}"/>
                        </xsl:otherwise>
                     </xsl:choose>
                     <lnci:jurisinfo>
                        <lnci:can>
                           <xsl:attribute name="district">
                              <xsl:choose>
                                 <xsl:when test="$legjuris = 'PQ'">QC</xsl:when>
                                 <xsl:when test="$legjuris = ('CD', 'Canada', 'UK')">CA</xsl:when>
                                 <xsl:when test="$legjuris = ('NF')">NL</xsl:when>
                                 <xsl:when test="$legjuris = ('NU')"/>
                                 <xsl:otherwise>
                                    <xsl:value-of select="$legjuris"/>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </xsl:attribute>
                        </lnci:can>
                     </lnci:jurisinfo>
                  </xsl:when>
                  <xsl:when test="$cicitecount = 4">
                     <xsl:choose>
                        <xsl:when test="not(contains($fullstring, '/'))">
                           <xsl:if test="not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])">
                              <lnci:popname value="{$fullstring}"/>
                           </xsl:if>
                           <xsl:if test="ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite] and count(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite]) = 1">
                              <lnci:popname value="{$fullstring}"/>
                           </xsl:if>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:if test="not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])">
                              <lnci:popname value="{$beforestring}"/>
                           </xsl:if>
                           <xsl:if test="ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite] and count(ancestor::ci:cite/preceding-sibling::ci:cite) = 1">
                              <lnci:popname value="{$beforestring}"/>
                           </xsl:if>
                           <xsl:if test="count(ancestor::ci:cite/preceding-sibling::ci:cite) = 2">
                              <lnci:popname value="{$afterstring}"/>
                           </xsl:if>
                           <xsl:if test="count(ancestor::ci:cite/preceding-sibling::ci:cite) = 3">
                              <lnci:popname value="{$afterstring}"/>
                           </xsl:if>
                        </xsl:otherwise>
                     </xsl:choose>
                     <lnci:jurisinfo>
                        <lnci:can>
                           <xsl:attribute name="district">
                              <xsl:choose>
                                 <xsl:when test="$legjuris = 'PQ'">QC</xsl:when>
                                 <xsl:when test="$legjuris = ('CD', 'Canada', 'UK')">CA</xsl:when>
                                 <xsl:when test="$legjuris = ('NF')">NL</xsl:when>
                                 <xsl:when test="$legjuris = ('NU')"/>
                                 <xsl:otherwise>
                                    <xsl:value-of select="$legjuris"/>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </xsl:attribute>
                        </lnci:can>
                     </lnci:jurisinfo>
                  </xsl:when>
                  <xsl:otherwise/>
               </xsl:choose>
            </xsl:if>
         </xsl:if>
         <xsl:if test="$streamID = 'CA03' and local-name() = 'hierlev' and not(child::ci:hierlev)">
            <xsl:variable name="beforeslash"
                          select="substring-before(ancestor::source_cttr:body/leg:info/leg:num, '/')"/>
            <xsl:variable name="afterslash"
                          select="substring-after(ancestor::source_cttr:body/leg:info/leg:num, '/')"/>
            <xsl:variable name="fullnumber" select="ancestor::source_cttr:body/leg:info/leg:num"/>
            <xsl:variable name="cicitecount"
                          select="count(ancestor::source_cttr:body/leg:info/leg:officialnum/ci:cite)"/>
            <xsl:variable name="legofnumchild"
                          select="ancestor::source_cttr:body/leg:info/leg:officialnum"/>
            <xsl:if test="contains(ancestor::leg:officialnum/preceding-sibling::leg:num, '/')">
               <xsl:choose>
                  <xsl:when test="$cicitecount = 1">
                     <lnci:hiertext value="{$beforeslash}"/>
                  </xsl:when>
                  <xsl:when test="$cicitecount = 2">
                     <lnci:hiertext value="{if(not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])) then $beforeslash else $afterslash}"/>
                  </xsl:when>
                  <xsl:when test="$cicitecount = 4">
                     <xsl:if test="not(ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite])">
                        <lnci:hiertext value="{$beforeslash}"/>
                     </xsl:if>
                     <xsl:if test="ancestor::ci:cite/preceding-sibling::*[1][self::ci:cite] and count(ancestor::ci:cite/preceding-sibling::ci:cite) = 2">
                        <lnci:hiertext value="{$afterslash}"/>
                     </xsl:if>
                  </xsl:when>
               </xsl:choose>
            </xsl:if>
         </xsl:if>
         <!-- Awantika-21-07-2017- For AU20 remotelink needs to be created outside ci:content -->
         <xsl:choose>
            <xsl:when test="$streamID='AU20' and local-name() = 'content'">
               <xsl:apply-templates select="node() except remotelink"/>
            </xsl:when>
            <xsl:when test="$streamID='CA02DC' and local-name()='content' and ancestor::case:reportercite">
               <xsl:apply-templates select="*"/>
            </xsl:when>
            <!-- Awantika-2018-01-25-  trailing comma and space should be suppressed in target lnci:content. Webstar # 7102029 -->
            <!-- Awantika-2018-01-29-  trailing space should be suppressed in target lnci:content. Webstar # 7102029 -->
            <xsl:when test="$streamID='CA02CC' and local-name()='content'">
               <xsl:choose>
                  <xsl:when test="starts-with(.,'Full text: ') and contains(.,',')">
                     <xsl:value-of select="replace(replace(.,', ',''),'Full text: ','')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(.,'Texte intgral :') and contains(.,',')">
                     <xsl:value-of select="replace(replace(.,', ',''),'Texte intgral :','')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(.,'Full text/texte intgral: ') and contains(.,',')">
                     <xsl:value-of select="replace(replace(.,', ',''),'Full text/texte intgral: ','')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(.,'Full text: ') and not(contains(.,','))">
                     <xsl:value-of select="replace(.,'Full text: ','')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(.,'Texte intgral :') and not(contains(.,','))">
                     <xsl:value-of select="replace(.,'Texte intgral :','')"/>
                  </xsl:when>
                  <xsl:when test="starts-with(.,'Full text/texte intgral: ') and not(contains(.,','))">
                     <xsl:value-of select="replace(.,'Full text/texte intgral: ','')"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:apply-templates select="node()"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:element>
   </xsl:template>
   <!-- JD: 20170524 : added to trap error output message -->
   <xsl:template match="ci:pinpoint/@searchtype"/>

   <xsl:template match="ci:*/@*[not(name() = ('searchtype', 'spanref', 'type', 'ID', 'ln.nsprefix'))]">
      <xsl:attribute name="{name()}">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="ci:volume[@num = ''] | ci:volume[@num = ' '] | ci:page[@num = '']"/>

   <xsl:template match="ci:*/@spanref | ci:*/@ln.nsprefix"/>

   <xsl:template match="ci:*/@ID">
      <xsl:param name="increment-caserefid" tunnel="yes"/>
      <xsl:variable name="dupStatus">
         <xsl:for-each select="parent::*">
            <xsl:call-template name="amIaDuplicate"/>
         </xsl:for-each>
      </xsl:variable>
      <xsl:choose>
         <xsl:when test="$dupStatus = 'false'">
            <xsl:attribute name="ID">
               <xsl:call-template name="normalizeIdString"/>
               <xsl:if test="$increment-caserefid = 'yes'">
                  <xsl:text>_01</xsl:text>
               </xsl:if>
            </xsl:attribute>
         </xsl:when>
         <xsl:otherwise>
            <xsl:message>citation ID for <xsl:value-of select="parent::*"/> was a duplicate and
					has been removed from the conversion.</xsl:message>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="citefragment | ci:span"><!-- Sudhanshu : 6 june 2017 , requirement for converting ci:span to lnci:span, so using choose scenario. -->
      <xsl:choose>
         <xsl:when test="$streamID = 'CA03' and not(ancestor::leg:officialnum) and not(ancestor::case:parallelcite)">
            <lnci:span>
               <xsl:apply-templates select="@* | node()"/>
            </lnci:span>
         </xsl:when>
         <xsl:otherwise>
            <xsl:apply-templates/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--<xsl:template
		match="citefragment[parent::ci:content and remotelink[@service = 'DOC-ID']][$streamID = 'AU04' or $streamID = 'AU08']"> </xsl:template>-->
   <xsl:template match="citefragment[parent::ci:content and remotelink[@service = 'DOC-ID']][$streamID = ('AU04', 'AU08')]">
      <xsl:call-template name="remotelinkDOCID"/>
   </xsl:template>

   <xsl:template match="citefragment[parent::ci:content and remotelink[@service = 'DOC-ID']][$streamID = ('NZ09', 'NZ07-DN')]">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="ci:cite[not(ancestor::case:references) or $streamID='NZ17CC' or $streamID='HK09']/@searchtype"
                 priority="25">
      <xsl:param name="childElementName"/>
      <xsl:choose><!-- JD: 2017-08-01: NZ06 includes standard module id-CCCC-10268; by my reading ci:cite/@type should not be suppressed, only the value 'legref'
			"If ci:cite@type comes with attribute value "legref" in source document then conversion needs to suppressed attribute value in target 
			and convert ci:cite according to general rule."
			Moving this logic to ci:cite/@type, below
			--><!--<xsl:when test="$streamID = ('NZ06')"/>-->
         <xsl:when test="      $childElementName = 'case' or $childElementName = 'form' or      $childElementName = 'misc' or $childElementName = 'admininterp' or      $childElementName = 'execdoc' or $childElementName = 'annot' or      $childElementName = 'constitution' or $childElementName = 'agencydecision' or      $childElementName = 'oag' or $childElementName = 'book' or      $childElementName = 'pinpoint' or $childElementName = 'periodical' or      $childElementName = 'lawrev' or $childElementName = 'copyright' or      $childElementName = 'tmark' or $childElementName = 'patent' or      $childElementName = 'sesslaw' or $childElementName = 'courtrule' or      $childElementName = 'reg' or $childElementName = 'juryinstr'"/>
         <xsl:otherwise>
            <xsl:attribute name="type">
               <xsl:choose>
                  <xsl:when test=". = 'LEG-REF'">legislation</xsl:when>
                  <xsl:when test=". = 'CASE-REF'">case</xsl:when>
                  <xsl:when test=". = 'BOOK-REF'">book</xsl:when>
                  <xsl:when test=". = 'BODY-CASE-REF'">case</xsl:when>
                  <xsl:when test=". = 'SUMM-CASE-REF'">case</xsl:when>
                  <xsl:when test=". = 'EU-REF'">EU-REF</xsl:when>
               </xsl:choose>
            </xsl:attribute>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="ci:cite/@type | ci:citeditem/@type">
      <xsl:choose><!-- 
				"Handling for NZ Regulation and NZ Act from services:
				If ci:cite@type comes with attribute value "legref" in source document then conversion needs to suppressed attribute value in target 
			  and convert ci:cite according to general rule."  -->
         <xsl:when test=".='legref' and $streamID=('NZ05','NZ06')"/>
         <!-- do nothing -->
         <xsl:when test=". = 'legref' or parent::ci:cite[ci:case | ci:stat | ci:juryinstr | ci:reg | ci:courtrule | ci:sesslaw | ci:patent | ci:tmark | ci:copyright | ci:lawrev | ci:periodical | ci:pinpoint | ci:book | ci:oag | ci:agencydecision | ci:constitution | ci:annot | ci:execdoc | ci:admininterp | ci:misc | ci:form]"/>
         <xsl:otherwise>
            <xsl:attribute name="type" select="."/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Vikas Rohilla : Added for the error messege	-->
   <xsl:template match="ci:cite/@searchtype"/>
   <!-- rosetta element: comm-info.contrib.note.p.text -->   <!--<topicref href="../../common_newest/Rosetta_Commentary_text-Chof-comm.info-contrib-note-p-LxAdv-seclaw.prelim-byline-inlinenote.dita"/>-->   <!-- start topichead  copyright  -->   <!-- <topicref href="../../common_newest/Rosetta_copyright-LxAdv-copyright.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>copyright</xd:i> becomes <xd:b>copyright</xd:b> with optional child
                <xd:ul>
               <xd:li>
                  <xd:i>copyright.holder</xd:i> becomes <xd:b>copyright-holder</xd:b>.
		          </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;copyright&gt;
      
    &lt;copyright.holder&gt;Crown Copyright&lt;/copyright.holder&gt; 
&lt;/copyright&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;copyright&gt;
       
     &lt;copyright-holder&gt;Crown Copyright&lt;/copyright-holder&gt; 
&lt;/copyright&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;copyright&gt;
   Copyright  Times Newspapers Ltd and Reed Elsevier (UK) Ltd 2007
&lt;/copyright&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;copyright&gt;
     Copyright  Times Newspapers Ltd and Reed Elsevier (UK) Ltd 2007
&lt;/copyright&gt;

		</xd:pre>
         <!--Changes2013-06-17: Added an example when copyright-holder is not present in the source.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_copyright-LxAdv-copyright.dita  -->
   <!-- Vikas Rohilla : Initial updated may be changed if required-->
   <xsl:template match="copyright">
      <copyright>
         <xsl:apply-templates select="@* | node()"/>
      </copyright>
   </xsl:template>

   <xsl:template match="copyright.holder">
      <copyright-holder>
         <xsl:apply-templates select="@* | node()"/>
      </copyright-holder>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_AU_NZ_copyright-LxAdv-copyright.dita"/> -->   <!--<xsl:include href="../../modules/nonamespace/Rosetta_AU_NZ_copyright-LxAdv-copyright.xsl"/>-->   <!--<topicref href="../../common_newest/Rosetta_NZ_copyright-LxAdv-copyright.dita"/>-->   <!-- end topichead  copyright  -->   <!-- rosetta element: credit -->   <!-- <topicref href="../../common_newest/Rosetta_credit-LxAdv-credit.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>credit</xd:i> becomes <xd:b>credit</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
    
    &lt;blockquote&gt;
      ...
      &lt;credit&gt;(Emphasis added.)&lt;/credit&gt;
    &lt;/blockquote&gt;
    
    	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
    
    &lt;blockquote&gt;
      ...
      &lt;credit&gt;(Emphasis added.)&lt;/credit&gt;
    &lt;/blockquote&gt;    
    
    	</xd:pre>
         <!--Changes2012-08-07: Created.
        -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_credit-LxAdv-credit.dita  -->
   <!-- Vikas Rohilla : Initial updated may be changed if required-->
   <xsl:template match="credit">
      <credit>
         <xsl:apply-templates select="@* | node()"/>
      </credit>
   </xsl:template>
   <!-- rosetta element: date -->   <!-- <topicref href="../../common_newest/Rosetta_date-LxAdv-date.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>date</xd:i> becomes <xd:b>date</xd:b> comes with following
				attributes: <xd:ul>
               <xd:li>
                  <xd:i>@month</xd:i> becomes <xd:b>@month</xd:b> is
						between 01-12. Any numbers outside this range, do not output a
							<xd:b>@month</xd:b>. </xd:li>
               <xd:li>
                  <xd:i>@day</xd:i> becomes <xd:b>@day</xd:b> is between
						01-31. Any numbers outside this range, do not output
							<xd:b>@day</xd:b>. </xd:li>
               <xd:li>
                  <xd:i>@year</xd:i> becomes <xd:b>@year</xd:b> is 4
						digits in length. Any other lengths, do not output
							<xd:b>@year</xd:b>. </xd:li>
            </xd:ul>
            <xd:p>
               <xd:b>Note: </xd:b>The format of the content of all <xd:b>date</xd:b> elements must be
					in 'YYYY-MM-DD'.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
	&lt;text&gt;The paragraph below is current to 
		&lt;emph typestyle="bf"&gt;
			&lt;date day="11" month="05" year="2010"&gt;11 May 2010&lt;/date&gt;
		&lt;/emph&gt;
	&lt;/text&gt;
&lt;/p&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
	&lt;text&gt;The paragraph below is current to 
		&lt;emph typestyle="bf"&gt;
			&lt;date day="11" month="05" year="2010"&gt;11 May 2010&lt;/date&gt;
		&lt;/emph&gt;
	&lt;/text&gt;
&lt;/p&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Populating the attribute @normdate</xd:b>
         </xd:p>
         <xd:p>
            <xd:ul>
               <xd:li>If one or more of the three date values (year, month or day) are absent,
						then decision:decisiondate/@normdate should not be populated.</xd:li>
               <xd:li>The <xd:i>@normdate</xd:i> should be populated with the values of
						date elements within New Lexis. </xd:li>
               <xd:li>Using case:decisiondate as an example the ru: case:decisiondate/date/@year,
						case:decisiondate/date/@month and case:decisiondate/date/@day concatenated
						and separated by a single hyphen. The values of
						case:decisiondate/date/@month and case:decisiondate/date/@day should be
						padded with zeroes so that they are 2 digits. </xd:li>
            </xd:ul>
            <xd:p>
               <xd:b>Note: </xd:b>The format of the content of all <xd:b>date</xd:b> elements must be
					in 'YYYY-MM-DD'.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
            <xd:b>Source 1</xd:b>	

     &lt;admindecision:dates&gt;
         &lt;decision:fileddate  day="8" month="02" year="1989"&gt;
             &lt;date-text&gt;8/2/1989&lt;/date-text&gt;
          &lt;/decision:fileddate&gt;
     &lt;/admindecision:dates&gt;


<xd:b>Source 2</xd:b>

		&lt;decision:dates&gt;
           &lt;decision:decisiondate day="8" month="02" year="1989"&gt;
             &lt;date-text&gt;8/2/1989&lt;/date-text&gt;
           &lt;/decision:decisiondate&gt;
       &lt;/decision:dates&gt;
		
		
<xd:b>Source 3</xd:b>
		
		
	&lt;primlawinfo:primlawinfo&gt;
     &lt;primlawinfo:dates&gt;
        &lt;primlawinfo:effdate year="1961" month="06" day="22"&gt;
            &lt;date-text&gt;June 22, 1961&lt;/date-text&gt;
        &lt;/primlawinfo:effdate&gt;
      &lt;/primlawinfo:dates&gt;
   &lt;/primlawinfo:primlawinfo&gt;
		

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
            <xd:b>Target 1</xd:b>	

   &lt;admindecision:dates&gt;
      &lt;decision:fileddate  day="8" month="02" year="1989" normdate="1989-02-08"&gt;
			&lt;date-text&gt;8/2/1989&lt;/date-text&gt;
		&lt;/decision:fileddate&gt;
   &lt;/admindecision:dates&gt;
		
		
<xd:b>Target 2</xd:b>

	&lt;decision:decisiondate day="8" month="02" year="1989" normdate="1989-02-08"&gt;
		&lt;date-text&gt;8/2/1989&lt;/date-text&gt;
	&lt;/decision:decisiondate&gt;
		
		
<xd:b>Target 3</xd:b>
		
		
	&lt;primlawinfo:dates&gt;
		&lt;primlawinfo:effdate year="1961" month="06" day="22" normdate="1961-06-22"&gt;
				&lt;date-text&gt;June 22, 1961&lt;/date-text&gt;
		&lt;/primlawinfo:effdate&gt;
	&lt;/primlawinfo:dates&gt;
		
				
		</xd:pre>
         <!--Changes2013-03-08 Added instruction for @normdate attribute that falls
					on various NL date elements-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_date-LxAdv-date.dita  -->
   <!-- IMPORTANT NOTE: if your stream wants to put the text content of the date element into a <date-text> wrapper, add 
		the streamID for your stream into the variable 'streamsThatUseDateTextChild' and it will add
		the date-text wrapper for that stream -->
   <!-- Awantika: Following the above instructions modified the template as in few streams date element is not required 
		but if date is coming in p/text then date element is created. -->
   <!-- Awantika: added stream AU20 to  streamsThatUseDateTextChild-->
   <xsl:template match="date">
      <xsl:variable name="streamsThatUseDateTextChild"
                    select="('HK03','AU01','NZ03','NZ13','CA02DC','UK05','AU20','UK01','UK03','UK11DA','UK12','AU09','UK11DN','UK22CF')"/>
      <xsl:choose>
         <xsl:when test="ancestor::case:dates or $streamID=('CA02DC','AU20','UK11DA','UK12','NZ13','UK11DN','UK22CF')">
            <xsl:choose>
               <xsl:when test="($streamID=$streamsThatUseDateTextChild and parent::entry)">
                  <date>
                     <xsl:apply-templates select="@*|node()"/>
                  </date>
               </xsl:when>
               <xsl:when test="($streamID=$streamsThatUseDateTextChild) and node()">
                  <date-text>
                     <xsl:apply-templates/>
                  </date-text>
               </xsl:when>
               <xsl:when test="not($streamID=$streamsThatUseDateTextChild) and node()">
                  <xsl:apply-templates/>
               </xsl:when>
               <!-- JD: 2017-06-27: 
						Excluding this template from UK01 under case:hearingdates.  
						
						date/@* are applied in the case:hearindates template as any attributes
						must be created before creating any nodes (<date-text>, text() content, etc.)
						
						Previously, the 'otherwise' condition would apply to the data below and would 
						output as @day="06", @month="12" @year="1934; the correct output is 
						@day="23", @month="01" @year="1935"
						
						<case:hearingdates>
							<date day="29" month="11" year="1934"/>
							<date day="30" month="11" year="1934"/>
							<date day="06" month="12" year="1934"/>
							<date day="13" month="12" year="1934">29, 30 November, 6, 13
								December 1934</date>
							<date day="23" month="01" year="1935">23 January 1935</date>
						</case:hearingdates>
						-->
               <xsl:when test="$streamID=('UK01','UK03') and (parent::case:hearingdates or parent::case:decisiondate)"><!-- do nothing; date attributes have been handled and there is no child node() to process --></xsl:when>
               <xsl:otherwise><!-- just apply attributes -->
                  <xsl:apply-templates select="@*"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise>
            <date>
               <xsl:call-template name="DATE_attributes">
                  <xsl:with-param name="date">
                     <xsl:copy-of select="."/>
                  </xsl:with-param>
               </xsl:call-template>
               <xsl:apply-templates select="node()"/>
            </date>
         </xsl:otherwise>
      </xsl:choose>
      <!--<date xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
			<xsl:call-template name="DATE_attributes">
				<xsl:with-param name="date">
					<xsl:copy-of select="."/>
				</xsl:with-param>
			</xsl:call-template>
		<!-\-  Original Target XPath:  date   -\->
		<!-\- Awantika: date becomes date-text if text() is coming else date becomes date in HK03 -\->
			<xsl:choose>
				<xsl:when test="($streamID=$streamsThatUseDateTextChild) and node()">
					<date-text xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
						<xsl:apply-templates/>
					</date-text>
				</xsl:when>
				<xsl:when test="not($streamID=$streamsThatUseDateTextChild) and node()">
					<xsl:apply-templates/>					
				</xsl:when>
			</xsl:choose>
		</date>-->
   </xsl:template>

   <xsl:template match="date[parent::p-limited or ancestor::text][$streamID='UK12']">
      <date>
         <xsl:copy-of select="@*"/>
         <xsl:apply-templates select="node()"/>
      </date>
   </xsl:template>
   <!-- start topichead  deflist  -->   <!-- <topicref href="../../common_newest/Rosetta_deflist-LxAdv-deflist.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>deflist</xd:i> becomes <xd:b>deflist</xd:b>
					with children as described below: </xd:p>
         <xd:p>
            <xd:i>defitem</xd:i> becomes <xd:b>defitem</xd:b>. </xd:p>
         <xd:p>
            <xd:i>defterm</xd:i> becomes <xd:b>defterm</xd:b>. </xd:p>
         <xd:p>
            <xd:i>defdesc</xd:i> becomes <xd:b>defdesc</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>When <xd:i>defitem</xd:i> contains
						<xd:i>footenote</xd:i> or <xd:i>fnr</xd:i> as a
					direct child, place the converted <xd:b>footnote</xd:b> and
						<xd:b>footnote-ref</xd:b> into either
						<xd:b>defterm</xd:b> or <xd:b>defdesc</xd:b>. If
					the <xd:i>footenote</xd:i> or <xd:i>fnr</xd:i>
					occurs either directly before or directly after
						<xd:b>defterm</xd:b>, place the footnote in
						<xd:b>defterm</xd:b>. If the
						<xd:i>footenote</xd:i> or <xd:i>fnr</xd:i>
					occurs after <xd:b>defdesc</xd:b>, place the footnote in
						<xd:b>defdesc</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt; &lt;emph
					typestyle="bf"&gt;an entitlement to redundancy pay&lt;/emph&gt;
					&lt;/defterm&gt; &lt;defdesc&gt; &lt;p&gt; &lt;text&gt;includes an
					entitlement for an employee to enter into a retention or redeployment
					period.&lt;/text&gt; &lt;/p&gt; &lt;/defdesc&gt; &lt;/defitem&gt;
					&lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt; &lt;emph
					typestyle="bf"&gt;an entitlement to redundancy pay&lt;/emph&gt;
					&lt;/defterm&gt; &lt;defdesc&gt; &lt;bodytext&gt; &lt;p&gt;
					&lt;text&gt;includes an entitlement for an employee to enter into a
					retention or redeployment period.&lt;/text&gt; &lt;/p&gt;
					&lt;/bodytext&gt; &lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt;
				</xd:pre>
         <xd:p>If the markup includes <xd:i>defitem/defterm</xd:i>, but no
					sibling <xd:i>defitem/defdesc</xd:i>, create a blank
						<xd:b>defitem/defdesc</xd:b> element after
						<xd:b>defterm</xd:b> but before any other text (such as a
					note or annottion). The resulting markup within
						<xd:b>deflist/defitem</xd:b> must always include a
						<xd:b>defdesc</xd:b> child to create the proper display to
					the end user.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt; &lt;emph
					typestyle="bf"&gt;FWA&lt;/emph&gt; &lt;/defterm&gt;
					&lt;leg:histnote&gt; &lt;p&gt; &lt;text&gt;[def rep Act 174 of 2012 s
					3 and Sch 9 item 14, effective 1 January 2013]&lt;/text&gt; &lt;/p&gt;
					&lt;/leg:histnote&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt; &lt;emph
					typestyle="bf"&gt;FWA&lt;/emph&gt; &lt;/defterm&gt; &lt;defdesc/&gt;
					&lt;note notetype="historical"&gt; &lt;bodytext&gt; &lt;p&gt;
					&lt;text&gt;[def rep Act 174 of 2012 s 3 and Sch 9 item 14, effective
					1 January 2013]&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
					&lt;/note&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p> For narrative content that immediately follows
						<xd:i>defterm</xd:i> create and wrap the narrative content
					within <xd:b>defdesc/bodytext/p/text</xd:b> retaining any
						<xd:i>emph</xd:i>. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;p&gt; &lt;text&gt;
					&lt;defterm&gt; &lt;refpt id="ACT_REG_1932-MAG_FINEDEFAULTER"
					type="ext"/&gt; &lt;emph typestyle="bf"&gt;fine defaulter&lt;/emph&gt;
					&lt;/defterm&gt; &amp;mdash;see the &lt;emph
					typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;,
					section&amp;#160;146. &lt;/text&gt; &lt;/p&gt; &lt;/defitem&gt;
					&lt;defitem&gt; &lt;p&gt; &lt;text&gt; &lt;defterm&gt; &lt;refpt
					id="ACT_REG_1932-MAG_OUTSTANDINGFINE" type="ext"/&gt; &lt;emph
					typestyle="bf"&gt;outstanding fine&lt;/emph&gt; &lt;/defterm&gt;
					&amp;mdash; see the &lt;emph typestyle="it"&gt;Magistrates Court Act
					1930&lt;/emph&gt;, section&amp;#160;146. &lt;/text&gt; &lt;/p&gt;
					&lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt;
					&lt;ref:anchor id="ACT_REG_1932-MAG_FINEDEFAULTER"
					anchortype="global"/&gt; &lt;emph typestyle="bf"&gt;fine
					defaulter&lt;/emph&gt; &lt;/defterm&gt; &lt;defdesc&gt;
					&lt;bodytext&gt; &lt;p&gt; &lt;text&gt; &amp;#x2014; see the &lt;emph
					typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;,
					section&amp;#x00A0;146. &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
					&lt;/defdesc&gt; &lt;/defitem&gt; &lt;defitem&gt; &lt;defterm&gt;
					&lt;ref:anchor id="ACT_REG_1932-MAG_OUTSTANDINGFINE"
					anchortype="global"/&gt; &lt;emph typestyle="bf"&gt;outstanding
					fine&lt;/emph&gt; &lt;/defterm&gt; &lt;defdesc&gt; &lt;bodytext&gt;
					&lt;p&gt; &lt;text&gt; &amp;#x2014; see the &lt;emph
					typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;,
					section&amp;#x00A0;146. &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
					&lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p> Handling of deflist with connector element. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem
					id="WFW.RL.WRA96.S6..APPLIES"&gt; &lt;defterm&gt; &lt;refpt
					id="WFW.RL.WRA96.S6..APPLIES" type="ext"/&gt; &lt;emph
					typestyle="bf"&gt;applies&lt;/emph&gt; &lt;/defterm&gt; :
					&lt;defdesc&gt; &lt;l&gt; &lt;li id="WFW.RL.WRA96.S6..APPLIES.A"&gt;
					&lt;lilabel&gt; &lt;refpt id="WFW.RL.WRA96.S6..APPLIES.A"
					type="ext"/&gt;(a) &lt;/lilabel&gt; &lt;/li&gt; &lt;/l&gt;
					&lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt;
					&lt;ref:anchor id="WFW.RL.WRA96.S6..APPLIES" anchortype="global"/&gt;
					&lt;emph typestyle="bf"&gt;applies&lt;/emph&gt; &lt;/defterm&gt;
					&lt;connector&gt;:&lt;/connector&gt; &lt;defdesc&gt; &lt;bodytext&gt;
					&lt;list&gt; &lt;listitem&gt; &lt;ref:anchor
					id="WFW.RL.WRA96.S6..APPLIES.A" anchortype="global"/&gt;
					&lt;label&gt;(a)&lt;/label&gt; &lt;/listitem&gt; &lt;/list&gt;
					&lt;/bodytext&gt; &lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt;
				</xd:pre>
         <xd:p> If there are more than one <xd:i>defterm</xd:i> in the
					input documents then it will be handled as: </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;p&gt; &lt;text&gt;
					&lt;defterm&gt; &lt;refpt id="VIC_ACT_797_BISHOP" type="ext"/&gt;
					&lt;emph typestyle="bf"&gt;"bishop"&lt;/emph&gt; &lt;/defterm&gt; or
					&lt;defterm&gt; &lt;refpt id="VIC_ACT_797_BISHOPOFADIOCESE"
					type="ext"/&gt; &lt;emph typestyle="bf"&gt;"bishop of a
					diocese"&lt;/emph&gt; &lt;/defterm&gt; shall mean as to the term
					"bishop" the bishop registered under the title of "bishop" under the
					provisions of the "&lt;emph typestyle="bf"&gt;Successory Trusts Act
					1878&lt;/emph&gt;" as head of the Church of England in the portion of
					Victoria described in the certificate of registrations, and shall
					include the administrator of the affairs of the dioceses during the
					vacancy of the see; and the term &lt;defterm&gt; &lt;refpt
					id="VIC_ACT_797_DIOCESE" type="ext"/&gt; &lt;emph
					typestyle="bf"&gt;"diocese"&lt;/emph&gt; &lt;/defterm&gt; shall mean
					the portion of Victoria described in such certificate as the diocese
					of the person so registered; &lt;/text&gt; &lt;/p&gt; &lt;/defitem&gt;
					&lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem&gt; &lt;defterm&gt;
					&lt;ref:anchor id="VIC_ACT_797_BISHOP" anchortype="global"/&gt;
					&lt;emph typestyle="bf"&gt;"bishop"&lt;/emph&gt; &lt;/defterm&gt;
					&lt;connector&gt;or&lt;/connector&gt; &lt;defterm&gt; &lt;ref:anchor
					bid="VIC_ACT_797_BISHOPOFADIOCESE" anchortype="global"/&gt; &lt;emph
					typestyle="bf"&gt;"bishop of a diocese"&lt;/emph&gt; &lt;/defterm&gt;
					&lt;defdesc&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt; shall mean as
					to the term "bishop" the bishop registered under the title of "bishop"
					under the provisions of the "&lt;emph typestyle="bf"&gt;Successory
					Trusts Act 1878&lt;/emph&gt;" as head of the Church of England in the
					portion of Victoria described in the certificate of registrations, and
					shall include the administrator of the affairs of the dioceses during
					the vacancy of the see; and the term &lt;/text&gt; &lt;/p&gt;
					&lt;/bodytext&gt; &lt;/defdesc&gt; &lt;defterm&gt; &lt;ref:anchor
					id="VIC_ACT_797_DIOCESE" anchortype="global"/&gt; &lt;emph
					typestyle="bf"&gt;"diocese"&lt;/emph&gt; &lt;/defterm&gt;
					&lt;defdesc&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt; shall mean the
					portion of Victoria described in such certificate as the diocese of
					the person so registered; &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
					&lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p> Handling of <xd:i>defitem/@id</xd:i> and
					<xd:i>defterm/@id</xd:i>. </xd:p>
         <xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>
               <xd:p>For GPL IN Content Stream <xd:ul>
                     <xd:li>
                        <xd:i>defitem/@id</xd:i> becomes
									<xd:b>defitem/@xml:id</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>defterm/@id</xd:i> becomes
									<xd:b>defterm/@xml:id</xd:b>
                     </xd:li>
                  </xd:ul>
               </xd:p>
            </xd:p>
         </xd:p>
         <xd:p>
            <xd:b>GPL IN Content Stream Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem id="S3.i"&gt; &lt;defterm
					id="s3.active service"&gt;active service&lt;/defterm&gt;
					&lt;defdesc&gt; &lt;p&gt; &lt;text&gt;, as applied to a person subject
					to this Act, means the time during which such
					person&amp;#x2014;&lt;/text&gt; &lt;/p&gt; &lt;/defdesc&gt;
					&lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p>
            <xd:b>GPL IN Content Stream Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;deflist&gt; &lt;defitem xml:id="S3.i"&gt; &lt;defterm
					xml:id="s3.active service"&gt;active service&lt;/defterm&gt;
					&lt;defdesc&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt;, as applied to
					a person subject to this Act, means the time during which such
					person&amp;#x2014;&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
					&lt;/defdesc&gt; &lt;/defitem&gt; &lt;/deflist&gt; </xd:pre>
         <xd:p>If the input document has subtitle/defterm scenario then
						<xd:i>defterm</xd:i> within a subtitle can be dropped, but
					the child element and content of the tag is retained and no text is
					dropped. </xd:p>
         <xd:p>
            <xd:b>Source XML having subtitle/defterm scenario:</xd:b>
         </xd:p>
         <xd:pre> &lt;subtitle&gt; &lt;defterm&gt; &lt;emph
						typestyle="bf"&gt;&amp;#x201C;Greenhouse Gas Storage Act
						2009&amp;#x201D;&lt;/emph&gt; &lt;/defterm&gt; &lt;/subtitle&gt;
					</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;subtitle&gt; &lt;emph
						typestyle="bf"&gt;&amp;#x201C;Greenhouse Gas Storage Act
						2009&amp;#x201D;&lt;/emph&gt; &lt;/subtitle&gt; </xd:pre>
         <!--Changes2014-03-21: Added instruction to handle
							defitem/@id and
							defterm/@id only for GPL IN content
						Streams.2013-12-20: Added note to place a
							footnote or fnr that
						is a child of defitem into one of its
						children. WebTeam #5158742 - AU04.2013-10-14: Added new rule to create a
						blank defitem/defdesc element after the defterm element. WebTeam #
						237242 and #247307.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="deflist"><!--  Original Target XPath:  deflist   -->
      <deflist>
         <xsl:apply-templates select="@* | node()"/>
      </deflist>
   </xsl:template>

   <xsl:template match="defitem"><!--  Original Target XPath:  defitem   -->
      <defitem>
         <xsl:apply-templates select="@id"/>
         <xsl:apply-templates select="@* except @id | defterm"/>
         <xsl:if test="not(defdesc | p/text/defdesc) and not(text()[normalize-space(replace(., '^[\t\p{Zs}]+$', '')) = ''])"><!-- JL added empty bodytext wrapper to validate to the target schemas -->
            <defdesc>
               <bodytext>
                  <xsl:apply-templates/>
               </bodytext>
            </defdesc>
         </xsl:if>
         <xsl:apply-templates select="node() except (footnote | fnr | defterm)"/>
      </defitem>
   </xsl:template>

   <xsl:template match="defitem[$streamID = ('UK06','UK07')]">
      <defitem>
         <xsl:apply-templates select="@* | defterm"/>
         <xsl:choose><!-- when there is a defdesc apply it --><!-- TODO: find/test p/text/defdesc branch to ensure nothing lost -->
            <xsl:when test="defdesc | p/text/defdesc">
               <xsl:apply-templates select="defdesc | p/text/defdesc"/>
            </xsl:when>
            <!-- when there is no defdesc and text() content that should become the definition -->
            <xsl:when test="not(defdesc | p/text/defdesc)"><!-- JL added empty bodytext wrapper to validate to the target schemas -->
               <defdesc>
                  <bodytext>
                     <xsl:variable name="defvalue"
                                   select="./text()[preceding-sibling::defterm and following-sibling::leg:histnote]"/>
                     <xsl:apply-templates select="node() except (footnote | fnr | defterm)"/>
                  </bodytext>
               </defdesc>
            </xsl:when>
         </xsl:choose>
      </defitem>
   </xsl:template>
   <!-- JD: Attempting to create single defitem template rule, 
		   limiting to specific streams for now.
		   
		   Handles both <defitem> with <defterm> and <defdesc> and the 		
			 condition where <defitem> has a <defterm> but no <defdesc>, but has text() containing the definition.
			
			Example:
	
		<defitem id="IPP.ICON.JRCTL.ART1.OFFICE">
			<defterm>
				<refpt id="IPP.ICON.JRCTL.ART1.OFFICE" type="ext"/>
		  	<emph typestyle="bf">Office</emph>
		 	</defterm>
		 	means the agency entrusted by a Member State with the registration of marks;
		</defitem>
	-->
   <xsl:template match="defitem[$streamID = ('AU11', 'NZ06', 'NZ10', 'AU18')]">
      <defitem>
         <xsl:choose>
            <xsl:when test="$streamID='AU18' and ./@id = descendant::refpt/@id"/>
            <xsl:otherwise>
               <xsl:apply-templates select="@id"/>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:apply-templates select="@* except @id | defterm"/>
         <!-- create <connector> if required  -->
         <xsl:apply-templates select="text()[normalize-space(replace(., '^[\t\p{Zs}]+$', '')) !='' and parent::defitem and preceding-sibling::defterm and (following-sibling::defdesc | following-sibling::leg:histnote[$streamID='AU18'])]"/>
         <xsl:choose><!-- when there is a defdesc apply it --><!-- TODO: find/test p/text/defdesc branch to ensure nothing lost -->
            <xsl:when test="defdesc | p/text/defdesc">
               <xsl:apply-templates select="defdesc | p/text/defdesc"/>
            </xsl:when>
            <!-- JD: 2017-12-01: found validation error and DT mismatch after SVN update.  Adding this when but limiting to affected stream for now.  May be more broadly applicable. -->
            <xsl:when test="glp:note and not(defdesc | p/text/defdesc) and normalize-space(replace(., '^[\t\p{Zs}]+$', '')) !='' and $streamID='NZ06'">
               <xsl:apply-templates select="node() except (footnote | fnr | defterm | leg:histnote)"/>
            </xsl:when>
            <!-- when there is no defdesc and text() content that should become the definition -->
            <xsl:when test="not(defdesc | p/text/defdesc) and normalize-space(replace(., '^[\t\p{Zs}]+$', '')) !=''">
               <defdesc>
                  <bodytext>
                     <p>
                        <text>
                           <xsl:apply-templates select="node() except (footnote | fnr | defterm | leg:histnote)"/>
                        </text>
                     </p>
                  </bodytext>
               </defdesc>
               <!--<xsl:apply-templates select="child::leg:histnote[$streamID='AU18']"/>-->
            </xsl:when>
            <!-- otherwise nothing to do (e.g., text() is all whitespace-->
            <xsl:otherwise/>
         </xsl:choose>
         <!-- now apply templates to any element other than defterm -->
         <xsl:apply-templates select="* except (defterm | defdesc | p/text/defdesc | glp:note)"/>
      </defitem>
   </xsl:template>
   <!-- JD: 2017-07-21: although not mentioned in the instructions, id-CCCC-10277 provides a special use case and example for <connector> 
	if text() contains anything but whitespace (tab, nonbreaking space, line feed) then wrap contents in <connector>
	-->
   <xsl:template match="text()[parent::defitem and preceding-sibling::defterm and following-sibling::defdesc][not(matches(., '^[\t\p{Zs}]+$'))]">
      <connector>
         <xsl:value-of select="."/>
      </connector>
   </xsl:template>
   <!-- if there is a space char (including nonbreaking) suppress it -->
   <xsl:template match="text()[parent::defitem and preceding-sibling::defterm][matches(., '^[\t\p{Zs}]+$')]"/>

   <xsl:template match="defterm"><!--  Original Target XPath:  defterm   -->
      <defterm>
         <xsl:apply-templates select="@* | node()"/>
         <xsl:if test="following-sibling::*[1][self::footnote | self::fnr] | preceding-sibling::*[1][self::footnote | self::fnr]">
            <xsl:apply-templates select="following-sibling::*[1][self::footnote | self::fnr] | preceding-sibling::*[1][self::footnote | self::fnr]"/>
         </xsl:if>
      </defterm>
   </xsl:template>

   <xsl:template match="defterm[parent::subtitle]">
      <xsl:apply-templates select="node()"/>
   </xsl:template>

   <xsl:template match="defdesc"><!--  Original Target XPath:  defdesc   -->
      <defdesc>
         <xsl:apply-templates select="@*"/>
         <bodytext>
            <xsl:apply-templates select="node()"/>
         </bodytext>
         <xsl:if test="following-sibling::*[1][self::footnote | self::fnr]">
            <xsl:apply-templates select="following-sibling::*[1][self::footnote | self::fnr]"/>
         </xsl:if>
      </defdesc>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_glp.note-Chof-deflist_defitem-LxAdv-deflist_defitem_defdesc_bodytext_note.dita"/> -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/glp/Rosetta_glp.note-Chof-deflist_defitem-LxAdv-deflist_defitem_defdesc_bodytext_note.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_text-Chof-deflist_defitem_p-LxAdv-deflist_defitem.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
                When the source has <xd:i>deflist/defitem/p/text</xd:i> then omit <xd:i>p/text</xd:i> and retain <xd:i>defitem</xd:i>.
            </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;deflist&gt;
    &lt;defitem&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;defterm&gt;
                    &lt;refpt id="ACT_REG_1932-MAG_FINEDEFAULTER" type="ext"/&gt;
                    &lt;emph typestyle="bf"&gt;fine defaulter&lt;/emph&gt;
                &lt;/defterm&gt;&amp;mdash;see the &lt;emph typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;,
                section&amp;#160;146.
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/defitem&gt;
    &lt;defitem&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;defterm&gt;
                    &lt;refpt id="ACT_REG_1932-MAG_OUTSTANDINGFINE" type="ext"/&gt;
                    &lt;emph typestyle="bf"&gt;outstanding fine&lt;/emph&gt;
                &lt;/defterm&gt;&amp;mdash; see the &lt;emph typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;,
                section&amp;#160;146.
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/defitem&gt;
&lt;/deflist&gt;


            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;deflist&gt;
    &lt;defitem&gt;
        &lt;defterm&gt;
            &lt;ref:anchor id="ACT_REG_1932-MAG_FINEDEFAULTER" anchortype="global"/&gt;
            &lt;emph typestyle="bf"&gt;fine defaulter&lt;/emph&gt;
        &lt;/defterm&gt;
        &lt;defdesc&gt;
            &lt;bodytext&gt;
                &lt;p&gt;
                    &lt;text&gt; &amp;#x2014; see the &lt;emph typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;, section&amp;#x00A0;146.&lt;/text&gt;
                &lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/defdesc&gt;     
    &lt;/defitem&gt;
    &lt;defitem&gt;
        &lt;defterm&gt;
            &lt;ref:anchor id="ACT_REG_1932-MAG_OUTSTANDINGFINE" anchortype="global"/&gt; 
            &lt;emph typestyle="bf"&gt;outstanding fine&lt;/emph&gt;
        &lt;/defterm&gt;
        &lt;defdesc&gt;
            &lt;bodytext&gt;
                &lt;p&gt;
                    &lt;text&gt;&amp;#x2014; see the &lt;emph typestyle="it"&gt;Magistrates Court Act 1930&lt;/emph&gt;, section&amp;#x00A0;146.&lt;/text&gt;
                &lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/defdesc&gt;
    &lt;/defitem&gt;
&lt;/deflist&gt;

            </xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_text-Chof-deflist_defitem_p-LxAdv-deflist_defitem.dita  -->
   <!-- Paul:  this functionality is in the deflist-to-deflist common module Rosetta_deflist_LxAdv_deflist_common_handling_test.xsl 
        
        <xsl:template match="deflist/defitem/p" priority="25">
		<!-\-  Original Target XPath:  deflist/defitem   -\->
	    <deflist xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
			<defitem>
				<xsl:apply-templates select="node()"/>
			</defitem>
		</deflist>
	</xsl:template>

    <xsl:template match="deflist/defitem/p/text" priority="25"> 
         <xsl:apply-templates select="node()"/>
    </xsl:template>
-->
   <!-- <topicref href="../../common_newest/Rosetta_deflist-Chof-p_text-LxAdv-p_deflist.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
                If the source XML has the scenario <xd:i>p/text/deflist</xd:i> then drop the text tag, i.e., <xd:i>p/text/deflist</xd:i> becomes <xd:b>p/deflist</xd:b>.
            </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;deflist&gt;
            &lt;defitem&gt;
                &lt;p&gt;
                    &lt;text&gt;
                        &lt;defterm&gt;&lt;emph typestyle="bf"&gt;Australian Standard 1885.1&lt;/emph&gt;&lt;/defterm&gt; means
                        Australian Standard 1885, being that standard as approved 20 March 1990 and published 11 
                        June 1990 entitled &amp;#x2018;Workplace injury and disease recording standard&amp;#x2019;.
                    &lt;/text&gt;
                &lt;/p&gt;
            &lt;/defitem&gt;
        &lt;/deflist&gt;
    &lt;/text&gt;
&lt;/p&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;deflist&gt;
        &lt;defitem&gt;
            &lt;defterm&gt;
                &lt;emph typestyle="bf"&gt;Australian Standard 1885.1&lt;/emph&gt;
            &lt;/defterm&gt;
            &lt;defdesc&gt;
                &lt;bodytext&gt;
                    &lt;p&gt;
                        &lt;text&gt;means Australian Standard 1885, being that 
                            standard as approved 20 March 1990 and published 11 June 1990 entitled 
                            &amp;#x201C;Workplace injury and disease recording standard&amp;#x201D;.
                        &lt;/text&gt;
                    &lt;/p&gt;
                &lt;/bodytext&gt;
            &lt;/defdesc&gt;
        &lt;/defitem&gt;
    &lt;/deflist&gt;
&lt;/p&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Special Scenario:</xd:b> If source document having
                "<xd:i>p/text/deflist</xd:i>" with running text which is comes before
                starting of <xd:i>deflist</xd:i> element and under
                    <xd:i>text</xd:i> markup then conversion should not drop
                    <xd:b>text</xd:b> markup in target and retain running text under
                    <xd:b>text</xd:b> and closing of text markup before
                    <xd:b>deflist</xd:b> in target document. Refer below source and target
                examples:</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
                
&lt;p&gt;
    &lt;text&gt;In these Rules&amp;#x2014;
        &lt;deflist&gt;
            &lt;defitem&gt;
                ...
            &lt;/defitem&gt;
        &lt;/deflist&gt;
    &lt;/text&gt;
&lt;/p&gt;


            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                
&lt;p&gt;
    &lt;text&gt;In these Rules&lt;/text&gt;
    &lt;deflist&gt;
        &lt;defitem&gt;
            
        &lt;/defitem&gt;
    &lt;/deflist&gt;
&lt;/p&gt;

            </xd:pre>
         <!--Changes2016-12-08: Added instruction to handle running text
                    which is comes before deflist and it comes under
                        p/text.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="text[child::deflist]" priority="1"><!--  Original Target XPath:  text   -->
      <xsl:for-each-group select="node()" group-adjacent="if (self::deflist) then 0 else 1">
         <xsl:choose>
            <xsl:when test="current-grouping-key()=0">
               <xsl:for-each select="current-group()">
                  <xsl:apply-templates select="."/>
               </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
               <text>
                  <xsl:for-each select="current-group()">
                     <xsl:apply-templates select="."/>
                  </xsl:for-each>
               </text>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each-group>
   </xsl:template>
   <!--<topicref href="../../common_newest/Rosetta_AU_Commentary_Forms_Precedents_deflist-LxAdv-deflist.dita"/>-->   <!-- end topichead  deflist  -->   <!-- start topichead  desig  -->   <!-- <topicref href="../../common_newest/Rosetta_desig-LxAdv-desig.dita"/> -->   <!-- **************** -->   <!-- MDS Be sure to include Rosetta_designum-Chof-desig-LxAdv-desig.xsl in any driver that includes this module. -->   <!-- **************** -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>desig</xd:i> becomes <xd:b>desig</xd:b>. </xd:p>
         <xd:p>
                Optional attribute <xd:i>@value</xd:i> becomes <xd:b>@value</xd:b>.
            </xd:p>
         <xd:p>
                Optional attribute <xd:i>@inline</xd:i> becomes <xd:b>@inline</xd:b>.
            </xd:p>
         <xd:p>
                Drop any remaining attributes.
            </xd:p>
         <xd:p>
                Please also see the instructions in <xd:a href="../common_newest/Rosetta_edpnum-LxAdv-desig.dita">edpnum</xd:a> regarding the
                occurrence of both <xd:i>desig</xd:i> and <xd:i>edpnum</xd:i> as sibling elements
                within the same parent element.
            </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;
    &lt;designum&gt;2200002817&lt;/designum&gt;
&lt;/desig&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;2200002817&lt;/desig&gt;

            </xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!-- Awantika: desig sibling of title becomes toc-ref in AU01 -->
   <!-- Awantika: to resolve the ambiguity between Rosetta_desig-LxAdv-desig_ref.para and Rosetta_desig-LxAdv-desig updated the template match witn not(parent::p) 
    as if desig is in the heading then it will convert ot desig if inside p then it will convert to ref:para. Removed toc-ref as it will bw mapped in toc module.
    -->
   <xsl:template match="desig[not(parent::p)]"><!--  Original Target XPath:  desig   -->
      <desig><!-- Awantika: created desig @value to get the value from designum and should not get the value of designum in text of desig
	               rather only desiglabel text is populated inside desig-->
         <xsl:choose>
            <xsl:when test="$streamID='AU20'">
               <xsl:attribute name="value">
                  <xsl:value-of select="child::designum"/>
               </xsl:attribute>
               <xsl:apply-templates select="node() except designum"/>
            </xsl:when>
            <!-- $streamID=('NZ11','AU10')
	                        when @id appears on designum, get error.  I suspect any stream would get this error, but 
	                            because this is common I opted for using stream ID.  If you get this error, consider this.
	                            Description: XTDE0410: An attribute node (xml:id) cannot be created after a child of the containing element."
	                            -->
            <xsl:when test="$streamID=('NZ11','AU10') and designum">
               <xsl:apply-templates select="@value | @inline | designum/@id"/>
               <xsl:apply-templates select="*"/>
            </xsl:when>
            <xsl:when test="$streamID=('NZ11','AU10') and not(designum)">
               <xsl:apply-templates select="@value | @inline"/>
               <xsl:apply-templates select="node()"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@value | @inline | node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </desig>
   </xsl:template>

   <xsl:template match="desig/@value | desig/@inline">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!-- edpnum has it's own element as sibling, and its own module. no need to affect this node. -->   <!-- <topicref href="../../common_newest/Rosetta_desiglabel-Chof-desig-LxAdv-desig.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>desig/desiglabel</xd:i> becomes <xd:b>desig</xd:b>.</xd:p>
         <xd:p>When combining <xd:i>desiglabel</xd:i> and <xd:i>designum</xd:i>
                the whitespace between should be retained. E.g "Part " and
                "1&amp;nbsp;&amp;nbsp;&amp;nbsp;" <xd:b>becomes</xd:b> "Part
                1&amp;nbsp;&amp;nbsp;&amp;nbsp;".</xd:p>
         <xd:p>
            <xd:b>
               <xd:i>For UK Streams:</xd:i>
            </xd:b> If source does not have whitespace between, then
                insert single space. If contents of source elements are wrapped in
                    <xd:i>emph</xd:i> then space is required at end of label content or
                start of number content; if neither space present, insert single space at end of
                label content.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>The element <xd:i>refpt</xd:i>should be suppressed </xd:p>
         <xd:p>
            <xd:b>Source XML 1: retain space</xd:b>
         </xd:p>
         <xd:pre>
 
&lt;desig searchtype="PART-NUM"&gt;
    &lt;desiglabel&gt;&lt;refpt type="ext" id="A2008L1_PART_1"/&gt;Part &lt;/desiglabel&gt;
    &lt;designum&gt;1&amp;#160;&amp;#160;&amp;#160;&lt;/designum&gt;
&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 1: retain space</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;Part 1&amp;#160;&amp;#160;&amp;#160;&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 2: insert space</xd:b>
         </xd:p>
         <xd:pre>
 
&lt;desig&gt;
    &lt;desiglabel&gt;Division&lt;/desiglabel&gt;
    &lt;designum&gt;12&lt;/designum&gt;
&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 2: insert space</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;Division 12&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 3: insert space within emph</xd:b>
         </xd:p>
         <xd:pre>
 
&lt;desig&gt;
    &lt;desiglabel&gt;&lt;emph typestyle="bf"&gt;Section&lt;/emph&gt;&lt;/desiglabel&gt;
    &lt;designum&gt;&lt;emph typestyle="bf"&gt;15&lt;emph typestyle="it"&gt;(a)&lt;/emph&gt;&lt;/emph&gt;&lt;/designum&gt;
&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 3: insert space within emph</xd:b>
         </xd:p>
         <xd:p>(space inserted at end of emph
                holding label content)</xd:p>
         <xd:pre>

&lt;desig&gt;&lt;emph typestyle="bf"&gt;Section &lt;/emph&gt;&lt;emph typestyle="bf"&gt;15&lt;emph typestyle="it"&gt;(a)&lt;/emph&gt;&lt;/emph&gt;&lt;/desig&gt;

	</xd:pre>
         <!--Changes2013-09-19: Added rules to insert space between label
                    and number when none present in source. Rule required for UK content.
                    Immediately known to occur in UK06, UK07, and UK12. R4.5 Post Iterative Testing
                    Issue 431. WebTeam # 236033.2013-08-23: Removed @value from
                    target example element desig, as it was decided, that if
                    source element doesn't contain @value then target element
                        desig will not contain
                    @value.2012-08-10: Added a note on the supression of element refpt within
                    desiglabel-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="desiglabel">
      <xsl:choose>
         <xsl:when test="parent::desigrange and $streamID='UK06'">
            <desig>
               <xsl:apply-templates select="node() except(refpt)"/>
               <!-- MDS created in HK04 but not applicable until UK06, 07, 12.  Retest with live data. -->
               <xsl:choose>
                  <xsl:when test="following-sibling::designum and (not(ends-with(., ' ')) or not(starts-with(following-sibling::designum, ' ')))">
                     <xsl:text> </xsl:text>
                  </xsl:when>
                  <xsl:when test="emph and following-sibling::designum/emph">
                     <xsl:choose>
                        <xsl:when test="(not(ends-with(emph, ' ')) or not(starts-with(following-sibling::designum/emph, ' ')))">
                           <xsl:text> </xsl:text>
                        </xsl:when>
                        <xsl:otherwise/>
                     </xsl:choose>
                  </xsl:when>
                  <xsl:otherwise/>
               </xsl:choose>
               <!--<xsl:apply-templates select="@* | node()"/>-->
               <xsl:apply-templates select="following-sibling::designum"/>
            </desig>
         </xsl:when>
         <xsl:otherwise>
            <xsl:apply-templates select="node() except(refpt)"/>
            <!-- MDS created in HK04 but not applicable until UK06, 07, 12.  Retest with live data. -->
            <xsl:choose>
               <xsl:when test="following-sibling::designum and (not(ends-with(., ' ')) or not(starts-with(following-sibling::designum, ' ')))">
                  <xsl:text> </xsl:text>
               </xsl:when>
               <xsl:when test="emph and following-sibling::designum/emph">
                  <xsl:choose>
                     <xsl:when test="(not(ends-with(emph, ' ')) or not(starts-with(following-sibling::designum/emph, ' ')))">
                        <xsl:text> </xsl:text>
                     </xsl:when>
                     <xsl:otherwise/>
                  </xsl:choose>
               </xsl:when>
               <xsl:otherwise/>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_designum-Chof-desig-LxAdv-desig.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>desig/designum</xd:i> becomes <xd:b>desig</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;
    &lt;designum&gt;2200002817&lt;/designum&gt;
&lt;/desig&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig&gt;2200002817&lt;/desig&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_designum-Chof-desig-LxAdv-desig.dita  -->
   <!-- JL note from dita for HK05
    
    *********************************************************************
                <note>If <sourcexml>dict:body/heading/desig/designum</sourcexml> have
                    <sourcexml>refpt</sourcexml> as child then move target mapping of
                    <sourcexml>refpt</sourcexml> to
                    <targetxml>dict:body/dict:defitem/tei:entry/tei:form/tei:orth/ref:anchor</targetxml></note>
    **********************************************************************-->
   <!-- ******************************************************************************************
        IMPORTANT NOTE!
    The  template for desig (match = "desig") SHOULD NOT BE IN THIS MODULE.
    
    That template (which used to be here)  has a conflict with the module for desig : 
    /XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_desig-LxAdv-desig.xsl
    
    Having the template for desig in this module caused over 1500 ambiguity errors in one test run.
    
    If you need a template for desig to go with designum, which you probably do, 
    please import the desig module for generic handling
    (/XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_desig-LxAdv-desig.xsl) 
    into your driver if it is not already there.  If you need specialized handing, please
    create a separate module for the desig template.
    
    Thanks, JL
    ********************************************************************************************** -->
   <xsl:template match="desig/designum">
      <xsl:choose>
         <xsl:when test="$streamID='HK05' and parent::desig/parent::heading/parent::source_dict:body">
            <xsl:apply-templates select="@* | node() except refpt"/>
            <xsl:apply-templates select="refpt" mode="hk05desig"/>
         </xsl:when>
         <!-- $streamID=('NZ11','AU10')
	                        when @id appears on designum, get error.  I suspect any stream would get this error, but 
	                            because this is common I opted for using stream ID.  If you get this error, consider this.
	                            Description: XTDE0410: An attribute node (xml:id) cannot be created after a child of the containing element."
	                            -->
         <xsl:when test="$streamID=('NZ11','AU10')">
            <xsl:apply-templates select="node() except refpt"/>
         </xsl:when>
         <xsl:otherwise><!-- <xsl:apply-templates select="@* | node()"/>--><!-- Awantika: ref:anchor is not allowed in desig -->
            <xsl:apply-templates select="@* | node() except refpt"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="refpt" mode="hk05desig">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- end topichead  desig  -->   <!-- rosetta element: dispformula -->   <!-- <topicref href="../../common_newest/Rosetta_dispformula-LxAdv-formula.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>dispformula</xd:i> becomes <xd:b>formula</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>frac</xd:i> becomes <xd:b>frac</xd:b>
                  <xd:ul>
                     <xd:li>
                        <xd:i>numer</xd:i> becomes <xd:b>numer</xd:b> is the required child element for <xd:b>frac</xd:b>.
                            </xd:li>
                     <xd:li>
                        <xd:i>denom</xd:i> becomes <xd:b>denom</xd:b> is the required child element for <xd:b>frac</xd:b>.
                            </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;dispformula&gt;
    &lt;frac&gt;
        &lt;numer&gt;2 &amp;times; P &amp;times; (J &amp;minus; A)&lt;/numer&gt;
        &lt;denom&gt;J&lt;/denom&gt;
    &lt;/frac&gt;
&lt;/dispformula&gt;
	
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;formula&gt;
    &lt;frac&gt;
         &lt;numer&gt;2 &amp;#x00D7; P &amp;#x00D7; (J &amp;#x2212; A)&lt;/numer&gt;
         &lt;denom&gt;J&lt;/denom&gt;
    &lt;/frac&gt;
&lt;/formula&gt;

		  </xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="dispformula"><!--  Original Target XPath:  formula   -->
      <formula>
         <xsl:apply-templates select="@* | node()"/>
      </formula>
   </xsl:template>
   <!-- MDS 2017-04-20 - This templates is already defined in '/nonamespace/Rosetta_frac-LxAdv-num_frac.xsl' -->   <!--	<xsl:template match="frac">

		<!-\-  Original Target XPath:  frac   -\->
		<frac>
			<xsl:apply-templates select="@* | node()"/>
		</frac>

	</xsl:template>-->   <!-- MDS 2017-04-20 - This templates is already defined in '/nonamespace/Rosetta_frac-LxAdv-num_frac.xsl' -->   <!--<xsl:template match="numer">

		<!-\-  Original Target XPath:  numer   -\->
		<numer>
			<xsl:apply-templates select="@* | node()"/>
		</numer>

	</xsl:template>-->   <!-- MDS 2017-04-20 - This templates is already defined in '/nonamespace/Rosetta_frac-LxAdv-num_frac.xsl' -->   <!--<xsl:template match="denom">

		<!-\-  Original Target XPath:  denom   -\->
		<denom>
			<xsl:apply-templates select="@* | node()"/>
		</denom>

	</xsl:template>-->   <!-- rosetta element: edpnum -->   <!-- <topicref href="../../common_newest/Rosetta_edpnum-LxAdv-desig.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:ul>
            <xd:li>If <xd:i>edpnum</xd:i> does <xd:b>not</xd:b> occur as a sibling of
                        <xd:i>desig</xd:i>, then <xd:i>edpnum</xd:i> becomes
                        <xd:b>desig</xd:b>.</xd:li>
            <xd:li>If <xd:i>edpnum</xd:i> and <xd:i>desig</xd:i> occur as
                    siblings, then <xd:i>edpnum</xd:i> becomes
                        <xd:b>altdesig</xd:b>. This scenario can occur in elements such as
                        <xd:i>leg:heading</xd:i>.</xd:li>
            <xd:li>In either case, preserve source document order in the output.</xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
  &lt;edpnum&gt;[LEN 5638]&lt;/edpnum&gt;
  &lt;title&gt;EPA v Multiplex Constructions Pty Ltd&lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
  &lt;desig&gt;[LEN 5638]&lt;/desig&gt;
  &lt;title&gt;EPA v Multiplex Constructions Pty Ltd&lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML - sibling <xd:i>edpnum</xd:i> and
                    <xd:i>desig</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:heading inline="true"&gt;
    &lt;edpnum&gt;[78,025]&lt;/edpnum&gt;
    &lt;title searchtype="SECT-TITLE"&gt;Children's evidence to which this Act applies&lt;/title&gt;
    &lt;desig searchtype="SECT-NUM"&gt;&lt;designum&gt;6&lt;/designum&gt;&lt;/desig&gt;
&lt;/leg:heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML - sibling <xd:i>edpnum</xd:i> and
                    <xd:i>desig</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;heading inline="true"&gt;
    &lt;altdesig&gt;[78,025]&lt;/altdesig&gt;
    &lt;title&gt;Children's evidence to which this Act applies&lt;/title&gt;
    &lt;desig&gt;6&lt;/desig&gt;    
&lt;/heading&gt;


	</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>pnum</xd:i> and <xd:i>edpnum </xd:i> occur as siblings,
            then <xd:i>edpnum</xd:i> becomes <xd:b>altdesig</xd:b> This scenario
            can occur in elements such as <xd:i>p</xd:i>(applicable for UK22CS and
            UK06).</xd:p>
         <xd:p>
            <xd:b>Source XML - sibling <xd:i>pnum</xd:i> and <xd:i>edpnum </xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;pnum&gt;1 (1)&lt;/pnum&gt;
    &lt;edpnum value="F1.302" inline="false"&gt;[F1.302]&lt;/edpnum&gt;         
&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML <xd:b>
                  <xd:i>edpnum</xd:i> becomes
                <xd:b>altdesig</xd:b>
               </xd:b>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;desig&gt;1 (1)&lt;/desig&gt;
    &lt;altdesig value="F1.302" inline="false"&gt;[F1.302]&lt;/altdesig&gt;         
&lt;/p&gt;

	</xd:pre>
         <!--Changes2016-10-12: Added rule for handling scenario when
                pnum and edpnum  occur as
                siblings (applicable for UK22CS and UK06).2016-03-15: Added rule for handling scenario when
                pnum and edpnum  occur as
                siblings (applicable only for UK22CS). [RFA #2755]2013-10-22: Not a rule change. Modified 2nd example for
                    clarity. Removed refpt from source markup. Not pertinent
                    to edpnum rules. Separate rules for
                        refpt provide details. Responds to UK LBU
                query.2013-03-06: Removed instructions/rules for exceptional
                    desig scenario and deprecated attribute @followstitle.
                    Added instructions for maintaining source document ordering.2011-12-21: Included example for multiple desig and added the CR number.2011-12-22: Added instructions regarding the creation of altdesig.2011-01-17: Removed CR number from the instruction based on latest schema
                release.2012-05-16: Corrected last example. Added exceptional use case (copied from heading
                module). For when desig and altdesig occur both before and after the title.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_edpnum-LxAdv-desig.dita  -->
   <!--<xsl:message>Rosetta_edpnum-LxAdv-desig.xsl requires manual development!</xsl:message>-->
   <!-- Awantika- added namespace attribute to the element -->
   <!-- Made sure refpt and its contents are suppressed as invalid in desig/altdesig; allow other child elements to convert over by applying templates. JL -->
   <!-- CSN: Created epdnum template -->
   <xsl:template match="edpnum">
      <xsl:choose>
         <xsl:when test="../desig or ../pnum">
            <xsl:element name="altdesig"
                         namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
               <xsl:apply-templates select="@*|node() except refpt"/>
            </xsl:element>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="desig"
                         namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
               <xsl:apply-templates select="@*|node() except refpt"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="edpnum/@inline[$streamID=('UK07')]">
      <xsl:attribute name="inline" select="."/>
   </xsl:template>

   <xsl:template match="edpnum/@value[$streamID=('UK07')]">
      <xsl:attribute name="value" select="."/>
   </xsl:template>

   <xsl:template match="edpnum/@inline[$streamID=('UK06','AU14','UK22CF')] | edpnum/@value[$streamID=('UK06','UK22CF')]"/>

   <xsl:template match="edpnum/@ln.user-displayed"/>
   <!-- rosetta element: email -->   <!-- <topicref href="../../common_newest/Rosetta_email-LxAdv-email.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>email</xd:i> becomes <xd:b>contact:email</xd:b>.</xd:p>
         <xd:p>The attributes and content of <xd:b>contact:email</xd:b> are populated as follows: <xd:ul>
               <xd:li>The value of <xd:i>email/remotelink/@href</xd:i> with the prefix "mailto:" should be placed in
                            <xd:b>contact:email/@normval</xd:b>.</xd:li>
               <xd:li>The content of <xd:i>email/remotelink</xd:i> should be placed in <xd:b>contact:email</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;email&gt;
    &lt;remotelink href="rtu@services.nsw.gov.au" hrefclass="mailto"&gt;rtu@services.nsw.gov.au&lt;/remotelink&gt;
&lt;/email&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;contact:email normval="mailto:rtu@services.nsw.gov.au"&gt;rtu@services.nsw.gov.au
&lt;/contact:email&gt;

	</xd:pre>
         <xd:p>If <xd:i>emph</xd:i> occurs within <xd:i>email/remotelink</xd:i> then <xd:i>emph</xd:i> should be suppressed from conversion.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;email&gt;
    &lt;remotelink href="Oliver@simplychateau.com" hrefclass="mailto"&gt;
        &lt;emph typestyle="it"&gt;Oliver@simplychateau.com&lt;/emph&gt; 
    &lt;/remotelink&gt;
&lt;/email&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;contact:email normval="mailto:Oliver@simplychateau.com"&gt;
    Oliver@simplychateau.com
&lt;/contact:email&gt;

	</xd:pre>
         <!--Changes2012-05-07: Created.2012-11-21: Added instruction and example for handling of email/remotelink/emph.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_email-LxAdv-email.dita  -->
   <!-- CSN: Created mail template -->
   <xsl:template match="email">
      <xsl:element name="contact:email">
         <xsl:attribute name="normval">
            <xsl:value-of select="./remotelink/@hrefclass"/>
            <xsl:text>:</xsl:text>
            <xsl:value-of select="./remotelink/@href"/>
         </xsl:attribute>
         <xsl:value-of select="string-join(remotelink , '')"/>
      </xsl:element>
   </xsl:template>
   <!-- Vikas Rohilla : Added for the UK12   -->
   <xsl:template match="email[$streamID='UK12']">
      <xsl:element name="contact:email">
         <xsl:choose>
            <xsl:when test="child::remotelink">
               <xsl:attribute name="normval">
                  <xsl:value-of select="./remotelink/@hrefclass"/>
                  <xsl:text>:</xsl:text>
                  <xsl:value-of select="./remotelink/@href"/>
               </xsl:attribute>
               <xsl:value-of select="string-join(remotelink , '')"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@*|node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:element>
   </xsl:template>
   <!-- start topichead  emph  -->   <!-- <topicref href="../../common_newest/Rosetta_emph-LxAdv-emph.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>emph</xd:i> becomes <xd:b>emph</xd:b>.
                    <xd:b>@typestyle</xd:b> values are tokenized. These are given below: <xd:ul>
               <xd:li>
                  <xd:b>@typestyle="bf"</xd:b> bold.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="biu"</xd:b> bold, italic and underline.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="bu"</xd:b> bold underline.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="caps"</xd:b> capital characters.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="dbl-un"</xd:b> double underline.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="grayscal"</xd:b> grayscale.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="hi"</xd:b> highlighted.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="ib"</xd:b> italic and bold.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="it"</xd:b> italic.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="iu"</xd:b> italic underline.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="ro"</xd:b> roman.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="smcaps"</xd:b> small caps.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="un"</xd:b> underline.</xd:li>
               <xd:li>
                  <xd:b>@typestyle="inherit"</xd:b> inherit.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>Children of <xd:i>emph</xd:i> should be processed.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:b>emph/emph</xd:b> has the same
            <xd:b>@typestyle</xd:b> value then remove one
            <xd:b>emph</xd:b> element.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>
               <xd:i>heading/title/emph</xd:i> becomes <xd:b>heading/title</xd:b>. That
                is, the <xd:i>emph</xd:i> start-tag and end-tag (but not the content) are dropped, and the content 
                becomes part of the target parent <xd:b>title</xd:b> element.</xd:p>
            <xd:p>
               <xd:i>emph/inlineobject</xd:i> becomes
                <xd:b>figure/ref:inlineobject</xd:b>.</xd:p>
            <xd:p>
               <xd:i>h/emph/inlineobject</xd:i> becomes
                <xd:b>emph/ref:inlineobject</xd:b>.</xd:p>
            <xd:p>
               <xd:i>sup/emph/emph/inlineobject</xd:i> becomes
                <xd:b>sup/emph/ref:inlineobject</xd:b>.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;
                &lt;emph typestyle="bf"&gt;Judgment&lt;/emph&gt;
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;
                Judgment
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Source XML: For multiple <xd:i>emph</xd:i> elements</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;
                &lt;emph typestyle="bf"&gt;
                &lt;emph typestyle="bf"&gt;
                Doc. 5.27 - Section 10(&lt;emph typestyle="it"&gt;&lt;emph typestyle="it"&gt;b&lt;/emph&gt;&lt;/emph&gt;) &amp;#x2014; Affidavit
                &lt;/emph&gt;
                &lt;/emph&gt;
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;Doc. 5.27 - Section 10(b) &amp;#x2014; Affidavit&lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Source XML: Showing an <xd:i>emph</xd:i> that contains a child element</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;
                &lt;emph typestyle="bf"&gt;Non-residential building(&lt;ci:cite searchtype="LEG-REF" status="invalid"&gt;
                &lt;ci:sesslaw&gt;
                &lt;ci:sesslawinfo&gt;
                &lt;ci:sesslawnum num="1994_23a"/&gt;
                &lt;ci:hierpinpoint&gt;&lt;ci:hierlev label="schedule" num="8"/&gt;&lt;/ci:hierpinpoint&gt;
                &lt;/ci:sesslawinfo&gt;
                &lt;ci:sesslawref&gt;&lt;ci:standardname normpubcode="UK_ACTS"/&gt;&lt;/ci:sesslawref&gt;
                &lt;/ci:sesslaw&gt;
                &lt;ci:content&gt;VATA 1994, Schedule 8, group 5&lt;/ci:content&gt;&lt;/ci:cite&gt;, note 7A)&lt;/emph&gt;
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;Non-residential building(&lt;lnci:cite searchtype="LEG-REF" status="invalid"&gt;
                &lt;lnci:sesslaw&gt;
                &lt;lnci:sesslawinfo&gt;
                &lt;lnci:sesslawnum num="1994_23a"/&gt;
                &lt;lnci:hierpinpoint&gt;&lt;lnci:hierlev label="schedule" num="8"/&gt;&lt;/lnci:hierpinpoint&gt;
                &lt;/lnci:sesslawinfo&gt;
                &lt;lnci:sesslawref&gt;&lt;lnci:standardname normpubcode="UK_ACTS"/&gt;&lt;/lnci:sesslawref&gt;
                &lt;/lnci:sesslaw&gt;
                &lt;lnci:content&gt;VATA 1994, Schedule 8, group 5&lt;/lnci:content&gt;&lt;/lnci:cite&gt;, note 7A)&lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Source XML: When source is having <xd:i>emph</xd:i> and <xd:i>PCDATA</xd:i> under <xd:i>heading/title</xd:i> than in that case the <xd:i>emph</xd:i> element get dropped from target and its content along with the PCDATA will be put directly under <xd:b>title</xd:b> element.</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;
                &lt;emph typestyle="it"&gt;R&lt;/emph&gt;(on the application of Green) v Police Complaints Authority
                &lt;fnr fnrtoken="d30e128" fntoken="d30e1108"&gt;13&lt;/fnr&gt;
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                
                &lt;heading&gt;
                &lt;title&gt;R (on the application of Green) v Police Complaints Authority
                &lt;footnote-ref anchoridref="d30e128"&gt;
                &lt;ref:anchor id="d30e1108"/&gt;
                &lt;label&gt;13&lt;/label&gt;
                &lt;/footnote-ref&gt;   
                &lt;/title&gt;
                &lt;/heading&gt;
                
            </xd:pre>
         <xd:p>
            <xd:i>emph/sub/inlineobject</xd:i> becomes
            <xd:b>figure/ref:inlineobject</xd:b>.</xd:p>
         <!--Changes2015-03-18: When heading\title contains emph and PCDATA under it then from target the emph tags will dropped and it's content along with PCDATA content will be put directly under title element . Applicable to UK09 only.2014-10-22: Added an example to explicitly show child elements of emph being retained. (R4.5 Content Issue List #1998)2014-06-04: Clarified instructions and added an example to show multiple emph elements being handled.2013-02-26: Created.-->
         <!--Changes2016-04-01: Added statement to clarify that children of emph should be processed.2013-01-08: Added note for handling
                emph/emph has the same
                @typestyle value.2012-02-28: Added instructions for handling of
                case:judges/emph/@typestyle="smcaps".2011-12-15: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="emph" name="emph-generic">
      <xsl:choose><!-- pass through when parent is title with heading parent or parent is emph with parent title with parent title-->
         <xsl:when test="(child::copyright and parent::disclaimer and $streamID='UK11DA')">
            <xsl:element name="emph">
               <xsl:copy-of select="@typestyle"/>
               <xsl:apply-templates select="@*|node() except copyright"/>
            </xsl:element>
         </xsl:when>
         <xsl:when test="parent::title/parent::heading[$streamID='UK07']">
            <xsl:element name="emph">
               <xsl:copy-of select="@typestyle"/>
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:when>
         <!-- 2016-10-24 - MDS: Pass through when child outputting as URL in UK11DA -->
         <xsl:when test="parent::remotelink[$streamID='UK11DA']">
            <xsl:apply-templates select="node()"/>
         </xsl:when>
         <!-- JD: excluding the dropping of <emph> within title for streams to match DT output.  
                    			There is no instruction to remove <emph> from <title> in 
                    		 emph to emph (id-CCCC-10316)
                    		 title to title (id-CCCC-10479)
                    		-->
         <xsl:when test="$streamID=('AU11','NZ06','NZ08','NZ18','NZ11','NZ13','AU14') and (parent::title/parent::heading                       |parent::emph/parent::title/parent::heading                       | parent::title/parent::leg:heading                       |parent::emph/parent::title/parent::leg:heading) and (not(preceding-sibling::text()) or not(following-sibling::text()))                       "><!-- not in CI, but match DT output: when parent emph is same, merge -->
            <xsl:choose><!-- pass through when there is a parent emph with the same @typestyle -->
               <xsl:when test="@typestyle=parent::emph/@typestyle">
                  <xsl:apply-templates/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:element name="emph">
                     <xsl:copy-of select="@typestyle"/>
                     <xsl:apply-templates/>
                  </xsl:element>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:when test="(parent::title/parent::heading                             |parent::emph/parent::title/parent::heading                             | parent::title/parent::leg:heading                             |parent::emph/parent::title/parent::leg:heading) and (not(preceding-sibling::text()) or not(following-sibling::text()))                             ">
            <xsl:apply-templates/>
         </xsl:when>
         <!--skip over emphasis if only refpt at child -->
         <xsl:when test="refpt and not(normalize-space(string-join(text(), '')))[$streamID!='CA10']"><!-- suppress --></xsl:when>
         <xsl:when test="refpt and parent::h[$streamID='CA10']">
            <xsl:element name="emph">
               <xsl:copy-of select="@typestyle"/>
               <xsl:for-each select="node()"><!-- there's no target for refpt here, strip it out but leave the txt content 
                                JL 20180212 Webstar 7113097 -->
                  <xsl:choose>
                     <xsl:when test="self::refpt">
                        <xsl:apply-templates select="text()"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates select="."/>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:for-each>
            </xsl:element>
         </xsl:when>
         <xsl:when test="@typestyle=parent::emph/@typestyle"><!-- pass through when there is a parent emph with the same @typestyle -->
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:when test="child::inlineobject and not(parent::h) and $streamID='AU08'">
            <xsl:apply-templates/>
         </xsl:when>
         <!-- The handling for AU06 could be shareable but keeping as stream-specific until we have more testing. -->
         <!-- JD: 2017-07-19: tested with UK01 too (added); this appears to be working properly.  
                    			Note that the following 'when' drops text() that should be emphasized -->
         <xsl:when test="child::inlineobject and not(parent::h) and ($streamID=('AU06','AU04','UK01','HK02'))"><!-- this attempts to allow the emphasis markup to be retained around some output but not around others. --><!-- keep current emph node to get to later. -->
            <xsl:variable name="me" select="."/>
            <xsl:for-each-group select="node()" group-adjacent="if (self::inlineobject) then 0 else 1">
               <xsl:choose><!-- anything here is not kept within emphasis. -->
                  <xsl:when test="current-grouping-key()=0">
                     <xsl:apply-templates select="current-group()"/>
                  </xsl:when>
                  <!-- the otherwise condition allows the retention of the emphasis markup. -->
                  <xsl:otherwise>
                     <emph><!-- build @typestyle using the input node's @typestyle. -->
                        <xsl:copy-of select="$me/@typestyle"/>
                        <xsl:apply-templates select="current-group()"/>
                     </emph>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:for-each-group>
         </xsl:when>
         <!-- JD: Note that this template will drop any text() appearing in emph, as in "Declared takings (F)"  
                    		<emph typestyle="bf">Declared takings (F) 
                    		   <inlineobject type="image" mimetype="image/gif" filename="VATC_19761_1.gif"/>
                    	  </emph>
                    		-->
         <xsl:when test="child::inlineobject and not(parent::h) and not ($streamID='UK09')"><!-- AS: for emph/inlineobject in DT GDS it's emph/ref:inlineobject but in CI it's figure/ref:inlineobeject -->
            <xsl:element name="figure">
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:when>
         <xsl:when test="child::sub/child::inlineobject">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:when test="ancestor::ci:content[$streamID='CA02DS']">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="emph">
               <xsl:copy-of select="@typestyle"/>
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--suppress to get rid of errors as @typestyle already handled. JL -->
   <xsl:template match="emph/@typestyle"/>
   <!-- <topicref href="../../common_newest/Rosetta_emph-Chof-case.judges-LxAdv-omit_tag.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>When <xd:i>emph</xd:i> is inside <xd:i>case:judges</xd:i> and <xd:i>@typestyle="smcaps"</xd:i> then conversion need to omit <xd:i>emph</xd:i> tag.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
					&lt;case:judgment&gt;
					  &lt;case:courtinfo&gt;
					      &lt;case:judges&gt;
					          JUDGE M 
					          &lt;emph typestyle="smcaps"&gt;c&lt;/emph&gt; 
					          ELREA. 
					      &lt;/case:judges&gt;
					  &lt;/case:courtinfo&gt;
					  ...
					&lt;/case:judgment&gt;
        	    </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
					&lt;courtcase:opinion&gt;
					  &lt;courtcase:opinionby&gt;
					    JUDGE M 
					    c
					    ELREA. 
					  &lt;/courtcase:opinion&gt;
					&lt;/courtcase:opinion&gt;
        	    </xd:pre>
         <!--Changes2011-12-15: Created.Added instructions for handling of case:judges/emph/@typestyle="smcaps".-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_emph-Chof-case.judges-LxAdv-omit_tag.dita  -->
   <!-- 20170424:  MCJ:  Handled to match the conversion instructions.  However, it feels like this would be better placed in a single module that handles emph to avoid spreading the instructions
    	                  across many modules. -->
   <!-- 20170424:  MCJ:  Also don't know if the XSLT that is embedded in the DITA needs to be changed. -->
   <xsl:template match="emph[parent::case:judges and ./@typestyle='smcaps']">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_emp-Chof-heading_title-LxAdv-heading_title.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>heading/title/emph</xd:i> becomes <xd:b>heading/title</xd:b>. That
        is, the <xd:i>emph</xd:i> start-tag and end-tag (but not the content) are dropped, and the content becomes part of the target parent <xd:b>title</xd:b> element.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
    &lt;title&gt;
        &lt;emph typestyle="bf"&gt;Judgment&lt;/emph&gt;
    &lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
    &lt;title&gt;
Judgment
    &lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML: For multiple <xd:i>emph</xd:i> elements</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
  &lt;title&gt;
    &lt;emph typestyle="bf"&gt;
      &lt;emph typestyle="bf"&gt;
        Doc. 5.27 - Section 10(&lt;emph typestyle="it"&gt;&lt;emph typestyle="it"&gt;b&lt;/emph&gt;&lt;/emph&gt;) &amp;#x2014; Affidavit
      &lt;/emph&gt;
    &lt;/emph&gt;
  &lt;/title&gt;
&lt;/heading&gt;
                  
       </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
  &lt;title&gt;Doc. 5.27 - Section 10(b) &amp;#x2014; Affidavit&lt;/title&gt;
&lt;/heading&gt;
               
       </xd:pre>
         <xd:p>
            <xd:b>Source XML: Showing an <xd:i>emph</xd:i> that contains a child element</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
    &lt;title&gt;
        &lt;emph typestyle="bf"&gt;Non-residential building(&lt;ci:cite searchtype="LEG-REF" status="invalid"&gt;
        &lt;ci:sesslaw&gt;
          &lt;ci:sesslawinfo&gt;
            &lt;ci:sesslawnum num="1994_23a"/&gt;
            &lt;ci:hierpinpoint&gt;&lt;ci:hierlev label="schedule" num="8"/&gt;&lt;/ci:hierpinpoint&gt;
          &lt;/ci:sesslawinfo&gt;
          &lt;ci:sesslawref&gt;&lt;ci:standardname normpubcode="UK_ACTS"/&gt;&lt;/ci:sesslawref&gt;
        &lt;/ci:sesslaw&gt;
        &lt;ci:content&gt;VATA 1994, Schedule 8, group 5&lt;/ci:content&gt;&lt;/ci:cite&gt;, note 7A)&lt;/emph&gt;
    &lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
    &lt;title&gt;Non-residential building(&lt;lnci:cite searchtype="LEG-REF" status="invalid"&gt;
      &lt;lnci:sesslaw&gt;
        &lt;lnci:sesslawinfo&gt;
          &lt;lnci:sesslawnum num="1994_23a"/&gt;
          &lt;lnci:hierpinpoint&gt;&lt;lnci:hierlev label="schedule" num="8"/&gt;&lt;/lnci:hierpinpoint&gt;
        &lt;/lnci:sesslawinfo&gt;
        &lt;lnci:sesslawref&gt;&lt;lnci:standardname normpubcode="UK_ACTS"/&gt;&lt;/lnci:sesslawref&gt;
      &lt;/lnci:sesslaw&gt;
      &lt;lnci:content&gt;VATA 1994, Schedule 8, group 5&lt;/lnci:content&gt;&lt;/lnci:cite&gt;, note 7A)&lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML: When source is having <xd:i>emph</xd:i> and <xd:i>PCDATA</xd:i> under <xd:i>heading/title</xd:i> than in that case the <xd:i>emph</xd:i> element get dropped from target and its content along with the PCDATA will be put directly under <xd:b>title</xd:b> element.</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
     &lt;title&gt;
        &lt;emph typestyle="it"&gt;R&lt;/emph&gt;(on the application of Green) v Police Complaints Authority
             &lt;fnr fnrtoken="d30e128" fntoken="d30e1108"&gt;13&lt;/fnr&gt;
     &lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
     &lt;title&gt;R (on the application of Green) v Police Complaints Authority
             &lt;footnote-ref anchoridref="d30e128"&gt;
                  &lt;ref:anchor id="d30e1108"/&gt;
                      &lt;label&gt;13&lt;/label&gt;
              &lt;/footnote-ref&gt;   
     &lt;/title&gt;
&lt;/heading&gt;

	</xd:pre>
         <!--Changes2015-03-18: When heading\title contains emph and PCDATA under it then from target the emph tags will dropped and it's content along with PCDATA content will be put directly under title element . Applicable to UK09 only.2014-10-22: Added an example to explicitly show child elements of emph being retained. (R4.5 Content Issue List #1998)2014-06-04: Clarified instructions and added an example to show multiple emph elements being handled.2013-02-26: Created.-->
      </xd:desc>
   </xd:doc>
   <!-- MDS - 2017-03-13 - Moved functionality to modules/nonamespace/Rosetta_emph-LxAdv-emph.xsl and removed this module from Driver -->
   <!-- CSN: Created mail template -->
   <xsl:template match="heading/title/emph">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="heading/title/emph/emph">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- HK02-Articles heading handling -->
   <xsl:template match="jrnl:prelim/heading/title">
      <nitf:hl1>
         <xsl:apply-templates/>
      </nitf:hl1>
   </xsl:template>
   <!-- end topichead  emph  -->   <!-- rosetta element: endnote -->   <!-- <topicref href="../../common_newest/Rosetta_endnote-LxAdv-endnote.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
               <xd:b>Handling of Footnote references and Endnotes</xd:b>
            </xd:b>
         </xd:p>
         <xd:p> Whenever <xd:i>refpt</xd:i> and <xd:i>remotelink</xd:i> occurs
                as adjacent siblings, this indicates they are footnote refernces and are linked to
                endnotes within the document or outside the document. <xd:ol>
               <xd:li> Check for the <xd:i>remotelink/@refpt</xd:i> value, if it is
                        "*_FN#", then create a <xd:b>footnote-ref</xd:b>. If it is
                        "*_FN#-R" then create the <xd:b>footnote</xd:b> as child of
                            <xd:b>endnotes</xd:b>. </xd:li>
               <xd:li> The <xd:i>l</xd:i> around endnotes is converted to
                            <xd:b>endnotes</xd:b> the <xd:i>li</xd:i> around a
                        endnote is removed when <xd:i>refpt</xd:i> and
                            <xd:i>remotelink</xd:i> is converted to
                            <xd:b>footnote/@role="endnote"</xd:b>. </xd:li>
            </xd:ol>
            <xd:p>
               <xd:b>Note: </xd:b>endnote references can be found at any place in the same document or in
                    another document.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>We are only converting <xd:i>refpt</xd:i> and
                        <xd:i>remotelink</xd:i> to
                        <xd:b>footnote/@role="endnote"</xd:b> within
                        <xd:b>primlaw:level/@leveltype="endnote"</xd:b> when they occurs
                    as adjacent siblings.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>footnote-ref/@reftype will be set to "global" if refpt/@id="ext".</xd:p>
         </xd:p>
         <xd:p> The attribute value's for <xd:i>refpt/@id</xd:i> and
                    <xd:i>remotelink/@refpt</xd:i> are duplicated within the source
                document i.e., <xd:ol>
               <xd:li>
                  <xd:i>refpt/@id</xd:i> (footnote refernce) and
                            <xd:i>remotelink/@refpt</xd:i> (endnote) will be same. and </xd:li>
               <xd:li>
                  <xd:i>remotelink/@refpt</xd:i> (footnote refernces) and
                            <xd:i>refpt/@id</xd:i> (endnote) will be same. </xd:li>
            </xd:ol>
            <xd:p>
               <xd:b>Note: </xd:b>The endnote and associated endnote references may be in different
                    documents.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Footnote-ref:</xd:b> Every occurance of <xd:i>refpt</xd:i> and
                    <xd:i>remotelink</xd:i> will become
                    <xd:b>footnote-ref</xd:b> in output. Populate
                    <xd:b>footnote-ref</xd:b> as follows: <xd:ul>
               <xd:li>
                  <xd:b>footnote-ref/@role</xd:b> will always be set to
                            <xd:b>"endnote"</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink/@refpt</xd:i> becomes
                            <xd:b>footnote-ref/@anchoridref</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>refpt/@id</xd:i> becomes
                            <xd:b>footnote-ref/ref:anchor/@id</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink/sup</xd:i> becomes
                            <xd:b>footnote-ref/label</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink</xd:i> attributes are converted as follows: <xd:p>
                            Create <xd:b>footnote:ref/ref:locator/ref:locator-key</xd:b>
                            with attributes and children as follows: <xd:ul>
                        <xd:li>If <xd:i>@remotekey1="DOC-ID"</xd:i> then <xd:ul>
                              <xd:li>
                                 <xd:b>ref:key-name/@name</xd:b> will have the
                                            value "DOC-ID".</xd:li>
                              <xd:li>
                                 <xd:b>key-value/@value</xd:b> will be the
                                            value of <xd:i>@dpsi</xd:i> followed by hyphen
                                            and concatenated with <xd:i>@refpt</xd:i> or
                                                <xd:i>@remotekey2</xd:i>, which ever is
                                            present (if both are present, use
                                                <xd:i>@remotekey2</xd:i>).</xd:li>
                           </xd:ul>
                        </xd:li>
                        <xd:li>If <xd:i>@remotekey1="REFPTID"</xd:i> then <xd:ul>
                              <xd:li>
                                 <xd:b>ref:key-name/@name</xd:b> will have the
                                            value "DOC-ID".</xd:li>
                              <xd:li>
                                 <xd:b>ref:key-value/@value</xd:b> will be the
                                            value of <xd:i>@dpsi</xd:i> followed by hyphen
                                            and concatenated with
                                            <xd:i>@docidref</xd:i>.</xd:li>
                              <xd:li>Create <xd:b>ref:locator/@anchoridref</xd:b>
                                            with value from <xd:i>@refpt</xd:i> or
                                                <xd:i>@remotekey2</xd:i>, which ever is
                                            present (if both are present, use
                                                <xd:i>@refpt</xd:i>).</xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                  </xd:p>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Endnote:</xd:b> Every occurance of <xd:i>refpt</xd:i> and
                    <xd:i>remotelink</xd:i> will become <xd:b>footnote</xd:b> as
                a child of <xd:b>endnotes</xd:b> which is the container element for all
                the converted endnotes. Populate each <xd:b>footnote</xd:b> created within
                    <xd:b>endnotes</xd:b> as follows: <xd:ul>
               <xd:li>
                  <xd:b>footnote/@role</xd:b> will always be set to "endnote".</xd:li>
               <xd:li>
                  <xd:i>refpt/@id</xd:i> becomes
                            <xd:b>footnote/ref:anchor/@id</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink/sup</xd:i> becomes
                            <xd:b>footnote/label</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink/sub</xd:i> becomes
                            <xd:b>footnote/label</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>remotelink</xd:i> attributes are converted as follows: <xd:p>
                            Create
                                <xd:b>footnote/ref:returnreference/ref:locator/ref:locator-key</xd:b>
                            with attributes and children as follows: <xd:ul>
                        <xd:li>If <xd:i>@remotekey1="DOC-ID"</xd:i> then <xd:ul>
                              <xd:li>
                                 <xd:b>ref:key-name/@name</xd:b> will have the
                                            value "DOC-ID".</xd:li>
                              <xd:li>
                                 <xd:b>key-value/@value</xd:b> will be the
                                            value of <xd:i>@dpsi</xd:i> followed by hyphen
                                            and concatenated with <xd:i>@refpt</xd:i> or
                                                <xd:i>@remotekey2</xd:i>, which ever is
                                            present (if both are present, use
                                                <xd:i>@remotekey2</xd:i>).</xd:li>
                           </xd:ul>
                        </xd:li>
                        <xd:li>If <xd:i>@remotekey1="REFPTID"</xd:i> then <xd:ul>
                              <xd:li>
                                 <xd:b>ref:key-name/@name</xd:b> will have the
                                            value "DOC-ID".</xd:li>
                              <xd:li>
                                 <xd:b>ref:key-value/@value</xd:b> will be the
                                            value of <xd:i>@dpsi</xd:i> followed by hyphen
                                            and concatenated with
                                            <xd:i>@docidref</xd:i>.</xd:li>
                              <xd:li>Create <xd:b>ref:locator/@anchoridref</xd:b>
                                            with value from <xd:i>@refpt</xd:i> or
                                                <xd:i>@remotekey2</xd:i>, which ever is
                                            present (if both are present, use
                                                <xd:i>@refpt</xd:i>).</xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                  </xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>If <xd:i>remotelink/@dpsi</xd:i> is not present, use value
                            from <xd:i>docinfo:dpsi/@id-string</xd:i> or capture value
                            from the LBU manifest file.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>
                     <xd:b>ref:locator/@anchoridref</xd:b> that begins with a
                            number must have an underscore added at start. Also apply other identifier data type format as
                            used for <xd:b>xml:id</xd:b> and <xd:b>ref:anchor/@id</xd:b>
                            (e.g. change colon to underscore). Refer to the section titled "Identifiers to ID Data Type - 
                            Handling Pattern Restrictions", if that section exists in this CI.</xd:p>
               </xd:li>
            </xd:ul>
            <xd:p>
               <xd:b>Note: </xd:b>All elements between the <xd:i>l</xd:i> and the nearest ancestor
                        <xd:i>leg:level</xd:i> are not converted as usual. For example,
                        <xd:i>leg:endmatter/leg:level/leg:level-vrnt/leg:levelbody/leg:bodytext/l/li</xd:i>
                    becomes <xd:b>primlaw:level/endnotes/footnote</xd:b> with appropriate
                    attributes. </xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>For the Xpath <xd:i>leg:bodytext/glp:note/l/li</xd:i>, all elements between <xd:i>l</xd:i> and the nearest 
                    ancestor <xd:i>glp:note</xd:i> are not converted as usual and the target <xd:b>endnote</xd:b> will be sibling of 
                    <xd:b>primlaw:bodytext</xd:b>. The target Xpath will be <xd:b>primlaw:level/endnotes/footnote</xd:b>. Refer below source XML 3 and target XML 3.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--Rosetta AU source markup for a reference to an endnote VIC_ACT_6231.xml--&gt;
    &lt;row&gt;
        &lt;entry colname="c1" align="left"&gt;Pt 3 Div. 1 Subdiv. (12) (Heading and ss 390396)
        &lt;/entry&gt;
        &lt;entry colname="c2" align="left"&gt;repealed. 
            &lt;emph typestyle="bf"&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;/emph&gt;
            
&lt;!-- Footnote-refernce-start --&gt;
            &lt;refpt id="VIC_ACT_6231_FN32-R" type="ext"/&gt;
            &lt;remotelink remotekey1="REFPTID" service="DOC-ID" dpsi="0062" docidref="ABCD_5641" refpt="VIC_ACT_6231_FN32"&gt;
                &lt;sup&gt;32&lt;/sup&gt;
            &lt;/remotelink&gt;
&lt;!-- Footnote-reference-end --&gt;

            &lt;emph typestyle="bf"&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;/emph&gt;
        &lt;/entry&gt;
    &lt;/row&gt;
...
&lt;leg:endmatter&gt;
    &lt;leg:level&gt;
        &lt;leg:level-vrnt&gt;
            &lt;leg:levelbody&gt;
                &lt;leg:bodytext&gt;
&lt;!--Endnote-start --&gt;
                    &lt;l&gt;
                        &lt;li&gt;
                            &lt;lilabel&gt;
                                &lt;refpt id="VIC_ACT_6231_FN32" type="ext"/&gt;
                                &lt;remotelink remotekey1="REFPTID" service="DOC-ID" dpsi="0062" docidref="ABCD_5641" refpt="VIC_ACT_6231_FN32-R"&gt;&lt;sup&gt;32&lt;/sup&gt;&lt;/remotelink&gt;
                            &lt;/lilabel&gt;
                            &lt;p&gt;
                                &lt;text align="left"&gt;...&lt;/text&gt;
                            &lt;/p&gt;
                        &lt;/li&gt;
                    &lt;!-- ... --&gt;
                    &lt;/l&gt;
&lt;!--Endnote-end --&gt;
                &lt;/leg:bodytext&gt;
            &lt;/leg:levelbody&gt;
        &lt;/leg:level-vrnt&gt;
    &lt;/leg:level&gt;
&lt;/leg:endmatter&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--
footnote-ref/@role will always be set to "endnote"
remotelink/@refpt becomes footnote-ref/@anchoridref
refpt/@id becomes footnote-ref/ref:anchor/@id
remotelink/sub becomes footnote-ref/label
--&gt;
    &lt;row&gt;
        &lt;entry colname="c1" align="left"&gt;Pt 3 Div. 1 Subdiv. (12) (Heading and ss 390396)
        &lt;/entry&gt;
        &lt;entry colname="c2" align="left"&gt;repealed. 
            &lt;emph typestyle="bf"&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;/emph&gt;
            
         &lt;!--   Footnote-reference-start --&gt; 
            
            &lt;footnote-ref role="endnote" anchoridref="VIC_ACT_6231_FN32"&gt;               	
               	&lt;ref:anchor id="_0062-VIC_ACT_6231_FN32-R" anchortype="global"/&gt;
                &lt;ref:locator anchoridref="VIC_ACT_6231_FN32"&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt; 
                    &lt;ref:key-value value="0062-ABCD_5641"/&gt;
                &lt;/ref:locator-key&gt;
            &lt;/ref:locator&gt;

               	&lt;label&gt;32&lt;/label&gt;
           &lt;/footnote-ref&gt;

           &lt;!-- Footnote-reference-end --&gt;
            
            &lt;emph typestyle="bf"&gt;&lt;sup&gt;,&lt;/sup&gt;&lt;/emph&gt;
        &lt;/entry&gt;
    &lt;/row&gt;

&lt;!--
...
endnotes/footnote/@role will always set to "endnote"
refpt/@id becomes footnote/ref:anchor/@id
remotelink/sub becomes footnote/label
--&gt;
&lt;!-- Endnote-start--&gt;
&lt;primlaw:level leveltype="endnote"&gt;
    &lt;endnotes&gt;
        &lt;footnote role="endnote"&gt;
            &lt;ref:returnreference&gt;
                &lt;ref:locator anchoridref="VIC_ACT_6231_FN32-R"&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="DOC-ID"/&gt;
                        &lt;ref:key-value value="0062-ABCD_5641"/&gt;
                    &lt;/ref:locator-key&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:returnreference&gt;
            &lt;ref:anchor id="0062-VIC_ACT_6231_FN32" anchortype="global"/&gt;
            &lt;label&gt;32&lt;/label&gt;
            &lt;bodytext&gt;
                &lt;p&gt;
                    &lt;text align="left"&gt;...&lt;/text&gt;
                &lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/footnote&gt;
        &lt;!-- rest of footnote@role='endnote' --&gt;
    &lt;/endnotes&gt;
&lt;/primlaw:level&gt;
&lt;!--Endnote-end --&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--Rosetta AU source markup for a reference to an endnote VIC_ACT_9595.xml--&gt;
    &lt;!-- Footnote-refernce-start --&gt;
&lt;title align="left" searchtype="SECT-TITLE"&gt;
    &lt;emph typestyle="bf"&gt;&lt;emph typestyle="it"&gt;Constitution of Board&lt;/emph&gt;&lt;/emph&gt;&lt;refpt id="VIC_ACT_9595_FN1-R" type="ext"/&gt;&lt;remotelink remotekey1="REFPTID" service="DOC-ID" refpt="VIC_ACT_9595_FN1"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/remotelink&gt;&amp;#x00A0;
    &lt;lnlink status="valid" service="SEARCH" scope="All Subscribed Australian Cases and Commentary" scope-protocol="combined-source-name"&gt;
        &lt;marker&gt;&lt;inlineobject width="21px" type="image" filename="mb.gif" attachment="web-server" alttext="click to find cases &amp;amp; commentary"/&gt;
        &lt;/marker&gt;
        &lt;api-params&gt;
            &lt;param name="expressSearch" value="true"/&gt;&lt;param name="searchString" value="COUNCIL OF ADULT EDUCATION ACT 1981 w/s LEG-REF(6)"/&gt;&lt;/api-params&gt;
    &lt;/lnlink&gt;
&lt;/title&gt;
&lt;!-- Footnote-reference-end --&gt;

&lt;!-- ... --&gt;

&lt;leg:level id="VIC_ACT_9595_NOTESPROV4"&gt;
    &lt;leg:level-vrnt leveltype="clause" searchtype="LEGISLATION" subdoc="true" toc-caption="4. List of Annotations"&gt;
        &lt;leg:heading&gt;
            &lt;!-- ... --&gt;
        &lt;/leg:heading&gt;
        &lt;leg:levelbody&gt;
          &lt;leg:bodytext&gt;
             &lt;table&gt;
                &lt;tgroup cols="2"&gt;
                 &lt;colspec colwidth="3*" colname="c1" colnum="1"/&gt;
                 &lt;colspec colwidth="12*" colname="c2" colnum="2"/&gt;
                 &lt;tbody&gt;
                &lt;row&gt;
                &lt;entry colname="c1"&gt;S. 2 def. of &amp;quot;adult, community and further education&amp;quot;&lt;/entry&gt;
                &lt;entry colname="c2"&gt;inserted by No. 91/1991 s. 44(a).&lt;/entry&gt;
               &lt;!--... --&gt; 
            &lt;/tbody&gt;
        &lt;/tgroup&gt;
    &lt;/table&gt;
               &lt;!--Endnote-start --&gt;
    &lt;l&gt;
        &lt;li&gt;&lt;lilabel&gt;&lt;refpt id="VIC_ACT_9595_FN1" type="ext"/&gt;&lt;remotelink remotekey1="REFPTID" service="DOC-ID" refpt="VIC_ACT_9595_FN1-R"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/remotelink&gt;&lt;/lilabel&gt;
            &lt;p&gt;&lt;text align="left"&gt;S. 6: Section&amp;#x00A0;50 of the &lt;emph typestyle="bf"&gt;Adult, Community and Further Education Act 1991&lt;/emph&gt;, No. 91/1991, provides as follows:&lt;/text&gt;&lt;/p&gt;
            &lt;p&gt;&lt;text align="left"&gt;&lt;emph typestyle="bf"&gt;'50. &lt;emph typestyle="it"&gt;Transitional provisions for the Council of Adult Education&lt;/emph&gt;&lt;/emph&gt;&lt;/text&gt;&lt;/p&gt;
        &lt;/li&gt;
        &lt;!-- ... --&gt;
    &lt;/l&gt;
            &lt;!--Endnote-end --&gt;   
           &lt;/leg:bodytext&gt;
        &lt;/leg:levelbody&gt;
    &lt;/leg:level-vrnt&gt;
&lt;/leg:level&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--
footnote-ref/@role will always be set to "endnote"
remotelink/@refpt becomes footnote-ref/@anchoridref
refpt/@id becomes footnote-ref/ref:anchor/@id
remotelink/sub becomes footnote-ref/label
--&gt;
   &lt;!--   Footnote-reference-start --&gt; 
            
            &lt;title align="left"&gt;
    &lt;emph typestyle="bf"&gt;&lt;emph typestyle="it"&gt;Constitution of Board&lt;/emph&gt;&lt;/emph&gt;
    &lt;footnote-ref role="endnote" anchoridref="VIC_ACT_9595_FN1"&gt;               	
        &lt;ref:anchor id="VIC_ACT_9595_FN1-R" anchortype="global"/&gt;
        &lt;ref:locator anchoridref="VIC_ACT_9595_FN1"&gt;
            &lt;ref:locator-key&gt;
                &lt;ref:key-name name="DOC-ID"/&gt; 
                &lt;ref:key-value value="0062-ABCD_1234"/&gt;
            &lt;/ref:locator-key&gt;
        &lt;/ref:locator&gt;        
        &lt;label&gt;1&lt;/label&gt;
    &lt;/footnote-ref&gt;&amp;#x00A0;    
&lt;/title&gt;

     &lt;!-- Footnote-reference-end --&gt;           
           
&lt;!--
...
endnotes/footnote/@role will always set to "endnote"
refpt/@id becomes footnote/ref:anchor/@id
remotelink/sub becomes footnote/label
--&gt;
&lt;primlaw:level xml:id="VIC_ACT_9595_NOTESPROV4" leveltype="clause" includeintoc="true" alternatetoccaption="4. List of Annotations"&gt;    
        &lt;heading&gt;
            &lt;!-- ... --&gt;
        &lt;/heading&gt;
        &lt;primlaw:bodytext&gt;
            &lt;table&gt;
                &lt;tgroup cols="2"&gt;
                    &lt;colspec colwidth="3*" colname="c1" colnum="1"/&gt;
                    &lt;colspec colwidth="12*" colname="c2" colnum="2"/&gt;
                    &lt;tbody&gt;
                        &lt;row&gt;&lt;entry colname="c1"&gt;S. 2 def. of &amp;quot;adult, community and further education&amp;quot;&lt;/entry&gt;&lt;entry colname="c2"&gt;inserted by No. 91/1991 s. 44(a).&lt;/entry&gt;
                            &lt;!--... --&gt; 
                    &lt;/tbody&gt;
                &lt;/tgroup&gt;
            &lt;/table&gt;
        &lt;/primlaw:bodytext&gt;
    &lt;!-- Endnote-start--&gt;
    &lt;endnotes&gt;
        &lt;footnote role="endnote"&gt;
            &lt;ref:returnreference&gt;
                &lt;ref:locator anchoridref="VIC_ACT_9595_FN1-R"/&gt;	
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt; 
                    &lt;ref:key-value value="0062-ABCD_1234"/&gt;
                &lt;/ref:locator-key&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:returnreference&gt;
            &lt;ref:anchor id="0062-VIC_ACT_9595_FN1" anchortype="global"/&gt;
            &lt;label&gt;1&lt;/label&gt;
            &lt;bodytext&gt;
                &lt;p&gt;&lt;text align="left"&gt;S. 6: Section&amp;#x00A0;50 of the &lt;emph typestyle="bf"&gt;Adult, Community and Further Education Act 1991&lt;/emph&gt;, No. 91/1991, provides as follows:&lt;/text&gt;&lt;/p&gt;
                &lt;p&gt;&lt;text align="left"&gt;&lt;emph typestyle="bf"&gt;'50. &lt;emph typestyle="it"&gt;Transitional provisions for the Council of Adult Education&lt;/emph&gt;&lt;/emph&gt;&lt;/text&gt;&lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/footnote&gt;
        &lt;!--rest of footnote@role=endnote --&gt;
    &lt;/endnotes&gt;
    &lt;!--Endnote-end --&gt;
&lt;/primlaw:level&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 3</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--Rosetta AU source markup for a reference to an endnote AUS-0065-20130614133539_VIC_REG_2012-14210020.xml--&gt;
   &lt;leg:level id="VIC_REG_2012-142_PROV4"&gt;
    - &lt;leg:level-vrnt searchtype="LEGISLATION" subdoc="true" leveltype="reg" toc-caption="4 Principal Rules"&gt;
        - &lt;leg:heading&gt;
            - &lt;desig searchtype="REG-NUM"&gt;
                - &lt;designum&gt;
                    &lt;refpt id="VIC_REG_2012-142_PROV4" type="ext" /&gt; 
                    &lt;emph typestyle="bf"&gt;4&lt;/emph&gt; 
                &lt;/designum&gt;
            &lt;/desig&gt;
            - &lt;title align="left" searchtype="REG-TITLE"&gt;
                &lt;emph typestyle="bf"&gt;Principal Rules&lt;/emph&gt; 
            &lt;/title&gt;
        &lt;/leg:heading&gt;
        - &lt;leg:levelbody&gt;
            - &lt;leg:bodytext&gt;
                - &lt;p&gt;
                    - &lt;text align="left"&gt;
                        In these Rules, the Supreme Court (General Civil Procedure) Rules 2005
                        
                        &lt;!-- Footnote-refernce-start --&gt;
                        &lt;refpt id="VIC_REG_2012-142_FN1-R" type="ext" /&gt; 
                        - &lt;remotelink remotekey1="REFPTID" service="DOC-ID" refpt="VIC_REG_2012-142_FN1" docidref="VIC_REG_2012-142_BODY"&gt;
                            &lt;sup&gt;1&lt;/sup&gt; 
                        &lt;/remotelink&gt;
                        
                        &lt;!-- Footnote-refernce-end --&gt;
                        are called the Principal Rules. 
                    &lt;/text&gt;
                &lt;/p&gt;
                - &lt;glp:note&gt;
                    &lt;!--Endnote-start --&gt;
                    - &lt;l&gt;
                        - &lt;li&gt;
                            - &lt;lilabel&gt;
                                &lt;refpt id="VIC_REG_2012-142_FN1" type="ext" /&gt; 
                                - &lt;remotelink remotekey1="REFPTID" service="DOC-ID" refpt="VIC_REG_2012-142_FN1-R" docidref="VIC_REG_2012-142_BODY"&gt;
                                    &lt;sup&gt;1&lt;/sup&gt; 
                                &lt;/remotelink&gt;
                            &lt;/lilabel&gt;
                            - &lt;p&gt;
                                &lt;text align="left"&gt;Rule 4: S.R. No. 148/2005. Reprint No. 4 as at 17 September 2012. Reprinted to S.R. No. 97/2012 and subsequently amended by S.R. Nos 39/2012 and 121/2012.&lt;/text&gt; 
                            &lt;/p&gt;
                        &lt;/li&gt;
                    &lt;/l&gt;
                    &lt;!--Endnote-end --&gt;
                &lt;/glp:note&gt;
            &lt;/leg:bodytext&gt;
        &lt;/leg:levelbody&gt;
    &lt;/leg:level-vrnt&gt;
&lt;/leg:level&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre>

&lt;!--
footnote-ref/@role will always be set to "endnote"
remotelink/@refpt becomes footnote-ref/@anchoridref
refpt/@id becomes footnote-ref/ref:anchor/@id
remotelink/sub becomes footnote-ref/label
--&gt;
   &lt;primlaw:level includeintoc="true" alternatetoccaption="4 Principal Rules"
    leveltype="regulation"&gt;
    &lt;ref:anchor id="VIC_REG_2012-142_PROV4" anchortype="global"/&gt;
    &lt;heading&gt;
        &lt;desig&gt;
            &lt;emph typestyle="bf"&gt;4&lt;/emph&gt;
        &lt;/desig&gt;
        &lt;title align="left"&gt;
            &lt;emph typestyle="bf"&gt;Principal Rules&lt;/emph&gt;
        &lt;/title&gt;
    &lt;/heading&gt;
    &lt;primlaw:bodytext&gt;
        &lt;p align="left"&gt;
            &lt;text&gt;In these Rules, the Supreme Court (General Civil Procedure) Rules
                2005
                &lt;!-- Footnote-refernce-start --&gt;
                &lt;footnote-ref anchoridref="VIC_REG_2012-142_FN1" role="endnote"&gt;
                    &lt;ref:anchor id="VIC_REG_2012-142_FN1-R"/&gt;
                    &lt;ref:locator anchoridref="VIC_REG_2012-142_FN1"&gt;
                        &lt;ref:locator-key&gt;&lt;ref:key-name name="DOC-ID"/&gt;
                            &lt;ref:key-value value="0065-VIC_REG_2012-142_BODY"
                            /&gt;
                        &lt;/ref:locator-key&gt;
                    &lt;/ref:locator&gt;
                    &lt;label&gt;1&lt;/label&gt;
                &lt;/footnote-ref&gt;
                 &lt;!-- Footnote-refernce-end --&gt;
                are called the Principal Rules.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/primlaw:bodytext&gt;
    &lt;!-- Endnote-start--&gt;
    &lt;endnotes&gt;
        &lt;footnote role="endnote"&gt;
            &lt;ref:returnreference&gt;
                &lt;ref:locator anchoridref="VIC_REG_2012142_FN1R"/&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt;
                    &lt;ref:key-value value="0065-VIC_REG_2012142_BODY"/&gt;
                &lt;/ref:locator-key&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:returnreference&gt;
            &lt;ref:anchor id="0065-VIC_REG_2012142_FN1" anchortype="global"/&gt;
            &lt;label&gt;1&lt;/label&gt; 
            &lt;bodytext&gt;
                &lt;p&gt;
                    &lt;text align="left"&gt;Rule 4: S.R. No. 148/2005. Reprint No. 4 as at 17 September 2012. Reprinted to S.R. No. 97/2012 and subsequently amended by S.R. Nos 39/2012 and 121/2012.&lt;/text&gt; 
                &lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/footnote&gt; 
    &lt;/endnotes&gt;
    &lt;!-- Endnote-end--&gt;
&lt;/primlaw:level&gt;

	</xd:pre>
         <!--Changes2016-11-16: Added to note regarding applying any rules related to 
                @anchoridref, referring specifically to section for "Identifiers to ID Data Type - 
                Handling Pattern Restrictions".2012-02-15: Created. 2012-09-05: Added to note for ref:locator/@anchoridref that begins with a number... Also apply other identifier data type format as
                used for xml:id and ref:anchor/@id
                (e.g. change colon to underscore).2012-10-03: Added another example for endnote handling.2013-10-07: Instruction and example for added for the Xpath leg:bodytext/glp:note/l/li related to endnote handling. WebTeam # is 238790.2013-12-18: Instruction added to convert remotelink/@refpt to footnote-ref/@anchoridref.  WebTeam #5158742 - AU04. Applies generally to all LBUs and streams.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_endnote-LxAdv-endnote.dita  -->
   <!-- JL 20171109: white-space proofed the test, with fallback to traditional remotelink processing.
    Also tightened up the criteria for refpt and remotelink matching to include the @refpt FN string,
    so the processing for refpt or remotelink will resort to default handling if all the criteria are not met.
    This fixes a few production webstars 
    -->
   <xsl:template match="refpt[         following-sibling::node()[1][self::remotelink[matches(@refpt , '^.*FN(\d+)\-R$') or matches(@refpt , '^.*FN(\d+)$')]]         or          preceding-sibling::node()[1][self::remotelink[matches(@refpt , '^.*FN(\d+)\-R$') or matches(@refpt , '^.*FN(\d+)$')]]         or          preceding-sibling::node()[1][self::text()[matches(. , '^\s+$')]         [preceding-sibling::node()[1][self::remotelink[matches(@refpt , '^.*FN(\d+)\-R$') or matches(@refpt , '^.*FN(\d+)$')]]]]         or          following-sibling::node()[1][self::text()[matches(. , '^\s+$')]         [following-sibling::node()[1][self::remotelink[matches(@refpt , '^.*FN(\d+)\-R$') or matches(@refpt , '^.*FN(\d+)$')]]]]                 ]"
                 priority="30"><!-- do nothing --></xsl:template>
   <!-- note: this logic will need to be merged with "remotelink" 
                
                JL made it node rather than element because there can be intervening text, and we don't want to do
                this with intervening text.-->
   <xsl:template match="remotelink[matches(@refpt , '^.*FN(\d+)\-R$') or matches(@refpt , '^.*FN(\d+)$')]         [preceding-sibling::node()[1][self::refpt]         or         following-sibling::node()[1][self::refpt]         or         preceding-sibling::node()[1][self::text()[matches(. , '^\s+$')][preceding-sibling::node()[1][self::refpt]]]         or         following-sibling::node()[1][self::text()[matches(. , '^\s+$')][following-sibling::node()[1][self::refpt]]]        ]"
                 priority="30">
      <xsl:choose>
         <xsl:when test="matches(@refpt , '^.*FN(\d+)\-R$')">
            <xsl:apply-templates select="." mode="endnote"/>
         </xsl:when>
         <xsl:when test="matches(@refpt , '^.*FN(\d+)$')">
            <xsl:apply-templates select="." mode="footnoteref"/>
         </xsl:when>
         <xsl:otherwise><!-- this should now never happen -->
            <xsl:call-template name="outputErrorMessage">
               <xsl:with-param name="messageText"
                               as="xs:string"
                               select=" 'remotelink/@refpt does not meet criteria for endnote or footnoteref' "/>
               <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
               <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
               <xsl:with-param name="context" as="xs:string">
                  <xsl:value-of select="base-uri()"/>
               </xsl:with-param>
            </xsl:call-template>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="remotelink" mode="footnoteref">
      <footnote-ref>
         <xsl:attribute name="role" select="'endnote'"/>
         <xsl:attribute name="anchoridref">
            <xsl:for-each select="@refpt">
               <xsl:call-template name="normalizeIdString"/>
            </xsl:for-each>
         </xsl:attribute>
         <xsl:for-each select="preceding-sibling::node()[1][self::refpt] | following-sibling::node()[1][self::refpt]">
            <xsl:call-template name="refpt-generic"/>
         </xsl:for-each>
         <xsl:call-template name="locator"/>
         <xsl:apply-templates select="sup" mode="footnoteref"/>
      </footnote-ref>
   </xsl:template>

   <xsl:template name="locator">
      <ref:locator>
         <xsl:for-each select=" if (@refpt) then @refpt else @remotekey2">
            <xsl:attribute name="anchoridref">
               <xsl:call-template name="normalizeIdString"/>
            </xsl:attribute>
         </xsl:for-each>
         <ref:locator-key>
            <ref:key-name name="DOC-ID"/>
            <ref:key-value>
               <xsl:attribute name="value">
                  <xsl:choose>
                     <xsl:when test="@dpsi">
                        <xsl:value-of select="@dpsi"/>
                     </xsl:when>
                     <xsl:when test="//docinfo:dpsi/@id-string">
                        <xsl:value-of select="//docinfo:dpsi/@id-string"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:value-of select="$dpsi"/>
                     </xsl:otherwise>
                  </xsl:choose>
                  <xsl:text>-</xsl:text>
                  <xsl:choose>
                     <xsl:when test=" @remotekey1 = 'DOC-ID' or @remotekey1 = 'DOCID' ">
                        <xsl:value-of select="if (@remotekey2) then @remotekey2 else @refpt"/>
                     </xsl:when>
                     <xsl:when test=" @remotekey1 = 'REFPTID' or @remotekey1 = 'REFPT' ">
                        <xsl:choose>
                           <xsl:when test="@docidref">
                              <xsl:value-of select="@docidref"/>
                           </xsl:when>
                           <xsl:when test="@status=('unval','invalid')"><!-- no @docidref however status is unvalidated or invalid so don't throw error  --></xsl:when>
                           <xsl:otherwise><!-- This should be an error message -->
                              <xsl:text>XXXX</xsl:text>
                              <xsl:call-template name="outputErrorMessage">
                                 <xsl:with-param name="messageText"
                                                 as="xs:string"
                                                 select=" 'remotelink/@docidref is missing and link cannot be correctly completed' "/>
                                 <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                                 <xsl:with-param name="errorCode" as="xs:string*" select=" '403' "/>
                                 <xsl:with-param name="context" as="xs:string">
                                    <xsl:value-of select="base-uri()"/>
                                 </xsl:with-param>
                              </xsl:call-template>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:when>
                  </xsl:choose>
               </xsl:attribute>
            </ref:key-value>
         </ref:locator-key>
      </ref:locator>
   </xsl:template>

   <xsl:template match="remotelink" mode="endnote">
      <footnote>
         <xsl:attribute name="role" select="'endnote'"/>
         <!-- Paul: moved the refanchor creation (foreach) before the ref:returnreference.
            The court rules schema (and statutory) requires this occur first.  -->
         <xsl:for-each select="preceding-sibling::refpt | following-sibling::refpt">
            <xsl:call-template name="refpt-generic"/>
         </xsl:for-each>
         <ref:returnreference>
            <xsl:call-template name="locator"/>
         </ref:returnreference>
         <xsl:apply-templates select="sup | sub" mode="footnoteref"/>
         <xsl:if test="parent::lilabel[following-sibling::node()]">
            <bodytext>
               <xsl:apply-templates select="parent::lilabel/following-sibling::node()"/>
            </bodytext>
         </xsl:if>
      </footnote>
   </xsl:template>

   <xsl:template match="sup | sub" mode="footnoteref">
      <label>
         <xsl:apply-templates/>
      </label>
   </xsl:template>

   <xsl:template match="l[li[lilabel[refpt][remotelink][not(child::*[3])]]][not(child::*[not(self::li[lilabel[refpt][remotelink][not(child::*[3])]])])][not(@virtual-nesting)]"
                 priority="30">
      <endnotes>
         <xsl:apply-templates select="li" mode="endnote"/>
      </endnotes>
   </xsl:template>

   <xsl:template match="li" mode="endnote">
      <xsl:apply-templates select="lilabel" mode="endnote"/>
   </xsl:template>

   <xsl:template match="lilabel" mode="endnote">
      <xsl:apply-templates select="remotelink" mode="endnote"/>
   </xsl:template>
   <!-- endnotes become a bump-up within primlaw:level (within and outside of glp:note) as well as leg:comntry
   Since I coded this for a dictionary stream, it hasn't been tested yet.  Someone with a 
   legislation stream should test it and sign off here. JL 
   
   JD: 2017-08-10: works for legislation stream NZ06; see notes in /modules/glp/Rosetta_glp.note-LxAdv-note.xsl
   -->
   <xsl:template match="leg:bodytext" priority="30"><!-- this will handle annotations interspersed with primlaw:bodytext elements in document order -->
      <xsl:for-each-group select="*"
                          group-adjacent="if (self::leg:comntry or self::l[li[lilabel[refpt][remotelink][not(child::*[3])]]][not(child::*[not(self::li[lilabel[refpt][remotelink][not(child::*[3])]])])][not(@virtual-nesting)]              or self::glp:note[l[li[lilabel[refpt][remotelink][not(child::*[3])]]][not(child::*[not(self::li[lilabel[refpt][remotelink][not(child::*[3])]])])][not(@virtual-nesting)]]             ) then 0 else 1">
         <xsl:choose>
            <xsl:when test="current-grouping-key()=0">
               <xsl:for-each select="current-group()">
                  <xsl:choose>
                     <xsl:when test="self::glp:note">
                        <xsl:apply-templates select="*"/>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates select="."/>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:for-each>
            </xsl:when>
            <xsl:otherwise>
               <xsl:choose>
                  <xsl:when test="$streamID='AU19LA' or ($streamID=('NZ12') and not(ancestor::legfragment))">
                     <admindoc:bodytext>
                        <xsl:apply-templates select="parent::leg:bodytext/@*"/>
                        <xsl:for-each select="current-group()">
                           <xsl:apply-templates select="."/>
                        </xsl:for-each>
                     </admindoc:bodytext>
                  </xsl:when>
                  <xsl:when test="$streamID='AU18' and not(ancestor::legfragment)">
                     <xsl:choose>
                        <xsl:when test="parent::leg:bodytext[preceding-sibling::leg:level]">
                           <xsl:element name="admindoc:level">
                              <xsl:attribute name="leveltype">
                                 <xsl:text>unclassified</xsl:text>
                              </xsl:attribute>
                              <admindoc:bodytext>
                                 <xsl:apply-templates select="parent::leg:bodytext/@*"/>
                                 <xsl:for-each select="current-group()">
                                    <xsl:apply-templates select="."/>
                                 </xsl:for-each>
                              </admindoc:bodytext>
                           </xsl:element>
                        </xsl:when>
                        <xsl:otherwise>
                           <admindoc:bodytext>
                              <xsl:apply-templates select="parent::leg:bodytext/@*"/>
                              <xsl:for-each select="current-group()">
                                 <xsl:apply-templates select="."/>
                              </xsl:for-each>
                           </admindoc:bodytext>
                        </xsl:otherwise>
                     </xsl:choose>
                  </xsl:when>
                  <xsl:otherwise>
                     <primlaw:bodytext>
                        <xsl:apply-templates select="parent::leg:bodytext/@*"/>
                        <xsl:for-each select="current-group()">
                           <xsl:apply-templates select="."/>
                        </xsl:for-each>
                     </primlaw:bodytext>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each-group>
   </xsl:template>
   <!-- This template is being suppressed as no requirement in the output. -->
   <xsl:template match="leg:bodytext/@searchtype[$streamID='UK06']"/>
   <!-- start topichead  figure  -->   <!-- <topicref href="../../common_newest/Rosetta_figure-LxAdv-figure.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                            <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>figure</xd:i> becomes <xd:b>figure</xd:b>. The children of
                    <xd:i>figure</xd:i> are handled as follows:<xd:ul>
               <xd:li>
                  <xd:i>caption</xd:i> becomes <xd:b>caption</xd:b>. The
                        content inside <xd:i>caption</xd:i> should be mapped to
                            <xd:b>caption/p/text</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> becomes
                            <xd:b>ref:inlineobject</xd:b>. See <xd:a href="../common_newest/Rosetta_inlineobject-LxAdv-figure_ref.inlineobject.dita"/> for details.</xd:li>
               <xd:li>
                  <xd:i>link</xd:i> becomes
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b>. See General
                        Markup section for details.</xd:li>
               <!-- Did not use xref markup for link-to-ref:lnlink instruction because some CIs have figure module but not link module, e.g. CA06-Regulations. McNally Mar 20 2014. -->
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>In NewLexis <xd:b>figure</xd:b> is not allowed within
                        <xd:b>blockquote</xd:b> element. If <xd:i>figure</xd:i>
                    element is a direct child of <xd:i>blockquote</xd:i> element and
                        <xd:i>figure</xd:i> element does not have any sibling element in
                        <xd:i>blockquote</xd:i> element, then drop the outer
                        <xd:i>blockquote</xd:i> element in NewLexis.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>
               <xd:b>
                  <xd:i>figure/glp:note/h</xd:i> becomes
                            <xd:b>figure/note/bodytext/h</xd:b> in NewLexis.</xd:b>
            </xd:p>
            <xd:p>If <xd:i>figure/p</xd:i> becomes
                        <xd:b>figure/note/bodytext/p</xd:b> in NL conversion.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Example 1</xd:b>
         </xd:p>
         <xd:pre>
&lt;blockquote&gt;
    &lt;figure&gt;
        &lt;glp:note&gt;
            &lt;h&gt;(MAB PROGRAMME STRUCTURE)&lt;/h&gt;
        &lt;/glp:note&gt;
        &lt;inlineobject type="image" attachment="ln-server" filename="pbep-g00121.gif"/&gt;
    &lt;/figure&gt;
&lt;/blockquote&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>                    
&lt;figure&gt;
    &lt;note&gt;
        &lt;bodytext&gt;
            &lt;h&gt;(MAB PROGRAMME STRUCTURE)&lt;/h&gt;
        &lt;/bodytext&gt;
    &lt;/note&gt;
    &lt;ref:inlineobject&gt;
        &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="object-key"/&gt;
                    &lt;ref:key-value value="X-Y-pbep-g00121"/&gt;    &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
                &lt;proc:param name="componentseq" value="1"/&gt;
                &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                &lt;proc:param name="object-smi" value=""/&gt;    &lt;!-- This @value assignment is done by conversion program --&gt;
            &lt;/ref:locator-params&gt;
        &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
&lt;/figure&gt;
            </xd:pre>
         <xd:p>
            <xd:b>Example 2</xd:b>
         </xd:p>
         <xd:pre>
&lt;figure&gt;
    &lt;inlineobject filename="1484985_RSOS_913_CURRENT-0001.jpg" type="image" attachment="ln-server"/&gt;
&lt;/figure&gt;

            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>                    
&lt;figure&gt;                   
    &lt;ref:inlineobject&gt;
        &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
                &lt;ref:key-name name="object-key"/&gt;
                &lt;ref:key-value value="X-Y-1484985-RSOS-913-CURRENT-0001"/&gt;  &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
                &lt;proc:param name="componentseq" value="1"/&gt;
                &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png)--&gt;
                &lt;proc:param name="object-smi" value=""/&gt;    &lt;!-- This @value assignment is done by conversion program --&gt;
            &lt;/ref:locator-params&gt;
        &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
&lt;/figure&gt;
            </xd:pre>
         <xd:p>
            <xd:b>Example 3</xd:b>
         </xd:p>
         <xd:pre>
&lt;figure&gt;
    &lt;caption&gt;Head of PSL IP&amp;amp;IT&lt;/caption&gt;
    &lt;inlineobject filename="Lawrence Milner.jpg"/&gt;
&lt;/figure&gt;
            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>                    
&lt;figure&gt;
    &lt;caption&gt;
        &lt;p&gt;
            &lt;text&gt;Head of PSL IP&amp;amp;IT&lt;/text&gt;
        &lt;/p&gt;
    &lt;/caption&gt;
    &lt;ref:inlineobject&gt;
        &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
                &lt;ref:key-name name="object-key"/&gt;
                &lt;ref:key-value value="X-Y-Lawrence Milner"/&gt;
                &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
                &lt;proc:param name="componentseq" value="1"/&gt;
                &lt;proc:param name="object-type" value="image"/&gt;
                &lt;proc:param name="object-smi" value=""/&gt;
                &lt;!-- This @value assignment is done by conversion program --&gt;
            &lt;/ref:locator-params&gt;
        &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
&lt;/figure&gt;
            </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:i>figure/p/text/inlineobject</xd:i> becomes
                <xd:b>figure/ref:inlineobject</xd:b>, omit p/text from output if
                <xd:i>figure/p/text/</xd:i> having only
                <xd:i>inlineobject</xd:i> as single child and no PCDATA within
                <xd:i>text</xd:i>. </xd:p>
         <xd:p>
            <xd:b>Example 4</xd:b>
         </xd:p>
         <xd:pre>

&lt;figure&gt;
   &lt;p&gt;
       &lt;text&gt;
               &lt;inlineobject type="image" filename="eu-tracker_band_of_flags.jpg"/&gt;
       &lt;/text&gt;
   &lt;/p&gt;
&lt;/figure&gt;

            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>                    

&lt;figure&gt;
    &lt;ref:inlineobject&gt;
        &lt;ref:locator&gt;
            &lt;ref:locator-key&gt;
                &lt;ref:key-name name="object-key"/&gt;
                &lt;ref:key-value value="X-Y-eu-tracker_band_of_flags"/&gt;
                &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
            &lt;/ref:locator-key&gt;
            &lt;ref:locator-params&gt;
                &lt;proc:param name="componentseq" value="1"/&gt;
                &lt;proc:param name="object-type" value="image"/&gt;
                &lt;proc:param name="object-smi" value=""/&gt;
                &lt;!-- This @value assignment is done by conversion program --&gt;
            &lt;/ref:locator-params&gt;
        &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
&lt;/figure&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Example 5. child <xd:i>link</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;figure&gt;
    &lt;link type="image" filename="HSWT-THS-W11037A.tif"&gt;Click here to view image&lt;/link&gt;
&lt;/figure&gt;


            </xd:pre>
         <xd:b>becomes</xd:b>
         <xd:pre>                    

&lt;figure&gt;
   &lt;ref:lnlink service="ATTACHMENT"&gt;
      &lt;ref:marker role="label"&gt;Click here to view image&lt;/ref:marker&gt;
      &lt;ref:locator&gt;
         &lt;ref:locator-key&gt;
            &lt;ref:key-name name="attachment-key"/&gt;
            &lt;ref:key-value value="X-Y-HSWT-THS-W11037A"/&gt;
            &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
         &lt;/ref:locator-key&gt;
         &lt;ref:locator-params&gt;
            &lt;proc:param name="componentseq" value="1"/&gt;
            &lt;proc:param name="attachment-type" value="image"/&gt;
            &lt;proc:param name="attachment-smi" value=""/&gt;
            &lt;!-- @value populated with SMI obtained from CSSM --&gt;
         &lt;/ref:locator-params&gt;
      &lt;/ref:locator&gt;
   &lt;/ref:lnlink&gt;
&lt;/figure&gt;

            </xd:pre>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate
                    image handling. Note summarizes move from Apollo to Blobstore application. UK is
                    first LBU to move to Blobstore.2014-10-28: Moved instruction regarding the XPath XPath
                        caption/note into a separate topic. Not a rule
                    change, just a minor reorganization of the instructions.2014-10-24: Added instructions and example to handle the
                    new XPath caption/note. (R4.5 Content Issue List
                    #1993)2014-03-20: Illustrative change. Added example to
                    explicitly show standard conversion of child link to ref:lnlink. Prompted by
                    Phase 6 UK Discussion Item 77. Webteam 252434.2013-10-23: Added instruction for handling
                    figure/p/text/inlineobject Webteam # 2398162013-07-15: Added instructions for handling
                    figure/caption and an example demonstrating the mapping.2013-05-08: Extended the list of allowable values for
                    image handling.2013-05-01: Removed instructions for section
                        "Pre-Release 4.0" because according to latest Apollo markup, section
                        "Release 4.0 and after" and section "Pre-Release 4.0" now have
                    similar conversion markup.2013-04-30: Updated target sample according to latest
                    Apollo markup.2013-02-18: Created two sections, one for "Release 4.0
                        and after" and another for "Pre-Release 4.0".2013-02-18: Target example updated per inlineobject instructions.2013-01-11: Example added for figure/inlineobject scenario.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="figure">
      <xsl:choose>
         <xsl:when test="$streamID='UK06'">
            <xsl:choose>
               <xsl:when test="p/text[not(child::node() except inlineobject)]">
                  <xsl:element name="figure">
                     <xsl:apply-templates select="p/text/inlineobject | (node() except p[text[not(child::node() except inlineobject)]])"/>
                  </xsl:element>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:element name="figure">
                     <xsl:apply-templates select="@*|node()"/>
                  </xsl:element>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:when test="$streamID='AU15'">
            <figure>
               <xsl:apply-templates select="node()"/>
            </figure>
         </xsl:when>
         <!--Ravikant: 2018-03-09: added the when condition for the stream ID MY02 -->
         <xsl:when test="$streamID='MY02'">
            <figure>
               <xsl:apply-templates select="caption"/>
               <xsl:apply-templates select="node() except caption"/>
            </figure>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="figure">
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="caption[not(preceding-sibling::*[1][self::caption])]">
      <xsl:element name="caption">
         <xsl:element name="p">
            <xsl:element name="text">
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:element>
         <xsl:apply-templates select="following-sibling::*[1][self::caption]" mode="caption_wrapper"/>
         <!-- JD: 2017-11-13: apply 'caption_wrapper' mode for follwing p elements that do not contain links/inlineobjects (Note: not limited to first sibling p). Limited to UK08OR for now. -->
         <xsl:apply-templates select="following-sibling::*[self::p[not(text/link or text/inlineobject)]][$streamID='UK08OR']"
                              mode="caption_wrapper"/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="caption[preceding-sibling::*[1][self::caption]]"
                 mode="caption_wrapper">
      <xsl:element name="p">
         <xsl:element name="text">
            <xsl:apply-templates/>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- JD: 2017-11-13: new mode 'caption_wrapper' for p siblings of caption that do not contain link or inlineobject (Note: not limited to first sibling p).  Limited to UK08OR for now.  -->
   <xsl:template match="p[not(text/inlineobject) or not(text/link)][preceding-sibling::*[self::caption]][$streamID='UK08OR']"
                 mode="caption_wrapper">
      <xsl:element name="p">
         <xsl:element name="text">
            <xsl:apply-templates/>
         </xsl:element>
      </xsl:element>
   </xsl:template>

   <xsl:template match="caption[preceding-sibling::*[1][self::caption]]"/>
   <!-- JD: 2017-11-13: suppress p when contents have been processed by mode 'caption_wrapper' for p siblings of caption that do not contain link or inlineobject (Note: not limited to first sibling p).  Limited to UK08OR for now.  -->
   <xsl:template match="figure/p[preceding-sibling::*[self::caption]][not(text/inlineobject or text/link)][$streamID='UK08OR']"
                 priority="21"/>

   <xsl:template match="figure/p" priority="20">
      <xsl:for-each-group select="*"
                          group-adjacent="if (self::heading or self::inlineobject or self::link           or self::text[not(child::*[not(self::heading or self::inlineobject or self::link)])]) then 0 else 1">
         <xsl:variable name="pVariable">
            <xsl:copy-of select="."/>
         </xsl:variable>
         <xsl:choose>
            <xsl:when test="current-grouping-key()=1">
               <note>
                  <bodytext>
                     <p>
                        <xsl:apply-templates select="$pVariable/p/@*"/>
                        <xsl:apply-templates select="current-group()"/>
                     </p>
                  </bodytext>
               </note>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="current-group()"/>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each-group>
   </xsl:template>

   <xsl:template match="figure/p/text" priority="20">
      <xsl:choose>
         <xsl:when test="parent::p[child::*[not(self::heading or self::inlineobject or self::link or                      self::text[not(child::*[not(self::heading or self::inlineobject or self::link)])])]]">
            <text>
               <xsl:apply-templates select="@* | node()"/>
            </text>
         </xsl:when>
         <xsl:otherwise>
            <xsl:apply-templates/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Vikas Rohilla : Updated for the streamID CA01   -->
   <xsl:template match="figure[child::p[child::text[child::inlineobject]]][$streamID='CA01' or $streamID='CA15']">
      <xsl:apply-templates select="descendant::inlineobject"/>
   </xsl:template>
   <!-- JD: 2017-11-27: updated for Web* 7054824.
  Limiting to certain streams for now, but may be more broadly applicable.  UK08 only mentions glp:note/h in this file (id-CCCC-10320), but glp:note has no handling.  Inferring from CI example.
  -->
   <xsl:template match="glp:note[$streamID='UK08OR']">
      <note>
         <bodytext>
            <xsl:apply-templates/>
         </bodytext>
      </note>
   </xsl:template>
   <!--<topicref href="../../common_newest/Rosetta_glp.note-Chof-figure-LxAdv-figure.dita"/>-->   <!-- end topichead  figure  -->   <!-- rosetta element: footnote -->   <!-- <topicref href="../../common_newest/Rosetta_footnote-LxAdv-footnote.dita"/> -->   <xd:doc>
      <xd:desc><!-- McNally June 9 2014. Commented-out the CA02 rule added at end of module. See below for details. -->
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>The source document has footnote references, footnotegrps and footnotes. In the
                    NL schema, footnote references, footnotegroup and footnotes are tagged at the
                    same location where they appear in the source document. </xd:p>
         <xd:p>The <xd:b>footnote</xd:b> markup for NL schema as described below: <xd:ul>
               <xd:li>
                  <xd:p>The <xd:i>footnotegrp/footnote</xd:i> becomes
                                    <xd:b>footnotegroup/footnote</xd:b>
                  </xd:p>
                  <xd:p>The <xd:i>footnotegrp/heading</xd:i> becomes
                                    <xd:b>footnotegroup/heading</xd:b>. </xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is the child of
                                    <xd:i>bodytext</xd:i>, then it becomes
                                    <xd:b>bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is the child of
                                    <xd:i>leg:bodytext</xd:i>, then it becomes
                                    <xd:b>primlaw:bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>level/bodytext</xd:i>,
                                    <xd:i>level/bodytext</xd:i> mapped with
                                    <xd:b>seclaw:level/seclaw:bodytext</xd:b> and
                                    <xd:b>primlaw:level/primlaw:bodytext</xd:b> in
                                different content model. Then follow below listed instructions: <xd:ul>
                        <xd:li>
                           <xd:b>Regulation:</xd:b>
                           <xd:b>primlaw:level/primlaw:bodytext/p/text/footnotegroup</xd:b>.</xd:li>
                        <xd:li>
                           <xd:b>Commentary, Form, Precedents and Textbooks:</xd:b>
                           <xd:b>seclaw:level/seclaw:bodytext/p/text/footnotegroup</xd:b>
                                        and
                                            <xd:b>form:form/form:document/form:bodytext/form:p/form:text/footnotegroup</xd:b>.</xd:li>
                     </xd:ul>
                  </xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:judgments</xd:i>, then it becomes
                                    <xd:b>courtcase:opinions/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:judgmentbody</xd:i>, then it becomes
                                    <xd:b>courtcase:opinion/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:headnote</xd:i>, then it becomes
                                    <xd:b>courtcase:head/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:decisionsummary</xd:i>, then it becomes
                                    <xd:b>casesum:decisionsummary/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:factsummary</xd:i>, then it becomes
                                    <xd:b>casesum:editorialsummary/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:references</xd:i>, then it becomes
                                    <xd:b>ref:relatedrefs/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:typeofcase</xd:i>, then it becomes
                                    <xd:b>casesum:overview/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>p</xd:i>, then it becomes
                                    <xd:b>p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>glp:note</xd:i>, then it becomes
                                    <xd:b>note/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>blockquote</xd:i>, then it becomes
                                    <xd:b>blockquote/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>li</xd:i>, then it becomes
                                    <xd:b>listitem/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>pgrp</xd:i>, then it becomes
                                    <xd:b>pgrp/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:appendix</xd:i>, then it becomes
                                    <xd:b>appendix/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:consideredcases</xd:i>, then it becomes
                                    <xd:b>ref:relatedrefs/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>case:priorhist</xd:i>, then it becomes
                                    <xd:b>casehist:summary/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>note</xd:i>, then it becomes
                                    <xd:b>note/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>prelim</xd:i>, then it becomes
                                    <xd:b>courtcase:prelim/bodytext/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>catchwordgrp</xd:i>, then it becomes
                                    <xd:b>classify:classification
                                    classify:classitem/classify:classitem-identifier/classify:classname/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>sigblock</xd:i>, then it becomes
                                    <xd:b>sigblock/p/text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>frm:body</xd:i>, then it becomes
                                    <xd:b>form:document/form:bodytext/form:p/form:text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>clause</xd:i>, then it becomes
                                    <xd:b>form:clause/form:bodytext/form:p/form:text/footnotegroup</xd:b>.</xd:p>
                  <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                                    <xd:i>frm:div</xd:i>, then it becomes
                                    <xd:b>form:div/form:bodytext/form:p/form:text/footnotegroup</xd:b>.</xd:p>
               </xd:li>
               <xd:li> Create <xd:b>footnote/ref:anchor</xd:b> with
                                <xd:b>@id</xd:b> and set
                                <xd:b>footnote/ref:anchor[@id]</xd:b> to the value of
                                <xd:i>footnote[@fntoken]</xd:i>.
                                    <xd:p>
                     <xd:b>Note: </xd:b>
                     <xd:b>ref:anchor[@id]</xd:b> that begins with a
                                number must have an underscore added at start.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>
                     <xd:p>This note is applicable only to <xd:b>UK footnotes with a value of
                                        "0" in <xd:i>footnote/@fntoken</xd:i>
                        </xd:b> (all
                                    content types within UK): For every
                                        <xd:i>footnote[@fntoken="0"]</xd:i>, a unique
                                    value should be placed in the target
                                        <xd:b>ref:anchor/@id</xd:b>. Numeric values in
                                        <xd:b>ref:anchor/@id</xd:b> must be prepended with
                                    "_". Any unique values are acceptable inside
                                        <xd:b>ref:anchor/@id</xd:b>, but the simplest
                                    solution is to start with <xd:b>&lt;ref:anchor
                                        id="_1"/&gt;</xd:b> for the first footnote encountered
                                    and increment the value by 1 for each subsequent footnote (e.g.
                                        <xd:b>&lt;ref:anchor id="_1"/&gt;</xd:b>,
                                        <xd:b>&lt;ref:anchor id="_2"/&gt;</xd:b>,
                                        <xd:b>&lt;ref:anchor id="_3"/&gt;</xd:b>,
                                    etc.)</xd:p>
                     <xd:p>If the value of
                                        <xd:b>ref:anchor/@id</xd:b> is not "0", then it
                                    should be carried through to
                                        <xd:b>ref:anchor/@id</xd:b> as is. </xd:p>
                  </xd:p>
               </xd:li>
               <xd:li>Drop attribute <xd:i>@fnrtokens</xd:i> and
                                <xd:i>@fntoken</xd:i> from the
                                <xd:i>footnote</xd:i> element, but note as described above
                            that the source <xd:i>footnote[@fntoken]</xd:i> value is moved
                            to the target <xd:b>footnote/ref:anchor[@id]</xd:b>
               </xd:li>
               <xd:li>Create <xd:b>ref:returnreference/reflocator</xd:b>.<xd:ul>
                     <xd:li>
                        <xd:b>@anchoridref</xd:b> is set to the id value of
                                    the first reference to this footnote. For example,
                                        <xd:b>footnote/ref:anchor[@id="_1"]</xd:b>, will
                                    use the value
                                        from<xd:b>((//footnote-ref[@anchoridref="_1"])[1])/ref:anchor/@id</xd:b>.<xd:p>
                           <xd:b>Note: </xd:b>If
                                        the return reference ID cannot be located, it is not
                                        necessary to create the
                                            <xd:b>ref:returnreference</xd:b>.</xd:p>
                     </xd:li>
                     <xd:li>
                        <xd:b>@anchortype</xd:b> is set to "local" </xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>footnote/fnlabel</xd:i> becomes
                                <xd:b>footnote/label</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>footnote/fnbody</xd:i> becomes
                                <xd:b>footnote/bodytext</xd:b>.<xd:ul>
                     <xd:li>
                        <xd:b>Special Canada rule to suppress indent:</xd:b>
                        <xd:i>footnote/fnbody/p[@indent]</xd:i> becomes
                                        <xd:b>footnote/bodytext/p</xd:b>. That is,
                                    suppress <xd:i>@indent</xd:i> for all Canada streams.
                                    (Note that attribute <xd:i>p[@i]</xd:i> is also
                                    suppressed, as per General Markup rules for
                                        <xd:i>p</xd:i>).</xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>footnote/@type</xd:i> becomes
                                <xd:b>footnote/@role</xd:b> unless the value of
                                <xd:i>footnote/@type</xd:i> is "default" or "annotation",
                            in which case <xd:i>footnote/@type</xd:i> is suppressed and
                                <xd:b>footnote/@role</xd:b> is not generated.</xd:li>
               <xd:li>
                  <xd:p>If <xd:i>footnote/fnbody</xd:i> contains
                                    <xd:i>p/refpt</xd:i> and the value of
                                    <xd:i>refpt/@id</xd:i> is the same as the value of
                                    <xd:i>footnote/@fntoken</xd:i>, then the
                                    <xd:i>refpt</xd:i> should be suppressed because a
                                    <xd:b>ref:anchor</xd:b> with the same value in
                                    <xd:b>@id</xd:b> is created as child of the target
                                    <xd:b>footnote</xd:b>
                  </xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>If <xd:i>footnote</xd:i> appears without
                                    <xd:i>fnr</xd:i> the footnote contents should still be
                                output as <xd:b>footnote</xd:b>.</xd:p>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>The <xd:b>fnr</xd:b> markup for NL schema as described below: <xd:ul>
               <xd:li>
                  <xd:i>fnr</xd:i> becomes
                            <xd:b>footnote-ref</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>@fntoken</xd:i> becomes
                                <xd:b>@anchoridref</xd:b>. </xd:li>
               <xd:li>
                  <xd:i>@fnrtoken</xd:i> becomes
                                <xd:b>footnote-ref/ref:anchor[@id]</xd:b> the value must
                            be unique.</xd:li>
               <xd:li>The <xd:i>fnr</xd:i> content becomes
                                <xd:b>label</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>fnr/@id</xd:i> becomes
                                <xd:b>footnote-ref/@xml:id</xd:b>. <xd:p>
                     <xd:b>Note: </xd:b>All
                                    <xd:b>xml:id</xd:b> attributes that begin with a
                                number must have an underscore added at start.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>
                     <xd:b>@anchoridref</xd:b> that begins with a number must
                                have an underscore added at start. Also apply other identifier data
                                type format as used for <xd:b>xml:id</xd:b> and
                                    <xd:b>ref:anchor/@id</xd:b> (e.g. change colon to
                                underscore).</xd:p>
               </xd:li>
               <xd:li>
                  <xd:i>fnr/@alt-label</xd:i> should be suppressed from
                            conversion because this attribute is already deprecated in the DTD
                            itself.</xd:li>
               <xd:li>
                  <xd:p>If input documents is having scenario
                                    <xd:i>leg:bodytext/fnr</xd:i> then it becomes
                                    <xd:b>primlaw:bodytext/textitem/footnote-ref</xd:b>.</xd:p>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p> Use the <xd:b>matching criteria</xd:b> below to ensure hyperlinks are working: <xd:ul>
               <xd:li>
                  <xd:p>Use the <xd:i>@fnrtoken</xd:i> attribute to match the
                                source footnote reference indicated by <xd:i>fnr</xd:i>
                                with the actual source footnote content contained in the
                                    <xd:i>footnote</xd:i>.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>If appears without <xd:i>footnote</xd:i> then conversion
                                need to put the reference <xd:b>(fnr)</xd:b> in an xml comment along with
                                this note: <xd:b>
                        <xd:i> footnote reference without footnote is a data
                                        error.</xd:i>
                     </xd:b>.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:p>If <xd:i>fnr</xd:i> is empty, then it should be
                                suppressed.</xd:p>
               </xd:li>
               <xd:li><!-- MDS 2017-05-05 - Also found in UK08CA -->
                  <xd:b>Exceptional scenario for UK22CS:</xd:b> Supress
                                <xd:i>@type="editorial"</xd:i> attribute from
                                <xd:i>footnote</xd:i> element in target. <xd:p>
                     <xd:b>Note: </xd:b>This
                                instruction should be revisited and possibly changed if editorial
                                is actually used more appropriately in the future.</xd:p>
               </xd:li>
               <xd:li>
                  <xd:i>lilabel/fnr</xd:i> becomes
                                <xd:b>label/footnote-ref</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>If <xd:i>footnotegrp</xd:i> is a child of
                        <xd:i>legfragment</xd:i>, then it becomes
                        <xd:b>primlaw:excerpt/primlaw:bodytext/p/text/footnotegroup</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;pnum count="2"&gt;[2]&lt;/pnum&gt; &lt;refpt
                    id="20101NZLR_297_p2" type="ext"/&gt; &lt;text&gt;Part2 of the Commerce Act
                    prohibits various restrictive practices, namely practices substantially
                    lessening competition, &lt;fnr fnrtoken="fnr-20101NZLR_297-1"
                    fntoken="fn-20101NZLR_297-1"&gt;1&lt;/fnr&gt; price fixing &lt;/text&gt;
                    &lt;/p&gt; .... &lt;footnotegrp&gt; &lt;footnote fnrtokens="fnr-20101NZLR_297-1"
                    fntoken="fn-20101NZLR_297-1"&gt; &lt;fnlabel&gt;1&lt;/fnlabel&gt; &lt;fnbody&gt;
                    &lt;p&gt; &lt;text&gt;Sections27 &amp;#x2013; 29.&lt;/text&gt; &lt;/p&gt;
                    &lt;/fnbody&gt; &lt;/footnote&gt; &lt;/footnotegrp&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;ref:anchor id="_20101NZLR_297_p2" anchortype="global"/&gt;
                    &lt;desig value="2"&gt;[2]&lt;/desig&gt; &lt;text&gt;Part2 of the Commerce Act
                    prohibits various restrictive practices, namely practices substantially
                    lessening competition, &lt;footnote-ref anchoridref="fn-20101NZLR_297-1"&gt;
                    &lt;ref:anchor id="fnr-20101NZLR_297-1"/&gt; &lt;label&gt;1&lt;/label&gt;
                    &lt;/footnote-ref&gt;price fixing &lt;/text&gt; &lt;/p&gt; &lt;footnotegroup&gt;
                    &lt;footnote&gt; &lt;ref:anchor id="fn-20101NZLR_297-1"/&gt;
                    &lt;ref:returnreference&gt; &lt;ref:locator anchoridref="fnr-20101NZLR_297-1"
                    anchortype="local"/&gt; &lt;/ref:returnreference&gt;
                    &lt;label&gt;1&lt;/label&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt;Sections27
                    &amp;#x2013; 29.&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt;
                    &lt;/footnotegroup&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: more than one footnote reference points at the same
                    footnote</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;table frame="all" pgwide="1"&gt; &lt;tgroup cols="1"
                    colsep="0" rowsep="0" align="left"&gt; &lt;colspec colwidth="50*" colname="col1"
                    colsep="0" rowsep="0"/&gt; &lt;tbody valign="top"&gt; &lt;row rowsep="0"&gt;
                    &lt;entry morerows="0" colsep="0" rowsep="0"&gt;Except for land and copyright,
                    &lt;fnr fntoken="PBEP.C5.FN51" fnrtoken="PBEP.C5.FN51-R"&gt;51&lt;/fnr&gt;
                    equitable interests can be created verbally. In undertaking an estate review,
                    care must be taken to establish the scope of equitable rights that may be
                    embedded in a person&amp;rsquo;s property at the time of review. The
                    practitioner must ensure that the existence and administration of those rights
                    are dealt with in accordance with the instruction of or legal obligations of the
                    client.&lt;/entry&gt; &lt;/row&gt; &lt;/tbody&gt; &lt;/tgroup&gt; &lt;/table&gt;
                    &lt;text&gt; &lt;fnr fntoken="PBEP.C5.FN51"
                    fnrtoken="PBEP.C5.FN51-R"&gt;51&lt;/fnr&gt; &lt;/text&gt; &lt;/p&gt;
                    &lt;footnotegrp&gt; &lt;!-- Etc. --&gt; &lt;footnote fntoken="PBEP.C5.FN51"
                    fnrtokens="PBEP.C5.FN51-R" type="default" &gt; &lt;fnlabel&gt;51&lt;/fnlabel&gt;
                    &lt;fnbody&gt; &lt;p&gt; &lt;refpt type="ext"
                    id="PBEP.C5.FN51"/&gt;&lt;text&gt;See Copyright Act 1968 (Cth) &lt;ci:cite
                    searchtype="LEG-REF"&gt; &lt;ci:content&gt; &lt;remotelink
                    refpt="IPCPY.CPA.CPA.S8" dpsi="0JVS" docidref="EFGH_9876" remotekey1="REFPTID"
                    service="DOC-ID"&gt;ss 8&lt;/remotelink&gt; &lt;/ci:content&gt;&lt;/ci:cite&gt;
                    and &lt;ci:cite searchtype="LEG-REF"&gt; &lt;ci:content&gt; &lt;remotelink
                    refpt="IPCPY.CPA.CPA.S196" dpsi="0JVS" docidref="EFGH_9876" remotekey1="REFPTID"
                    service="DOC-ID" &gt;196&lt;/remotelink&gt; &lt;/ci:content&gt;
                    &lt;/ci:cite&gt;. &lt;/text&gt; &lt;/p&gt; &lt;/fnbody&gt; &lt;/footnote&gt;
                    &lt;/footnotegrp&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: more than one footnote reference points at the same
                    footnote</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;table frame="all" pgwide="1"&gt; &lt;tgroup cols="1"
                    align="left"&gt; &lt;colspec colname="col1" colwidth="50&amp;#x002A;"/&gt;
                    &lt;tbody valign="top"&gt; &lt;row&gt; &lt;entry&gt;Except for land and
                    copyright, &lt;footnote-ref anchoridref="PBEP.C5.FN51"&gt; &lt;ref:anchor
                    id="PBEP.C5.FN51-R"/&gt; &lt;label&gt;51&lt;/label&gt; &lt;/footnote-ref&gt;
                    equitable interests can be created verbally. In undertaking an estate review,
                    care must be taken to establish the scope of equitable rights that may be
                    embedded in a person&amp;#x2019;s property at the time of review. The
                    practitioner must ensure that the existence and administration of those rights
                    are dealt with in accordance with the instruction of or legal obligations of the
                    client. &lt;/entry&gt; &lt;/row&gt; &lt;/tbody&gt; &lt;/tgroup&gt;
                    &lt;/table&gt; &lt;text&gt; &lt;footnote-ref anchoridref="PBEP.C5.FN51"&gt;
                    &lt;ref:anchor id="PBEP.C5.FN51-R_1"/&gt; &lt;label&gt;51&lt;/label&gt;
                    &lt;/footnote-ref&gt; &lt;/text&gt; &lt;/p&gt; &lt;footnotegroup&gt;
                    &lt;footnote&gt; &lt;ref:anchor id="PBEP.C5.FN51"/&gt;
                    &lt;ref:returnreference&gt; &lt;ref:locator anchoridref="PBEP.C5.FN51-R"
                    anchortype="local"/&gt; &lt;/ref:returnreference&gt;
                    &lt;label&gt;51&lt;/label&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt;See
                    Copyright Act 1968 &amp;#x0028;Cth&amp;#x0029; &lt;lnci:cite
                    type="legislation"&gt; &lt;lnci:content&gt; &lt;ref:crossreference
                    crossreferencetype="seeAlso"&gt; &lt;ref:content&gt;ss 8&lt;/ref:content&gt;
                    &lt;ref:locator anchoridref="IPCPY.CPA.CPA.S8"&gt; &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt; &lt;ref:key-value
                    value="0JVS-EFGH_9876"/&gt; &lt;/ref:locator-key&gt; &lt;/ref:locator&gt;
                    &lt;/ref:crossreference&gt; &lt;/lnci:content&gt; &lt;/lnci:cite&gt; and
                    &lt;lnci:cite type="legislation"&gt; &lt;lnci:content&gt; &lt;ref:crossreference
                    crossreferencetype="seeAlso"&gt; &lt;ref:content&gt;196&lt;/ref:content&gt;
                    &lt;ref:locator anchoridref="IPCPY.CPA.CPA.S196"&gt; &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt; &lt;ref:key-value
                    value="0JVS-EFGH_9876"/&gt; &lt;/ref:locator-key&gt; &lt;/ref:locator&gt;
                    &lt;/ref:crossreference&gt; &lt;/lnci:content&gt; &lt;/lnci:cite&gt;.
                    &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt;
                    &lt;/footnotegroup&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>fnr</xd:i> appear without
                        <xd:i>footnote</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;case:factsummary&gt; &lt;p&gt; &lt;text&gt; &lt;fnr
                    fntoken="1ald095fn2" fnrtoken="1ald095fn2-r"&gt;1&lt;/fnr&gt; Crystal wine
                    glasses sent on behalf of the applicant by post from Sydney to Melbourne were
                    broken in transit. The glasses were packed in individual compartments in a box
                    made of fairly flimsy cardboard and were individually wrapped in tissue paper.
                    There was no external packaging to cushion the box and its contents against
                    damage by impact. The box was marked Fragile. The applicant claimed compensation
                    from the Australian Postal Commission for the breakage of the glasses. His claim
                    was refused on the basis that Postal by-law 292 precluded compensation where the
                    goods damaged were not adequately wrapped to protect them in the ordinary course
                    of transmission. The applicant appealed to the Tribunal asserting that the
                    marking Fragile on the goods should have indicated to the Commission that the
                    goods had to be handled with care. &lt;/text&gt; &lt;/p&gt; 
                    &lt;/case:factsummary&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: <xd:i>fnr</xd:i> appear without
                        <xd:i>footnote</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;casesum:summaries&gt; &lt;casesum:editorialsummar&gt; &lt;p&gt;
                    &lt;text&gt; &lt;!-- a footnote reference without footnote is a data error.
                    &lt;fnr fntoken="1ald095fn2" fnrtoken="1ald095fn2-r"&gt;1&lt;/fnr&gt; --&gt;
                    Crystal wine glasses sent on behalf of the applicant by post from Sydney to
                    Melbourne were broken in transit. The glasses were packed in individual
                    compartments in a box made of fairly flimsy cardboard and were individually
                    wrapped in tissue paper. There was no external packaging to cushion the box and
                    its contents against damage by impact. The box was marked Fragile. The applicant
                    claimed compensation from the Australian Postal Commission for the breakage of
                    the glasses. His claim was refused on the basis that Postal by-law 292 precluded
                    compensation where the goods damaged were not adequately wrapped to protect them
                    in the ordinary course of transmission. The applicant appealed to the Tribunal
                    asserting that the marking Fragile on the goods should have indicated to the
                    Commission that the goods had to be handled with care. &lt;/text&gt; &lt;/p&gt;
                     &lt;/casesum:editorialsummar&gt; &lt;/casesum:summaries&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>leg:bodytext/fnr</xd:i> scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:bodytext&gt; &lt;fnr fntoken="CPQ.QCAT.QCATPD"
                    fnrtoken="CPQ.QCAT.QCATPD-R"&gt;*&lt;/fnr&gt; &lt;/leg:bodytext&gt; ....
                    &lt;footnotegrp&gt; &lt;footnote fntoken="CPQ.QCAT.QCATPD"
                    fnrtokens="CPQ.QCAT.QCATPD-R" type="default"&gt;
                    &lt;fnlabel&gt;*&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;p&gt;&lt;refpt type="ext"
                    id="CPQ.QCAT.QCATPD"/&gt; &lt;text&gt; &amp;copy; The State of Queensland
                    (Queensland Civil and Administrative Tribunal) 2010. QCAT applications fees
                    reproduced with the kind permission of the Queensland Civil and Administrative
                    Tribunal. See &lt;remotelink href="www.qcat.qld.gov.au" hrefclass="http"
                    newwindow="YES"&gt; www.qcat.qld.gov.au&lt;/remotelink&gt; &lt;/text&gt;
                    &lt;/p&gt; &lt;/fnbody&gt; &lt;/footnote&gt; &lt;/footnotegrp&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: <xd:i>leg:bodytext/fnr</xd:i> scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;primlaw:bodytext&gt; &lt;textitem&gt; &lt;footnote-ref
                    anchoridref="CPQ.QCAT.QCATPD"&gt; &lt;ref:anchor id="CPQ.QCAT.QCATPD-R"/&gt;
                    &lt;label&gt;*&lt;/label&gt; &lt;/footnote-ref&gt; &lt;/textitem&gt;
                    &lt;/primlaw:bodytext&gt; &lt;footnotegroup&gt; &lt;footnote&gt; &lt;ref:anchor
                    id="CPQ.QCAT.QCATPD"/&gt; &lt;ref:returnreference&gt; &lt;ref:locator
                    anchoridref="CPQ.QCAT.QCATPD-R" anchortype="local"/&gt;
                    &lt;/ref:returnreference&gt; &lt;label&gt;*&lt;/label&gt; &lt;bodytext&gt;
                    &lt;p&gt; &lt;text&gt; &amp;#x00A9; The State of Queensland (Queensland Civil
                    and Administrative Tribunal) 2010. QCAT applications fees reproduced with the
                    kind permission of the Queensland Civil and Administrative Tribunal. See &lt;url
                    normval="http://www.qcat.qld.gov.au"&gt; www.qcat.qld.gov.au&lt;/url&gt;
                    &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt;
                    &lt;/footnotegroup&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>footnote/fnbody/p/refpt/@id</xd:i> holds the same
                    value as <xd:i>footnote/@fntoken</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt;The purchaser's solicitor should be careful where
                    a right to rescind arises in the purchaser's favour. In conveyancing matters,
                    the solicitor's knowledge of the right to rescind or the facts giving rise to
                    that right is imputed to the client. The solicitor's conduct may, if care is not
                    taken, amount to an affirmation of the contract as still on foot or a
                    termination of it, notwithstanding the client's ignorance. &lt;fnr
                    fnrtoken="CONN.DAR.11102.ANT2-R" fntoken="CONN.DAR.11102.ANT2"&gt;2&lt;/fnr&gt;
                    &lt;/text&gt; &lt;/p&gt; &lt;!-- Etc. --&gt; &lt;footnote
                    fnrtokens="CONN.DAR.11102.ANT2-R" fntoken="CONN.DAR.11102.ANT2"
                    type="default"&gt; &lt;fnlabel&gt;2&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;p&gt;
                    &lt;refpt id="CONN.DAR.11102.ANT2" type="ext"/&gt; &lt;text&gt; &lt;ci:cite
                    searchtype="CASE-REF"&gt;...&lt;/ci:cite&gt; &lt;/text&gt; &lt;/p&gt;
                    &lt;/fnbody&gt; &lt;/footnote&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: <xd:i>footnote/fnbody/p/refpt</xd:i> has been
                    suppressed</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt;The purchaser's solicitor should be careful where
                    a right to rescind arises in the purchaser's favour. In conveyancing matters,
                    the solicitor's knowledge of the right to rescind or the facts giving rise to
                    that right is imputed to the client. The solicitor's conduct may, if care is not
                    taken, amount to an affirmation of the contract as still on foot or a
                    termination of it, notwithstanding the client's ignorance. &lt;footnote-ref
                    anchoridref="CONN.DAR.11102.ANT2"&gt; &lt;ref:anchor
                    id="CONN.DAR.11102.ANT2-R"/&gt; &lt;label&gt;2&lt;/label&gt;
                    &lt;/footnote-ref&gt; &lt;/text&gt; &lt;/p&gt; &lt;footnote&gt; &lt;ref:anchor
                    id="CONN.DAR.11102.ANT2"/&gt; &lt;ref:returnreference&gt; &lt;ref:locator
                    anchoridref="CONN.DAR.11102.ANT2-R" anchortype="local"/&gt;
                    &lt;/ref:returnreference&gt; &lt;label&gt;2&lt;/label&gt; &lt;bodytext&gt;
                    &lt;p&gt; &lt;text&gt; &lt;lnci:cite&gt;...&lt;/lnci:cite&gt; &lt;/text&gt;
                    &lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>leg:bodytext/footnotegrp</xd:i> scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:bodytext&gt; &lt;p&gt; &lt;text&gt; (a) An oil discharge
                    monitoring and control system approved by the Administration shall be fitted. In
                    considering the design of the oil content meter to be incorporated in the
                    system, the Administration shall have regard to the specification recommended by
                    the Organization. &lt;fnr fntoken="WA_ACT_1987-14_FN"
                    fnrtoken="WA_ACT_1987-14_FN-R"&gt;*&lt;/fnr&gt; .... &lt;/text&gt; &lt;/p&gt;
                    &lt;footnotegrp&gt; &lt;footnote fntoken="WA_ACT_1987-14_FN"
                    fnrtokens="WA_ACT_1987-14_FN-R" type="default"&gt;
                    &lt;fnlabel&gt;*&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;p&gt; &lt;text
                    align="left"&gt; Reference is made to the Recommendation on International
                    Performance Specifications for Oily-Water Separating Equipment and Oil Content
                    Meters adopted by the Organization by Resolution A.233(VII). &lt;/text&gt;
                    &lt;/p&gt; &lt;/fnbody&gt; &lt;/footnote&gt; &lt;/footnotegrp&gt;
                    &lt;/leg:bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: <xd:i>primlaw:bodytext/p/text/footnotegroup</xd:i>
                    scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;primlaw:bodytext&gt; &lt;p&gt; &lt;text&gt;(a) An oil discharge
                    monitoring and control system approved by the Administration shall be fitted. In
                    considering the design of the oil content meter to be incorporated in the
                    system, the Administration shall have regard to the specification recommended by
                    the Organization. &lt;footnote-ref anchoridref="WA_ACT_1987-14_FN"&gt;
                    &lt;ref:anchor id="WA_ACT_1987-14_FN-R"/&gt; &lt;label&gt;*&lt;/label&gt;
                    &lt;/footnote-ref&gt; .... &lt;/text&gt; &lt;/p&gt; &lt;p&gt; &lt;text&gt;
                    &lt;footnotegroup&gt; &lt;footnote&gt; &lt;ref:anchor
                    id="WA_ACT_1987-14_FN"/&gt; &lt;ref:returnreference&gt; &lt;ref:locator
                    anchoridref="WA_ACT_1987-14_FN-R" anchortype="local"/&gt;
                    &lt;/ref:returnreference&gt; &lt;label&gt;*&lt;/label&gt; &lt;bodytext&gt;
                    &lt;p&gt; &lt;text&gt; &lt;p align="left"&gt; &lt;text&gt;Reference is made to
                    the Recommendation on International Performance Specifications for Oily-Water
                    Separating Equipment and Oil Content Meters adopted by the Organization by
                    Resolution A.233(VII). &lt;/text&gt; &lt;/p&gt; &lt;/text&gt; &lt;/p&gt;
                    &lt;/bodytext&gt; &lt;/footnote&gt; &lt;/footnotegroup&gt; &lt;/text&gt;
                    &lt;/p&gt; &lt;/primlaw:bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>bodytext/footnotegrp</xd:i> scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext&gt; ... &lt;entry colname="c1"&gt;Fair Work (State Referral
                    and Consequential and Other Amendments) Act 2009 No&amp;#160;54 &lt;fnr
                    fntoken="WRA.OL.ICAC06.FNT1" fnrtoken="WRA.OL.ICAC06.FNT1-R"&gt;*&lt;/fnr&gt;
                    &lt;/entry&gt; &lt;entry colname="c2"&gt;25 June 2009&lt;/entry&gt; &lt;entry
                    colname="c3"&gt;Sch 14[1]&amp;ndash;[11]: 1 July 2009&lt;/entry&gt; ...
                    &lt;footnotegrp&gt; &lt;footnote fntoken="WRA.OL.ICAC06.FNT1"
                    fnrtokens="WRA.OL.ICAC06.FNT1-R" type="default"&gt;
                    &lt;fnlabel&gt;*&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;h&gt;Editor's
                    note:&lt;/h&gt; &lt;p&gt;&lt;refpt type="ext" id="WRA.OL.ICAC06.FNT1"/&gt;
                    &lt;text&gt;&lt;emph typestyle="bf"&gt;Please be aware that item 11, Schedule 14
                    of this Act provides the following:&lt;/emph&gt; &lt;/text&gt; &lt;/p&gt;
                    &lt;/fnbody&gt; &lt;/footnote&gt; &lt;/footnotegrp&gt; &lt;/bodytext&gt;
                </xd:pre>
         <xd:p>
            <xd:b>Target xml: <xd:i>bodytext/p/text/footnotegroup</xd:i>
                    scenario</xd:b>
         </xd:p>
         <xd:pre> &lt;bodytext&gt; ... &lt;entry colname="c1"&gt;Fair Work (State Referral
                    and Consequential and Other Amendments) Act 2009 No&amp;#160;54 &lt;footnote-ref
                    anchoridref="WRA.OL.ICAC06.FNT1"&gt; &lt;ref:anchor
                    id="WRA.OL.ICAC06.FNT1-R"/&gt; &lt;label&gt;*&lt;/label&gt;
                    &lt;/footnote-ref&gt; &lt;/entry&gt; &lt;entry colname="c2"&gt;25 June
                    2009&lt;/entry&gt; &lt;entry colname="c3"&gt;Sch 14[1]&amp;ndash;[11]: 1 July
                    2009&lt;/entry&gt; .... &lt;p&gt; &lt;text&gt; &lt;footnotegroup&gt;
                    &lt;footnote&gt; &lt;ref:anchor id="WRA.OL.ICAC06.FNT1"/&gt;
                    &lt;ref:returnreference&gt; &lt;ref:locator anchoridref="WRA.OL.ICAC06.FNT1-R"
                    anchortype="local"/&gt; &lt;/ref:returnreference&gt;
                    &lt;label&gt;*&lt;/label&gt; &lt;bodytext&gt; &lt;h&gt;Editor's note:&lt;/h&gt;
                    &lt;p&gt; &lt;text&gt;&lt;emph typestyle="bf"&gt;Please be aware that item 11,
                    Schedule 14 of this Act provides the following:&lt;/emph&gt; &lt;/text&gt;
                    &lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt; &lt;/footnotegroup&gt;
                    &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: Canada only, suppress indent from
                        <xd:i>footnote/fnbody/p[@indent]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;footnotegrp&gt; &lt;footnote fntoken="fn-1" fnrtokens="fnr-1"&gt;
                    &lt;fnlabel&gt;1&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;p i="2"
                    indent="1st-line"&gt; &lt;text&gt;Decision...&lt;/text&gt; &lt;/p&gt;
                    &lt;/fnbody&gt; &lt;/footnote&gt; ... &lt;/footnotegrp&gt; </xd:pre>
         <xd:p>
            <xd:b>Target xml: Canada only, suppress indent from
                        <xd:i>footnote/fnbody/p[@indent]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;footnotegroup&gt; &lt;footnote&gt; &lt;ref:anchor id="fn-1"/&gt;
                    &lt;ref:returnreference&gt; &lt;ref:locator anchoridref="fnr-1"
                    anchortype="local"/&gt; &lt;/ref:returnreference&gt;
                    &lt;label&gt;1&lt;/label&gt; &lt;bodytext&gt; &lt;p&gt;
                    &lt;text&gt;Decision...&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
                    &lt;/footnote&gt; ... &lt;/footnotegroup&gt; </xd:pre>
         <xd:p>
            <xd:b>Source xml: <xd:i>legfragment/footnotegrp</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
                    
&lt;legfragment&gt;
    ........
    &lt;footnotegrp&gt;
        &lt;footnote type="endnote" fntoken="d42e225" fnrtokens="d42e222"&gt;
            &lt;fnlabel&gt;(*)&lt;/fnlabel&gt;
            &lt;fnbody&gt;
                &lt;p&gt;
                    &lt;text&gt;OJ L 149, 11.6.2005, p 22.;&lt;/text&gt;
                &lt;/p&gt;
            &lt;/fnbody&gt;
        &lt;/footnote&gt;
    &lt;/footnotegrp&gt;
&lt;/legfragment&gt;

                </xd:pre>
         <xd:p>
            <xd:b>Target xml:
                        <xd:b>primlaw:excerpt/primlaw:bodytext/p/text/footnotegroup</xd:b>
            </xd:b>
         </xd:p>
         <xd:pre>
                    
&lt;primlaw:excerpt&gt;
    ..........
    &lt;primlaw:bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;footnotegroup&gt;
                    &lt;footnote&gt;
                        &lt;ref:anchor id="d42e225"/&gt;
                        &lt;ref:returnreference&gt;
                            &lt;ref:locator anchoridref="d42e222" anchortype="local"/&gt;
                        &lt;/ref:returnreference&gt;
                        &lt;label&gt;*&lt;/label&gt;
                        &lt;bodytext&gt;
                            &lt;p&gt;
                                &lt;text&gt;OJ L 149, 11.6.2005, p 22.;&lt;/text&gt;
                            &lt;/p&gt;
                        &lt;/bodytext&gt;
                    &lt;/footnote&gt;
                &lt;/footnotegroup&gt;
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/primlaw:bodytext&gt;
&lt;/primlaw:excerpt&gt;

                </xd:pre>
         <!-- McNally June 9 2014. Commenting-out the following CA02 rule, example, and changelog entry. 
            Target is not valid, ...bodytext/courtcase:opinion.... 
            If only applies to CA02-CC consider adding as rule only in that CI.  -->
         <!--        <note>
            <b>Canada CA02 Only:</b> If <sourcexml>footnotegrp</sourcexml> is a child of
                <sourcexml>case:judgments</sourcexml>, then it becomes
                <targetxml>casedigest:body/casedigest:decision/casedigest:decisionsummary/bodytext/courtcase:opinion/footnotegroup</targetxml>.
            Please refer the example below for more clarification. </note>

        <example><b>Source XML</b>
            <codeblock>
&lt;case:judgments>
    &lt;footnotegrp>
        &lt;footnote fntoken="fn-1" fnrtokens="fnr-1">
            &lt;fnlabel>1&lt;/fnlabel>
            &lt;fnbody>
                &lt;p>
                    &lt;text>R.S.N.L. 1990, c. F-12.&lt;/text>
                &lt;/p>
            &lt;/fnbody>
        &lt;/footnote>
    &lt;/footnotegrp>
&lt;/case:judgments>
            </codeblock>
        </example>

        <example>
            <b>Target XML</b>
            <codeblock>
&lt;casedigest:body>
    &lt;casedigest:decision>
        &lt;casedigest:decisionsummary>
            &lt;bodytext>
                &lt;courtcase:opinion>
                    &lt;footnotegroup>
                        &lt;footnote>
                        &lt;ref:anchor id="fn-1" />
                        &lt;ref:returnreference>
                            &lt;ref:locator anchoridref="fnr-1" anchortype="local" />
                        &lt;/ref:returnreference>
                        &lt;label>1&lt;/label>
                         &lt;bodytext>
                             &lt;p>
                                &lt;text>R.S.N.L. 1990, c. F-12.&lt;/text>
                            &lt;/p>
                        &lt;/bodytext>
                        &lt;/footnote>
                    &lt;/footnotegroup>
                &lt;/courtcase:opinion>
            &lt;/bodytext>
            &lt;/casedigest:decisionsummary>
    &lt;/casedigest:decision>
&lt;/casedigest:body>
    </codeblock>
        </example>-->
         <!--Changes2017-03-07: Added instructions for handling
                            legfragment/footnotegrp.[Webstar#6805157]2016-08-08: Removing duplicate entry of
                            lilabel/fnr2016-08-04: Added note for handling
                            lilabel/fnr Applicable for AU05, Incident
                        #65978932016-02-29: Added note for handling
                            @type="editorial" attribute. Applicable for
                        UK22CS, RFA# 27622016-01-05: Added instructions for
                            footnotegrp within
                        frm:div. To generate
                            form:p/form:text wrapper for target
                            footnotegroup. Immediately affects UK12 but will
                        apply to any stream if the use case occurs. RFA 2653.2015-05-14: Added instructions for
                            footnotegrp within
                            frm:body and clause. To
                        generate form:p/form:text wrapper for target
                            footnotegroup. Immediately affects UK12 but will
                        apply to any stream if the use case occurs. R4.5 Content Issues 2316 and
                        2317.2014-06-02: Canada only. Added special rule to
                        suppress indent from footnote/fnbody/p[@indent].
                        Applies immediately to all Canada streams. R4.5 Content Issue 1609.2014-04-17: Added instruction for
                            footnotegrp within
                            sigblock. Specifies p/text
                        wrapper for target sigblock/p/text/footnotegroup.
                        Immediately affects UK12 but will apply to any stream if the use case
                        occurs. Phase 6 UK discussion items 76 and 88.2014-01-06: Updated target example for applying the
                        rule of "deleting extraneous instances of @morerows, @colsep and @rowsep" in
                        sample documents.2013-10-02: Not a rule change. Cleaned up the note
                        regarding the scenario when footnote/@fntoken has a value of "0" in an
                        attempt to make the directions clearer.2013-08-22: Not a rule change. Second target sample
                        modified to remove attribute lnci:cite[@citeref]
                        because value captured in descendant
                            ref:crossreference/ref:locator[@anchoridref].
                        Ancillary/illustrative within this module. Change made to promote uniformity
                        across samples.2013-01-09: Added instruction note for handling of
                            footnote[@fntoken] with value 0 for UK content
                        types.2012-11-05: Added instructions for handling of footnotegrp
                    within case:appendix,
                        case:consideredcases,
                        case:priorhist, note and
                        prelim.2012-10-18: Added instructions for creating
                        footnote/ref:returnreference.2012-10-05: Added instructions for handling of
                        pgrp/footnotegrp.2012-10-03: Added standard note about @anchoridref format
                    and fixed a few typos.2012-09-18: Updated instructions for handling
                        form:form/form:document/form:bodytext/form:p/form:text/footnotegroup.2012-08-28: Added instructions for handling footnotegrp
                    when it is a child of the following elements:
                        case:judgments,
                        case:judgmentbody,
                        case:headnote,
                        case:decisionsummary,
                        case:factsummary,
                        case:references,
                        case:typeofcase, p,
                        glp:note, blockquote,
                        li, catchwordgrp2012-08-28: Updated instructions for handling
                        level/bodytext/footnotegrp.2012-08-23: Updated sample containing
                        ci:content/remotelink to add target
                        ref:crossreference.2012-08-23: Updated Notes that @xml:id and
                        ref:anchor@id beginning with number should start with
                    underscore, not country code2012-08-14: Added instructions for handling
                        level/bodytext/footnotegrp.2012-08-14: Added instructions and example for handling
                        leg:bodytext/footnotegrp and
                        bodytext/footnotegrp scenario and renamed
                        footnotegrp to footnotegroup
                    according to schema.2012-07-31: Updated the instructions for handling
                        footnotegrp adding footnotegrp to footnotegrp
                    instruction. Also updated samples to include footnotegrp wrapper elements where
                    necessary 2012-07-06: Updated the instructions for handling
                        footnote/@type with directions to supress
                        @type when it has a value of "annotation".2012-06-15: Removed the sample mapping for the scenario of
                        footnote without a corresponding
                        fnr.2012-05-24: Removed the instructions for handling footnote
                    without a corresponding fnr.2012-05-11: Added note that the value of footnote/@xml:id
                    should be prefixed with the lower case country code followed by an
                    underscore.2012-05-10: Updated the instructions for handling footnote
                    without a corresponding fnr.2012-05-10: Added instructions to suppress fnr when it is
                    empty.2012-05-07: Added instructions for handling the scenario when
                        footnote/fnbody/p/refpt/@id holds the same value as
                        footnote/@fntoken2012-05-07: Instruction and example added for
                        leg:bodytext/fnr scenario.2012-05-04: Updated the instruction and example for handling -
                        fnr appears without
                    footnote.2012-04-27: Added instruction for handling of
                        footnote/@type, fnr/@alt-label
                    and fnr/id.2012-04-26: Added the instruction and example for handling -
                        fnr appears without
                    footnote.2012-04-16: Added the instruction and example for handling,
                        footnote appears without
                    fnr.2012-04-16: Added the instruction for handling of
                        footnotegrp/heading.2012-01-05: Add the instruction when more than one footnote reference points at
                    the same footnote.2011-12-21: Fixed instructions to indicate that the @fntoken value (not
                    @fnrtokens) should be used to populate ref:anchor[@id].2011-12-21: Several changes to clarify instructions.2011-12-15: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_footnote-LxAdv-footnote.dita  -->
   <!-- JL: keys for testing 

    <xsl:key name="idTypeValue" match="*[@id]" use="@id"/>
    <xsl:key name="idTypeValue" match="*[@ID]" use="@ID"/>
    <xsl:key name="idTypeValue" match="footnote" use="@fntoken"/>
    <xsl:key name="idTypeValue" match="fnr" use="@fnrtoken"/>
    
    <xsl:key name="fnr-footnote-tokens" match="fnr" use="@fntoken"/>
    
    <xsl:include
        href="../../modules/nonamespace/Rosetta_identifier-LxAdv-ID_data_type-HandlingPatternRestrictions.xsl"/>
    
    <xsl:include
        href="../../modules/nonamespace/Rosetta_identifier-LxAdv-ID_data_type-HandlingDuplicates.xsl"/>
    
    <xsl:include href="../../../global/functions/globalFunctions.xsl"/>
    <xsl:include href="../../../global/defaultRules.xsl"/>
    <xsl:include href="../../modules/nonamespace/Rosetta_refpt-LxAdv-ref.anchor.xsl"/>
    <xsl:variable name="streamID" select="HK02"/>
    <xsl:template match="@*|node()">
        <xsl:copy>
            <xsl:apply-templates/>
        </xsl:copy>
    </xsl:template>
     JL: end of code for testing -->
   <xsl:template match="footnotegrp"><!--  default behavior   -->
      <xsl:variable name="form-level-types"
                    select="('prec.grp' , 'precgrp' , 'precgrp1' , 'precgrp2' , 'prec' , 'form')"/>
      <xsl:choose><!-- in these scenarios, parent elements should have already been transformed to the appropriate
            bodytext (or other appropriate) parent wrapper, and will need a p/text parent. At least in the 
            generic modules, which I, JL, checked. case:appendix doesn't have the instruction but the examples
            show it, and case:consideredcases may be dicey, depending on how its template is developed. 
            -JL
            --><!-- this clause parent works for UK14 CIs, not sure about anything else - JL -->
         <xsl:when test="parent::frm:div or parent::frm:body or parent::clause or ($streamID=('AU05' , 'NZ09') and (parent::bodytext[parent::level[@leveltype=$form-level-types]]                  or                  parent::bodytext[parent::level[@leveltype='comm.chap'][level[@leveltype=$form-level-types]][not(level[@leveltype='para0'])]]                  or                 parent::blockquote[parent::bodytext[parent::level[@leveltype=$form-level-types]]]                 or                 parent::blockquote[parent::bodytext[parent::level[@leveltype='comm.chap'][level[@leveltype=$form-level-types]][not(level[@leveltype='para0'])]]])                 or parent::bodytext[parent::form] or parent::blockquote[parent::bodytext[parent::form]]                 )">
            <form:p>
               <form:text>
                  <footnotegroup>
                     <xsl:apply-templates select="@* | node()"/>
                  </footnotegroup>
               </form:text>
            </form:p>
         </xsl:when>
         <xsl:when test="$streamID='HK07' and parent::bodytext[parent::level[@leveltype='prec' or @leveltype='prec.grp' or @leveltype='precgrp' or @leveltype='precgrp1' or @leveltype='precgrp2' or parent::comm.chap or ancestor::level[@leveltype = 'prec.grp']]]">
            <form:p>
               <form:text>
                  <footnotegroup>
                     <xsl:apply-templates select="@* | node()"/>
                  </footnotegroup>
               </form:text>
            </form:p>
         </xsl:when>
         <xsl:when test="parent::bodytext or parent::leg:bodytext or parent::case:judgmentbody or parent::case:decisionsummary or parent::case:factsummary or parent::case:references or parent::case:typeofcase or parent::glp:note or parent::blockquote or parent::li or parent::pgrp or parent::case:appendix or parent::case:consideredcases or parent::case:priorhist or parent::note or parent::prelim or parent::jrnl:prelim or parent::sigblock">
            <p>
               <text>
                  <footnotegroup>
                     <xsl:apply-templates select="/JOURNALDOC/jrnl:body/jrnl:prelim/footnotegrp/footnote[$streamID='CA15']"/>
                     <xsl:apply-templates select="@* | node()"/>
                  </footnotegroup>
               </text>
            </p>
         </xsl:when>
         <xsl:when test="parent::p">
            <text>
               <footnotegroup>
                  <xsl:apply-templates select="@* | node()"/>
               </footnotegroup>
            </text>
         </xsl:when>
         <xsl:otherwise><!--  accounting for these parents even tho the instruction is redundant so I can keep track
                    case:judgements becomes courtcase:opinions
                    case:headnote becomes courtcase:head
                    no intervening p/text needed
                    catchwordgrp parent - one of the catchwordgrp modules indicates where the footnotegroup should be output
                    so I'll assume the placement of footnotegrp is handled there (which is the proper place), 
                    but it takes this option.                  
                    - JL                
                -->
            <footnotegroup>
               <xsl:apply-templates select="@* | node()"/>
            </footnotegroup>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- CSN - 2018-01-18 - Webstar 7097397 - handle footnotegrp parents leg:levelbody and primlaw:level by adding bodytext wrapper.-->
   <xsl:template match="footnotegrp[parent::leg:levelbody][$streamID='UK06']">
      <primlaw:bodytext>
         <p>
            <text>
               <footnotegroup>
                  <xsl:apply-templates select="@* | node()"/>
               </footnotegroup>
            </text>
         </p>
      </primlaw:bodytext>
   </xsl:template>

   <xsl:template match="footnote">
      <footnote>
         <xsl:apply-templates select="@type"/>
         <xsl:variable name="fnDupStatus">
            <xsl:call-template name="amIaDuplicate"/>
         </xsl:variable>
         <xsl:variable name="normalizedfnfntoken"><!-- normalize the footnote's fntoken -->
            <xsl:for-each select="@fntoken">
               <xsl:call-template name="normalizeIdString"/>
            </xsl:for-each>
         </xsl:variable>
         <xsl:variable name="normalizedmatchingfnrtoken"><!-- normalize the fnrtoken of the first matching fnr --><!-- if there is no match this variable will return empty and that is fine -->
            <xsl:if test="key('fnr-footnote-tokens', @fntoken)"><!-- if there is any matching fnr, for the first one... -->
               <xsl:for-each select="key('fnr-footnote-tokens', @fntoken)[1]">
                  <xsl:for-each select="@fnrtoken">
                     <xsl:call-template name="normalizeIdString"/>
                  </xsl:for-each>
               </xsl:for-each>
            </xsl:if>
         </xsl:variable>
         <xsl:variable name="isSpecialMatchingConditionMet"
                       select="if ($normalizedfnfntoken = $normalizedmatchingfnrtoken and count(key('idTypeValue', @fntoken)) &lt; 3                 and  not(key('idTypeValue' , concat($normalizedmatchingfnrtoken , '_R')))                 ) then 0 else 1"/>
         <!-- we're only going to increment if we have 2 of the same input tokens or less (1 each fntoken, fnrtoken).  Otherwise, too messy -->
         <!-- we're not going to increment if the incremented value is already an ID. No point in it. -->
         <!-- 0 means we have a match, 1 means we failed to match anything -->
         <xsl:choose>
            <xsl:when test="$fnDupStatus = 'false' or $isSpecialMatchingConditionMet=0">
               <ref:anchor>
                  <xsl:apply-templates select="@fntoken"/>
                  <xsl:if test="$streamID = 'AU15'">
                     <xsl:attribute name="anchortype">global</xsl:attribute>
                  </xsl:if>
               </ref:anchor>
            </xsl:when>
            <xsl:when test="starts-with($streamID, 'UK') and @fntoken='0'"><!-- generate unique id here, how? -->
               <xsl:variable name="newID">
                  <xsl:value-of select="concat('_' , count(preceding::footnote)+1)"/>
               </xsl:variable>
               <xsl:choose>
                  <xsl:when test="key('idTypeValue', $newID)">
                     <xsl:attribute name="id" select="concat($newID, '_footnote_footnote')"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:attribute name="id" select="$newID"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:when>
            <xsl:otherwise>
               <ref:anchor><!-- Awantika: creating @id as it required with the dummy value -->
                  <xsl:attribute name="id">
                     <xsl:text>XXXX_</xsl:text>
                     <xsl:value-of select="generate-id()"/>
                  </xsl:attribute>
                  <xsl:comment>Data Error: footnote token was a duplicate id and has been removed. ref:anchor output with autogenerated @id.</xsl:comment>
               </ref:anchor>
               <!-- use default rules to throw an error message here, need error code -->
               <xsl:call-template name="outputErrorMessage">
                  <xsl:with-param name="messageText"
                                  as="xs:string"
                                  select="concat('Data Error: footnote token was a duplicate id and has been removed. Value of duplicate @fntoken is ', @fntoken , ' . ref:anchor output with autogenerated @id.')"/>
                  <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                  <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
                  <xsl:with-param name="context" as="xs:string">
                     <xsl:value-of select="base-uri()"/>
                  </xsl:with-param>
               </xsl:call-template>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:if test="key('fnr-footnote-tokens', @fntoken) or ($isSpecialMatchingConditionMet=0)">
            <xsl:for-each select="key('fnr-footnote-tokens', @fntoken)[1]">
               <ref:returnreference>
                  <ref:locator>
                     <xsl:attribute name="anchoridref">
                        <xsl:choose>
                           <xsl:when test="$isSpecialMatchingConditionMet=0">
                              <xsl:value-of select="concat($normalizedmatchingfnrtoken , '_R')"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:for-each select="@fnrtoken">
                                 <xsl:call-template name="normalizeIdString"/>
                              </xsl:for-each>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                     <xsl:attribute name="anchortype">local</xsl:attribute>
                  </ref:locator>
               </ref:returnreference>
            </xsl:for-each>
         </xsl:if>
         <xsl:apply-templates/>
      </footnote>
   </xsl:template>

   <xsl:template match="footnote/fnlabel">
      <label>
         <xsl:apply-templates select="@* | node()"/>
      </label>
   </xsl:template>

   <xsl:template match="footnote/fnbody"><!--  Original Target XPath:  footnote/bodytext   -->
      <bodytext>
         <xsl:apply-templates select="@* | node()"/>
      </bodytext>
   </xsl:template>
   <!-- JD: SharedServices schemas only allow @role of 'footnote' or 'endnote'; removing $streamID as @role='editorial' is not allowed in ANY stream. -->
   <xsl:template match="footnote/@type">
      <xsl:choose>
         <xsl:when test=". = 'editorial'"/>
         <!--  and $streamID='UK08CA'  -->
         <!--<xsl:when test=". = 'editorial' and $streamID='UK09' "/>-->
         <!-- AS:For UK09 if role ="editorial" comes then validation error is coming as contravenes to footnote ,endnot role -->
         <xsl:when test=".!='default' and .!='annotation'">
            <xsl:attribute name="role">
               <xsl:value-of select="."/>
            </xsl:attribute>
         </xsl:when>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="footnote/@fntoken"><!--for use in ref:anchor
            This shouldn't be applied unless we've already removed duplicates -->
      <xsl:attribute name="id">
         <xsl:call-template name="normalizeIdString"/>
      </xsl:attribute>
   </xsl:template>
   <!-- Vikas Rohilla : Added the priority for resolve the Ambiguous it matches the Rosetta_p-LxAdv-p.xsl at line  996-->
   <xsl:template match="fnbody/p/@indent[starts-with($streamID, 'CA')]" priority="2"/>

   <xsl:template match="fnr">
      <xsl:if test="node() | @*">
         <xsl:choose><!-- see if there is a footnote which has a @fntoken matching this fnr/@fntoken 
                could try 2nd attmept with @fnrtoken / @fnrtokens but that requires new key
                --><!-- JD: 2017-06-14: adding additional keys; data clearly has matching tokens that aren't picked up by existing keys -->
            <xsl:when test=" key('idTypeValue', @fntoken)[self::footnote]"><!--xsl:when test="key('idTypeValue', @fntoken)[self::footnote]"-->
               <xsl:choose>
                  <xsl:when test="parent::leg:bodytext">
                     <textitem>
                        <xsl:call-template name="outputFootnoteRef"/>
                     </textitem>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:call-template name="outputFootnoteRef"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:when>
            <xsl:otherwise><!-- CSN - 2017/10/25 - Webstar 7026508 - Stream UK06 should not show error message, just comment out fnr if no footnote --><!-- JL 20180104 - Many webstars including email with Andrew Martin and Sivapragasam M. to "turn off" this footnote
                        error message for all AU and NZ streams.  It was already "off" for AU11, AU14, NZ06, NZ08, and NZ18, so those streams won't
                        need to be re-released -->
               <xsl:if test="not($streamID = ('UK01','UK02','UK03','UK06','UK07','UK08OR','UK08CA','UK20') or starts-with($streamID , 'AU') or starts-with($streamID , 'NZ'))">
                  <xsl:call-template name="outputErrorMessage">
                     <xsl:with-param name="messageText"
                                     as="xs:string"
                                     select=" 'footnote reference without a footnote is a data error.' "/>
                     <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                     <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
                     <xsl:with-param name="context" as="xs:string">
                        <xsl:value-of select="base-uri()"/>
                     </xsl:with-param>
                  </xsl:call-template>
               </xsl:if>
               <xsl:comment>
                  <xsl:text>footnote reference without a footnote is a data error. </xsl:text>
                  <xsl:copy-of select="."/>
               </xsl:comment>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:if>
   </xsl:template>

   <xsl:template name="outputFootnoteRef"><!--saves typing multiple times-->
      <footnote-ref>
         <xsl:apply-templates select="@id"/>
         <xsl:apply-templates select="@fntoken"/>
         <xsl:variable name="fnrDupStatus">
            <xsl:call-template name="amIaDuplicate"/>
         </xsl:variable>
         <xsl:variable name="normalizedfnrfnrtoken"><!-- normalize the footnote's fntoken -->
            <xsl:for-each select="@fnrtoken">
               <xsl:call-template name="normalizeIdString"/>
            </xsl:for-each>
         </xsl:variable>
         <xsl:variable name="normalizedmatchingfnsfntoken"><!-- normalize the value of fnrtokens for each matching footnote
                If there are multiples, it won't work, I'll consider it's just not a match and we move on.
                --><!-- if there is no match or this variable will return empty and that is fine -->
            <xsl:for-each select="key('idTypeValue' , @fntoken)[self::footnote]">
               <xsl:for-each select="(@fntoken)">
                  <xsl:call-template name="normalizeIdString"/>
               </xsl:for-each>
            </xsl:for-each>
         </xsl:variable>
         <xsl:variable name="isSpecialfnrMatchingConditionMet"
                       select="if ($normalizedfnrfnrtoken = $normalizedmatchingfnsfntoken                 and count(key('idTypeValue', @fnrtoken)) &lt; 3                 and  not(key('idTypeValue' , concat($normalizedfnrfnrtoken , '_R')))                 ) then 0 else 1"/>
         <!-- we're only going to increment if we have 2 of the same input tokens or less (1 each fntoken, fnrtoken).  Otherwise, too messy -->
         <!-- we're not going to increment if the incremented value is already an ID. No point in it. -->
         <!-- 0 means we have a match, 1 means we failed to match anything -->
         <xsl:choose>
            <xsl:when test="$fnrDupStatus = 'false' or $isSpecialfnrMatchingConditionMet=0">
               <xsl:apply-templates select="@fnrtoken">
                  <xsl:with-param name="specialMatch" select="$isSpecialfnrMatchingConditionMet"/>
                  <xsl:with-param name="incrementedfnrtokenValue"
                                  select="concat($normalizedfnrfnrtoken , '_R')"/>
               </xsl:apply-templates>
            </xsl:when>
            <xsl:otherwise>
               <ref:anchor><!-- Awantika: creating @id as it required with the dummy value -->
                  <xsl:attribute name="id">
                     <xsl:text>XXXX_</xsl:text>
                     <xsl:value-of select="generate-id()"/>
                  </xsl:attribute>
                  <!-- may also need error message output -->
                  <!-- wpk 2017-12-11.  Removed comment.  You can read background in webstar 7055608.
                            in short: multiple references to single footnote creates ID problem in that what does user get set "back to" when linking back to reference.
                            App has no way to "link back" to the second (or subsequent) references to a given footnote.  So default behavior is to link back to 
                            the first one.  This limitation confirmed with presentation team.
                        <xsl:comment>footnote reference token was a duplicate or missing id and has been removed. ref:anchor output with generated @id.</xsl:comment>
                        -->
                  <!--<xsl:value-of select="name()"/>-->
               </ref:anchor>
               <!-- JL 20171108: this is a data error that rarely causes a problem with footnote linking.  Comma should be sufficient. 
                        LBUs do not want webstars for this, as most of these footnote do not have 2-way linking per CI.
                        webstar 7043982
                    <xsl:call-template name="outputErrorMessage">
                        <xsl:with-param name="messageText" as="xs:string" select=" 'footnote reference token was a duplicate or missing id and has been removed.
                            ref:anchor output with no @id. ' "/>
                        <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                        <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
                        <xsl:with-param name="context" as="xs:string"><xsl:value-of select="base-uri()"/></xsl:with-param>
                    </xsl:call-template>  -->
            </xsl:otherwise>
         </xsl:choose>
         <label>
            <xsl:apply-templates select="node()"/>
         </label>
      </footnote-ref>
   </xsl:template>

   <xsl:template match="fnr/@fnrtoken"><!-- output only after dup check --><!-- 2018-02-16 - MDS - removed single quotes around 1 in @select to change from string to integer value due to Webstar 7121369 -->
      <xsl:param name="specialMatch" select="1"/>
      <xsl:param name="incrementedfnrtokenValue"/>
      <ref:anchor>
         <xsl:attribute name="id">
            <xsl:choose>
               <xsl:when test="$specialMatch=0">
                  <xsl:value-of select="$incrementedfnrtokenValue"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:call-template name="normalizeIdString"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:attribute>
      </ref:anchor>
   </xsl:template>

   <xsl:template match="fnr/@fntoken"><!-- 
        No dup check necessary-->
      <xsl:attribute name="anchoridref">
         <xsl:call-template name="normalizeIdString"/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="fnr/@alt-label"/>

   <xsl:template match="footnote/fnbody/p/refpt">
      <xsl:variable name="ancestorFnToken" select="ancestor::footnote/@fntoken"/>
      <xsl:if test="refpt/@id!=$ancestorFnToken">
         <xsl:call-template name="refpt-generic"/>
      </xsl:if>
   </xsl:template>
   <!-- <p>If <sourcexml>footnote/fnbody</sourcexml> contains
                                    <sourcexml>p/refpt</sourcexml> and the value of
                                    <sourcexml>refpt/@id</sourcexml> is the same as the value of
                                    <sourcexml>footnote/@fntoken</sourcexml>, then the
                                    <sourcexml>refpt</sourcexml> should be suppressed because a
                                    <targetxml>ref:anchor</targetxml> with the same value in
                                    <targetxml>@id</targetxml> is created as child of the target
                                    <targetxml>footnote</targetxml></p>-->   <!-- rosetta element: form-chars -->   <!-- <topicref href="../../common_newest/Rosetta_form-chars-LxAdv-formchars.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>
               <xd:i>form-chars</xd:i> becomes <xd:b>proc:formchars</xd:b>
                    and includes the attributes <xd:b>@formchar</xd:b> and
                        <xd:b>@formcharuse</xd:b>. Attributes
                        <xd:b>@formchar</xd:b> and <xd:b>@formcharuse</xd:b> are
                    required attributes in <xd:b>proc:formchars</xd:b> and the values for
                    these attributes are tokenized in the NewLexis Schema.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Attribute <xd:b>@formchar</xd:b> allows the tokenized values listed
                    below:</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="dot"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="dbl-rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="hypen"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>Below are the values for <xd:b>proc:formchars[@formchar]</xd:b> found
                    in the source documents and the corresponding mapping in NewLexis.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>form-chars[@character="."]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="dot"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character="_"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character="underline"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="rule"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character="-"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="hypen"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character=" "]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character=""]</xd:i> becomes
                        <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@character="&amp;nbsp;"]</xd:i> becomes
                            <xd:b>proc:formchars[@formchar="invisible"]</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Attribute <xd:b>@formcharuse</xd:b> values are listed below:</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="date"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="month"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="year"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="num"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="money"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="address"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="name"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="longname"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="leaderfill"]</xd:b>
                  <xd:b>@formcharuse="leaderfill"</xd:b> means fill the available
                        space with the formchar. Basically, push the text on each side out to the
                        margins if possible.</xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="other"]</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>The following are the widths (in points) used for this element in print for each
                    possible value of <xd:b>@formcharuse</xd:b>. To determine the number
                    of characters, divide the point value by 6.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="date"] 66 -&gt;11</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="day"] 36 -&gt;6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="month"] 48 -&gt; 8</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="year"] 36 -&gt; 6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="num"] 36 -&gt; 6</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="money"] 42 -&gt; 7</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="address"] 72 -&gt; 12</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="name"] 66 -&gt; 11</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="longname"] 132 -&gt;
                        22</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>proc:formchars[@formcharuse="other"] 66 -&gt; 11</xd:b>
               </xd:li>
            </xd:ul>
            <xd:b>Below are the values for <xd:b>proc:formchars[@formcharuse]</xd:b>
                    found in the source documents and the corresponding mapping in NewLexis.</xd:b>
            <xd:ul>
               <xd:li>
                  <xd:i>form-chars[@num-char="2"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@num-char="4"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="day"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@num-char="8"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="month"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@num-char="12"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="address"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>form-chars[@num-char="16"]</xd:i> becomes
                            <xd:b>proc:formchars[@formcharuse="longname"]</xd:b>
               </xd:li>
            </xd:ul>
            <xd:p>
               <xd:b>Note: </xd:b>If the value for <xd:i>@num-char</xd:i> doesn't fall in the above
                    specified list then use higher <xd:b>@formcharuse</xd:b> value in
                    target mapping. For example: If value for
                        <xd:i>form-chars/@num-char</xd:i> is "7" then use
                        <xd:b>"month"</xd:b> as the value for
                        <xd:b>proc:formchars/@formcharuse</xd:b>.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
&lt;p indent="none"&gt;
&lt;text&gt;&lt;form-chars character="_" num-char="7"/&gt;&lt;/text&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
&lt;p indent="none"&gt;
&lt;text&gt;&lt;proc:formchars formchar="rule" formcharuse="month"/&gt;&lt;/text&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>@num-char</xd:i> value goes beyond <xd:b>22</xd:b> simply use
                <xd:b>@formcharuse="longname"</xd:b> except below use case:
                <xd:i>&lt;form-chars character="dotleader" num-char="55.4" /&gt;</xd:i>
            will become <xd:b>&lt;proc:formchars formchar="invisible" fromcharuse="leaderfill"
                /&gt;</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
&lt;p indent="none"&gt;
&lt;text&gt;&lt;form-chars character="_" num-char="8"/&gt;&lt;/text&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;blockquote&gt;
&lt;p indent="none"&gt;
&lt;text&gt;&lt;proc:formchars formchar="rule" formcharuse="month"/&gt;&lt;/text&gt;
&lt;/p&gt;
&lt;/blockquote&gt;

	</xd:pre>
         <xd:p>
            <xd:i>form-chars/@character="line"</xd:i> will become
                <xd:b>proc:formchars/@formchar="rule"</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;form-chars character="line" num-char="6" /&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;proc:formchars formchar="rule" formcharuse="month"/&gt;

	</xd:pre>
         <xd:p>
            <xd:i>form-chars/@character="blank"</xd:i> will become
                <xd:b>proc:formchars/@formchar="invisible"</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;form-chars character="blank" num-char="40" /&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;proc:formchars formchar="invisible" formcharuse="longname"/&gt;

	</xd:pre>
         <xd:p>In Input if @num-char is not specified it means <xd:b>fill available space</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;form-chars character="." /&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;proc:formchars formchar="dot" fromcharuse="leaderfill"/&gt;

	</xd:pre>
         <!--Changes2013-02-08: Corrected the last mapping of
                        form-chars[@character=" "] to
                        proc:formchars[@formchar="invisible"] so that the
                    source element properly displays as
                        form-chars[@character="&nbsp;"].2012-08-30: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="form-chars"><!--  Original Target XPath:  proc:formchars   -->
      <proc:formchars>
         <xsl:variable name="character" select="@character"/>
         <xsl:variable name="numChar" select="number(@num-char)"/>
         <xsl:attribute name="formchar">
            <xsl:choose>
               <xsl:when test="$character = '.'">dot</xsl:when>
               <xsl:when test="$character = '_'">rule</xsl:when>
               <xsl:when test="$character = 'line'">rule</xsl:when>
               <xsl:when test="$character = 'underline'">rule</xsl:when>
               <xsl:when test="$character = '-'">hyphen</xsl:when>
               <xsl:when test="normalize-space($character) = ''">invisible</xsl:when>
               <xsl:when test="$character = 'blank'">invisible</xsl:when>
               <xsl:when test="$character = ''">invisible</xsl:when>
               <xsl:when test="$character = ''">invisible</xsl:when>
               <xsl:when test="$character = '??'">invisible</xsl:when>
               <xsl:when test="$character = 'dotleader' and $numChar = 55.4">invisible</xsl:when>
               <xsl:when test="$character = 'dotleader'">dot</xsl:when>
               <xsl:when test="$character = 'fullpoint'">dot</xsl:when>
               <xsl:otherwise>
                  <xsl:call-template name="outputErrorMessage">
                     <xsl:with-param name="messageText"
                                     as="xs:string"
                                     select=" 'ERROR:  Rosetta_form-chars-LxAdv-formchars.xsl - The source value is unknown.' "/>
                     <xsl:with-param name="errorType" as="xs:string" select=" 'ROCKET' "/>
                     <xsl:with-param name="errorCode" as="xs:string*" select=" '502' "/>
                     <xsl:with-param name="context" as="xs:string">
                        <xsl:value-of select="base-uri()"/>
                     </xsl:with-param>
                  </xsl:call-template>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:attribute>
         <xsl:attribute name="formcharuse"><!-- When statements are overlapping in order to match Instructions -->
            <xsl:choose>
               <xsl:when test="string($numChar) = 'NaN'">leaderfill</xsl:when>
               <xsl:when test="$numChar = 55.4 and $character = 'dotleader'">leaderfill</xsl:when>
               <xsl:when test="$numChar &gt; 22">longname</xsl:when>
               <xsl:when test="$numChar le 2">day</xsl:when>
               <xsl:when test="$numChar le 4">day</xsl:when>
               <xsl:when test="$numChar le 8">month</xsl:when>
               <xsl:when test="$numChar le 12">address</xsl:when>
               <xsl:when test="$numChar le 16">longname</xsl:when>
               <xsl:when test="$numChar le 22">longname</xsl:when>
               <xsl:otherwise>leaderfill</xsl:otherwise>
            </xsl:choose>
         </xsl:attribute>
         <xsl:apply-templates select="node()"/>
      </proc:formchars>
   </xsl:template>
   <!-- start topichead  glp:note  -->   <!-- <topicref href="../../common_newest/Rosetta_glp.note-LxAdv-note.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>glp:note</xd:i> becomes <xd:b>note</xd:b> and attribute <xd:i>@notetype</xd:i> becomes <xd:b>notetype</xd:b>. The children of <xd:i>glp:note</xd:i> are handled as
                follows: <xd:ul>
               <xd:li>
                  <xd:i>glp:note/heading</xd:i> becomes <xd:b>note/heading</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>glp:note/refpt</xd:i> becomes <xd:b>note/ref:anchor</xd:b>.</xd:li>
               <xd:li>
                  <xd:p>Other children of <xd:i>glp:note</xd:i> should map to children of <xd:b>note/bodytext</xd:b>.</xd:p>
                  <xd:p>Ex.</xd:p>
                  <xd:ul>
                     <xd:li>
                        <xd:i>glp:note/p</xd:i> becomes <xd:b>note/bodytext/p</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>glp:note/pgrp</xd:i> becomes <xd:b>note/bodytext/pgrp</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>glp:note/table</xd:i> becomes <xd:b>note/bodytext/table</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>glp:note/h</xd:i> becomes <xd:b>note/bodytext/h</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>glp:note/blockquote</xd:i> becomes <xd:b>note/bodytext/blockquote</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>glp:note/page</xd:i> becomes <xd:b>note/bodytext/ref:page</xd:b>.</xd:li>
                     <xd:li/>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i/>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;glp:note&gt;
	&lt;refpt id="257_ALR_1_1" type="ext"/&gt;
&lt;/glp:note&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;note&gt;
	&lt;ref:anchor id="au_257_ALR_1_1" anchortype="global"/&gt;
&lt;/note&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;glp:note notetype="warning"&gt;
&lt;p&gt;&lt;text&gt;Editor's Note: This document contains the full text of sections 1 to 70 and the Schedule. The Appendices to the Act are found in a separate document. Please conduct a cite search for "S.B.C. 1999, c. 2" to obtain all relevant documents.Acts Affected: Adoption Act, R.S.B.C. 1996, c. 5; Child, Family and Community Service Act, R.S.B.C. 1996, c. 46; Environmental Assessment Act, R.S.B.C. 1996, c. 119; Estate Administration Act, R.S.B.C. 1996, c. 122;...&lt;/text&gt;&lt;/p&gt;
&lt;/glp:note&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;note notetype="warning"&gt;
&lt;bodytext&gt;
&lt;p&gt;&lt;text&gt;Editor's Note: This document contains the full text of sections 1 to 70 and the Schedule. The Appendices to the Act are found in a separate document. Please conduct a cite search for "S.B.C. 1999, c. 2" to obtain all relevant documents.Acts Affected: Adoption Act, R.S.B.C. 1996, c. 5; Child, Family and Community Service Act, R.S.B.C. 1996, c. 46; Environmental Assessment Act, R.S.B.C. 1996, c. 119; Estate Administration Act, R.S.B.C. 1996, c. 122;...&lt;/text&gt;&lt;/p&gt;
&lt;/bodytext&gt;
&lt;/note&gt;

	</xd:pre>
         <!--Changes2012-11-30: Added instruction for attribute handling of glp:note.-->
         <!-- SEP 2015-8-6 added -->
         <!--  <xsltinclusion>
      <xsl:stylesheet version="2.0">
        <xsl:template match="glp:note">
			<xsl:element name="note">
				<xsl:apply-templates select="@*"/>
				<xsl:apply-templates select="heading"/>
				<xsl:element name="bodytext">
					<xsl:apply-templates select="*[not(heading)]"/>
				</xsl:element>
			</xsl:element>
			<xsl:apply-templates/>
        </xsl:template>
      </xsl:stylesheet>
    </xsltinclusion>	-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_glp.note-LxAdv-note.dita  -->
   <!-- JD: 2017-08-08: Note that this also processes 'leg:histnote' via template name, called from this module; this was done to match DT output, which groups both under a <notes> wrapper -->
   <xsl:template match="glp:note" name="glp-note-generic">
      <note>
         <xsl:if test="self::leg:histnote">
            <xsl:attribute name="notetype" select="'historical'"/>
         </xsl:if>
         <xsl:if test="$streamID='AU18' and child::heading/desig/designum/refpt">
            <xsl:attribute name="notetype" select="'jurisdiction-variant'"/>
         </xsl:if>
         <xsl:choose>
            <xsl:when test="$streamID='AU18' and ./@id = descendant::refpt/@id"/>
            <xsl:otherwise>
               <xsl:apply-templates select="@id"/>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:apply-templates select="@* except @id"/>
         <!-- from 
                DITA/ConversionInstructions/Rosetta/common_newest/Rosetta_leg.comntry-level_LEVELTYPE_GROUP-LxAdv-annot.annotations-annot.annotation-grp.dita
            and other annotation CIs-->
         <xsl:if test="not(@notetype) and ancestor::level[ancestor::leg:comntry] and not(descendant::inlineobject | following-sibling::inlineobject)">
            <xsl:attribute name="notetype" select="'xref'"/>
         </xsl:if>
         <xsl:apply-templates select="refpt | heading/descendant::refpt"/>
         <xsl:apply-templates select="heading"/>
         <!-- SS: template added for handling heading and h under caseinfo for NZ03 cases-->
         <xsl:if test="preceding-sibling::heading[parent::caseinfo][$streamID='NZ03']">
            <xsl:apply-templates select="preceding-sibling::heading[parent::caseinfo]"/>
            <xsl:apply-templates select="preceding-sibling::h[parent::caseinfo]"/>
         </xsl:if>
         <xsl:if test="child::*[not(self::heading)][not(self::refpt)]">
            <bodytext><!-- Awantika: if remotelink is the child of glp:note then p/text is required -->
               <xsl:choose>
                  <xsl:when test="child::remotelink or not(child::p/child::table or child::p/child::text) and $streamID=('HK03, NZ03')">
                     <p>
                        <text>
                           <xsl:apply-templates select="child::* except (heading | refpt)"/>
                        </text>
                     </p>
                  </xsl:when>
                  <!--Satbir: Added condition for handling "glp:note/p/table"-->
                  <xsl:when test="child::p/child::table or child::p/child::text and $streamID='NZ03'">
                     <xsl:apply-templates select="child::* except (heading | refpt)"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:apply-templates select="child::* except (heading | refpt)"/>
                  </xsl:otherwise>
               </xsl:choose>
            </bodytext>
         </xsl:if>
      </note>
   </xsl:template>

   <xsl:template match="glp:note/@notetype">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!-- Vikas Rohilla : Updated for the streamID CA01 -->
   <xsl:template match="glp:note[parent::lilabel][$streamID=('CA01','CA04')]">
      <xsl:value-of select="."/>
   </xsl:template>
   <!-- Vikas Rohilla : Updated for the streamID CA14    -->
   <xsl:template match="glp:note[parent::dig:info[parent::dig:collection]][$streamID='CA14']">
      <xsl:text disable-output-escaping="yes">&lt;!--</xsl:text>
      <xsl:copy-of select="." copy-namespaces="no"/>
      <xsl:text disable-output-escaping="yes">--&gt;</xsl:text>
   </xsl:template>

   <xsl:template match="glp:note[parent::case:headnote][$streamID='NZ04']">
      <caseinfo:caseinfo>
         <note>
            <bodytext>
               <xsl:apply-templates/>
            </bodytext>
         </note>
      </caseinfo:caseinfo>
   </xsl:template>
   <!-- paul: this is a template that merges sibling glp:notes into <notes> wrapper.  add your stream id if you want to use it rather than the generic above 
    		JD: Note that in order to merge this must NOT be called from a for-each; see below template
    		JD: 2017-08-10: added 'leg:histnote' as well, as (at least in NZ06) these are grouped under the same <notes> wrapper.
    -->
   <xsl:template match="glp:note[$streamID=('AU10','NZ06','NZ13','NZ18')] | leg:histnote[$streamID=('AU10','NZ06','NZ13','NZ18')]"
                 name="glp-note-mergesiblings"
                 priority="2">
      <xsl:choose>
         <xsl:when test=".=''"/>
         <xsl:when test="parent::level or parent::heading/parent::level"><!-- these get mapped to prelim, which can't contain notes plural wrapper -->
            <xsl:call-template name="glp-note-generic"/>
         </xsl:when>
         <!-- when this is the first note and there are following sibling notes to be included in it, create wrapper  -->
         <xsl:when test="not(preceding-sibling::*[1][self::glp:note or self::leg:histnote]) and (following-sibling::glp:note or following-sibling::leg:histnote)">
            <notes>
               <xsl:call-template name="glp-note-generic"/>
               <!-- JD: replacing this for-each to (a) include leg:histnote and (b) limit to immediate siblings -->
               <!--<xsl:for-each select="following-sibling::*[name()='glp:note']/preceding-sibling::glp:note">-->
               <xsl:for-each select="following-sibling::glp:note[preceding-sibling::*[1][name()=('glp:note','leg:histnote')]]                   | following-sibling::leg:histnote[preceding-sibling::*[1][name()=('glp:note','leg:histnote')]]">
                  <xsl:call-template name="glp-note-generic"/>
               </xsl:for-each>
            </notes>
         </xsl:when>
         <!-- when the immediate preceding sibling is a glp:note it will have been grouped above, do nothing -->
         <xsl:when test="preceding-sibling::*[1][self::glp:note or self::leg:histnote]"/>
         <!-- otherwise, process in generic fashion -->
         <xsl:otherwise>
            <xsl:call-template name="glp-note-generic"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- JD: 2017-08-08: new template to group multiple contiguous <glp:note> and <leg:histnote> under <notes> 
		   when called from a for-each-group (e.g., under <leg:bodytext> created from template priority="30" in /modules/nonamespace/Rosetta_endnote-LxAdv-endnote.xsl)
	-->
   <xsl:template match="glp:note[$streamID=('NZ06','NZ13') and parent::leg:bodytext   and not(preceding-sibling::*[1][name()=('glp:note','leg:histnote')])]    | leg:histnote[$streamID=('NZ06','NZ13') and parent::leg:bodytext   and not(preceding-sibling::*[1][name()=('glp:note','leg:histnote')])]    "
                 name="glp-note-mergesiblings-from-loop"
                 priority="3">
      <xsl:choose>
         <xsl:when test=".=''"/>
         <!-- if no content do nothing -->
         <xsl:when test="parent::level or parent::heading/parent::level"><!-- these get mapped to prelim, which can't contain notes plural wrapper -->
            <xsl:call-template name="glp-note-generic"/>
         </xsl:when>
         <!-- when this is the first note and there are following sibling notes to be included in it, create wrapper  -->
         <xsl:when test="not(preceding-sibling::*[1][self::glp:note or self::leg:histnote])     and (following-sibling::*[1][name()=('glp:note','leg:histnote')])">
            <notes><!-- process the first note -->
               <xsl:call-template name="glp-note-generic"/>
               <!-- 
					group immediate sibling notes (logic modified from https://gist.github.com/empo/1105204 )
					-->
               <xsl:variable name="children"
                             select="following-sibling::glp:note | following-sibling::leg:histnote"/>
               <xsl:for-each select="following-sibling::*">
                  <xsl:variable name="index" select="position()"/>
                  <xsl:if test="         generate-id( . ) = generate-id( $children[$index] )">
                     <xsl:call-template name="glp-note-generic"/>
                  </xsl:if>
               </xsl:for-each>
            </notes>
         </xsl:when>
         <!-- when the immediate preceding sibling is a glp:note it will have been grouped above, do nothing -->
         <xsl:when test="preceding-sibling::*[1][self::*[name()=('glp:note','leg:histnote')]]"/>
         <!-- otherwise, process in generic fashion -->
         <xsl:otherwise>
            <xsl:call-template name="glp-note-generic"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="glp:note[$streamID=('AU14')]">
      <xsl:choose>
         <xsl:when test="self::glp:note[following-sibling::level | preceding-sibling::level]">
            <bodytext>
               <xsl:call-template name="AU14-glp-note"/>
            </bodytext>
         </xsl:when>
         <xsl:otherwise>
            <xsl:call-template name="AU14-glp-note"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template name="AU14-glp-note">
      <note>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt"/>
         <xsl:apply-templates select="heading"/>
         <xsl:apply-templates select="contrib"/>
         <xsl:if test="child::*[not(self::heading)][not(self::refpt)][not(self::contrib)]">
            <bodytext>
               <xsl:apply-templates select="child::* except (heading | refpt | contrib)"/>
            </bodytext>
         </xsl:if>
      </note>
   </xsl:template>
   <!-- Awantika:2017-10-31- added template for AU01.
		If glp:note is the child of text then glp:note becomes inlinenote with attribute @notetype="editor-note" -->
   <xsl:template match="glp:note[parent::text][$streamID=('AU01', 'NZ03')]">
      <inlinenote>
         <xsl:attribute name="notetype" select="'editor-note'"/>
         <xsl:value-of select="."/>
      </inlinenote>
   </xsl:template>
   <!-- Awantika: Not in GDS -->   <!-- <topicref href="../../common_newest/Rosetta_glp.note_blockquote_p_text_inlineobject-LxAdv-note_bodytext_p_text.dita"/> -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/glp/Rosetta_glp.note_blockquote_p_text_inlineobject-LxAdv-note_bodytext_p_text.xsl"/>
	<!-\- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -\->
	<!-\- <topicref href="../../common_newest/Rosetta_glp.note-Chof-p-LxAdv-note.dita"/> -\->
	<xsl:include href="../../modules/glp/Rosetta_glp.note-Chof-p-LxAdv-note.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_glp.note-Chof-level_heading-LxAdv-seclaw.level_seclaw.prelim_note.dita"/> -\->
	<!-\- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -\->
	<xsl:include
		href="../../modules/glp/Rosetta_glp.note-Chof-level_heading-LxAdv-seclaw.level_seclaw.prelim_note.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_glp.note-Chof-leg.comntry_level-LxAdv-annot.annotation_bodytext_note.dita"/> -\->
	<!-\- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -\->
	<xsl:include
		<!-\- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -\->
		href="../../modules/glp/Rosetta_glp.note-Chof-leg.comntry_level-LxAdv-annot.annotation_bodytext_note.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_glp.note-Chof-leg.comntry_level_level-LxAdv-annot.annotationlevel_annot.bodytext_note.dita"/> -\->
	<xsl:include
		href="../../modules/glp/Rosetta_glp.note-Chof-leg.comntry_level_level-LxAdv-annot.annotationlevel_annot.bodytext_note.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_glp.note-Chof-leg.heading-LxAdv-primlaw.level_note.dita"/> -->   <!--	<xsl:include href="../../modules/glp/Rosetta_glp.note-Chof-leg.heading-LxAdv-primlaw.level_note.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_glp.note-Chof-text-LxAdv-inlinenote.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>If <xd:i>glp:note</xd:i> is the child of <xd:i>text</xd:i> then
              <xd:i>glp:note</xd:i> becomes <xd:b>inlinenote</xd:b> with
            attribute <xd:b>@notetype="editor-note"</xd:b>
               </xd:li>
               <xd:li>If <xd:i>p/text</xd:i> is the child of <xd:i>glp:note</xd:i> then
            conversion should suppress <xd:i>p/text</xd:i> element only and PCDATA of this
            directly goes into <xd:b>inlinenote</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
  &lt;text&gt;
    &lt;glp:note&gt;
        &lt;p nl="0"&gt;
            &lt;text&gt;[Editor's note: Figure 1 could not be reproduced online. Please 
contact Quicklaw Customer Service at 1-800-387-0899 or service@quicklaw.com and request 
the following document: 07aeub57Figure1.doc]&lt;/text&gt;
      &lt;/p&gt;
    &lt;/glp:note&gt; A number of area residents expressed opposition to the proposed wells, as described below. 
  &lt;/text&gt;
&lt;/p&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
  &lt;text&gt;
    &lt;inlinenote notetype="editor-note"&gt;      
        [Editor's note: Figure 1 could not be reproduced online. 
Please contact Quicklaw Customer Service at 1-800-387-0899 or service@quicklaw.com and 
request the following document: 07aeub57Figure1.doc]        
    &lt;/inlinenote&gt; A number of area residents expressed opposition to the proposed wells, as described below. 
&lt;/text&gt;
&lt;/p&gt;

</xd:pre>
         <!--Changes2016-04-01: Added instruction for child elements of glp:note element, Applicable on CA01.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_glp.note-Chof-text-LxAdv-inlinenote.dita  -->
   <!-- Vikas Rohilla : Initial created the text/glp:note-->
   <!-- Sudhanshu Srivastava added CA02 Stream ID for converting glpnote to inline -->
   <xsl:template match="text/glp:note[$streamID='CA01' or $streamID='CA02CC' or $streamID='CA04' ]">
      <inlinenote>
         <xsl:attribute name="notetype">
            <xsl:text>editor-note</xsl:text>
         </xsl:attribute>
         <xsl:apply-templates/>
      </inlinenote>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_glp.note-Chof-emph-LxAdv-inlinenote.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
            If <xd:i>glp:note</xd:i> is the child of <xd:i>emph</xd:i> then <xd:i>glp:note</xd:i> becomes <xd:b>inlinenote</xd:b> with attribute <xd:b>@notetype="editor-note"</xd:b>
               </xd:li>
               <xd:li>If <xd:i>p/text</xd:i> is the child of <xd:i>glp:note</xd:i> then
            conversion should suppress <xd:i>p/text</xd:i> element only and PCDATA of this
            directly goes into <xd:b>inlinenote</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML </xd:b>
         </xd:p>
         <xd:pre>

&lt;p indent="1st-line"&gt;
  &lt;text&gt;
    &lt;emph typestyle="bf"&gt;
      &lt;glp:note&gt;
         &lt;p&gt;
          &lt;text&gt;
[Editor's note: Appendix A could not be reproduced online. Please contact Quicklaw Customer 
Service at 1-800-387-0899 or service@quicklaw.com and request the following document: 
07bcl217.doc.]&lt;/text&gt;
        &lt;/p&gt;     
    &lt;/glp:note&gt;
  &lt;/emph&gt;
 &lt;/text&gt;
&lt;/p&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p indent="1st-line"&gt;
  &lt;text&gt;
    &lt;emph typestyle="bf"&gt;
      &lt;inlinenote notetype="editor-note"&gt;        
[Editor's note: Appendix A could not be reproduced online. Please contact Quicklaw Customer 
Service at 1-800-387-0899 or service@quicklaw.com and request the following document: 
07bcl217.doc.]
    &lt;/inlinenote&gt;
  &lt;/emph&gt;
 &lt;/text&gt;
&lt;/p&gt;

</xd:pre>
         <!--Changes2016-04-01: Added instruction for child elements of glp:note element, Applicable on CA01.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_glp.note-Chof-emph-LxAdv-inlinenote.dita  -->
   <!-- Vikas Rohilla : Initila updated -->
   <xsl:template match="emph/glp:note[$streamID='CA01']">
      <inlinenote>
         <xsl:attribute name="notetype">
            <xsl:text>editor-note</xsl:text>
         </xsl:attribute>
         <xsl:value-of select="."/>
      </inlinenote>
   </xsl:template>
   <!-- end topichead  glp:note  -->   <!-- start topichead  h  -->   <!-- <topicref href="../../common_newest/Rosetta_h-LxAdv-h.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>h</xd:i> becomes <xd:b>h</xd:b>. The attributes of <xd:i>h</xd:i> are
					handled as follows: <xd:ul>
               <xd:li>
                  <xd:i>h/@l</xd:i> becomes <xd:b>h/@level</xd:b>.</xd:li>
               <xd:li>
                  <xd:i>h/@align</xd:i> becomes <xd:b>h/@align</xd:b>. The valid values for
								<xd:b>h/@align</xd:b> are:<xd:ul>
                     <xd:li>"left"</xd:li>
                     <xd:li>"right"</xd:li>
                     <xd:li>"center"</xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <!-- MDS - 2017-05-12 - Addded due to need to match DT output. -->If the Stream is UK08CA and the parent element is <xd:i>entry</xd:i>, pass through the element
				and process the children.<xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;h l="3" align="center"&gt; &lt;emph typestyle="it"&gt;Background&lt;/emph&gt; &lt;/h&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;h level="3" align="center"&gt; &lt;emph typestyle="it"&gt;Background&lt;/emph&gt; &lt;/h&gt;
				</xd:pre>
         <!--Changes-->
         <!-- SEP 2015-8-12 copied from Rosetta-to-LA\modules\base\base.xsl -->
         <!-- MDS 2017-04-05 - Added from UK08CA stream inlineobject handling  -->
         <xd:p>Within UK08CA stream, when source is having emph followed by inlineobject inside base:h element
						<xd:i>h/emph/inlineobject</xd:i>than in Target it should Map with and becomes
						<xd:b>emph/ref:inlineobject</xd:b>.</xd:p>
         <!-- MDS 2017-05-15 - Added from /nonamespace/Rosetta_h-Chof-form_bodytext-LxAdv-form.h.xsl -->
         <xd:p>
            <xd:i>form/bodytext/h</xd:i> becomes <xd:b>form:h</xd:b>.</xd:p>
         <xd:pre> &lt;h&gt; &lt;emph typestyle="bf"&gt;Table 2 Estimation of regression coefficients using the SUR
					model &lt;inlineobject type="image" mimetype="image/gif" filename="JFRC_2005_Vol13_Issue2_May_167_1.gif" /&gt;
					&lt;/emph&gt; &lt;/h&gt; <xd:b>Becomes</xd:b> &lt;emph typestyle="bf"&gt;Table 2 Estimation of regression
					coefficients using the SUR model &lt;ref:inlineobject&gt; &lt;ref:locator&gt; &lt;ref:locator-key&gt;
					&lt;ref:key-name name="object-key"/&gt; &lt;ref:key-value value="X-Y-JFRC_2005_Vol13_Issue2_May_167_1"/&gt;
					&lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt; &lt;/ref:locator-key&gt;
					&lt;ref:locator-params&gt; &lt;proc:param name="componentseq" value="1"/&gt; &lt;proc:param name="object-type"
					value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt; &lt;proc:param
					name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
					&lt;/ref:locator-params&gt; &lt;/ref:locator&gt; &lt;/ref:inlineobject&gt; &lt;/emph&gt; </xd:pre>
      </xd:desc>
   </xd:doc>
   <xsl:variable name="docinfoidtext" select="/*/docinfo/docinfo:doc-id/text()"/>
   <xsl:template match="h">
      <xsl:choose><!-- MDS 2017-05-12 - Added to match DT Output -->
         <xsl:when test="$streamID = 'UK08CA' and parent::entry">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:when test="$streamID='UK06'">
            <h>
               <xsl:apply-templates select="@*|node()"/>
            </h>
         </xsl:when>
         <!-- 2017-10-19 MDS: Added handling for parent:clause[parent::frm:div] -->
         <xsl:when test="(parent::bodytext|parent::blockquote|parent::frm:*|parent::clause)[parent::form|parent::frm:*|parent::clause[ancestor::frm:divs]]">
            <form:h>
               <xsl:if test="@l">
                  <xsl:attribute name="level">
                     <xsl:value-of select="@l"/>
                  </xsl:attribute>
               </xsl:if>
               <xsl:copy-of select="@* except (@typesize|@l)"/>
               <xsl:apply-templates select="node()"/>
            </form:h>
         </xsl:when>
         <!-- 20170601:  MCJ:  Excluding AU06 from this condition because the regulation schema does not support base:entry/base:toc. -->
         <!-- JL added AU05 -->
         <!-- 2017-11-15: JD: Excluding UK01. 
        Rather than add all to this exclude list maybe we should specifically INCLUDE what we want(?)
        -->
         <!-- 2017-11-16 - CSN: Added UK03.  webstar 7050317.   
			Totally agree with JD above.   This logic is backwards. -->
         <xsl:when test="parent::entry and not($streamID = ('AU05','AU06','AU15','NZ09','UK01','UK03','UK09','NZ12','UK07'))">
            <xsl:element name="toc">
               <xsl:element name="toc-entry">
                  <heading>
                     <xsl:if test="@l">
                        <xsl:attribute name="level">
                           <xsl:value-of select="@l"/>
                        </xsl:attribute>
                     </xsl:if>
                     <!-- SEP 2015-08-06 looks like there was a missing @ here, added it -->
                     <xsl:if test="@align">
                        <xsl:attribute name="align">
                           <xsl:value-of select="@align"/>
                        </xsl:attribute>
                     </xsl:if>
                     <title>
                        <xsl:apply-templates/>
                     </title>
                  </heading>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:when test="child::inlineobject">
            <figure><!-- SEP 2015-08-06 looks like there was a missing @ here, added it -->
               <xsl:if test="@align">
                  <xsl:attribute name="align">
                     <xsl:value-of select="@align"/>
                  </xsl:attribute>
               </xsl:if>
               <xsl:apply-templates/>
            </figure>
         </xsl:when>
         <!-- MDS - 2017-05-05 - As specified in '/comm/UK08_QUASI_ReguMate_COMMTOADMINDOC-Body.xsl' -->
         <xsl:when test="$streamID = 'UK08CA' and emph/inlineobject">
            <xsl:apply-templates select="node()"/>
         </xsl:when>
         <!-- 2017-12-18 - CSN - Webstar 7074749 - Remove typeofcase.  Handled in that module. -->
         <xsl:when test="(parent::case:decisionsummary) and $streamID='UK03'">
            <bodytext>
               <h>
                  <xsl:apply-templates select="@*|node()"/>
               </h>
            </bodytext>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose>
               <xsl:when test="contains(lower-case($docinfoidtext),'overview') and //source_cttr:annotations[@id='OP15']/heading/note/h[@id='OP15A']">
                  <xsl:apply-templates/>
               </xsl:when>
               <xsl:when test="contains(lower-case($docinfoidtext),'analytics') and parent::comm:citations and $streamID='AU20'">
                  <xsl:apply-templates/>
               </xsl:when>
               <xsl:otherwise>
                  <h>
                     <xsl:if test="@l">
                        <xsl:attribute name="level">
                           <xsl:value-of select="@l"/>
                        </xsl:attribute>
                     </xsl:if>
                     <!-- SEP 2015-08-06 looks like there was a missing @ here, added it -->
                     <xsl:if test="@align">
                        <xsl:attribute name="align">
                           <xsl:value-of select="@align"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:apply-templates/>
                  </h>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="h/@l">
      <xsl:choose>
         <xsl:when test="$streamID='UK06'"/>
         <xsl:otherwise>
            <xsl:attribute name="level">
               <xsl:value-of select="."/>
            </xsl:attribute>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="h/@align">
      <xsl:attribute name="align">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>
   <!-- Awantika: Not in GDS -->   <!-- <topicref href="../../common_newest/Rosetta_h-Chof-entry-LxAdv-entry_toc_toc-entry_heading.dita"/> -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/nonamespace/Rosetta_h-Chof-entry-LxAdv-entry_toc_toc-entry_heading.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_h-Chof-form_bodytext-LxAdv-form.h.dita"/> -\->
	<xsl:include href="../../modules/nonamespace/Rosetta_h-Chof-form_bodytext-LxAdv-form.h.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- end topichead  h  -->   <!-- rosetta element: heading -->   <!-- <topicref href="../../common_newest/Rosetta_heading-LxAdv-heading.dita"/> -->   <xd:doc>
      <xd:desc><!--   @SBy:  bodytext/heading is added based on the QC XSLT   --><!--p><sourcexml>heading</sourcexml> becomes <targetxml>heading</targetxml>. The attributes of <sourcexml>heading</sourcexml> are handled as  -->
         <xd:p>
            <xd:i>heading</xd:i> becomes <xd:b>heading</xd:b> and <xd:i>bodytext/heading</xd:i> becomes <xd:b>h</xd:b>. The attributes of <xd:i>heading</xd:i> are handled as
					follows: <xd:ul>
               <xd:li>
                  <xd:i>heading/@inline</xd:i> is suppressed if target is <xd:b>h</xd:b>.  Otherwise, <xd:i>heading/@inline</xd:i> becomes <xd:b>heading/@inline</xd:b>. The valid values for
								<xd:b>@inline</xd:b> are:<xd:ul>
                     <xd:li>"true"</xd:li>
                     <xd:li>"false"</xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>heading/@align</xd:i> becomes <xd:b>heading@align</xd:b>. The valid values for
								<xd:b>@align</xd:b> are:<xd:ul>
                     <xd:li>"left"</xd:li>
                     <xd:li>"right"</xd:li>
                     <xd:li>"center"</xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>
                  <xd:i>heading/@searchtype</xd:i> should be suppressed.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Conversion should not create consecutive <xd:b>heading</xd:b> elements. When 2 or more sibling source elements map to
						<xd:b>heading</xd:b>, the data should be merged into a single <xd:b>heading</xd:b> element unless this would
					interfere with content ordering.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading align="center"&gt;
	&lt;title&gt;Consideration&lt;/title&gt;
&lt;/heading&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading align="center"&gt;
  &lt;title&gt;Consideration&lt;/title&gt;
&lt;/heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading inline="false"&gt;
	&lt;title&gt;Summary&lt;/title&gt;
&lt;/heading&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading inline="false"&gt;
	  &lt;title&gt;Summary&lt;/title&gt;
&lt;/heading&gt;

		</xd:pre>
         <!--Changes-->
         <xd:p>2013-03-06: Removed instructions/rules for exceptional desig scenario and deprecated
				attribute <xd:b>@followstitle</xd:b>.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_heading-LxAdv-heading.dita  -->
   <xsl:template match="bodytext/heading[not($streamID='CA14' or $streamID='USLPA')]"><!--   @SBy:  this rule added based on the QC XSLT   -->
      <h>
         <xsl:choose>
            <xsl:when test="$streamID=('UK07','AU14','HK07')">
               <xsl:apply-templates select="title | subtitle" mode="bodytext_heading"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@* | node()"/>
               <!--    ... When 2 or more sibling source elements map to <targetxml>heading</targetxml>, the data should be merged into a single <targetxml>heading</targetxml> element unless this would interfere with content ordering.</note>     -->
               <xsl:for-each select="following-sibling::node()[1][ self::heading ]">
                  <xsl:call-template name="combineSiblingsOfSameName"/>
               </xsl:for-each>
            </xsl:otherwise>
         </xsl:choose>
      </h>
   </xsl:template>

   <xsl:template match="heading"><!--  Original Target XPath:  heading   -->
      <heading><!-- MDS 2017-05-05 - Added 'except(refpt) due to UK08CA source markup 
	JL added leg:empleg to except list - it's addressed elsewhere and not valid here ever -->
         <xsl:apply-templates select="@* | node() except (refpt | leg:empleg)"/>
         <!--    ... When 2 or more sibling source elements map to <targetxml>heading</targetxml>, the data should be merged into a single <targetxml>heading</targetxml> element unless this would interfere with content ordering.</note>     -->
         <xsl:for-each select="following-sibling::node()[1][ self::heading ]">
            <xsl:call-template name="combineSiblingsOfSameName"/>
         </xsl:for-each>
         <xsl:if test="$streamID=('UK06','UK12')">
            <xsl:apply-templates select="following-sibling::note"/>
         </xsl:if>
      </heading>
   </xsl:template>
   <!--		<li><sourcexml>heading/@searchtype</sourcexml> should be suppressed.</li>  -->   <!--		<li><sourcexml>heading/@inline</sourcexml> is suppressed if target is <targetxml>h</targetxml>.  Otherwise, ...  -->   <!--    ... When 2 or more sibling source elements map to <targetxml>heading</targetxml>, the data should be merged into a single <targetxml>heading</targetxml> element unless this would interfere with content ordering.</note>     -->
   <xsl:template match="heading/@searchtype | bodytext/heading/@inline | heading[ preceding-sibling::node()[1][ self::heading ] ]"/>

   <xsl:template match="heading[ not( parent::bodytext ) ]/@inline"><!--  Original Target XPath:  @inline   -->
      <xsl:copy-of select=" . "/>
   </xsl:template>

   <xsl:template match="heading/@align"><!--  Original Target XPath:  @align   -->
      <xsl:copy-of select=" . "/>
   </xsl:template>

   <xsl:template match="title [$streamID=('UK07','AU14','HK07')]"
                 mode="bodytext_heading">
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>

   <xsl:template match="subtitle [$streamID=('UK07','AU14','HK07')]"
                 mode="bodytext_heading">
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>
   <!-- rosetta element: hrule -->   <!-- <topicref href="../../common_newest/Rosetta_hrule-LxAdv-hrule.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>hrule</xd:i> becomes <xd:b>hrule</xd:b> and attributes
                    <xd:i>@align</xd:i> and <xd:i>@width</xd:i> needs to be
                supressed and presentation stylesheet will render <xd:b>hrule</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>hrule[parent::blockquote]</xd:i>
            <xd:i>hrule</xd:i> should become <xd:b>pgrp/hrule</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;hrule align="true" width="5"/&gt;

   </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;hrule/&gt;

	</xd:pre>
         <!--Changes2011-12-21: Created. 2012-12-06: Instruction added for attributes handling.-->
         <!-- SEP 2015-8-12 added -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_hrule-LxAdv-hrule.dita  -->
   <xsl:template match="hrule">
      <xsl:element name="hrule"
                   namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
         <xsl:apply-templates select="@*"/>
      </xsl:element>
   </xsl:template>

   <xsl:template match="hrule[parent::blockquote[not(ancestor::leg:comntry)]]">
      <pgrp>
         <xsl:element name="hrule">
            <xsl:apply-templates select="@*"/>
         </xsl:element>
      </pgrp>
   </xsl:template>
   <!--  Vikas Rohilla : Created the template for the stream CA14   -->
   <xsl:template match="hrule[parent::highlight][$streamID='CA14']"/>

   <xsl:template match="hrule/@align | hrule/@width"/>
   <!-- start topichead  inlineobject  -->   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-LxAdv-ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>If the <xd:i>inlineobject</xd:i>
            <xd:i>is not</xd:i> a diagram or picture illustrating textual material (e.g. a minor icon or
        symbol that is not otherwise suppressed), <xd:i>inlineobject</xd:i> becomes
          <xd:b>ref:inlineobject</xd:b>. <xd:ul>
               <xd:li>Create <xd:b>ref:locator</xd:b> and describe as: <xd:ul>
                     <xd:li>Create <xd:b>ref:locator-key</xd:b> and describe as: <xd:ul>
                           <xd:li>Create <xd:b>ref:key-name</xd:b> with
                      <xd:b>@name="object-key"</xd:b>. This line is hard coded. </xd:li>
                           <xd:li>Create <xd:b>ref:key-value</xd:b> with
                    <xd:b>@value</xd:b>, as follows: <xd:ul>
                                 <xd:li>If <xd:i>inlineobject[@smi]</xd:i> is present, then
                          <xd:b>@value</xd:b> is copied from
                          <xd:i>inlineobject[@filename]</xd:i>.</xd:li>
                                 <xd:li>If <xd:i>inlineobject[@smi]</xd:i> is not present, then
                          <xd:b>@value="X-Y-Z"</xd:b>, where X is LNI, Y is SMI, and Z is
                        filename. LNI and SMI(retreived from CSSM) values are added by <xd:b>"Workflow
                          Generic Image Handlers"</xd:b>. The last component "Z" is copied from
                          <xd:i>inlineobject[@filename]</xd:i>.</xd:li>
                                 <xd:p>
                                    <xd:b>Note: </xd:b>
                                    <!-- Added by MDS (2017-03-20) - Based on email from Roopa Singh (2017-03-17 6:19pm) -->
                        If <xd:i>inlineobject[@smi]</xd:i> still add the <xd:i>@filename</xd:i> value as the value of <xd:b>ref:key-value/@value</xd:b>.
                            The correct format of the value will be established using the Generic Image Handler process downstream.
                        </xd:p>
                                 <xd:li>If <xd:i>inlineobject[@smi]</xd:i> is not present, conversion
                        program should pass <xd:i>inlineobject[@filename]</xd:i> value to
                          <xd:b>Generic Image Handler</xd:b> as is and <xd:b>Generic Image Handler</xd:b>
                        will do conversion of filename value as noted above. <xd:b>Conversion of
                          filename replaces underscore, blank, and period with hyphen.</xd:b>
                                 </xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                     </xd:li>
                     <xd:li>Create <xd:b>ref:locator-params</xd:b> and describe as: <xd:ul>
                           <xd:li>Create <xd:b>proc:param[@name]</xd:b> and
                      <xd:b>proc:param[@value]</xd:b> pairs as follows: <xd:ul>
                                 <xd:li>
                                    <xd:b>proc:param[@name="componentseq"]</xd:b> with the attribute
                          <xd:b>@value="1"</xd:b>. This line is hard coded.</xd:li>
                                 <xd:li>
                                    <xd:b>proc:param[@name="object-type"]</xd:b> with the attribute
                          <xd:b>@value="image"</xd:b> if the extension of
                          <xd:i>inlineobject[@filename]</xd:i> is either of these values
                        (.jpg, .gif, .png, .tiff and .bmp).</xd:li>
                                 <xd:li>
                                    <xd:b>proc:param[@name="object-smi"]</xd:b> with the attribute
                          <xd:b>@value</xd:b>. The <xd:b>@value</xd:b> value is
                        from <xd:i>inlineobject[@smi]</xd:i>. If
                          <xd:i>inlineobject[@smi]</xd:i> is not present, obtain SMI from
                        CSSM. This <xd:b>@value</xd:b> assignment is done by conversion
                        program.
                          <xd:p>
                                       <xd:b>Note: </xd:b>
                                       <!-- Added by MDS (2017-03-20) - Based on email from Roopa Singh (2017-03-17 6:19pm) -->
                              If <xd:i>inlineobject[@smi]</xd:i> is not present, add the following <xd:b>proc:param</xd:b> markup:
                              <xd:ul>
                                          <xd:li>@name='external-or-local' @value='external'</xd:li>
                                          <xd:li>@name='object-server' @value='Blobstore'</xd:li>
                                          <xd:li>@name='object-pguid' @value='urn:contentitem'</xd:li>
                                       </xd:ul>
                                    </xd:p>
                                 </xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                     </xd:li>
                  </xd:ul>
               </xd:li>
               <xd:li>The other attributes of <xd:i>inlineobject</xd:i> are handled as follows: <xd:ul>
                     <xd:li>
                        <xd:i>inlineobject/@height</xd:i> becomes
                  <xd:b>ref:inlineobject/@height</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>inlineobject/@width</xd:i> becomes
                  <xd:b>ref:inlineobject/@width</xd:b>.</xd:li>
                     <xd:li>
                        <xd:i>inlineobject/@attachment</xd:i> should be suppressed.</xd:li>
                     <xd:li>
                        <xd:i>inlineobject/@key</xd:i> should be suppressed.</xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>In the case of icons or other boilerplate images, the <xd:i>inlineobject</xd:i>
          shall usually be suppressed from conversion and a corresponding product requirement should
          be created with instructions to instantiate the image on retrieval based on
          information/semantic markup in the document. This will sometimes include additional
          attributes being added to target elements created from parent source elements (such as
          <xd:b>ref:crossreference</xd:b> from <xd:i>remotelink</xd:i>).</xd:p>
            <xd:p>Usually, any icons encountered from the list below should be suppressed. These files
          should be suppressed for both *.gif and *.png file types. <xd:ul>
                  <xd:li>1.gif</xd:li>
                  <xd:li>2.gif</xd:li>
                  <xd:li>3.gif</xd:li>
                  <xd:li>4.gif</xd:li>
                  <xd:li>5.gif</xd:li>
                  <xd:li>IconSignalPositive.gif</xd:li>
                  <xd:li>IconSignalNegative.gif</xd:li>
                  <xd:li>IconSignalNeutral.gif</xd:li>
                  <xd:li>IconSignalPossibleNegative.gif</xd:li>
                  <xd:li>IconSignalCiteInfoOnly.gif</xd:li>
                  <xd:li>cbcc.gif</xd:li>
                  <xd:li>leg1.gif</xd:li>
                  <xd:li>mb.gif</xd:li>
                  <xd:li>au_repealed.gif</xd:li>
                  <xd:li>au_exclaim.gif</xd:li>
               </xd:ul>
            </xd:p>
            <xd:p>Use cases where the LBU feels the product requirement cannot be met if the markup is
          completely suppressed shall be handled case-by-case, and as usual additional topics will
          contain specific instructions for these scenarios that override the instructions in this
          note.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML. Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt; 
        &lt;inlineobject type="image" 
                      smi="98765" 
                      attachment="ln-server" 
                      filename="3S3J-WW80-003F-W39R-00000-00-98765-importantIcon.gif" /&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Target XML. Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;ref:inlineobject&gt;
            &lt;ref:locator&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="object-key"/&gt;
                    &lt;ref:key-value value="3S3J-WW80-003F-W39R-00000-00-98765-importantIcon"/&gt;
                &lt;/ref:locator-key&gt;
                &lt;ref:locator-params&gt;
                    &lt;proc:param name="componentseq" value="1"/&gt;
                    &lt;proc:param name="object-type" value="image"/&gt;
                    &lt;proc:param name="object-smi" value="98765"/&gt;
                &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
        &lt;/ref:inlineobject&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Source XML. Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt; 
        &lt;inlineobject type="image" 
                      attachment="ln-server" 
                      filename="importantIcon.gif" /&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Target XML. Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;       
        &lt;ref:inlineobject&gt;
            &lt;ref:locator&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="object-key"/&gt;
                    &lt;ref:key-value value="X-Y-importantIcon"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                &lt;/ref:locator-key&gt;
                &lt;ref:locator-params&gt;
                    &lt;proc:param name="componentseq" value="1"/&gt;
                    &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                    &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                &lt;/ref:locator-params&gt;
            &lt;/ref:locator&gt;
        &lt;/ref:inlineobject&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Output example without @smi with real values - Conversion output (Input for the image processor)</xd:b>
         </xd:p>
         <xd:pre>
                

&lt;text&gt;&lt;figure&gt;
&lt;ref:inlineobject&gt;
&lt;ref:locator&gt;
&lt;ref:locator-key&gt;
&lt;ref:key-name name="object-key"&gt;&lt;/ref:key-name&gt;
&lt;ref:key-value value="06-Capital-Gains-Tax-09(995-1044)-2.gif"&gt;&lt;/ref:key-value&gt;
&lt;/ref:locator-key&gt;
&lt;ref:locator-params&gt;
&lt;proc:param name="componentseq" value="1"&gt;&lt;/proc:param&gt;
&lt;proc:param name="object-type" value="IMG"&gt;&lt;/proc:param&gt;
&lt;proc:param name="external-or-local" value="external"&gt;&lt;/proc:param&gt;
&lt;proc:param name="object-server" value="Blobstore"&gt;&lt;/proc:param&gt;
&lt;proc:param name="object-pguid" value="urn:contentItem:"&gt;&lt;/proc:param&gt;
&lt;/ref:locator-params&gt;
&lt;/ref:locator&gt;
&lt;/ref:inlineobject&gt;
&lt;/figure&gt;&lt;/text&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Image processor output:</xd:b>
         </xd:p>
         <xd:pre>



              &lt;text&gt;
                &lt;figure&gt;
                  &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                      &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="5M8J-YJF1-JNCK-23YG-00000-00-12634-06-Capital-Gains-Tax-09(995-1044)-2"/&gt;
                      &lt;/ref:locator-key&gt;
                      &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt;
                        &lt;proc:param name="external-or-local" value="external"/&gt;
                        &lt;proc:param name="object-server" value="Blobstore"/&gt;
                        &lt;proc:param name="object-pguid" value="urn:contentItem:5M8J-YJF1-JNCK-23YG-00000-00"/&gt;
                      &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                  &lt;/ref:inlineobject&gt;
                &lt;/figure&gt;
              &lt;/text&gt;

            </xd:pre>
         <!--Changes2015-11-16: Added instruction for inlineobject/@key 
                to be suppressed.2014-07-08: Not a rule change. Clarification added to note regarding suppression of inlineobject when inlineobject/@filename contains certain values.2013-05-24: Updated instruction for handling of inlineobject when smi is present and some of the verbiage is changed.2013-05-08: Extended the list of allowable values for image handling.2013-05-02: Some of the verbiage is changed and updated target example to if the SMI is present then a ref:inliineobject/@status attribute is set to valid.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-04-30: Updated target sample according to latest Apollo markup.2013-03-13: Removed the value leg1.png and added the statement "These files should be suppressed for both *.gif and *.png file types" was added.2013-03-12: Added an additional value of leg1.pngto the inlineobjectsuppression list2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-02-08: Updated intsructions and examples per project requirement.2012-11-30: Created .-->
      </xd:desc>
   </xd:doc>
   <!-- created 2 global parameters to be used in driver, 
        
        <xsl:param name="inlineobjBoilerplateFiles" select="('xxx.gif', 'xxx.png')"/> for boilerplate filenames that ARE
        to be converted to ref:inlineobject.
        
        <xsl:param name="inlineobjFilesToSuppress" select="('yyy.png', 'yyy.gif')"/> for filenames that are to be 
        *SUPPRESSED* from conversion but require special handling elsewhere.  That other handling is not specified in this module
        
        
    
    This will allow us to be LBU-specific in names of files for specific handling.
    
    ALSO REFACTORED this template to a MODE and not a named template so it works for figures as well.
    
    JL
    -->
   <!-- Awantika: Added name for the template to be used in element 'p'  -->
   <!-- JL Suppression is done when inlineobject is a child of remotelink and the grandparent of inlineobject (the parent of remotelink) is not ci:content.
    from DITA/ConversionInstructions/Rosetta/common_newest/Rosetta_AU_legistlation_courtrule_inlineobject-Chof-remotelink-LxAdv-SUPPRESS.dita-->
   <xsl:template match="inlineobject[@filename = $inlineobjFilesToSuppress][parent::remotelink][not(parent::remotelink/parent::ci:content) or $streamID=('AU08', 'AU04', 'AU10', 'AU09')]"/>

   <xsl:template match="inlineobject[@filename=$inlineobjBoilerplateFiles][not(parent::p) and not(parent::blockquote)]">
      <xsl:apply-templates select="." mode="refinline"/>
   </xsl:template>

   <xsl:template match="inlineobject[$streamID='CA14'][not(parent::p) and not(parent::blockquote)]">
      <xsl:apply-templates select="." mode="refinline"/>
   </xsl:template>
   <!-- MDS 2017-05-17 - Found in AU04 - Suppress inlineobject that is a descendent of glp.note and has a @filename[contains(., 'leg1')] -->   <!-- See module '/glp/Rosetta_glp.note_blockquote_p_text_inlineobject-LxAdv-note_bodytext_p_text.xsl' for documentation. -->
   <xsl:template match="inlineobject[@filename='leg1.gif' or @filename='leg1.png'][ancestor::blockquote/parent::glp:note]"/>

   <xsl:template match="inlineobject[@filename=$inlineobjBoilerplateFiles][parent::p]">
      <text>
         <xsl:apply-templates select="." mode="refinline"/>
      </text>
   </xsl:template>
   <!--Below template is created for AU09 and not read the [$inlineobjFilesToSuppress].-->
   <xsl:template match="inlineobject[parent::pgrp | parent::p][$streamID='AU09']">
      <figure>
         <xsl:apply-templates select="." mode="refinline"/>
      </figure>
   </xsl:template>

   <xsl:template match="inlineobject" mode="refinline">
      <xsl:param name="bpf_from_case_filenum" tunnel="yes"/>
      <ref:inlineobject>
         <xsl:choose>
            <xsl:when test="$streamID='USLPA'">
               <ref:locator>
                  <ref:locator-key><!-- Awantika: ref:key-value should be the sibling of ref:key-name -->
                     <ref:key-name>
                        <xsl:attribute name="name">object-key</xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="@filename"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params>
                     <proc:param>
                        <xsl:attribute name="name">componentseq</xsl:attribute>
                        <xsl:attribute name="value">1</xsl:attribute>
                     </proc:param>
                     <xsl:if test="contains(@filename, 'jpg')  or contains(@filename, 'jpeg') or contains(@filename, 'gif') or contains(@filename, 'png') or contains(@filename, 'tiff') or contains(@filename, 'bmp')">
                        <proc:param>
                           <xsl:attribute name="name">object-type</xsl:attribute>
                           <xsl:attribute name="value">image</xsl:attribute>
                        </proc:param>
                     </xsl:if>
                     <xsl:choose><!--
	                                Paul: Wondering if SMI should be a param just like dpsi.  Its going to get dropped unless something is done.
	                            -->
                        <xsl:when test="@smi">
                           <proc:param>
                              <xsl:attribute name="name">object-smi</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="@smi"/>
                              </xsl:attribute>
                           </proc:param>
                        </xsl:when>
                        <xsl:when test="not(@smi) and $streamID=('AU16','CA05','CA09','CA06','AU07', 'AU09','USLPA')">
                           <proc:param>
                              <xsl:attribute name="name">object-smi</xsl:attribute>
                              <xsl:attribute name="value"/>
                           </proc:param>
                           <xsl:comment>Empty @value created by 'Rosetta_inlineobject-LxAdv-ref.inlineobject.xsl'</xsl:comment>
                        </xsl:when>
                        <xsl:otherwise><!--  Paul: commented out these params, they are for blobstore.  they should be done via this template in Rosetta_inlineobject-to-LxAdv_figure_ref.inlineobject
     <xsl:template match="inlineobject" name="inlineobjblobstore">
                                    <proc:param>
	                                    <xsl:attribute name="name">external-or-local</xsl:attribute>
	                                    <xsl:attribute name="value">external</xsl:attribute>
	                                </proc:param>
	                                <proc:param>
	                                    <xsl:attribute name="name">object-server</xsl:attribute>
	                                    <xsl:attribute name="value">Blobstore</xsl:attribute>
	                                </proc:param>
	                                <proc:param>
	                                    <xsl:attribute name="name">object-pguid</xsl:attribute>
	                                    <xsl:attribute name="value">urn:contentitem:</xsl:attribute>
	                                </proc:param>
--></xsl:otherwise>
                     </xsl:choose>
                  </ref:locator-params>
               </ref:locator>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@*[not(name()='attachment' or name()='key')]" mode="refinline"/>
               <xsl:apply-templates select="@attachment|@key" mode="refinline"/>
               <ref:locator>
                  <ref:locator-key><!-- Awantika: ref:key-value should be the sibling of ref:key-name -->
                     <ref:key-name>
                        <xsl:attribute name="name">
                           <xsl:value-of select="if ($streamID='CA19x' or $streamID='AU19_CC') then 'attachment-key' else 'object-key'"/>
                        </xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="@filename"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params>
                     <proc:param>
                        <xsl:attribute name="name">componentseq</xsl:attribute>
                        <xsl:attribute name="value">1</xsl:attribute>
                     </proc:param>
                     <xsl:if test="contains(@filename, 'jpg')  or contains(@filename, 'jpeg') or contains(@filename, 'gif') or contains(@filename, 'png') or contains(@filename, 'tiff') or contains(@filename, 'bmp')">
                        <proc:param>
                           <xsl:attribute name="name">
                              <xsl:value-of select="if ($streamID='CA19x' or $streamID='AU19_CC') then 'attachment-type' else 'object-type'"/>
                           </xsl:attribute>
                           <xsl:attribute name="value">image</xsl:attribute>
                        </proc:param>
                     </xsl:if>
                     <xsl:choose><!--
	                                Paul: Wondering if SMI should be a param just like dpsi.  Its going to get dropped unless something is done.
	                                JD: the CI examples state "This @value assignment is done by conversion program"
	                            -->
                        <xsl:when test="@smi">
                           <proc:param>
                              <xsl:attribute name="name">object-smi</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:value-of select="@filename"/>
                              </xsl:attribute>
                           </proc:param>
                        </xsl:when>
                        <xsl:when test="not(@smi) and $streamID='CA19' or $streamID='AU19_CC' or $streamID='AU18'"><!--these Apollo SMI values come from a John B. email:
												PCT                  PCSI    Name         SMI
												urn:pct:444         232583 Pleadings      10909
												urn:pct:442         232585 Facta          10912
												urn:pct:443         232584 Motions        100132
												-->
                           <proc:param>
                              <xsl:attribute name="name">object-smi</xsl:attribute>
                              <xsl:choose>
                                 <xsl:when test="$bpf_from_case_filenum = 'brief'">
                                    <xsl:attribute name="value">10912</xsl:attribute>
                                 </xsl:when>
                                 <xsl:when test="$bpf_from_case_filenum = 'pleading'">
                                    <xsl:attribute name="value">10909</xsl:attribute>
                                 </xsl:when>
                                 <xsl:when test="$bpf_from_case_filenum = 'motion'">
                                    <xsl:attribute name="value">100132</xsl:attribute>
                                 </xsl:when>
                                 <xsl:otherwise>
                                    <xsl:attribute name="value">
                                       <xsl:value-of select="'unk'"/>
                                    </xsl:attribute>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </proc:param>
                        </xsl:when>
                        <!-- Awantika:2017-11-14- Added CA01 to the streams for webstar  7044267 -->
                        <xsl:when test="not(@smi) and not(starts-with($streamID, 'UK')) and not(starts-with($streamID , 'HK'))">
                           <proc:param>
                              <xsl:attribute name="name">object-smi</xsl:attribute>
                              <xsl:attribute name="value" select="$smi"/>
                           </proc:param>
                           <xsl:comment>Empty @value created by 'Rosetta_inlineobject-LxAdv-ref.inlineobject.xsl'</xsl:comment>
                        </xsl:when>
                        <xsl:otherwise><!--  Paul: commented out these params, they are for blobstore.  they should be done via this template in Rosetta_inlineobject-to-LxAdv_figure_ref.inlineobject
     <xsl:template match="inlineobject" name="inlineobjblobstore">
                                    <proc:param>
	                                    <xsl:attribute name="name">external-or-local</xsl:attribute>
	                                    <xsl:attribute name="value">external</xsl:attribute>
	                                </proc:param>
	                                <proc:param>
	                                    <xsl:attribute name="name">object-server</xsl:attribute>
	                                    <xsl:attribute name="value">Blobstore</xsl:attribute>
	                                </proc:param>
	                                <proc:param>
	                                    <xsl:attribute name="name">object-pguid</xsl:attribute>
	                                    <xsl:attribute name="value">urn:contentitem:</xsl:attribute>
	                                </proc:param>
--></xsl:otherwise>
                     </xsl:choose>
                  </ref:locator-params>
               </ref:locator>
            </xsl:otherwise>
         </xsl:choose>
         <!-- Awantika: Commented xsl:copy as it was copying the attributes of inlineobject which are not used in target -->
         <!--<xsl:copy-of select="@*[not(name()='attachment' or name()='key')]"/>-->
      </ref:inlineobject>
   </xsl:template>

   <xsl:template match="inlineobject/@mimetype|inlineobject/@attachment|inlineobject/@key | inlineobject/@filename | inlineobject/@type"
                 mode="refinline"/>

   <xsl:template match="@*" mode="refinline">
      <xsl:copy>
         <xsl:value-of select="."/>
      </xsl:copy>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-LxAdv-figure_ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                            <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>If the <xd:i>inlineobject</xd:i>
            <xd:i>is</xd:i> a diagram or picture illustrating textual material (e.g. not a minor icon
                or symbol), <xd:i>inlineobject</xd:i> becomes
                    <xd:b>figure/ref:inlineobject</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>When <xd:i>inlineobject</xd:i> is a child of
                    <xd:i>verbatim</xd:i> then conversion should suppress
                    <xd:i>proc:nl</xd:i> from before and after of
                    <xd:b>figure</xd:b> element in the target. For more clarification see
                Example: 3.</xd:p>
         <xd:p>
            <xd:b>Source XML 1: Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt; 
        &lt;inlineobject type="image" 
                      smi="98765" 
                      attachment="ln-server" 
                      filename="3S3J-WW80-003F-W39R-00000-00-98765-xmp6.gif" /&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Target XML 1: Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;figure&gt;
            &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="3S3J-WW80-003F-W39R-00000-00-98765-xmp6"/&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt;
                        &lt;proc:param name="object-smi" value="98765"/&gt;
                    &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
        &lt;/figure&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Source XML 2: Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt; 
        &lt;inlineobject type="image" 
                      attachment="ln-server" 
                      filename="sch2.gif" /&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Target XML 2: Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;figure&gt;
            &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="X-Y-sch2"/&gt;   &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                &lt;ref:locator-params&gt;
                    &lt;proc:param name="componentseq" value="1"/&gt;
                    &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                    &lt;proc:param name="object-smi" value=""/&gt;    &lt;!-- This @value assignment is done by conversion program --&gt;
                &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
        &lt;/figure&gt;
    &lt;/text&gt;
&lt;/p&gt;

             </xd:pre>
         <xd:p>
            <xd:b>Source XML 3: &lt;nl/&gt; before and after &lt;inlineobject&gt;</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;verbatim verbatimclass="future"&gt;
            ...
            &lt;nl/&gt; 26. Each of the provisions of the Act listed in
            Column A of the&lt;nl/&gt; Table to this section is amended in the manner specified for
            the&lt;nl/&gt; provision in Column B of the Table.&lt;nl/&gt;
            &lt;inlineobject filename="SO13_18FT-0001.jpg" type="image" attachment="ln-server"/&gt;&lt;nl/&gt;
            &lt;inlineobject filename="SO13_18FT-0002.jpg" type="image" attachment="ln-server"/&gt;&lt;nl/&gt;
            &lt;inlineobject filename="SO13_18FT-0003.jpg" type="image" attachment="ln-server"/&gt;&lt;nl/&gt;
            SOLICITORS ACT&lt;nl/&gt;
            &lt;nl/&gt; 27. (1) Section 1 of the Solicitors Act is amended by striking&lt;nl/&gt; out "If a
            person, unless a party to the proceeding, commences" at the&lt;nl/&gt; beginning and
            substituting "Subject to subsection (2), if a person&lt;nl/&gt; commences".&lt;nl/&gt;
        &lt;/verbatim&gt;
    &lt;/text&gt;
&lt;/p&gt;
             </xd:pre>
         <xd:p>
            <xd:b>Target XML 3: &lt;nl/&gt; before and after &lt;inlineobject&gt;</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;verbatim verbatimclass="future"&gt;
            ...
            &lt;proc:nl/&gt; 26. Each of the provisions of the Act listed in
            Column A of the&lt;proc:nl/&gt; Table to this section is amended in the manner specified for
            the&lt;proc:nl/&gt; provision in Column B of the Table.
            
            &lt;figure&gt;
                &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="object-key"/&gt;
                            &lt;ref:key-value value="X-Y-SO13_18FT-0001"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                        &lt;/ref:locator-key&gt;
                        &lt;ref:locator-params&gt;
                            &lt;proc:param name="componentseq" value="1"/&gt;
                            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                            &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                        &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                &lt;/ref:inlineobject&gt;
            &lt;/figure&gt;
            &lt;figure&gt;
                &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="object-key"/&gt;
                            &lt;ref:key-value value="X-Y-SO13_18FT-0002"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                        &lt;/ref:locator-key&gt;
                        &lt;ref:locator-params&gt;
                            &lt;proc:param name="componentseq" value="1"/&gt;
                            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                            &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                        &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                &lt;/ref:inlineobject&gt;
            &lt;/figure&gt;
            &lt;figure&gt;
                &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="object-key"/&gt;
                            &lt;ref:key-value value="X-Y-SO13_18FT-0003"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                        &lt;/ref:locator-key&gt;
                        &lt;ref:locator-params&gt;
                            &lt;proc:param name="componentseq" value="1"/&gt;
                            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                            &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                        &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                &lt;/ref:inlineobject&gt;
            &lt;/figure&gt;
            SOLICITORS ACT&lt;proc:nl/&gt;
            &lt;proc:nl/&gt; 27. (1) Section 1 of the Solicitors Act is amended by striking&lt;proc:nl/&gt; out "If a
            person, unless a party to the proceeding, commences" at the&lt;proc:nl/&gt; beginning and
            substituting "Subject to subsection (2), if a person&lt;proc:nl/&gt; commences".&lt;proc:nl/&gt;
        &lt;/verbatim&gt;
    &lt;/text&gt;
&lt;/p&gt;
             </xd:pre>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate
                    image handling. Note summarizes move from Apollo to Blobstore application. UK is
                    first LBU to move to Blobstore.2014-10-13: Added note and example to suppress
                        proc:nl from before and after of
                        figure/inlineobject when it comes inside
                        verbatim element.2013-05-24: Updated target example, "when smi is
                    present".2013-05-08: Extended the list of allowable values for
                    image handling.2013-05-02: Updated target example to if the SMI is
                    present then a ref:inliineobject/@status attribute is set
                    to valid.2013-05-01: Removed instructions for section
                        "Pre-Release 4.0" because according to latest Apollo markup, section
                        "Release 4.0 and after" and section "Pre-Release 4.0" now have
                    similar conversion markup.2013-04-30: Updated target sample according to latest
                    Apollo markup.2013-02-18: Created two sections, one for "Release 4.0
                        and after" and another for "Pre-Release 4.0".2013-02-18: Target example updated per inlineobject instructions. 2012-11-30: Moved full conversion instruction to new base
                    topic inlineobject to
                        ref:inlineobject. This topic now specific to
                        figure/ref:inlineobject mapping.2012-10-26: Changed to reflect recent requirements for attachment-type links.-->
      </xd:desc>
   </xd:doc>
   <xd:doc/>
   <!-- created 2 global parameters to be used in driver, 
        
        <xsl:param name="inlineobjBoilerplateFiles" select="('xxx.gif', 'xxx.png')"/> for boilerplate filenames that ARE
        to be converted to ref:inlineobject.
        
        <xsl:param name="inlineobjFilesToSuppress" select="('yyy.png', 'yyy.gif')"/> for filenames that are to be 
        *SUPPRESSED* from conversion but require special handling elsewhere.  That other handling is not specified in this module
        
    When the @filename attribute of inlineobject is not on either of those lists, we will output the figure wrapper in this module.    
    
    This will allow us to be LBU-specific in names of files for specific handling.
    
    
    JL
    -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_inlineobject-LxAdv-figure_ref.inlineobject.dita  -->
   <!-- <xsl:param name="inlineobjFilesToSuppress"/>
	<xsl:param name="inlineobjBoilerplateFiles" select="('1.gif', '2.gif', '3.gif', '4.gif', '5.gif', 'IconSignalPositive.gif', 'IconSignalNegative.gif', 'IconSignalNeutral.gif', 'IconSignalPossibleNegative.gif', 'IconSignalCiteInfoOnly.gif', 'cbcc.gif', 'leg1.gif', 'mb.gif', 'au_repealed.gif', 'au_exclaim.gif', '1.png', '2.png', '3.png', '4.png', '5.png', 'IconSignalPositive.png', 'IconSignalNegative.png', 'IconSignalNeutral.png', 'IconSignalPossibleNegative.png', 'IconSignalCiteInfoOnly.png', 'cbcc.png', 'leg1.png', 'mb.png', 'au_repealed.png', 'au_exclaim.png')"/>
	 -->
   <xsl:template match="inlineobject[not(@filename=$inlineobjFilesToSuppress          or @filename=$inlineobjBoilerplateFiles          or parent::blockquote         or parent::dispformula          )]"><!--  Paul: I removed this bodytext parent check from the not() part of the match predicate.  
            It was causing objects to get suppressed.
        "or parent::bodytext"
        FYI:
        parent::blockquote seems to be handled by 	<xsl:template match="blockquote[inlineobject and not(inlinobject/following-sibling::* or inlineobject/preceding-sibling::*)]">
        parent::dispformula is handled by 	<xsl:template match="dispformula">
--><!-- Ravikant: 2018-03-09 Added the streamID 'MY01','MY02','MY03','MY04','MY05LB','MY05LL','MY06','MY07' for blobstoreStreams -->
      <xsl:variable name="blobstoreStreams"
                    select="('UK01','UK02','UK03', 'UK04', 'UK05', 'UK06', 'UK07', 'UK08CA', 'UK08OR', 'UK09', 'UK10', 'UK11DA', 'UK11DN', 'UK12', 'UK14', 'UK15', 'UK15', 'UK16', 'UK17', 'UK17', 'UK18', 'UK22CF', 'UK22CS','HK01','HK02', 'HK03','HK04','HK05','HK06','HK07','HK08', 'HK09', 'MY01','MY02','MY03','MY04','MY05LB','MY05LL','MY06','MY07'             )"/>
      <!-- Paul: I removed 2 non-uk streams from the $blobstoreStreams.
            I'm pretty sure people were only doing this to get the "when" behavior below instead of the "otherwise".
            They aren't blobstore streams.  See otherwise clause comment.  I know the otherwise <figure> output is difference from DT but i think that may be incorrect.
            As of 2017-05-27, the ONLY blobstore streams are UK.  No other LBU has moved there yet.

            , 'CA19', 'AU04' 
        -->
      <xsl:choose><!-- JL added to handle some UK streams that use blobstore; the test for link parent ensures the output is valid
                as figure isn't valid in ref:marker
                -->
         <xsl:when test="$streamID=$blobstoreStreams"><!-- JD: 2017-06-08: similar to Paul's note below, UK08CA is adding a <figure> wrapper; 
                		I assume this is because the overlapping conditions in CCCC-10540 and CCCC-10368), 
                		including this dubious instruction: 
                		"If the inlineobject is a diagram or picture illustrating textual material (e.g. not a minor icon or symbol), inlineobject becomes figure/ref:inlineobject."
                		(how are we or the XSLT processor to know whether the image is a diagram or picture illustrating textual material?)
                		
                		For now, hacking with additional xsl:when clause
                	-->
            <xsl:choose>
               <xsl:when test="parent::h[$streamID='UK09']">
                  <xsl:call-template name="inlineobjblobstore"/>
               </xsl:when>
               <xsl:when test="parent::link | parent::figure | parent::emph | parent::publication  and not(parent::emph/parent::h) or (parent::text and $streamID=('UK08CA','UK11DA','UK06'))">
                  <xsl:call-template name="inlineobjblobstore"/>
               </xsl:when>
               <!-- JD: 2017-10-31: when ancestor is figure the <figure> element has already been created.  
                        This may be brittle; the source is:
                      <figure>
                        <p>
                           <text>
                              <inlineobject ...>
                            </text>
                        </p>
                      </figure>
                      -->
               <xsl:when test="$streamID=('UK01','UK08OR') and ancestor::figure">
                  <xsl:call-template name="inlineobjblobstore"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:choose><!-- Awantika: Added condition when parent is case:judgements for HK03 -->
                     <xsl:when test="$streamID='HK03' and parent::case:judgments">
                        <attachments>
                           <appendix>
                              <bodytext>
                                 <figure>
                                    <xsl:call-template name="inlineobjblobstore"/>
                                 </figure>
                              </bodytext>
                           </appendix>
                        </attachments>
                     </xsl:when>
                     <xsl:otherwise>
                        <figure>
                           <xsl:call-template name="inlineobjblobstore"/>
                        </figure>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise><!-- Paul: DT seems to be omitting the figure wrapper.  is this correct? -->
            <xsl:choose>
               <xsl:when test="$streamID = ('AU16') or parent::figure[$streamID= ('AU15' , 'AU05', 'NZ12', 'AU18')] or parent::remotelink[ ( @service = 'URL' or @href ) and not( ( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) ) ) ]">
                  <xsl:apply-templates select="." mode="refinline"/>
               </xsl:when>
               <!-- 20170607:  MCJ:  Added condition for AU06.  I am not sure why this wouldn't be the default handling (to avoid a figure within a figure) but
                                              don't want to affect other streams. -->
               <xsl:when test="($streamID = 'AU06') or ($streamID = 'NZ05') or ($streamID='AU19_CC')">
                  <xsl:choose><!-- this condition is probably not complete in terms of preventing a double wrapper for 'figure'.  The test for an ancestor figure will
                                     cover most things but could also cause trouble if there are constructs in between the outer wrapper and the current
                                     inline object that need different handling.  This module could use some refactoring (not just for this stream area). -->
                     <xsl:when test="(./parent::leg:bodytext or ./parent::li or ./parent::text or ./parent::legfragment) and not(ancestor::figure)">
                        <figure>
                           <xsl:apply-templates select="." mode="refinline"/>
                        </figure>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates select="." mode="refinline"/>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:when>
               <!-- JD: probably more applicable, but setting to AU11 for now.  leg:bodytext/inlineobject would need to create primlaw:bodytext/p/text/figure -->
               <xsl:when test="$streamID='AU11' and parent::leg:bodytext">
                  <p>
                     <text>
                        <figure>
                           <xsl:apply-templates select="." mode="refinline"/>
                        </figure>
                     </text>
                  </p>
               </xsl:when>
               <!-- JD: probably more applicable, but settting to NZ18 for now.  Do not create <figure> wrapper when under <lnci:content> -->
               <xsl:when test="$streamID='NZ18' and parent::remotelink/parent::ci:content">
                  <xsl:apply-templates select="." mode="refinline"/>
               </xsl:when>
               <xsl:when test="$streamID='AU04' and preceding-sibling::*[1][self::ci:cite]">
                  <xsl:apply-templates select="." mode="refinline"/>
               </xsl:when>
               <xsl:when test="parent::figure">
                  <xsl:apply-templates select="." mode="refinline"/>
               </xsl:when>
               <!-- Awantika: 2017-12-28- Added when condition for ancestor figure as two wrappers for figure
                        were being created. Webstar # 7080120-->
               <xsl:when test="ancestor::figure and $streamID='AU04'">
                  <xsl:apply-templates select="." mode="refinline"/>
               </xsl:when>
               <xsl:otherwise>
                  <figure>
                     <xsl:apply-templates select="." mode="refinline"/>
                  </figure>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- JL Included template name inlineobjblobstore from another module with DITA instructions
    <dita:topic xmlns="http://dita.oasis-open.org/architecture/2005/" id="Rosetta_inlineobject-to-LexisAdvance_ref.inlineobject_BLOBSTORE">
    -->
   <xsl:template match="inlineobject" name="inlineobjblobstore">
      <xsl:choose>
         <xsl:when test="$streamID=('AU04', 'AU06') and parent::blockquote">
            <p>
               <figure>
                  <ref:inlineobject>
                     <xsl:apply-templates select="@height | @width"/>
                     <ref:locator>
                        <ref:locator-key>
                           <ref:key-name name="object-key"/>
                           <ref:key-value>
                              <xsl:apply-templates select="@filename"/>
                           </ref:key-value>
                        </ref:locator-key>
                        <ref:locator-params>
                           <proc:param name="object-type" value="IMG"/>
                           <proc:param name="external-or-local" value="external"/>
                           <proc:param name="object-server" value="Blobstore"/>
                           <proc:param name="object-pguid"
                                       value="urn:contentItem:0000-0000-0000-0000-00000-00"/>
                           <proc:param name="componentseq" value="1"/>
                        </ref:locator-params>
                     </ref:locator>
                  </ref:inlineobject>
               </figure>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <ref:inlineobject>
               <xsl:apply-templates select="@height | @width"/>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name name="object-key"/>
                     <ref:key-value>
                        <xsl:apply-templates select="@filename"/>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params>
                     <proc:param name="object-type" value="IMG"/>
                     <proc:param name="external-or-local" value="external"/>
                     <proc:param name="object-server" value="Blobstore"/>
                     <proc:param name="object-pguid"
                                 value="urn:contentItem:0000-0000-0000-0000-00000-00"/>
                     <proc:param name="componentseq" value="1"/>
                  </ref:locator-params>
               </ref:locator>
            </ref:inlineobject>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="inlineobject/@height | inlineobject/@width">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="inlineobject/@filename">
      <xsl:attribute name="value">
         <xsl:apply-templates select="parent::inlineobject/@dpsi"/>
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="inlineobject/@dpsi">
      <xsl:value-of select="concat('[[DPSI:', . , ']]')"/>
   </xsl:template>

   <xsl:template match="inlineobject[$streamID='CA10']" priority="25">
      <figure>
         <xsl:apply-templates select="." mode="refinline"/>
      </figure>
   </xsl:template>

   <xsl:template match="inlineobject[@filename='au_repeal01.png'][$streamID='AU04'] | inlineobject[@filename='au_repeal01.gif'][$streamID='AU04']">
      <legisinfo:status statuscode="repealed"/>
   </xsl:template>

   <xsl:template match="nl[following-sibling::*[1][self::inlineobject[@filename!=$inlineobjFilesToSuppress]]][following-sibling::*[2][self::nl]] | nl[preceding-sibling::*[1][self::inlineobject[@filename!=$inlineobjFilesToSuppress]]][following-sibling::*[2][self::nl]]"/>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-h-LxAdv-figure_ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                            <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                            <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>h/inlineobject</xd:i> becomes
                    <xd:b>figure/ref:inlineobject</xd:b>. The attributes of
                    <xd:i>h</xd:i> are handled as follows: <xd:ul>
               <xd:li>
                  <xd:i>h/@align</xd:i> becomes
                        <xd:b>figure/@align</xd:b>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML showing <xd:i>inlineobject</xd:i> occurring in
                    <xd:i>h</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:levelbody&gt;
    &lt;leg:bodytext&gt;
        &lt;h align="center"&gt;
            &lt;inlineobject type="image" filename="CTH_ACT_2001-65_PIC030.gif" attachment="ln-server"/&gt;
        &lt;/h&gt;
    &lt;/leg:bodytext&gt;
&lt;/leg:levelbody&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;primlaw:bodytext&gt;
    &lt;figure align="center"&gt;
        &lt;ref:inlineobject&gt;
            &lt;ref:locator&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="object-key"/&gt;
                    &lt;ref:key-value value="X-Y-CTH-ACT-2001-65-PIC030"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                &lt;/ref:locator-key&gt;
                &lt;ref:locator-params&gt;
                    &lt;proc:param name="componentseq" value="1"/&gt;
                    &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                    &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                &lt;/ref:locator-params&gt;
            &lt;/ref:locator&gt;
        &lt;/ref:inlineobject&gt;
    &lt;/figure&gt;
&lt;/primlaw:bodytext&gt;

            </xd:pre>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate
                    image handling. Note summarizes move from Apollo to Blobstore application. UK is
                    first LBU to move to Blobstore.2012-10-26: Updated ref:locator markup in Target sample. 2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0
                        and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest
                    Apollo markup.2013-05-01: Removed instructions for section
                        "Pre-Release 4.0" because according to latest Apollo markup, section
                        "Release 4.0 and after" and section "Pre-Release 4.0" now have
                    similar conversion markup.2013-05-08: Extended the list of allowable values for
                    image handling.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="h[inlineobject]"><!--  Original Target XPath:  figure/ref:inlineobject   -->
      <figure>
         <xsl:apply-templates select="@* | node()"/>
      </figure>
   </xsl:template>

   <xsl:template match="h[inlineobject][$streamID='UK09']" priority="25"><!--  Original Target XPath:  figure/ref:inlineobject   -->
      <h>
         <xsl:apply-templates select="@* | node()"/>
      </h>
   </xsl:template>

   <xsl:template match="h/@align" priority="2"><!-- wpk 2017-12-13.  webstar 7067569.
	        Changed priority to 2.
	        The base "nonamespace/Rosetta_h-LxAdv-h.xsl" has this identical template.  Ideally it should be removed here so 
	        as to avoid amiguous match when both are included.
	        There are streams in which the base module is not used but this module is used.  So we cannot rely on the common exclusively.
	        In order to ensure no side effects and to avoid ambiguity, the priority is changed to 2.-->
      <xsl:attribute name="align">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-emph-LxAdv-figure_ref.inlinobject.dita"/> -->   <!-- ********************** -->   <!-- Use '/nonamespace/Rosetta_emph-LxAdv-emph.xsl' instead -->   <!-- ********************** -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>emph/inlineobject</xd:i> becomes
                    <xd:b>figure/ref:inlineobject</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML showing <xd:i>inlineobject</xd:i> occurring in
                    <xd:i>emph</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;emph typestyle="it"&gt;
            &lt;inlineobject type="image" filename="SA_ACT_1984-3_PIC2.gif" attachment="ln-server"/&gt;
        &lt;/emph&gt;
    &lt;/text&gt;
&lt;/p&gt;
            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;figure&gt;
            &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="X-Y-SA-ACT-1984-3-PIC2"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                        &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
    &lt;/figure&gt;
  &lt;/text&gt;  
&lt;/p&gt;
            </xd:pre>
         <xd:p>When source is having emph followed by inlineobject inside base:h element
                    <xd:i>h/emph/inlineobject</xd:i>than in Target it should Map with and becomes
                    <xd:b>emph/ref:inlineobject</xd:b>.</xd:p>
         <xd:pre>
&lt;h&gt;
    &lt;emph typestyle="bf"&gt;Table 2 Estimation of regression coefficients using the SUR model 
        &lt;inlineobject type="image" mimetype="image/gif" filename="JFRC_2005_Vol13_Issue2_May_167_1.gif" /&gt;
    &lt;/emph&gt;
&lt;/h&gt;

<xd:b>Becomes</xd:b>
    
 &lt;emph typestyle="bf"&gt;Table 2 Estimation of regression coefficients using the SUR model
     &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="X-Y-JFRC_2005_Vol13_Issue2_May_167_1"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                        &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
&lt;/emph&gt;
            </xd:pre>
         <!-- This doesn't have anything to do with inlineobject.  It is regarding emph markup. -->
         <xd:p>When source is having emph followed by another emph of same typestyle and then
                followed by inlineobject <xd:i>sup/emph/emph/inlineobject</xd:i>than in
                Target it should drop one emph and the followed
                    <xd:i>emph/inlineobject</xd:i> should directly Map it with and becomes
                    <xd:b>sup/emph/ref:inlineobject</xd:b>.</xd:p>
         <xd:pre>
&lt;row&gt;
    &lt;entry&gt;
        &lt;sup&gt;
            &lt;emph typestyle="it"&gt;
                &lt;emph typestyle="it"&gt;
                    &lt;inlineobject type="image" mimetype="image/gif" filename="ALE_2014_Vol16_Issue2_Sep_433_1.gif" /&gt;
                &lt;/emph&gt;
            &lt;/emph&gt;
        &lt;/sup&gt;
    &lt;/entry&gt;
    &lt;entry&gt;(1)&lt;/entry&gt;
&lt;/row&gt;

<xd:b>Becomes</xd:b>

&lt;row&gt;
    &lt;entry&gt;
        &lt;sup&gt;
            &lt;emph&gt;
                &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="object-key"/&gt;
                            &lt;ref:key-value value="X-Y-ALE_2014_Vol16_Issue2_Sep_433_1"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                        &lt;/ref:locator-key&gt;
                        &lt;ref:locator-params&gt;
                            &lt;proc:param name="componentseq" value="1"/&gt;
                            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                            &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                        &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                &lt;/ref:inlineobject&gt;
            &lt;/emph&gt;
        &lt;/sup&gt;
    &lt;/entry&gt;    
&lt;/row&gt;
            </xd:pre>
         <!-- This doesn't have anything to do with the inlinobject. It is about the conversion of heading as a descendant of leg:comntry -->
         <xd:p>When source is having
                <xd:i>leg:comntry/level/bodytext/heading/title/emph/inlineobject</xd:i>
            then it becomes
                <xd:b>annot:annotations/annot:annotation-grp/annot:annotation/bodytext/h/emph/ref:inlineobject</xd:b>.</xd:p>
         <xd:pre>
&lt;leg:comntry searchtype="ANNOTATIONS"&gt;
    &lt;level leveltype="comm30"&gt;
        &lt;bodytext&gt;
            &lt;heading searchtype="ANNOTATIONS"&gt;
                &lt;title&gt;
                    &lt;emph typestyle="bf"&gt;
                        &lt;inlineobject type="image" mimetype="image/gif" filename="img8d4.gif" /&gt;NOTES
                    &lt;/emph&gt;
                &lt;/title&gt;
            &lt;/heading&gt;
        &lt;/bodytext&gt;
    &lt;/level&gt;
&lt;/leg:comntry&gt;

<xd:b>Becomes</xd:b>

&lt;annot:annotations&gt;
    &lt;annot:annotation-grp grptype="COMMENTARY"&gt;
        &lt;annot:annotation&gt;
            &lt;bodytext&gt;
                &lt;h&gt;
                    &lt;emph typestyle="bf"&gt;&lt;ref:inlineobject&gt;
                        &lt;ref:locator&gt;
                            &lt;ref:locator-key&gt;
                                &lt;ref:key-name name="object-key"/&gt;
                                &lt;ref:key-value value="X-Y-img8d4"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                            &lt;/ref:locator-key&gt;
                            &lt;ref:locator-params&gt;
                                &lt;proc:param name="componentseq" value="1"/&gt;
                                &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                                &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                            &lt;/ref:locator-params&gt;
                        &lt;/ref:locator&gt;
                    &lt;/ref:inlineobject&gt;NOTES&lt;/emph&gt;
                &lt;/h&gt;
            &lt;/bodytext&gt;
        &lt;/annot:annotation&gt;
    &lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;
            </xd:pre>
         <!--Changes2012-10-26: Updated ref:locator markup in Target sample. 2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0
                        and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest
                    Apollo markup.2013-05-01: Removed instructions for section
                        "Pre-Release 4.0" because according to latest Apollo markup, section
                        "Release 4.0 and after" and section "Pre-Release 4.0" now have
                    similar conversion markup.2013-05-08: Extended the list of allowable values for
                    image handling.2015-06-18: When source is having emph followed by inlineobject inside base:h element h/emph/inlineobject than in Target it should Map it like emph/ref:inlineobject as emph containing text under it.2015-07-21: When Inlineobject is followed by two emph
                    elements of same typestyle then from Target we should drop the one emph element
                    and the followed emph/inlineobject should mapped with
                        figure/ref:inlineobject in Target. applicable to
                UK09 only RFA #2354. 2015-07-24: When Inlineobject is followed by two emph
                elements of same typestyle sup/emph/emph/inlineobjectthen from Target we should drop the one emph element
                and the followed emph/inlineobject should mapped with
                emph/ref:inlineobject in Target. applicable to
                UK09 only RFA #2354. 2015-08-12: Added instruction and example for 
                leg:comntry/level/bodytext/heading/title/emph/inlineobject, Applicable on UK07, R4.5 issue # 2364.2016-08-01: Added Note about xml snippets that illustrate
                image handling. Note summarizes move from Apollo to Blobstore application. UK is
                first LBU to move to Blobstore.-->
      </xd:desc>
   </xd:doc>
   <!--<xsl:template match="emph/inlineobject">

		<!-\-  Original Target XPath:  figure/ref:inlineobject   -\->
	    <figure xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
			<ref:inlineobject>
				<xsl:apply-templates select="@* | node()"/>
			</ref:inlineobject>
		</figure>

	</xsl:template>-->
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-sub-LxAdv-figure_ref.inlineobject.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>sub/inlineobject</xd:i> becomes <xd:b>figure/ref:inlineobject</xd:b>. Suppress <xd:i>sub</xd:i> from conversion.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;text&gt;
    The various language versions of that phrase use the terms
    'adscribirse' (Spanish), 'tages sammen' (Danish), 'angehngt'
    (German), 
    '&lt;sub&gt;
        &lt;inlineobject type="image" mimetype="image/gif"
        filename="img1c4e.gif"/&gt;
    &lt;/sub&gt;' 
    (Greek), 'added on'
    (English), 'rattache' (French), 'collegato' (Italian), 'gevoegd
    bij' (Dutch), 'ligado' (Portuguese), 'yhteydess' (Finnish) and
    'lggas samman' (Swedish).
&lt;/text&gt;

    </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;text&gt;
    The various language versions of that phrase use the terms
    'adscribirse' (Spanish), 'tages sammen' (Danish), 'angehngt'
    (German), 
    '&lt;figure&gt;
        &lt;ref:inlineobject&gt;
            &lt;ref:locator&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="object-key"/&gt;
                    &lt;ref:key-value value="X-Y-img1c4e"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                &lt;/ref:locator-key&gt;
                &lt;ref:locator-params&gt;
                    &lt;proc:param name="componentseq" value="1"/&gt;
                    &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                    &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                &lt;/ref:locator-params&gt;
            &lt;/ref:locator&gt;
        &lt;/ref:inlineobject&gt;
    &lt;/figure&gt;' 
    (Greek), 'added on'
    (English), 'rattache' (French), 'collegato' (Italian), 'gevoegd
    bij' (Dutch), 'ligado' (Portuguese), 'yhteydess' (Finnish) and
    'lggas samman' (Swedish).
&lt;/text&gt;

    </xd:pre>
         <!--Changes2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest Apollo markup.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-05-08: Extended the list of allowable values for image handling.2016-08-01: Added Note about xml snippets that illustrate
                image handling. Note summarizes move from Apollo to Blobstore application. UK is
                first LBU to move to Blobstore.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="sub[inlineobject]"><!--  Original Target XPath:  figure/ref:inlineobject   -->
      <xsl:apply-templates select="node()"/>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-dispformula-LxAdv-formula_ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>dispformula/inlineobject</xd:i> becomes <xd:b>formula/ref:inlineobject</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML showing <xd:i>inlineobject</xd:i> occurring in <xd:i>dispformula</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;dispformula&gt;
            &lt;inlineobject type="image" attachment="ln-server" filename="g0146031.gif"/&gt;
        &lt;/dispformula&gt;
    &lt;/text&gt;
&lt;/p&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;
        &lt;formula&gt;
            &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="X-Y-g0146031"/&gt;   &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                        &lt;proc:param name="object-smi" value=""/&gt;    &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
        &lt;/formula&gt;
    &lt;/text&gt;
&lt;/p&gt;

            </xd:pre>
         <!--Changes2012-10-26: Updated ref:locator markup in Target sample. 2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest Apollo markup.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-05-08: Extended the list of allowable values for image handling.2016-08-01: Added Note about xml snippets that illustrate
                image handling. Note summarizes move from Apollo to Blobstore application. UK is
                first LBU to move to Blobstore.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="inlineobject[parent::dispformula]"><!--  Original Target XPath:  formula/ref:inlineobject   -->
      <xsl:apply-templates select="." mode="refinline"/>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-p_blockquote-LxAdv-p_figure_ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a shared topic
                rather than duplicated to ensure consistency and accuracy. The xml snippets contained in this
                topic reflect markup needed for the Apollo image handling application. The UK is the first LBU
                to move from Apollo to the Blobstore application for image handling. Therefore, if this is a UK
                conversion instruction document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
                        (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to <xd:b>ref:inlineobject</xd:b> for
                        BLOBSTORE images (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE images
                        (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>p/blockquote/inlineobject</xd:i> becomes
                    <xd:b>p/figure/ref:inlineobject</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b> If <xd:i>inlineobject</xd:i> in this context contains sibling elements
                (other children of <xd:i>blockquote</xd:i>), do not complete this
                instruction. Instead, complete <xd:a href="Rosetta_inlineobject-w-siblings-Chof-p_blockquote-LxAdv-p_figure_ref.inlineobject.dita#Rosetta_inlineobject-w-siblings-Chof-p_blockquote-LxAdv-p_figure_ref.inlineobject"/>
         </xd:p>
         <xd:p>
            <xd:b>Source XML showing <xd:i>inlineobject</xd:i> occurring in <xd:i>blockquote</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:levelbody&gt;
    &lt;leg:bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;The value of ...&lt;/text&gt;
            &lt;blockquote&gt;
                &lt;inlineobject type="image" filename="TAS_ACT_1987-13_HIGH-PENAM07.tiff" attachment="ln-server"/&gt;
            &lt;/blockquote&gt;
            &lt;text&gt;where&amp;#160;&amp;ndash;&lt;/text&gt;
        &lt;/p&gt;
    &lt;/leg:bodytext&gt;
&lt;/leg:levelbody&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML showing <xd:i>inlineobject</xd:i> occurring in <xd:i>blockquote</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;primlaw:bodytext&gt;
    &lt;p&gt;
        &lt;text&gt;The value of ...&lt;/text&gt;
        &lt;figure&gt;
            &lt;ref:inlineobject&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="object-key"/&gt;
                        &lt;ref:key-value value="X-Y-TAS-ACT-1987-13-HIGH-PENAM07"/&gt; &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp, .tiff)--&gt;
                        &lt;proc:param name="object-smi" value=""/&gt; &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:inlineobject&gt;
        &lt;/figure&gt;
    &lt;/p&gt;
&lt;/primlaw:bodytext&gt;

            </xd:pre>
         <!--Changes2016-07-26: Added Note about xml snippets that
                    illustrate image handling. Note summarizes move from Apollo to Blobstore
                    application. UK is first LBU to move to Blobstore. 2012-10-26: Updated ref:locator markup in Target sample. 2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest Apollo markup.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-05-08: Extended the list of allowable values for image handling.2013-05-08: Added note to use a different instruction if inlineobject contains siblings.2015-12-08: Added '.tiff' to the list of allowable values for proc:param[@name="object-type"]/@value="image".-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="blockquote[inlineobject and not(inlinobject/following-sibling::node() or inlineobject/preceding-sibling::node())]"><!--  Original Target XPath:  p/figure/ref:inlineobject   -->
      <p>
         <figure>
            <ref:inlineobject>
               <xsl:apply-templates select="inlineobject" mode="refinline"/>
            </ref:inlineobject>
         </figure>
      </p>
   </xsl:template>
   <!-- Template specific to p/blockquote so a new p wrapper is not created... a better way probably exists to do this. -->
   <xsl:template match="p/blockquote[inlineobject and not(inlinobject/following-sibling::node() or inlineobject/preceding-sibling::node())]"
                 priority="25"><!--  Original Target XPath:  p/figure/ref:inlineobject   -->
      <figure>
         <xsl:apply-templates select="." mode="refinline"/>
      </figure>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_inlineobject-Chof-bodytext-LxAdv-bodytext_p_text_figure_ref.inlineobject.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:i>bodytext/inlineobject</xd:i> becomes
                <xd:b>bodytext/p/text/figure/ref:inlineobject</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;bodytext&gt;
    &lt;inlineobject type="image" attachment="ln-server" filename="elb31.gif"/&gt;
    &lt;p&gt;
        &lt;text&gt;The European Court of Justice also found that contracting out arrangements could fall under the Directive...&lt;/text&gt;
    &lt;/p&gt;
    ...
&lt;/bodytext&gt;

    </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;figure&gt;
                    &lt;ref:inlineobject&gt;
                        &lt;ref:locator&gt;
                            &lt;ref:locator-key&gt;
                                &lt;ref:key-name name="object-key"/&gt;
                                &lt;ref:key-value value="X-Y-elb31"/&gt;  &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                            &lt;/ref:locator-key&gt;
                            &lt;ref:locator-params&gt;
                                &lt;proc:param name="componentseq" value="1"/&gt;
                                &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                                &lt;proc:param name="object-smi" value=""/&gt;        &lt;!-- This @value assignment is done by conversion program --&gt;                                
                            &lt;/ref:locator-params&gt;
                        &lt;/ref:locator&gt;
                    &lt;/ref:inlineobject&gt;
                &lt;/figure&gt;
            &lt;/text&gt;
        &lt;/p&gt;
        &lt;p&gt;
            &lt;text&gt;The European Court of Justice also found that contracting out arrangements could fall under the Directive...&lt;/text&gt;
        &lt;/p&gt;
        ...
&lt;/bodytext&gt;

    </xd:pre>
         <!--Changes2016-07-29: Added Note about xml snippets that illustrate
                image handling. Note summarizes move from Apollo to Blobstore application. UK is
                first LBU to move to Blobstore. VSTS 761462013-05-08: Extended the list of allowable values for image handling.2013-05-01: Removed instructions for section
                "Pre-Release 4.0" because according to latest Apollo markup, section
                "Release 4.0 and after" and section "Pre-Release 4.0" now have
                similar conversion markup.2013-04-30: Updated target sample according to latest Apollo markup.2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-02-18: Target example updated per inlineobject instructions. -->
         <!-- SEP 2015-9-23 added; method A versus method B? (depends on how bodytext is implemented externally)   -->
      </xd:desc>
   </xd:doc>
   <xsl:template xmlns="http://dita.oasis-open.org/architecture/2005/"
                 match="inlineobject[parent::bodytext]">
      <xsl:element name="p">
         <xsl:element name="text">
            <xsl:element name="figure">
               <xsl:apply-templates select="." mode="refinline"/>
            </xsl:element>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!--topicref href="AU01_Rosetta_inlineobject-Chof-ci.conent_remotelink-LxAdv-lnci.content_ref.crossreference.dita"/-->   <!-- <topicref href="../../common_newest/Rosetta_AU_commentary_inlineobject-Chof-ci.conent_remotelink-LxAdv-lnci.content_ref.crossreference.dita"/> -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/nonamespace/Rosetta_AU_commentary_inlineobject-Chof-ci.conent_remotelink-LxAdv-lnci.content_ref.crossreference.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- end topichead  inlineobject  -->   <!-- rosetta element: insert-line -->   <!-- <topicref href="../../common_newest/Rosetta_insert-line-LxAdv-proc.nl.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>insert-line[@character]</xd:i> becomes
						<xd:b>proc:nl</xd:b>.</xd:p>
         <!-- Moved to Rosetta_blockquote-LxAdv-blockquote.xsl -->
         <!--<p><b>If <sourcexml>insert-line</sourcexml> occurs as the only child within <sourcexml>blockquote</sourcexml> then drop outer <sourcexml>blockquote</sourcexml> in NewLexis conversion.</b></p>-->
         <xd:p>
            <xd:b>Source XML : If <xd:i>insert-line/@character=" "</xd:i>
					comes in XPATH
					<xd:i>bodytext/blockquote/insert-line</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;insert-line character=" "/&gt;
					&lt;/blockquote&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML : If <xd:i>insert-line/@character=" "</xd:i>
					comes in XPATH
					<xd:i>bodytext/blockquote/insert-line</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;p/&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML : If <xd:i>insert-line/@character=""</xd:i>
					comes in XPATH
					<xd:i>bodytext/blockquote/insert-line</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;insert-line character=""/&gt;
					&lt;/blockquote&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML : If <xd:i>insert-line/@character=""</xd:i>
					comes in XPATH
					<xd:i>bodytext/blockquote/insert-line</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;p/&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>When <xd:i>insert-line</xd:i> occurs as a child of a
					<xd:i>blockquote</xd:i> and the character type is <xd:b>space,
					nbsp, or thinsp,</xd:b> then the result is mapped to an empty
					<xd:b>p</xd:b> tag.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:bodytext&gt; &lt;p&gt; &lt;blockquote&gt;
					&lt;insert-line character=" "/&gt; &lt;p
					indent="none"&gt;&lt;text&gt;Tape reference: &lt;form-chars
					character="." num-char="16"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text&gt;&lt;form-chars character="."
					num-char="16"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text&gt;Name of complainant: &lt;form-chars
					character="." num-char="16"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text&gt;Cross reference to other interviews with
					complainant: &lt;form-chars character="."
					num-char="16"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;insert-line character="
					"/&gt; &lt;p indent="none"&gt;&lt;text&gt;I certify that the contents
					of this certificate are correct.&lt;/text&gt;&lt;/p&gt;
					&lt;insert-line character=" "/&gt; &lt;p
					indent="none"&gt;&lt;text&gt;&lt;form-chars character="."
					num-char="12"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text align="center"&gt;Signature of
					Interviewer&lt;form-chars character=" "
					num-char="16"/&gt;&lt;form-chars character=" "
					num-char="2"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;insert-line character="
					"/&gt; &lt;p indent="none"&gt;&lt;text align="center"&gt;Date of
					Certificate&lt;form-chars character=" "
					num-char="16"/&gt;&lt;form-chars character=" "
					num-char="2"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;/blockquote&gt;
					&lt;/p&gt; &lt;/leg:bodytext&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;primlaw:bodytext&gt; &lt;p&gt; &lt;blockquote&gt;
					&lt;p/&gt; &lt;p indent="none"&gt;&lt;text&gt;Tape reference:
					&lt;proc:formchars formchar="dot"
					formcharuse="longname"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text&gt;&lt;proc:formchars formchar="dot"
					formcharuse="longname"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text&gt;Name of complainant: &lt;proc:formchars
					formchar="dot" formcharuse="longname"/&gt;&lt;/text&gt;&lt;/p&gt;
					&lt;p indent="none"&gt;&lt;text&gt;Cross reference to other interviews
					with complainant: &lt;proc:formchars formchar="dot"
					formcharuse="longname"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p/&gt; &lt;p
					indent="none"&gt;&lt;text&gt;I certify that the contents of this
					certificate are correct.&lt;/text&gt;&lt;/p&gt; &lt;p/&gt; &lt;p
					indent="none"&gt;&lt;text&gt;&lt;proc:formchars formchar="dot"
					formcharuse="address"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p
					indent="none"&gt;&lt;text align="center"&gt;Signature of
					Interviewer&lt;proc:formchars formchar="dot"
					formcharuse="longname"/&gt;&lt;proc:formchars formchar="dot"
					formcharuse="day"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;p/&gt; &lt;p
					indent="none"&gt;&lt;text align="center"&gt;Date of
					Certificate&lt;proc:formchars formchar="dot"
					formcharuse="longname"/&gt;&lt;proc:formchars formchar="dot"
					formcharuse="day"/&gt;&lt;/text&gt;&lt;/p&gt; &lt;/blockquote&gt;
					&lt;/p&gt; &lt;/primlaw:bodytext&gt; </xd:pre>
         <!--Changes2012-01-16: Created.2012-02-28: Instruction and Example added if
						insert-line comes in XPATH
						bodytext/blockquote/insert-line2012-05-15: Instruction and Example added when
						insert-line[@character] is space, nbsp, or
					thinsp in the source.2012-05-15: Remove rest of note to handling
						insert-line.2012-10-25: Instruction and example added when
						insert-line occurs as a child of a
						blockquote.-->
      </xd:desc>
   </xd:doc>
   <!-- MCJ:  2017-08-01: updated predicate to test for not(parent::blockquote) in order to remove ambiguity with other template.
    	                   this introduces new holes that will need to be refactored if/when relevant data appears.  My guess is that
    	                   these templates need to be consolidated so that the transform to proc:nl is the default and the test on
    	                   parent::blockquote (and testing @character) becomes exceptions. -->
   <!-- JD: 2017-07-25: modified per instruction "insert-line[@character] becomes proc:nl." -->
   <!--xsl:template match="insert-line"-->
   <xsl:template match="insert-line[@character and not(parent::blockquote)]"><!--  Original Target XPath:  proc:nl   -->
      <proc:nl>
         <xsl:apply-templates select="@* | node()"/>
      </proc:nl>
   </xsl:template>
   <!-- JD: 2017-07-25: modified below to test unicode value of character, as contains() won't work on character entities -->   <!--xsl:template match="insert-line[parent::blockquote and (@character=' ' or contains(@character,'nbsp') or contains(@character, 'thinsp'))]"-->
   <xsl:template match="insert-line[parent::blockquote and @character = ('', '', ' ')]">
      <xsl:choose>
         <xsl:when test="parent::blockquote[parent::p][not(child::*[2])]">
            <text>
               <proc:nl/>
            </text>
         </xsl:when>
         <xsl:otherwise>
            <p/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="insert-line[parent::blockquote[parent::bodytext[parent::level[@leveltype=('prec.grp' , 'precgrp' , 'precgrp1' , 'precgrp2' , 'prec' , 'form')]]] and @character = ('', '', ' ')][$streamID=('AU05', 'NZ09')]"
                 priority="2">
      <form:p/>
   </xsl:template>
   <!-- start topichead  l  -->   <!-- <topicref href="../../common_newest/Rosetta_l-LxAdv-list.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>l</xd:i> becomes <xd:b>list</xd:b>.</xd:p>
         <xd:p>The child <xd:i>li</xd:i> becomes
        <xd:b>listitem</xd:b>. <xd:b>bodytext</xd:b> is the required child element for
        <xd:b>listitem</xd:b>. The child <xd:i>lilabel</xd:i> becomes <xd:b>label</xd:b>. </xd:p>
         <xd:p>Any <xd:i>h</xd:i> children of the <xd:i>li</xd:i> should be processed as <xd:b>h</xd:b> within the <xd:b>listitem/bodytext</xd:b>.  Process the children of <xd:i>h</xd:i>.</xd:p>
         <xd:p>Nested lists, when a <xd:i>li</xd:i> contains a <xd:i>l</xd:i> element, the mapping should appear as follows: create <xd:b>list/listitem/bodytext</xd:b>
       followed by a <xd:i>list</xd:i> within the <xd:i>bodytext</xd:i> element.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;l&gt;
  &lt;li&gt;
   &lt;lilabel&gt;
	   &lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;
   &lt;/lilabel&gt;
   &lt;p&gt;
	 &lt;text&gt;The plaintiffs&amp;#x2019; application is dismissed.&lt;/text&gt;
   &lt;/p&gt;
 &lt;/li&gt;
 &lt;li&gt;
   &lt;lilabel&gt;
	   &lt;emph typestyle="ro"&gt;(2)&lt;/emph&gt;
   &lt;/lilabel&gt;
   &lt;p&gt;
	 &lt;text&gt;The plaintiffs pay the defendant&amp;#x2019;s costs, including each appearance in the court, as taxed, if not agreed.&lt;/text&gt;
   &lt;/p&gt;
 &lt;/li&gt;
&lt;/l&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML </xd:b>
         </xd:p>
         <xd:pre>

&lt;list&gt;
 &lt;listitem&gt;
	&lt;label&gt;
	  &lt;emph typestyle="ro"&gt;(1)&lt;/emph&gt;
	&lt;/label&gt;
	&lt;bodytext&gt;
	 &lt;p&gt;
	  &lt;text&gt;The plaintiffs&amp;#x2019; application is dismissed.&lt;/text&gt;
	 &lt;/p&gt;
	&lt;/bodytext&gt; 
 &lt;/listitem&gt;
 &lt;listitem&gt;
	&lt;label&gt;
	  &lt;emph typestyle="ro"&gt;(2)&lt;/emph&gt;
	&lt;/label&gt;
	&lt;bodytext&gt;
	 &lt;p&gt;
	  &lt;text&gt;The plaintiffs pay the defendant&amp;#x2019;s costs, including each appearance in the court, as taxed, if not agreed.&lt;/text&gt;
	 &lt;/p&gt;
	&lt;/bodytext&gt; 
 &lt;/listitem&gt;
&lt;/list&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Nested list Source(l/li/l)</xd:b>
         </xd:p>
         <xd:pre>
    
              &lt;l&gt;
            &lt;li&gt;
              &lt;lilabel&gt;&amp;#x2022;&lt;/lilabel&gt;
              &lt;p&gt;
                &lt;text&gt;the health and safety of workers who are:&lt;/text&gt;
              &lt;/p&gt;
            &lt;/li&gt;
            &lt;li&gt;
              &lt;l&gt;
                &lt;li&gt;
                  &lt;lilabel&gt;&amp;#x25E6;&lt;/lilabel&gt;
                  &lt;p&gt;
                    &lt;text&gt;engaged by the person conducting the business or undertaking;&lt;/text&gt;
                  &lt;/p&gt;
                &lt;/li&gt;
              &lt;/l&gt;
            &lt;/li&gt;
            ...  
            
  </xd:pre>
         <xd:p>
            <xd:b>Nested list Target (list/listitem/bodytext/list)</xd:b>
         </xd:p>
         <xd:pre>
    
          &lt;list&gt;
            &lt;listitem&gt;
              &lt;label&gt;&amp;#x2022;&lt;/label&gt;
              &lt;bodytext&gt;
              &lt;p&gt;
                &lt;text&gt;the health and safety of workers who are:&lt;/text&gt;
              &lt;/p&gt;
              &lt;/bodytext&gt;
            &lt;/listitem&gt;
            &lt;listitem&gt;
               &lt;bodytext&gt;
                 &lt;list&gt;
                   &lt;listitem&gt;
                      &lt;label&gt;&amp;#x25E6;&lt;/label&gt;
                      &lt;bodytext&gt;
                        &lt;p&gt;
                         &lt;text&gt;engaged by the person conducting the business or undertaking;&lt;/text&gt;
                        &lt;/p&gt;
                      &lt;/bodytext&gt;  
                   &lt;/listitem&gt;
                 &lt;/list&gt;
               &lt;/bodytext&gt;  
            &lt;/listitem&gt;  
            ...
  
  </xd:pre>
         <!--Changes2016-04-01: Added mapping instruction for handling h within listitem.2014-01-16: Added mapping instruction for nested lists.-->
      </xd:desc>
   </xd:doc>
   <!-- Done as part of ROCKET but not for any particular stream JL 2017-03-14 -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_l-LxAdv-list.dita  -->
   <!-- virtual nesting requires its own template -->
   <xsl:template match="l[not(@virtual-nesting)]">
      <xsl:choose><!-- Awantika: specific for AU20 -->
         <xsl:when test="$streamID='AU20' and ancestor::source_cttr:annotations[@id='OI7' or @id='OP3']/heading/note/l">
            <xsl:for-each select="li/p/text">
               <primlaw:subordinatelaw-item>
                  <textitem>
                     <xsl:apply-templates select="@* | node()"/>
                  </textitem>
               </primlaw:subordinatelaw-item>
            </xsl:for-each>
         </xsl:when>
         <!-- 2017-10-17 - MDS: Added due to Webstar 7025682 -->
         <xsl:when test="parent::l">
            <xsl:apply-templates select="node()"/>
         </xsl:when>
         <xsl:otherwise><!-- 2017-10-17 - MDS: Removed 'except l' because it was dropping content as found in Webstar 7025682.  See when statement 'parent::l'-->
            <xsl:element name="list">
               <xsl:apply-templates select="@*"/>
               <xsl:if test="$streamID='UK09' and note[not(preceding-sibling::li)]">
                  <listitem>
                     <bodytext/>
                  </listitem>
               </xsl:if>
               <xsl:apply-templates select="node()"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="l[ancestor::frm:body][not(ancestor::footnote or ancestor::note)][$streamID='UK12']"
                 priority="25">
      <form:list>
         <xsl:apply-templates select="@*|node() except l"/>
      </form:list>
   </xsl:template>
   <!-- Sudhanshu added this template as li and h element is not handled , so added for UK06. -->   <!-- JD: 2017-07-10: this should be the default, not stream-specific; appears duplicate of /modules/nonamespace/Rosetta_li-LxAdv-listitem.xsl -->
   <xsl:template match="li[$streamID='UK06' or $streamID='USLPA']">
      <listitem>
         <xsl:apply-templates select="lilabel"/>
         <bodytext>
            <xsl:apply-templates select="h"/>
            <xsl:apply-templates select="@* | node() except (lilabel|h)"/>
         </bodytext>
      </listitem>
   </xsl:template>
   <!-- JD: 2017-07-10: this should be the default, not stream-specific -->   <!--<xsl:template match="h[$streamID='UK06']">
    <h>
      <xsl:apply-templates select="@*|node()"/>
    </h>
  </xsl:template>-->   <!--  <xsl:template match="h/@l[$streamID='UK06']"/>-->   <!-- 
    ********************************************************************************************
    NOTE!
    from  /XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_refpt-LxAdv-ref.anchor.xsl
   
    this is **GENERIC** behavior. If your stream implements differently, fork template or give a streamID test
   
    <p>If <sourcexml>refpt</sourcexml> comes within <sourcexml>l/li/lilabel</sourcexml>
					then <targetxml>ref:anchor</targetxml> will become the first child of
						<targetxml>listitem</targetxml>.</p>
					-	JL
    ************************************************************************************************  -->
   <xsl:template match="lilabel">
      <xsl:choose><!-- SS: Only for HK07 - Remove EMPTY label element inside list--><!-- Awantika: Corrected dropping of lilabel --><!-- JD: 2017-07-24: added NZ18 to streams to suppress empty <label> from; added 'replace' test to get rid of characters not handled by normalize-space(e.g., nbsp) -->
         <xsl:when test="$streamID=('HK07','NZ18', 'AU16', 'NZ12','CA14', 'AU18') and normalize-space(replace(., '^[\t\p{Zs}]+$', '')) = ''"><!--<xsl:if test=".[normalize-space() = '']"/>--></xsl:when>
         <xsl:when test="$streamID=('NZ13', 'AU18') and normalize-space(replace(., '^$', '')) = ''"/>
         <xsl:otherwise>
            <xsl:element name="label">
               <xsl:apply-templates select="@* | node() except(refpt)"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Awantika: wrapper p to be created around list if coming in case:factsummary and case:decisionsummary for HK03 -->
   <xsl:template match="l[not(@virtual-nesting)][parent::case:factsummary or parent::case:decisionsummary]"
                 priority="25"><!-- JD: 2017-06-16: removing $streamID test, as this is supposed to be the default handling.  
  	If stream-specific handling is required this should be moved to a stream-specific module. --><!--<xsl:if test="$streamID='HK03'">-->
      <xsl:choose>
         <xsl:when test="$streamID=('NZ04', 'AU13')">
            <list>
               <xsl:apply-templates select="@* | node()"/>
            </list>
         </xsl:when>
         <!-- JD: UK02 wraps in list when a child of case:decisionsummary but not case:factsummary -->
         <xsl:when test="$streamID=('UK02') and parent::case:decisionsummary">
            <list>
               <xsl:apply-templates select="@* | node()"/>
            </list>
         </xsl:when>
         <xsl:otherwise>
            <p>
               <list>
                  <xsl:apply-templates select="@* | node()"/>
               </list>
            </p>
         </xsl:otherwise>
      </xsl:choose>
      <!--</xsl:if>-->
   </xsl:template>
   <!-- Vikas Rohilla : Added template for the empty lilabel   -->   <!-- SP : don't apply this rule if child elements exist   -->
   <xsl:template match="lilabel[matches(.,'^$') and not(child::*)]"/>
   <!-- MDS 207-05-17 - Exception found in AU04 There is no target attribute in <list> for l/@type -->
   <xsl:template match="l/@type"/>
   <!-- <topicref href="../../common_newest/Rosetta_fnr-Chof-lilabel-LxAdv-label_footnote.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>lilabel/fnr</xd:i> becomes <xd:b>label/footnote</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML having lilabel/fnr:</xd:b>
         </xd:p>
         <xd:pre>
         &lt;li id="AFL.FL.FLA75.S31.1.C"&gt;    
             &lt;lilabel&gt;        
                 &lt;refpt id="AFL.FL.FLA75.S31.1.C" type="ext"/&gt;        
                 &lt;fnr fnrtoken="AFL.FL.FLA75.S31.1.C.FTN1-R" fntoken="AFL.FL.FLA75.S31.1.C.FTN1"&gt;*&lt;/fnr&gt;(c)        
             &lt;/lilabel&gt;    
             . . .     
         &lt;/li&gt; 
     </xd:pre>
         <xd:p>
            <xd:b>Target XML </xd:b>
         </xd:p>
         <xd:pre>

&lt;listitem&gt;
    &lt;ref: anchor id=" AFL.FL.FLA75.S31.1.C " anchortype="global"/&gt;
    &lt;bodytext&gt;
        ...
    &lt;/bodytext&gt;
    &lt;label&gt;(c)
        &lt;footnote&gt;
            &lt;ref:anchor id="AFL.FL.FLA75.S31.1.C.FTN1" anchortype="global"/&gt;
            &lt;label&gt;*&lt;/label&gt;
            &lt;bodytext&gt;
                ....
            &lt;/bodytext&gt;
        &lt;/footnote&gt;
    &lt;/label&gt;
&lt;/listitem&gt;

</xd:pre>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_fnr-Chof-lilabel-LxAdv-label_footnote.dita  -->
   <!-- Vikas Rohilla : initila updated may by changed if required-->
   <!-- 20170531:  MCJ:  Enforced order of processing attributes since some create elements. -->
   <xsl:template match="lilabel/fnr">
      <footnote>
         <xsl:choose>
            <xsl:when test="$streamID=('AU18', 'UK12')">
               <xsl:element name="ref:anchor">
                  <xsl:attribute name="id">
                     <xsl:value-of select="@fnrtoken"/>
                  </xsl:attribute>
                  <xsl:attribute name="anchortype">
                     <xsl:text>global</xsl:text>
                  </xsl:attribute>
               </xsl:element>
               <label>
                  <xsl:apply-templates select="node()"/>
               </label>
               <bodytext>
                  <xsl:text><!--Mandatory element per the target schema--></xsl:text>
               </bodytext>
            </xsl:when>
            <xsl:otherwise><!-- Process all attributes except @fnrtoken because fnrtoken produces an element.  This does assume that no other
		         attributes produce elements. -->
               <xsl:apply-templates select="@* except @fnrtoken"/>
               <!-- Now process @fnrtoken as the last attribute since it produces an element. -->
               <xsl:apply-templates select="@fnrtoken"/>
               <xsl:apply-templates select="node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </footnote>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_li-LxAdv-listitem.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>li</xd:i> has attribute <xd:i>@level</xd:i> then conversion need to suppress
      <xd:i>@level</xd:i>.</xd:p>
         <xd:p>When <xd:i>li</xd:i> is immediately followed by a <xd:i>l</xd:i> that list should be brought into the end of the <xd:b>listitem/bodytext</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML having li/@level</xd:b>
         </xd:p>
         <xd:pre>

&lt;l&gt;
    &lt;li level="1"&gt;
        &lt;lilabel&gt;(a)&lt;/lilabel&gt;
            &lt;p&gt;
                &lt;text&gt;the day on which the person with the claim first knew,&lt;/text&gt;
            &lt;/p&gt;
    &lt;/li&gt;
&lt;/l&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;list&gt;
    &lt;listitem&gt;
        &lt;label&gt;(a)&lt;/label&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;the day on which the person with the claim first
                    knew,&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/listitem&gt;
&lt;/list&gt;

        </xd:pre>
      </xd:desc>
   </xd:doc>
   <xsl:template match="li"><!--  Original Target XPath:  listitem   -->
      <listitem>
         <xsl:choose>
            <xsl:when test="@id = ''"/>
            <xsl:when test="$streamID='AU18' and ./@id = descendant::refpt/@id"/>
            <xsl:otherwise>
               <xsl:apply-templates select="@id"/>
            </xsl:otherwise>
         </xsl:choose>
         <xsl:apply-templates select="@* except @id"/>
         <xsl:apply-templates select="lilabel/refpt"/>
         <xsl:apply-templates select="lilabel"/>
         <bodytext><!-- 
                <xsl:apply-templates select="* except lilabel"/>
-->
            <xsl:choose>
               <xsl:when test="$streamID=('AU10','NZ11')"><!-- WPK 2017-12-08.  In pacific PG, "some" glp:notes can become margin notes.
                            However they are not done by creating new <p><text><marginnote> for each note.
                            The margin notes are all placed inside the preceding <p><text> (already created text node).
                            This is achieved by applying following-sibling glp:note from within the first p/text.
                            Since the following sibling is done there, applying templates here will create duplicates.
                            So this "when" clause prevents duplication of margin notes.
                            4.2.2.3. heading (id-CCCC-10182)
                            1. bodytext/glp:note[notetype="xref"] becomes seclaw:bodytext/p/text/marginnote. New p and text elements are not created;
                            instead, the newly created marginnote is placed in the p that was mapped from the preceding sibling p of glp:note[notetype="xref"]. Within
                            this p the marginnote is placed within the text element that was mapped from the preceding sibling p element's last existing child text element.
                            2. li/glp:note[notetype="xref"] becomes listitem/bodytext/p/text/marginnote. Within the listitem/bodytext, new p
                            and text elements are usually not created; instead, the newly created marginnote is placed in the p that was mapped from the preceding sibling p of
                            glp:note[notetype="xref"]. Within this p the marginnote is placed within the text element that was mapped from the preceding sibling p
                            element's last child text source element. A new text element will need to be created if and only if the glp:note[notetype="xref"] occurs in
                            an li before any sibling p in the li (because in this case there would be no li/p that precedes the li/glp:note).

2018-01-31 update WPK:
original template call:
                        <xsl:apply-templates select="* except (lilabel | glp:note[@notetype='xref'][preceding-sibling::*[1][self::p[text[not(*) and normalize-space(.)!='']] or self::glp:note[@notetype='xref']]])"/>                        
This resulted in extraneous marginnotes (sibling margin notes are merged into p within one marginnote tag) to occur in a second, duplicate marginnote.
example: EMP_GUID_210381000.xml

new template call rectifies this and omits duplicate.

Regarding p/text predicate phrases:
(not(*) and normalize-space(.)!='') :::::: prevents creation of a marginnote from a glp:note following an empty p/text (yes this needs to be handled)
(emph and normalize-space(.)!='')   :::::: allows for emph to be in the preceding text.  Tried to merge with phrase above but this was easier to read and debug.

ideally this should be in a stream specific template since its has become a monster.

                        -->
                  <xsl:apply-templates select="* except (lilabel | glp:note[@notetype='xref']                             [                                 preceding-sibling::*[1]                                 [                                     self::p[text[not(*) and normalize-space(.)!='']] or self::glp:note[@notetype='xref']                                     or self::p[text[emph and normalize-space(.)!='']]                                  ]                             ])"/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="* except lilabel"/>
               </xsl:otherwise>
            </xsl:choose>
            <xsl:if test="following-sibling::*[1][self::l]">
               <xsl:apply-templates select="following-sibling::*[1][self::l]" mode="nested-list"/>
            </xsl:if>
         </bodytext>
      </listitem>
   </xsl:template>
   <!-- JL: change to handle potential multiple nested consecutive lists between lis -->
   <xsl:template match="l" mode="nested-list">
      <xsl:choose>
         <xsl:when test="ancestor::frm:body and not(ancestor::footnote or ancestor::note)">
            <form:list>
               <xsl:apply-templates/>
            </form:list>
         </xsl:when>
         <xsl:otherwise>
            <list>
               <xsl:apply-templates/>
            </list>
         </xsl:otherwise>
      </xsl:choose>
      <xsl:if test="following-sibling::*[1][self::l]">
         <xsl:apply-templates select="following-sibling::*[1][self::l]" mode="nested-list"/>
      </xsl:if>
   </xsl:template>

   <xsl:template match="li[ancestor::frm:body][not(ancestor::footnote or ancestor::note)]"
                 priority="25"><!--  Original Target XPath:  listitem   -->
      <form:listitem>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="lilabel/refpt"/>
         <xsl:apply-templates select="lilabel"/>
         <form:bodytext>
            <xsl:apply-templates select="* except lilabel"/>
            <xsl:if test="following-sibling::*[1][self::l]">
               <xsl:apply-templates select="following-sibling::*[1][self::l]" mode="nested-list"/>
            </xsl:if>
         </form:bodytext>
      </form:listitem>
   </xsl:template>

   <xsl:template match="li/@level"/>
   <!-- <topicref href="../../common_newest/Rosetta_glp.note-Chof-li-LxAdv-listitem-note.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>l</xd:i> has 2 or more <xd:i>consecutive</xd:i>
            <xd:i>glp:note</xd:i> children, they should be mapped to a single <xd:b>note</xd:b> child of
        <xd:b>list</xd:b>. The content of each <xd:i>glp:note</xd:i> should be placed inside
        <xd:b>note/bodytext</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML 4 - Multiple Consecutive <xd:i>glp:note</xd:i> Children of <xd:i>l</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;l&gt;
    ...
    &lt;li&gt;
        &lt;lilabel&gt;&amp;#x2022;&lt;/lilabel&gt;
        &lt;p&gt;
            &lt;text&gt;Estoppel &amp;#x2013; if the true owner induces another to believe in a state of affairs and causes that other person to act on that
                belief to his or her detriment, the true owner will not be allowed to deny that the state of affairs exists. In the context of sale of
                goods, this means that if the true owner knowingly allows a seller to represent to a buyer that the seller has title to the goods and
                the buyer, believing the representation, purchases the goods from the seller, the buyer will get title to the goods as against the
                true owner. If the true owner owes the buyer a duty of care to the buyer to make the true owner&amp;#x2019;s title to the goods known or
                apparent to the buyer, but breaches that duty and the buyer purchases the goods from a seller who in fact has no title, the true owner
                might be estopped by negligence from asserting that ownership. Proving the existence of the duty is usually very difficult.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/li&gt;
    &lt;glp:note notetype="xref"&gt;
        &lt;p nl="0"&gt;
            &lt;text&gt;&lt;emph typestyle="it"&gt;Big Rock Pty Ltd v Esanda Finance Corp Ltd &lt;/emph&gt;10 WAR 259&lt;/text&gt;
        &lt;/p&gt;
    &lt;/glp:note&gt;
    &lt;glp:note notetype="xref"&gt;
        &lt;p nl="0"&gt;
            &lt;text&gt;&lt;emph typestyle="it"&gt;Thomas Australia Wholesale Vehicle Trading Co Pty Ltd v Marac Finance Australia Ltd &lt;/emph&gt;(1985) 3 NSWLR
                452&lt;/text&gt;
        &lt;/p&gt;
    &lt;/glp:note&gt;
&lt;/l&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML 4</xd:b>
         </xd:p>
         <xd:pre>

&lt;list&gt;
    ...
    &lt;listitem&gt;
        &lt;label&gt;&amp;#x2022;&lt;/label&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;Estoppel &amp;#x2013; if the true owner induces another to believe in a state of affairs and causes that
                    other person to act on that belief to his or her detriment, the true owner will not be allowed to deny
                    that the state of affairs exists. In the context of sale of goods, this means that if the true owner
                    knowingly allows a seller to represent to a buyer that the seller has title to the goods and the buyer,
                    believing the representation, purchases the goods from the seller, the buyer will get title to the goods
                    as against the true owner. If the true owner owes the buyer a duty of care to the buyer to make the true
                    owner&amp;#x2019;s title to the goods known or apparent to the buyer, but breaches that duty and the buyer
                    purchases the goods from a seller who in fact has no title, the true owner might be estopped by negligence
                    from asserting that ownership. Proving the existence of the duty is usually very difficult.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/listitem&gt;
    &lt;note notetype="xref"&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;&lt;emph typestyle="it"&gt;Big Rock Pty Ltd v Esanda Finance Corp Ltd &lt;/emph&gt;10 WAR 259&lt;/text&gt;
            &lt;/p&gt;
            &lt;p&gt;
                &lt;text&gt;&lt;emph typestyle="it"&gt;Thomas Australia Wholesale Vehicle Trading Co Pty Ltd v Marac Finance Australia Ltd
                &lt;/emph&gt;(1985) 3 NSWLR 452&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/note&gt;
&lt;/list&gt;

            </xd:pre>
         <!--Changes2013-11-10: Fixed title to correctly indicate mapping described. Not a rule change.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_glp.note-Chof-li-LxAdv-listitem-note.dita  -->
   <!-- JL STILL TESTING IT'S BUGGY THERE'S AN XSPEC FOR YOU TO USE  CAN'T GET @notetype to work yet -->
   <xsl:template match="l[not(@virtual-nesting)][child::glp:note]" priority="25">
      <list>
         <xsl:for-each-group select="*" group-adjacent="if (self::glp:note) then 0 else 1">
            <xsl:choose>
               <xsl:when test="current-grouping-key()=0">
                  <note>
                     <xsl:copy-of select="current-group()[1]/@notetype"/>
                     <xsl:apply-templates select="current-group()/refpt"/>
                     <xsl:apply-templates select="current-group()/heading"/>
                     <xsl:if test="current-group()/child::*[not(self::heading)][not(self::refpt)]">
                        <bodytext>
                           <xsl:apply-templates select="current-group()/child::* except (heading | refpt)"/>
                        </bodytext>
                     </xsl:if>
                  </note>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:for-each select="current-group()">
                     <xsl:apply-templates select="."/>
                  </xsl:for-each>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each-group>
      </list>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_l_virtual-nesting-LxAdv-list.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>l</xd:i> has attribute <xd:i>@virtual-nesting </xd:i> then
        it should be converted to real list nesting (mean's creating some parent nested list on
        basis of attribute value i.e. "@virtual-nesting='3'"). Drop <xd:i>@virtual-nesting</xd:i> and add n-1 list wrappers, where <xd:b>n</xd:b> is the value of <xd:i>@virtual-nesting</xd:i>. Please refer the below input and target markups for more clarification: </xd:p>
         <xd:p>
            <xd:b>Source XML having l/@virtual-nesting</xd:b>
         </xd:p>
         <xd:pre>

&lt;l virtual-nesting="3"&gt;
    &lt;li&gt;
        &lt;lilabel/&gt;
        &lt;p&gt;
            &lt;text&gt;&lt;emph typestyle="bf"&gt;Unless the agreement provides otherwise...&lt;/emph&gt;&lt;/text&gt;
        &lt;/p&gt;
    &lt;/li&gt;
&lt;/l&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;list&gt;
    &lt;listitem&gt;
      &lt;bodytext&gt;
        &lt;p&gt;
          &lt;list&gt;
            &lt;listitem&gt;
              &lt;bodytext&gt;
                &lt;p&gt;
                  &lt;list&gt;
                    &lt;listitem&gt;
                      &lt;bodytext&gt;
                        &lt;p&gt;&lt;text&gt;&lt;emph typestyle="bf"&gt;Unless the agreement provides otherwise...&lt;/emph&gt;&lt;/text&gt;&lt;/p&gt;
                      &lt;/bodytext&gt;
                    &lt;/listitem&gt;
                  &lt;/list&gt;
                &lt;/p&gt;
              &lt;/bodytext&gt;
            &lt;/listitem&gt;
          &lt;/list&gt;
        &lt;/p&gt;
      &lt;/bodytext&gt;
    &lt;/listitem&gt;
  &lt;/list&gt;

        </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--Vikas Rohilla : updated for the streamID CA01  -->
   <!-- Sudhanshu Srivastava : Added CA02CC for listing conversion -->
   <xsl:template match="l[@virtual-nesting='1'][$streamID='CA01' or $streamID='CA02CC' or $streamID='CA12' or $streamID='CA19' or $streamID='CA14' or $streamID='CA15' or $streamID='CA04' ]"
                 priority="2">
      <xsl:call-template name="virtualNesting">
         <xsl:with-param name="content" select="li"/>
         <xsl:with-param name="counter" select="number(@virtual-nesting)"/>
      </xsl:call-template>
   </xsl:template>
   <!-- Assumes @virtual-nesting is always a digit and never less than 2 -->
   <xsl:template match="l[@virtual-nesting]">
      <xsl:choose>
         <xsl:when test="$streamID='CA01' and(starts-with(ancestor::case:decisionsummary/child::heading/title,'Court Summary:') or         starts-with(ancestor::case:decisionsummary/child::heading/title,'Court Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Rsum de la Cour :') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Commission Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Board Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Tribunal Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Executive Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Commissioner Summary:') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Rsum du tribunal :') or        starts-with(ancestor::case:decisionsummary/child::heading/title,'Sommaire du tribunal :') or        contains(ancestor::case:decisionsummary/child::heading/title,'Subsequent History') or contains(ancestor::case:decisionsummary/child::heading/title,'Historique subsquent') or contains(ancestor::case:decisionsummary/child::heading/title,'Court Catchwords') or contains(ancestor::case:decisionsummary/child::heading/title,'Indexation de la Cour') or contains(ancestor::case:decisionsummary/child::p[1]/text[1]/emph[1],'Subsequent History') or contains(ancestor::case:decisionsummary/child::p[1]/text[1]/emph[1],'Historique subsquent') or contains(ancestor::case:decisionsummary/child::p[1]/text[1]/emph[1],'Court Catchwords') or contains(ancestor::case:decisionsummary/child::p[1]/text[1]/emph[1],'Indexation de la Cour'))">
            <p>
               <list>
                  <listitem>
                     <bodytext>
                        <p>
                           <xsl:call-template name="virtualNesting">
                              <xsl:with-param name="content" select="li"/>
                              <xsl:with-param name="counter" select="number(@virtual-nesting)"/>
                           </xsl:call-template>
                        </p>
                     </bodytext>
                  </listitem>
               </list>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <list>
               <listitem>
                  <bodytext>
                     <p>
                        <xsl:call-template name="virtualNesting">
                           <xsl:with-param name="content" select="li"/>
                           <xsl:with-param name="counter" select="number(@virtual-nesting)"/>
                        </xsl:call-template>
                     </p>
                  </bodytext>
               </listitem>
            </list>
         </xsl:otherwise>
      </xsl:choose>
      <!--  Original Target XPath:  list   -->
   </xsl:template>

   <xsl:template name="virtualNesting">
      <xsl:param name="content"/>
      <xsl:param name="counter"/>
      <xsl:choose>
         <xsl:when test="($counter - 1)&gt;1">
            <list>
               <listitem>
                  <bodytext>
                     <p>
                        <xsl:call-template name="virtualNesting">
                           <xsl:with-param name="content" select="$content"/>
                           <xsl:with-param name="counter" select="$counter - 1"/>
                        </xsl:call-template>
                     </p>
                  </bodytext>
               </listitem>
            </list>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose>
               <xsl:when test="$streamID='CA04' or $streamID='CA02CC' or $streamID='CA12' or $streamID='CA19'">
                  <xsl:choose>
                     <xsl:when test="count(child::*) = 1 and (@virtual-nesting[.='1'] or not(@virtual-nesting))">
                        <list>
                           <listitem>
                              <xsl:apply-templates select="$content/lilabel"/>
                              <bodytext>
                                 <xsl:apply-templates select="$content/(* except lilabel)"/>
                              </bodytext>
                           </listitem>
                        </list>
                     </xsl:when>
                     <xsl:when test="count(child::*) = 1">
                        <list>
                           <listitem>
                              <xsl:apply-templates select="$content/lilabel"/>
                              <bodytext>
                                 <xsl:apply-templates select="$content/(* except lilabel)"/>
                              </bodytext>
                           </listitem>
                        </list>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:for-each select="child::*">
                           <list>
                              <xsl:apply-templates select="."/>
                           </list>
                        </xsl:for-each>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:when>
               <xsl:when test="$streamID='CA08'">
                  <list>
                     <listitem>
                        <bodytext>
                           <list>
                              <xsl:apply-templates select="$content | node() except lilabel"/>
                           </list>
                        </bodytext>
                     </listitem>
                  </list>
               </xsl:when>
               <xsl:when test="$streamID='CA15' or $streamID='CA01' or $streamID='CA14'">
                  <list>
                     <xsl:for-each select="child::*">
                        <xsl:apply-templates select="."/>
                     </xsl:for-each>
                  </list>
               </xsl:when>
               <xsl:otherwise>
                  <list>
                     <listitem>
                        <bodytext>
                           <xsl:apply-templates select="$content/*"/>
                        </bodytext>
                     </listitem>
                  </list>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- end topichead  l  -->   <!-- start topichead  leg-comntry  -->   <!-- <topicref href="../../common_newest/Rosetta_leg.comntry-LxAdv-annot.annotations-annot.annotation-grp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>leg:comntry</xd:i>
                  <xd:b>Becomes</xd:b>
                  <xd:b>annot:annotations/annot:annotation-grp</xd:b> with optional attributes
            and child elements converted as: <xd:ul>
                     <xd:li>
                        <xd:i>@subdoc</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@includeintoc</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>@toc-caption</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@alternatetoccaption</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/@searchtype</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                        <xd:p>
                           <xd:b>Note: </xd:b>For GPL IN Content Stream
                  <xd:i>leg:comntry/@searchtype</xd:i> becomes
                  <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                        </xd:p>
                     </xd:li>
                     <xd:li>
                        <xd:i>refpt</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>ref:anchor</xd:b> and must be the first child in the sequence. Refer
                to the <xd:a href="Rosetta_refpt-LxAdv-ref.anchor.dita">refpt</xd:a> section for
                more information.</xd:li>
                     <xd:li>
                        <xd:i>heading/edpnum</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/desig</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/title</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/title</xd:b>
                     </xd:li>
                  </xd:ul>
                  <xd:p>
                     <xd:b>Note: </xd:b>In the input Xpath, <xd:i>leg:comntry</xd:i> is allowed within
                <xd:i>leg:bodytext</xd:i>, but the target New Lexis Xpath allows
                <xd:b>annot:annotations</xd:b> to be a sibling to
                <xd:b>primlaw:bodytext</xd:b> and child element of
                <xd:b>primlaw:level</xd:b> i.e.
                <xd:i>leg:bodytext/leg:comntry</xd:i> becomes
                <xd:b>annot:annotations/annot:annotation-grp</xd:b>.</xd:p>
               </xd:li>
               <xd:li> The conversion of <xd:i>level</xd:i> is determined by the value of
              <xd:i>@leveltype</xd:i> which also reflects the nesting structure.
              <xd:p>
                     <xd:b>Note: </xd:b>Maintain source nesting.</xd:p>
               </xd:li>
               <xd:li>If source document is having empty elements (i.e.
              <xd:i>bodytext/p/text</xd:i> and <xd:i>hrule</xd:i>) within
              <xd:i>leg:comntry</xd:i> then removed the empty markups from
              <xd:i>leg:comntry</xd:i> and <xd:i>leg:comntry</xd:i> should be
            mapped with <xd:b>annot:annotations</xd:b>. Please refer the below markups for
            understanding this scenario: </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:comntry subdoc="true" toc-caption="Notes"&gt;
  &lt;bodytext&gt;
    &lt;p&gt;&lt;text&gt;&lt;/text&gt;&lt;/p&gt;
    &lt;p&gt;&lt;text&gt;&lt;/text&gt;&lt;/p&gt;
    &lt;hrule/&gt;
  &lt;/bodytext&gt;
  &lt;level id="NZREGS_REGS-H.SGM_PARA-2009R165S1-COMPENDIUM" leveltype="para0"&gt;
    &lt;bodytext searchtype="COMMENTARY"&gt;
      ...
    &lt;/bodytext&gt;
  &lt;/level&gt;
 &lt;/leg:comntry&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;annot:annotations&gt;
  &lt;annot:annotation-grp includeintoc="true" alternatetoccaption="Notes"&gt;
    &lt;annot:annotation xml:id="NZREGS_REGS-H.SGM_PARA-2009R165S1-COMPENDIUM"&gt;
      &lt;bodytext&gt;
        ...
      &lt;/bodytext&gt;
    &lt;/annot:annotation&gt;
  &lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;

	</xd:pre>
         <xd:p>For GPL IN Content Streams</xd:p>
         <xd:p>
            <xd:b>GPL IN LEG Source XML</xd:b>
         </xd:p>
         <xd:pre>
        
       &lt;leg:comntry searchtype="commentary"&gt;
             &lt;level leveltype="comm1"&gt;
                  &lt;bodytext&gt;
                    &lt;pgrp&gt;
                      &lt;heading searchtype="commentary"&gt;
                           &lt;title align="center"&gt;COMMENTS&lt;/title&gt;
                      &lt;/heading&gt;
                    .....
                    &lt;/pgrp&gt;
                &lt;/bodytext&gt;
            &lt;/level&gt;
        &lt;/leg:comntry&gt;
        
      </xd:pre>
         <xd:p>
            <xd:b>GPL IN LEG Target XML</xd:b>
         </xd:p>
         <xd:pre>
 
&lt;annot:annotations&gt;
  &lt;annot:annotation-grp grptype="COMMENTARY"&gt;
    &lt;annot:annotation&gt;
       &lt;bodytext&gt;
          &lt;pgrp&gt;
            &lt;heading&gt;
              &lt;title align="center"&gt;COMMENTS&lt;/title&gt;
            &lt;/heading&gt;
          ....
          &lt;/pgrp&gt;
      &lt;/bodytext&gt;
    &lt;/annot:annotation&gt;
  &lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;
        
      </xd:pre>
         <!--Changes2012-11-20: Added the instruction and example for handling the empty markups (i.e.
          bodytext/p/text and hrule) within
          leg:comntry.2013-05-15 Fixed typo: (extra semicolon in xpath
       expression)2014-03-21:  Added instruction to handle leg:comntry/@searchtype For GPL IN Content Streams-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.comntry-LxAdv-annot.annotations-annot.annotation-grp.dita  -->
   <xsl:template match="leg:comntry" name="leg-comntry-generic">
      <annot:annotations><!-- based on the examples for comm.intro and group children, outputting the annotation group only in certain conditions 
		 but what are they? -->
         <xsl:choose>
            <xsl:when test="child::*[not(self::level[@leveltype=('comm.intro' , 'group')])]">
               <annot:annotation-grp>
                  <xsl:choose><!-- 20170601:  MCJ:  Added 'AU06' to list. -->
                     <xsl:when test="$streamID = ('AU04', 'AU05', 'AU06', 'AU08', 'NZ05','NZ06' , 'NZ12', 'NZ10', 'AU18')">
                        <xsl:apply-templates select="@*"/>
                        <xsl:if test="heading/@searchtype[.='COMMENTARY'] or level/heading[@searchtype='COMMENTARY'] or (starts-with($streamID, 'IN') and @searchtype[.='COMMENTARY'])">
                           <xsl:attribute name="grptype" select="'COMMENTARY'"/>
                        </xsl:if>
                        <xsl:apply-templates select="refpt | heading//refpt | bodytext/refpt"/>
                        <xsl:apply-templates select="heading"/>
                        <!-- JD: 2017-08-07: Adding for-each here to preserve ordering (don't just test that there is any child named bodytext, loop through each child and test self::); don't include levelinfo only having currency-statement (maps to doc:docinfo/currencystatement) -->
                        <xsl:for-each select="* except (refpt,heading,levelinfo[docinfo:currencystatement and count(*)=1])">
                           <xsl:choose>
                              <xsl:when test="self::bodytext"><!-- 20170728:  MCJ:
			                    An annotation wrapper should only be created if the bodytext transformation has results.  There are other instructions that suppress paragraphs and other
			                    constructs when they are effectively empty (whitespace, tabs, etc.).  We attempted to do this by applying the regex of '[\t\s\p{Z}]+' to the string value
			                    of the bodytext child (not an exact comparison of what apply-templates against the bodytext) but a possible encoding problem is causing the character count
			                    to always be off.  As an alternative, the results of transforming bodytext are stored in a variable which is then evaluated.  For future reference, the
			                    regex that was originally attempted is here within the comment.
	
			                        <xsl:variable name="bodytextString"><xsl:value-of select="bodytext" /></xsl:variable>
			                        <xsl:variable name="replacedBodytextString" select="replace($bodytextString, '[\t\s\p{Z}]+', '')" />
			                -->
                                 <xsl:variable name="bodytextResult">
                                    <xsl:apply-templates select="."/>
                                    <!-- JD: 2017-08-07: changed from 'bodytext' to '.' since for-each loop has changed context node -->
                                 </xsl:variable>
                                 <!-- MCJ:  Test both the result as a string and also that it doesn't have child nodes... both suggest that the transform of bodytext has a result that should be
			                           wrapped in an annotation.  Without this test, empty occurrences of annot:annotation are created. -->
                                 <xsl:if test="normalize-space($bodytextResult) != '' or $bodytextResult/*">
                                    <annot:annotation>
                                       <xsl:apply-templates select="."/>
                                    </annot:annotation>
                                 </xsl:if>
                                 <!-- JD: 2017-08-07: removing this; after for-each causing duplicates -->
                                 <!--<xsl:apply-templates select="node() except (refpt | heading | bodytext)"/>-->
                              </xsl:when>
                              <!-- JD: 2017-08-08: when self is create <annot:annotation-grp> -->
                              <xsl:when test="self::level[@leveltype=('comm.intro' , 'group')]">
                                 <xsl:apply-templates select="."/>
                              </xsl:when>
                              <!-- <xsl:when test="bodytext[string-length(replace(., '[\t\s\p{Z}]+', '')) != 0]">
			                <xsl:variable name="bodytextString">
			                  <xsl:value-of select="bodytext" />
			                </xsl:variable>
			                <blah>Text of bodytext is :<xsl:value-of select="replace($bodytextString, '[\t\s\p{Z}]+', '')" />:</blah>
	                    <annot:annotation>
	                      <xsl:apply-templates select="bodytext" />
	                    </annot:annotation>
			                <xsl:apply-templates select="node() except (refpt | heading | bodytext)"/>
			              </xsl:when> -->
                              <xsl:otherwise>
                                 <annot:annotation><!--<xsl:apply-templates select="@* | node() except (levelinfo[docinfo:currencystatement and count(*)=1])"/>-->
                                    <xsl:apply-templates select="@*"/>
                                    <xsl:apply-templates select="refpt | heading//refpt | bodytext/refpt"/>
                                    <!-- JL from bodytext template, we are outputting level/glp:note in bodytext except for UK15, UK06 and 
			              	    other xpaths that don't apply here -->
                                    <xsl:choose>
                                       <xsl:when test="$streamID= ('UK15' , 'UK06')">
                                          <xsl:apply-templates select="node() except (refpt,levelinfo[docinfo:currencystatement and count(*)=1])"/>
                                       </xsl:when>
                                       <xsl:otherwise>
                                          <xsl:apply-templates select="node() except (refpt,glp:note,levelinfo[docinfo:currencystatement and count(*)=1])"/>
                                       </xsl:otherwise>
                                    </xsl:choose>
                                 </annot:annotation>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:for-each>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates select="@*"/>
                        <xsl:if test="heading/@searchtype[.='COMMENTARY'] or level/heading[@searchtype='COMMENTARY'] or (starts-with($streamID, 'IN') and @searchtype[.='COMMENTARY'])">
                           <xsl:attribute name="grptype" select="'COMMENTARY'"/>
                        </xsl:if>
                        <xsl:apply-templates select="refpt | heading//refpt | bodytext/refpt"/>
                        <xsl:apply-templates select="node() except refpt"/>
                     </xsl:otherwise>
                  </xsl:choose>
               </annot:annotation-grp>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="node() except refpt"/>
            </xsl:otherwise>
         </xsl:choose>
      </annot:annotations>
   </xsl:template>
   <!-- these are common attributes for all generic "level" elements as well as leg:comntry, so we might as well handle once and done -->
   <xsl:template match="leg:comntry/@subdoc | level[ancestor::leg:comntry]/@subdoc">
      <xsl:attribute name="includeintoc">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="leg:comntry/@toc-caption | level[ancestor::leg:comntry]/@toc-caption">
      <xsl:attribute name="alternatetoccaption">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="leg:comntry/@includeintoc | level[ancestor::leg:comntry]/@includeintoc">
      <xsl:attribute name="toc-caption">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="leg:comntry/bodytext/p[normalize-space(string-join(text , ''))=''][not(child::*[not(self::text[normalize-space(string-join(. , ''))=''])])]"/>

   <xsl:template match="leg:comntry//hrule"/>
   <!-- per updated CIs if we come across leveltypes we don't recognize, right now we just output them same as para0/subpara0  -->
   <xsl:template match="level[ancestor::level[parent::leg:comntry]][not(@leveltype=('para0', 'subpara0' , 'comm.intro' , 'group'))]">
      <annot:annotationlevel>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt | heading/descendant::refpt | bodytext/refpt"/>
         <xsl:apply-templates select="heading"/>
         <xsl:if test="child::*[not(self::refpt or self::heading)]">
            <annot:bodytext>
               <xsl:apply-templates select="node() except (heading | refpt)"/>
            </annot:bodytext>
         </xsl:if>
      </annot:annotationlevel>
   </xsl:template>

   <xsl:template match="level[ancestor::level[parent::leg:comntry]][not(@leveltype=('para0', 'subpara0' , 'comm.intro' , 'group'))]/bodytext">
      <xsl:apply-templates select="@* | node() except refpt"/>
   </xsl:template>

   <xsl:template match="level[parent::leg:comntry][not(@leveltype=('para0', 'subpara0' , 'comm.intro' , 'group'))]">
      <annot:annotation>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt | heading/descendant::refpt | bodytext/refpt"/>
         <xsl:apply-templates select="node() except refpt"/>
      </annot:annotation>
   </xsl:template>
   <!-- JL  to handle nested leg:comntry in all sorts of ridiculousness found as far as I know only in HK01.
  This is really kludgy, there is no way around kludgy with this stuff. We do simliar things for legfragments
  -->
   <xsl:template match="leg:comntry[parent::bodytext[ancestor::leg:comntry]]"
                 priority="25">
      <blockquote>
         <primlaw:level leveltype="unclassified">
            <xsl:call-template name="leg-comntry-generic"/>
         </primlaw:level>
      </blockquote>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_leg.comntry-level_LEVELTYPE_COMM.INTRO-LxAdv-annot.annotations-annot.annotation-grp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>@leveltype="comm.intro"</xd:i>
                  <xd:b>becomes</xd:b>
                  <xd:b>annot:annotation-grp</xd:b> with optional attributes and child elements converted as: <xd:ul>
                     <xd:li>
                        <xd:i>@subdoc</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@includeintoc</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>@toc-caption</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@alternatetoccaption</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/@searchtype</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>refpt</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>ref:anchor</xd:b> and must be the first child in the sequence.
                 Refer to the <xd:a href="Rosetta_refpt-LxAdv-ref.anchor.dita">refpt</xd:a>
                 section for more information.</xd:li>
                     <xd:li>
                        <xd:i>heading/edpnum</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/desig</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/title</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/title</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>bodytext</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation/bodytext</xd:b>
                     </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
            <xd:pre>
               <xd:b>
                  <xd:i>Example: Source XML 1</xd:i>
               </xd:b>                 

&lt;leg:comntry&gt;
    &lt;level id="PFI_CODES.SGM_COMM.INTRO_1" leveltype="comm.intro" toc-caption="FOREWORD" subdoc="true"&gt;
        &lt;heading searchtype="COMMENTARY"&gt;&lt;title&gt;FOREWORD&lt;/title&gt;&lt;/heading&gt;
        &lt;bodytext searchtype="COMMENTARY"&gt;
            &lt;p&gt;&lt;text&gt;As the Minister for Finance, Superannuation and.....&lt;/text&gt;&lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/level&gt;
&lt;/leg:comntry&gt;
</xd:pre>
            <xd:pre>
               <xd:b>
                  <xd:i>Example: Target XML 1</xd:i>
               </xd:b>
              

&lt;annot:annotations&gt;
		&lt;annot:annotation-grp xml:id="PFI_CODES.SGM_COMM.INTRO_1" grptype="COMMENTARY" alternatetoccaption="FOREWORD" includeintoc="true"&gt;
			&lt;heading&gt;&lt;title&gt;FOREWORD&lt;/title&gt;&lt;/heading&gt;
			&lt;annot:annotation&gt;
				&lt;bodytext&gt;
					&lt;p&gt;&lt;text&gt;As the Minister for Finance, Superannuation and.....&lt;/text&gt;&lt;/p&gt;
				&lt;/bodytext&gt;
			&lt;/annot:annotation&gt;
	 &lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;

       </xd:pre>
            <xd:pre>
              <xd:b>
                  <xd:i>Example: Source XML 2</xd:i>
               </xd:b>                 

&lt;leg:comntry&gt;
    &lt;level id="AEFP_ASX3.SGM_COMM.INTRO_8" leveltype="comm.intro" toc-caption="Appendices to ASX Operating Rules Procedures" subdoc="true"&gt;
        &lt;heading searchtype="COMMENTARY"&gt;&lt;title&gt;Appendices to ASX Operating Rules Procedures&lt;/title&gt;&lt;/heading&gt;
        &lt;level id="AEFP_ASX3.SGM_GROUP_9" leveltype="group" toc-caption="Contents" subdoc="true"&gt;
            &lt;heading searchtype="COMMENTARY"&gt;&lt;title&gt;Contents&lt;/title&gt;&lt;/heading&gt;
            &lt;bodytext searchtype="COMMENTARY"&gt;
               &lt;p&gt;&lt;table frame="none" pgwide="1"&gt;
                      &lt;tgroup cols="3" colsep="0" rowsep="0" align="left"&gt;
                        &lt;colspec colwidth="65*" colname="col1" colsep="0" rowsep="0"/&gt;
                        &lt;colspec colwidth="205*" colname="col2" colsep="0" rowsep="0"/&gt;
                        &lt;colspec colwidth="30*" colname="col3" align="right" colsep="0" rowsep="0"/&gt;
                        &lt;tbody valign="top"&gt;
                            &lt;row rowsep="0"&gt;
                                &lt;entry morerows="0" colsep="0" rowsep="0"&gt;SECTION 1&lt;/entry&gt;
                                ....
                            &lt;/row&gt;
                        &lt;/tbody&gt;
                    &lt;/tgroup&gt;
                &lt;/table&gt;&lt;/p&gt;
            &lt;/bodytext&gt;
        &lt;/level&gt;
    &lt;/level&gt;
&lt;/leg:comntry&gt;
</xd:pre>
            <xd:pre>
              <xd:b>
                  <xd:i>Example: Target XML 2</xd:i>
               </xd:b>
              
&lt;annot:annotations&gt;
	&lt;annot:annotation-grp xml:id="AEFP_ASX3.SGM_COMM.INTRO_8" grptype="COMMENTARY" alternatetoccaption="Appendices to ASX Operating Rules Procedures" includeintoc="true"&gt;
		&lt;heading&gt;&lt;title&gt;Appendices to ASX Operating Rules Procedures&lt;/title&gt;&lt;/heading&gt;
		&lt;annot:annotation-grp xml:id="AEFP_ASX3.SGM_GROUP_9" grptype="COMMENTARY" alternatetoccaption="Contents" includeintoc="true"&gt;
		  &lt;heading&gt;&lt;title&gt;Contents&lt;/title&gt;&lt;/heading&gt;
		  &lt;annot:annotation&gt;
			  &lt;bodytext&gt;
				  &lt;p&gt;&lt;table frame="none" pgwide="1"&gt;
                        &lt;tgroup cols="3" colsep="0" rowsep="0" align="left"&gt;
                        &lt;colspec colwidth="65*" colname="col1" colsep="0" rowsep="0"/&gt;
                        &lt;colspec colwidth="205*" colname="col2" colsep="0" rowsep="0"/&gt;
                        &lt;colspec colwidth="30*" colname="col3" align="right" colsep="0" rowsep="0"/&gt;
                        &lt;tbody valign="top"&gt;
                              &lt;row rowsep="0"&gt;
                                  &lt;entry morerows="0" colsep="0" rowsep="0"&gt;SECTION 1&lt;/entry&gt;
                                  ....
                              &lt;/row&gt;
                        &lt;/tbody&gt;
                    &lt;/tgroup&gt;
                &lt;/table&gt;&lt;/p&gt;
			     &lt;/bodytext&gt;
		     &lt;/annot:annotation&gt;
	    &lt;/annot:annotation-grp&gt;
	&lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;
       </xd:pre>
            <xd:p>
               <xd:b>Note: </xd:b>For the scenario, <xd:i>leg:comntry/level/glp:note</xd:i> add a
         attribute value <xd:b>@notetype="xref"</xd:b> to note in order to
         distinguish from other notes.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>Refer common markup for handling of <xd:a href="Rosetta_glp.note-Chof-leg.comntry_level-LxAdv-annot.annotation_bodytext_note.dita">glp:note</xd:a>.</xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>For handling of <xd:i>glp:note/blockquote/hrule</xd:i> omit
         <xd:i>hrule</xd:i> and presentation stylesheet will handle
         formatting.</xd:p>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.comntry-level_LEVELTYPE_COMM.INTRO-LxAdv-annot.annotations-annot.annotation-grp.dita  -->
   <!-- ****************************************************************************************************
	This file is so completely identical except in attribute value of the matching "level" element, that 
	the functionality has been moved to 
	/XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_leg.comntry-level_LEVELTYPE_GROUP-LxAdv-annot.annotations-annot.annotation-grp.xsl
	THIS MODULE IS INACTIVE.
	- JL
	****************************************************************************************************
	-->
   <!-- <topicref href="../../common_newest/Rosetta_leg.comntry-level_LEVELTYPE_GROUP-LxAdv-annot.annotations-annot.annotation-grp.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>@leveltype="group"</xd:i>
                  <xd:b>becomes</xd:b>
                  <xd:b>annot:annotation-grp</xd:b> with optional attributes and  child
            elements converted as: <xd:ul>
                     <xd:li>
                        <xd:i>@subdoc</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@includeintoc</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>@toc-caption</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@alternatetoccaption</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/@searchtype</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>refpt</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>ref:anchor</xd:b> and must be the first child in the sequence.
                Refer to the <xd:a href="Rosetta_refpt-LxAdv-ref.anchor.dita">refpt</xd:a>
                section for more information.</xd:li>
                     <xd:li>
                        <xd:i>heading/edpnum</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/desig</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/title</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/title</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>bodytext</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation/bodytext</xd:b>
                     </xd:li>
                  </xd:ul>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Source XML</xd:i>
                     </xd:b>                 

&lt;leg:comntry toc-caption="Reader's Guide" subdoc="true"&gt;
      &lt;heading searchtype="COMMENTARY"&gt;
          &lt;title&gt;
            &lt;refpt type="ext" id="CLSA.VOFF.ARRS.RGUIDE"/&gt;
            Reader's Guide
          &lt;/title&gt;
      &lt;/heading&gt;
      &lt;level 
        id="CLSA_VOFF.SGM_GROUP_2" 
        leveltype="group" 
        toc-caption="Aim of the Guide" 
        subdoc="true"&gt;
          &lt;heading searchtype="COMMENTARY"&gt;
              &lt;title&gt;
                &lt;refpt type="ext" id="CLSA.VOFF.29035-1"/&gt;
                Aim of the Guide
              &lt;/title&gt;
          &lt;/heading&gt;
          &lt;bodytext searchtype="COMMENTARY"&gt;
              &lt;p&gt;
                  &lt;text&gt;
                      The aim of this Guide...
                  &lt;/text&gt;
              &lt;/p&gt;
          &lt;/bodytext&gt;
      &lt;/level&gt;
  &lt;/leg:comntry&gt;
</xd:pre>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Target XML</xd:i>
                     </xd:b>

&lt;annot:annotations&gt;
    &lt;annot:annotation-grp 
      grptype="COMMENTARY" 
      alternatetoccaption="Reader's Guide" 
      includeintoc="true"&gt;
        &lt;ref:anchor 
          id="CLSA.VOFF.ARRS.RGUIDE" 
          anchortype="global"/&gt;
        &lt;heading&gt;
          &lt;title&gt;Reader's Guide&lt;/title&gt;
        &lt;/heading&gt;
          &lt;annot:annotation-grp 
            xml:id="CLSA_VOFF.SGM_GROUP_2" 
            grptype="COMMENTARY" 
            alternatetoccaption="Aim of the Guide" 
            includeintoc="true"&gt;
                &lt;ref:anchor 
                  id="CLSA.VOFF.29035-1" 
                  anchortype="global"/&gt;
                &lt;heading&gt;
                  &lt;title&gt;Aim of the Guide&lt;/title&gt;
                &lt;/heading&gt;
            &lt;annot:annotation&gt;
              &lt;bodytext&gt;
                &lt;p&gt;
                  &lt;text&gt;
                    The aim of this Guide ...
                  &lt;/text&gt;
                &lt;/p&gt;
              &lt;/bodytext&gt;
            &lt;/annot:annotation&gt;
         &lt;/annot:annotation-grp&gt;
    &lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;

</xd:pre>
                  <xd:p>
                     <xd:b>Note: </xd:b>For the scenario, <xd:i>leg:comntry/level/glp:note</xd:i> add a
              attribute value <xd:b>@notetype="xref"</xd:b> to note in order to
              distinguish from other notes.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>If <xd:i>glp:note</xd:i> occurs before <xd:i>heading</xd:i> then move the <xd:i>note</xd:i> inside <xd:b>bodytext</xd:b> after <xd:b>heading</xd:b>.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>Refer common markup for handling of <xd:a href="Rosetta_glp.note-LxAdv-note.dita">glp:note</xd:a>.</xd:p>
                  <xd:p>
                     <xd:b>Note: </xd:b>For handling of <xd:i>glp:note/blockquote/hrule</xd:i> omit
              <xd:i>hrule</xd:i> and presentation stylesheet will handle
              formatting.</xd:p>
               </xd:li>
            </xd:ul>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.comntry-level_LEVELTYPE_GROUP-LxAdv-annot.annotations-annot.annotation-grp.dita  -->
   <!-- this is entirely identical to the comm.intro module and therefore the comm.intro module is handled here -->
   <xsl:template match="level[ancestor::leg:comntry][@leveltype=('group' , 'comm.intro')]"><!--  Original Target XPath:  annot:annotations/annot:annotation-grp/annot:annotation-grp   -->
      <annot:annotation-grp>
         <xsl:if test="heading[@searchtype='COMMENTARY'] or heading[contains(title, '[Commentary]')]">
            <xsl:attribute name="grptype" select="'COMMENTARY'"/>
         </xsl:if>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt | heading//refpt | bodytext/refpt"/>
         <!-- JD: 2017-08-08: added NZ06 here and to exclusion list below in order to match DT output (output header within <annot:annotation-grp> per instruction in DITA above, rather than within <annot:annotation>). -->
         <xsl:apply-templates select="heading[$streamID=('AU08','AU04','NZ06' , 'NZ12', 'AU18')]"/>
         <!-- paul: see AU08 PS2017050300592679148LNIAUCOURTRULES_input_crimproc10061174.xml where heading is in group not in annotation  -->
         <xsl:if test="*[not(self::levelinfo[source_docinfo:currencystatement] or self::level or self::refpt or self::glp:note or self::heading[$streamID=('AU04', 'AU08' , 'NZ12', 'AU18')])]">
            <annot:annotation>
               <xsl:choose>
                  <xsl:when test="heading[preceding-sibling::glp:note]">
                     <xsl:apply-templates select="node() except (refpt | glp:note | heading[$streamID=('AU08', 'AU04','NZ06' , 'NZ12')])"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:apply-templates select="node() except (level |refpt | heading[$streamID=('AU08', 'AU04','NZ06' , 'NZ12', 'AU18')])"/>
                  </xsl:otherwise>
               </xsl:choose>
            </annot:annotation>
         </xsl:if>
         <xsl:apply-templates select="level"/>
      </annot:annotation-grp>
   </xsl:template>
   <!-- note: we need to do something about refpt moving holistically. Where are the target, valid places? -->   <!-- suppress the output of leg:comntry descendant level/@leveltype or else it gets copied. This should cover all leveltypes -->
   <xsl:template match="level[ancestor::leg:comntry]/@leveltype"/>
   <!-- JL I guess the instructions means this? 
  JL 20171012 removed because it is ambiguous with same-output template for leg:comntry-->   <!--<xsl:template match="level[ancestor::leg:comntry]/glp:note/blockquote/hrule"/>-->   <!-- <topicref href="../../common_newest/Rosetta_leg.comntry-level_LEVELTYPE_PARA0-LxAdv-annot.annotations-annot.annotation-grp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>@leveltype="para0"</xd:i>
                  <xd:b>becomes</xd:b>
                  <xd:b>annot:annotation</xd:b> with optional attributes and  child elements
            converted as: <xd:ul>
                     <xd:li>
                        <xd:i>@subdoc</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@includeintoc</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>@toc-caption</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@alternatetoccaption</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/@searchtype</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>refpt</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>ref:anchor</xd:b> and must be the first child in the sequence.
                Refer to the <xd:a href="Rosetta_refpt-LxAdv-ref.anchor.dita">refpt</xd:a>
                section for more information.</xd:li>
                     <xd:li>
                        <xd:i>heading/edpnum</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/desig</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/title</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/title</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>bodytext</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>bodytext</xd:b>
                     </xd:li>
                  </xd:ul>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Source XML</xd:i>
                     </xd:b>                 

&lt;leg:comntry subdoc="true" toc-caption="COMMENTARY ON REGULATION 12"&gt;
	&lt;heading searchtype="COMMENTARY"&gt;
		&lt;title&gt;&lt;refpt id="CLWA.SL.SARW03.REG12.COM1" type="ext"/&gt;COMMENTARY ON REGULATION 12&lt;/title&gt;
	&lt;/heading&gt;
	&lt;level id="CLWA_SL.SGM_CLWA.SL.SARR12-1" leveltype="para0" subdoc="true" toc-caption="[SAR r 12.1] Cross references"&gt;
		&lt;heading searchtype="COMMENTARY"&gt;
			&lt;edpnum&gt;&lt;refpt id="CLWA.SL.SARR12-1" type="ext"/&gt;[SAR r 12.1] &lt;/edpnum&gt;
			&lt;title&gt;Cross references&lt;/title&gt;
		&lt;/heading&gt;
		&lt;bodytext searchtype="COMMENTARY"&gt;
			&lt;p&gt;&lt;text&gt;See Halsbury's Laws of Australia Criminal Law [335&amp;#x2013;40] for details on the
			powers and duties of prison officers, including the search of prisoners, in other jurisdictions.&lt;/text&gt;&lt;/p&gt;
		&lt;/bodytext&gt;
	&lt;/level&gt;
&lt;/leg:comntry&gt;
</xd:pre>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Target XML</xd:i>
                     </xd:b>
              

&lt;annot:annotations&gt;
	&lt;annot:annotation-grp grptype="COMMENTARY" includeintoc="true" alternatetoccaption="COMMENTARY ON REGULATION 12"&gt;
		&lt;ref:anchor id="CLWA.SL.SARW03.REG12.COM1" anchortype="global"/&gt;
		&lt;heading&gt;&lt;title&gt;COMMENTARY ON REGULATION 12&lt;/title&gt;&lt;/heading&gt;
		&lt;annot:annotation xml:id="CLWA_SL.SGM_CLWA.SL.SARR12-1" alternatetoccaption="[SAR r 12.1] Cross references"
         includeintoc="true"&gt;
			&lt;ref:anchor id="CLWA.SL.SARR12-1" anchortype="global"/&gt;
			&lt;heading&gt;
				&lt;desig&gt;[SAR r 12.1]&lt;/desig&gt;
				&lt;title&gt;Cross references&lt;/title&gt;
			&lt;/heading&gt;
			&lt;bodytext&gt;
				&lt;p&gt;&lt;text&gt;See Halsbury's Laws of Australia Criminal Law [335&amp;#x2013;40] for details
				on the powers and duties of prison officers, including the search of prisoners, in 
				other jurisdictions.&lt;/text&gt;&lt;/p&gt;
			&lt;/bodytext&gt;
		&lt;/annot:annotation&gt;
	&lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;

 </xd:pre>
               </xd:li>
            </xd:ul>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.comntry-level_LEVELTYPE_PARA0-LxAdv-annot.annotations-annot.annotation-grp.dita  -->
   <xsl:template match="level[ancestor::leg:comntry][@leveltype='para0']">
      <annot:annotation>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt | heading/descendant::refpt | bodytext/refpt"/>
         <xsl:if test="$streamID='AU07' and child::*[1][self::glp:note]">
            <xsl:apply-templates select="glp:note"/>
         </xsl:if>
         <xsl:apply-templates select="heading"/>
         <xsl:choose>
            <xsl:when test="bodytext">
               <xsl:apply-templates select="node() except (refpt | heading | glp:note)"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:if test="not($streamID='AU07' and child::*[1][self::glp:note])">
                  <bodytext>
                     <xsl:apply-templates select="glp:note"/>
                  </bodytext>
               </xsl:if>
               <xsl:apply-templates select="node() except (refpt | heading | glp:note)"/>
            </xsl:otherwise>
         </xsl:choose>
      </annot:annotation>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_leg.comntry-level_LEVELTYPE_SUBPARA0-LxAdv-annot.annotations-annot.annotation-grp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>@leveltype="subpara0"</xd:i>
                  <xd:b>becomes</xd:b>
                  <xd:b>annot:annotationlevel</xd:b> with optional attributes and child elements converted as: <xd:ul>
                     <xd:li>
                        <xd:i>@subdoc</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@includeintoc</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>@toc-caption</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>@alternatetoccaption</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/@searchtype</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>annot:annotation-grp/@grptype="COMMENTARY"</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>refpt</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>ref:anchor</xd:b> and must be the first child in the sequence.
                Refer to the <xd:a href="Rosetta_refpt-LxAdv-ref.anchor.dita">refpt</xd:a>
                section for more information.</xd:li>
                     <xd:li>
                        <xd:i>heading/edpnum</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/desig</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>heading/title</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>heading/title</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:i>bodytext</xd:i>
                        <xd:b>becomes</xd:b>
                        <xd:b>bodytext</xd:b>
                     </xd:li>
                  </xd:ul>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Source XML</xd:i>
                     </xd:b>                 

&lt;leg:comntry subdoc="true" toc-caption="Commentary"&gt;
	&lt;level id="ACLL_CCPA.SGM_GROUP_2" leveltype="para0" toc-caption="Outline" subdoc="true"&gt;
		&lt;heading searchtype="COMMENTARY"&gt;&lt;title&gt;Outline&lt;/title&gt;&lt;/heading&gt;
		&lt;bodytext searchtype="COMMENTARY"&gt;
			&lt;p&gt;&lt;text&gt;The Corporations (Commonwealth Powers) Acts 2001 [State] are Acts which....&lt;/text&gt;&lt;/p&gt;
		&lt;/bodytext&gt;
		&lt;level id="ACLL_CCPA.SGM_GROUP_3" leveltype="subpara0" toc-caption="Provisions" subdoc="true"&gt;
			&lt;heading searchtype="COMMENTARY"&gt;&lt;title&gt;Provisions&lt;/title&gt;&lt;/heading&gt;
			&lt;bodytext searchtype="COMMENTARY"&gt;
				&lt;p&gt;&lt;text&gt;This Act enacts ancillary provisions, including transitional provisions...&lt;/text&gt;&lt;/p&gt;
			&lt;/bodytext&gt;
		&lt;/level&gt;
	&lt;/level&gt;
&lt;/leg:comntry&gt;
</xd:pre>
                  <xd:pre>
                     <xd:b>
                        <xd:i>Example: Target XML</xd:i>
                     </xd:b>
              

&lt;annot:annotations&gt;
	&lt;annot:annotation-grp alternatetoccaption="Commentary" includeintoc="true"&gt;
		&lt;annot:annotation xml:id="ACLL_CCPA.SGM_GROUP_2" alternatetoccaption="Outline" includeintoc="true"&gt;
			&lt;heading&gt;&lt;title&gt;Outline&lt;/title&gt;&lt;/heading&gt;
			&lt;bodytext&gt;
				&lt;p&gt;&lt;text&gt;The Corporations (Commonwealth Powers) Acts 2001 [State] are Acts which....&lt;/text&gt;&lt;/p&gt;
			&lt;/bodytext&gt;
			&lt;annot:annotationlevel xml:id="ACLL_CCPA.SGM_GROUP_3" alternatetoccaption="Provisions" includeintoc="true"&gt;
				&lt;heading&gt;&lt;title&gt;Provisions&lt;/title&gt;&lt;/heading&gt;
				&lt;annot:bodytext&gt;
					&lt;p&gt;&lt;text&gt;This Act enacts ancillary provisions, including transitional provisions...&lt;/text&gt;&lt;/p&gt;
				&lt;/annot:bodytext&gt;
			&lt;/annot:annotationlevel&gt;
		&lt;/annot:annotation&gt;
	&lt;/annot:annotation-grp&gt;
&lt;/annot:annotations&gt;

                </xd:pre>
               </xd:li>
            </xd:ul>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.comntry-level_LEVELTYPE_SUBPARA0-LxAdv-annot.annotations-annot.annotation-grp.dita  -->
   <xsl:template match="level[@leveltype='subpara0'][ancestor::leg:comntry]">
      <annot:annotationlevel>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="refpt | heading/descendant::refpt | bodytext/refpt"/>
         <xsl:apply-templates select="heading"/>
         <xsl:if test="child::*[not(self::refpt or self::heading)]">
            <annot:bodytext>
               <xsl:apply-templates select="node() except (heading | refpt)"/>
            </annot:bodytext>
         </xsl:if>
         <!-- JL: annot:bodytext is requires so do this if there is no content at all. -->
         <xsl:if test="not(child::*[not(self::refpt or self::heading)])">
            <annot:bodytext>
               <p/>
            </annot:bodytext>
         </xsl:if>
      </annot:annotationlevel>
      <!--<annot:annotationlevel>
			<xsl:apply-templates select="@*"/>
			<xsl:apply-templates select="refpt | heading/descendant::refpt | bodytext/refpt"/>
			<xsl:apply-templates select="node() except (refpt | level)"/>
		  <xsl:if test="not(bodytext) and level">
		    <annot:bodytext>
		      <xsl:apply-templates select="node() except (heading)"/>
		    </annot:bodytext>
		  </xsl:if>
		</annot:annotationlevel>-->
   </xsl:template>

   <xsl:template match="level[@leveltype='subpara0'][ancestor::leg:comntry]/bodytext">
      <xsl:apply-templates select="@* | node() except refpt"/>
   </xsl:template>
   <!-- end topichead  leg-comntry  -->   <!-- start topichead  legfragment  -->   <!-- <topicref href="../../common_newest/Rosetta_blockquote-legfragment-leg.level-LxAdv-primlaw.excerpt-primlaw.level.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>legfragment</xd:i> becomes <xd:b>primlaw:excerpt</xd:b>.
       <xd:b>blockquote/legfragment/leg:level</xd:b>: When legfragment is the first child of
       blockquote, drop the blockquote and convert the legfragment to primlaw:excerpt. If the
       Xpath is blockquote/legfragment/leg:level, then drop the blockquote and convert to
       primlaw:excerpt/primlaw:level. <xd:pre>

&lt;leg:level id="NSW_ACT_2009-100_SCH1AMCL12"&gt;&lt;leg:level-vrnt leveltype="clause" searchtype="LEGISLATION" subdoc="true" toc-caption="[12] Section 97CB Annual greenhouse gas benchmark statements"&gt;....
&lt;leg:levelbody&gt;
&lt;leg:bodytext&gt;
&lt;p&gt;
&lt;text&gt;Omit section 97CB (1). Insert instead:&lt;/text&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;legfragment&gt;
&lt;leg:level&gt;
&lt;leg:level-vrnt leveltype="subclause"&gt;
&lt;leg:heading
inline="true"&gt;
&lt;desig&gt;&lt;designum&gt;(1)&lt;/designum&gt;&lt;/desig&gt;
&lt;/leg:heading&gt;
&lt;leg:levelbody&gt;
&lt;leg:bodytext&gt;
&lt;p&gt;
&lt;text&gt;A benchmark participant must lodge with the Tribunal a greenhouse gas benchmark statement:&lt;/text&gt;
&lt;l type="def"&gt;
&lt;li&gt;&lt;lilabel&gt;(a)&lt;/lilabel&gt;
&lt;p&gt;
&lt;text&gt;in respect of a compliance period (other than the final compliance period), not later than 1 March in the year immediately
following the end of that compliance period, or&lt;/text&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;lilabel&gt;(b)&lt;/lilabel&gt;
&lt;p&gt;
&lt;text&gt;in respect of the final compliance period, not later than 3 months after the termination day.&lt;/text&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/l&gt;

        </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre>      

&lt;primlaw:level xml:id="NSW_ACT_2009-100_SCH1AMCL12" leveltype="clause" subdoc="true" toc-caption="[12] Section 97CB Annual
 greenhouse gas benchmark statements"&gt;.....
 &lt;primlaw:bodytext&gt;
 &lt;p&gt;
 &lt;text&gt;Omit section 97CB (1). Insert instead:&lt;/text&gt;
  &lt;/p&gt;
  &lt;primlaw:excerpt&gt;
  &lt;primlaw:level leveltype="subclause"&gt;
  &lt;heading inline="true"&gt;&lt;desig&gt;(1)&lt;/desig&gt;&lt;/heading&gt;&lt;primlaw:bodytext&gt;
  &lt;p&gt;
  &lt;text&gt;A benchmark participant must lodge with the Tribunal a greenhouse gas benchmark statement:&lt;/text&gt;
  &lt;list&gt;
    &lt;listitem&gt;
      &lt;label&gt;(a)&lt;/label&gt;
      &lt;bodytext&gt;
      &lt;p&gt;
      &lt;text&gt;in respect of a compliance period (other than the final compliance period), not later than 1 March in the
      year immediately following the end of that compliance period, or
      &lt;/text&gt;
      &lt;/p&gt;
      &lt;/bodytext&gt;
    &lt;/listitem&gt;
   &lt;listitem&gt;
      &lt;label&gt;(b)&lt;/label&gt;
      &lt;bodytext&gt;
      &lt;p&gt;
      &lt;text&gt;in respect of the final compliance period, not later than 3 months after the termination
        day.
      &lt;/text&gt;
      &lt;/p&gt;
      &lt;/bodytext&gt;
    &lt;/listitem&gt; 
  &lt;/list&gt;

        </xd:pre>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_blockquote-legfragment-leg.level-LxAdv-primlaw.excerpt-primlaw.level.dita  -->
   <!-- JL separated out the templates because I need to convert legfragment without leg:level in it for other modules 
	 blockquote passthrough is effected in the blockquote module 
	 -->
   <xsl:template match="legfragment//leg:level" priority="25"><!--  Original Target XPath:  primlaw:excerpt/primlaw:level   -->
      <primlaw:level>
         <xsl:if test="not(leg:level-vrnt/@leveltype)">
            <xsl:attribute name="leveltype">unclassified</xsl:attribute>
         </xsl:if>
         <xsl:apply-templates select="leg:level-vrnt/@*"/>
         <!-- 2017-09-25 - MDS removed 'leg:level-vrnt/leg:heading/desig/designum/refpt' from A-T to stop duplication due to handling of leg:level-vrnt in 
			  /modules/leg/leg.level-LxAdv-primlaw.level.xsl-->
         <xsl:apply-templates select="leg:heading/desig/designum/refpt"/>
         <xsl:apply-templates select="@* | node()"/>
      </primlaw:level>
   </xsl:template>
   <!-- I assume we want to output excerpt level children without running them through bodytext first  JL -->
   <xsl:template match="legfragment"><!--  Original Target XPath:  primlaw:excerpt   -->
      <primlaw:excerpt>
         <xsl:apply-templates select="@*"/>
         <xsl:for-each-group select="*" group-adjacent="if (self::leg:level) then 0 else 1">
            <xsl:choose>
               <xsl:when test="current-grouping-key()=0">
                  <xsl:apply-templates select="current-group()"/>
               </xsl:when>
               <xsl:otherwise>
                  <primlaw:bodytext>
                     <xsl:apply-templates select="current-group()"/>
                  </primlaw:bodytext>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each-group>
      </primlaw:excerpt>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_blockquote-legfragment-p-LxAdv-primlaw.excerpt-primlaw.bodytext-p.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>blockquote/legfragment/p</xd:b>: If the first child of <xd:i>legfragment</xd:i>
          is a paragraph, list, or table, then omit <xd:i>blockquote</xd:i> and convert
            <xd:i>legfragment</xd:i> to
            <xd:b>primlaw:excerpt/primlaw:bodytext</xd:b>. <xd:p>
               <xd:b>Note: </xd:b>In all cases,
              <xd:b>primlaw:excerpt</xd:b> comes as a sibling of <xd:b>p</xd:b>
            under bodytext because <xd:b>p</xd:b> doesn't allow
              <xd:b>primlaw:excerpt</xd:b>.</xd:p>
         </xd:p>
         <xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>For more information regarding <xd:i>legfragment</xd:i> within
              <xd:i>blockquote</xd:i>, please see the instructions for <xd:a href="Rosetta_blockquote-LxAdv-blockquote.dita">blockquote</xd:a>.</xd:p>
            <xd:pre> &lt;footnote fntoken="ABCE.LEG.EAN95.S47.FTN1"
            fnrtokens="ABCE.LEG.EAN95.S47.FTN1-R" type="default"&gt;
            &lt;fnlabel&gt;*&lt;/fnlabel&gt; &lt;fnbody&gt; &lt;h&gt;Commonwealth
            variations&lt;/h&gt; &lt;p&gt;&lt;refpt type="ext" id="ABCE.LEG.EAN95.S47.FTN1"/&gt;
            &lt;text&gt;Section 47 of the Commonwealth Act concludes:&lt;/text&gt;
            &lt;blockquote&gt; &lt;legfragment&gt; &lt;p&gt; &lt;text&gt;&amp;ldquo;Note: Section
            182 gives this section a wider application in relation to Commonwealth records and
            certain Commonwealth documents.&amp;rdquo;&lt;/text&gt;&lt;/p&gt; &lt;/legfragment&gt;
            &lt;/blockquote&gt; &lt;/p&gt; &lt;/fnbody&gt; &lt;/footnote&gt; </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre> &lt;footnote&gt; &lt;ref:anchor id="ABCE.LEG.EAN95.S47.FTN1"
            anchortype="global"/&gt; &lt;label&gt;*&lt;/label&gt; &lt;bodytext&gt;
            &lt;h&gt;Commonwealth variations&lt;/h&gt; &lt;p&gt; &lt;ref:anchor
            id="ABCE.LEG.EAN95.S47.FTN1" anchortype="global"/&gt; &lt;text&gt;Section 47 of the
            Commonwealth Act concludes:&lt;/text&gt; &lt;/p&gt; &lt;primlaw:excerpt&gt;
            &lt;primlaw:bodytext&gt; &lt;p&gt; &lt;text&gt;&amp;#x201C;Note: Section 182 gives this
            section a wider application in relation to Commonwealth records and certain Commonwealth
            documents.&amp;#x201D;&lt;/text&gt; &lt;/p&gt; &lt;/primlaw:bodytext&gt;
            &lt;/primlaw:excerpt&gt; &lt;/bodytext&gt; ... &lt;/footnote&gt; </xd:pre>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_blockquote-legfragment-p-LxAdv-primlaw.excerpt-primlaw.bodytext-p.dita  -->
   <xsl:template match="legfragment[child::*[1][self::p or self::l or self::table or self::leg:level or self::deflist]]"
                 priority="30">
      <xsl:choose>
         <xsl:when test="$streamID = 'NZ03'">
            <blockquote>
               <xsl:apply-templates select="@* | node()"/>
            </blockquote>
         </xsl:when>
         <xsl:otherwise><!-- JD: 2017-07-25: Original contents here: 	
	    	 	<primlaw:bodytext>
	          <xsl:apply-templates/>
	        </primlaw:bodytext>
	        but this had the side effect of wrapping all content in primlaw:bodytext; adding logic to output sibling <primlaw:level> when required.
	    	
        JL 20171027: changed for-each-group select="node()" to select="*" because it was picking up on whitespace nodes 
        to output empty bodytext elements and legfragment has no PCDATA children in the dtd.
        -->
            <primlaw:excerpt>
               <xsl:for-each-group select="*" group-adjacent="boolean(self::*:level)">
                  <xsl:choose><!-- when current element is *:level (e.g., leg:level) A-T to produce primlaw:level -->
                     <xsl:when test="current-grouping-key()">
                        <xsl:apply-templates select="current-group()"/>
                     </xsl:when>
                     <!-- otherwise create a <primlaw:bodytext> wrapper and process children -->
                     <xsl:otherwise>
                        <primlaw:bodytext>
                           <xsl:apply-templates select="current-group()"/>
                        </primlaw:bodytext>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:for-each-group>
            </primlaw:excerpt>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_legfragment-glp.note-LxAdv-primlaw.excerpt-primlaw.bodytext-note.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>legfragment/glp:note:</xd:b> Handling of glp:note when it occurs within
        legfragment:
      <xd:pre>
             &lt;blockquote&gt;
            &lt;legfragment&gt;
             &lt;glp:note&gt;
              &lt;p&gt;
               &lt;text&gt;
                &lt;emph typestyle="it"&gt;for this provision.&lt;/emph&gt;
                &lt;/text&gt;
              &lt;/p&gt;
          &lt;/glp:note&gt;
     &lt;/legfragment&gt;
&lt;/blockquote&gt;

 </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre>
        &lt;primlaw:excerpt&gt;
          &lt;primlaw:bodytext&gt;   
          &lt;note&gt;                          
          &lt;bodytext&gt;
          &lt;p&gt;
          &lt;text&gt;
          &lt;emph typestyle="it"&gt;for this&lt;/emph&gt;
          &lt;/text&gt;
          &lt;/p&gt;
          &lt;/bodytext&gt;
          &lt;/note&gt;
          &lt;/primlaw:bodytext&gt;
          &lt;/primlaw:excerpt&gt;
    
      </xd:pre>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_legfragment-glp.note-LxAdv-primlaw.excerpt-primlaw.bodytext-note.dita  -->
   <xsl:template match="legfragment/glp:note"><!--  Original Target XPath:  primlaw:excerpt/primlaw:bodytext/note   -->
      <primlaw:excerpt>
         <primlaw:bodytext>
            <note>
               <xsl:apply-templates select="@*"/>
               <xsl:apply-templates select="heading"/>
               <bodytext>
                  <xsl:apply-templates select="node() except(heading)"/>
               </bodytext>
            </note>
         </primlaw:bodytext>
      </primlaw:excerpt>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_p-blockquote-legfragment-LxAdv-primlaw.excerpt-primlaw.bodytext.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>p/blockquote/legfragment:</xd:b> Handling of p/blockquote/legfragment:
      <xd:pre>
       &lt;p&gt;
       &lt;text&gt;The meaning of sexual penetration for the purposes of subdivisions (8A) to (8G) of Div1 of Pt1 of the Crimes Act 1958 is defined in s 35(1) of the Crimes Act in the following terms:&lt;/text&gt;
   &lt;blockquote&gt;
      &lt;legfragment&gt;
        &lt;deflist&gt;
          &lt;defitem&gt;
            &lt;defterm&gt;
                 &lt;emph typestyle="bf"&gt;sexual penetration&lt;/emph&gt;
            &lt;/defterm&gt;
            &lt;defdesc&gt;
          &lt;p&gt;
          &lt;text&gt;means&lt;/text&gt;
          &lt;/p&gt;
          ...
          &lt;/defdesc&gt;
          &lt;/defitem&gt;
        &lt;/deflist&gt;
      &lt;/legfragment&gt;
   &lt;/blockquote&gt;
&lt;/p&gt;
 
      </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre>
       &lt;p&gt;
       &lt;text&gt;The meaning of sexual penetration for the purposes of subdivisions (8A) to (8G) of Div1 of Pt1 of the Crimes Act 1958 is defined in s 35(1) of the Crimes Act in the following terms:&lt;/text&gt;&lt;/p&gt;
       &lt;primlaw:excerpt&gt;
      &lt;primlaw:bodytext&gt;
        &lt;deflist&gt;
          &lt;defitem&gt;
            &lt;defterm&gt;
                 &lt;emph typestyle="bf"&gt;sexual penetration&lt;/emph&gt;
            &lt;/defterm&gt;
           &lt;defdesc&gt;
          &lt;bodytext&gt;
          &lt;p&gt;
          &lt;text&gt;means&lt;/text&gt;
          &lt;/p&gt;
          ...
          &lt;/bodytext&gt;
          &lt;/defdesc&gt;
          &lt;/defitem&gt;
        &lt;/deflist&gt;
        &lt;/primlaw:bodytext&gt;
      &lt;/primlaw:excerpt&gt;
  
 
</xd:pre>
         </xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-blockquote-legfragment-LxAdv-primlaw.excerpt-primlaw.bodytext.dita  -->
   <!-- JL: passthru for blockquote/legfragment is in blockquote template.  Here we just need to insert the wrappers -->
   <xsl:template match="p/blockquote/legfragment">
      <primlaw:excerpt>
         <xsl:apply-templates select="@*"/>
         <xsl:for-each-group select="*" group-adjacent="if (self::leg:level) then 0 else 1">
            <xsl:choose>
               <xsl:when test="current-grouping-key()=0">
                  <xsl:apply-templates select="current-group()"/>
               </xsl:when>
               <xsl:otherwise>
                  <primlaw:bodytext>
                     <xsl:apply-templates select="current-group()"/>
                  </primlaw:bodytext>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each-group>
      </primlaw:excerpt>
   </xsl:template>
   <!--<topicref
				href="../../common_newest/Rosetta_AU-Legislation_Courtrule_p-blockquote-p-blockquote-legfragment-leg.level-LxAdv-p_blockquote_p_blockquote_primlaw.excerpt-primlaw.level.dita"/>-->   <!--BRT file below was deleted -->   <!--topicref
        href="../../common_newest/Rosetta_AU-Caselaw_p-blockquote-p-blockquote-legfragment-l-LxAdv-p_blockquote_p_blockquote_list.dita"/-->   <!--<topicref
      href="../../common_newest/Rosetta_AU-Regulatory_Material_li-blockquote-legfragment-l-LxAdv-listitem-bodytext-blockquote-list.dita"/>-->   <!-- <topicref href="../../common_newest/Rosetta_AU-Caselaw_p-blockquote-p-blockquote-legfragment-leg.level-LxAdv-p_blockquote_p_blockquote_primlaw.excerpt_primlaw.level.dita"/> -->   <!-- Awantika: Not in GDS -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include
		href="../../modules/leg/Rosetta_AU-Caselaw_p-blockquote-p-blockquote-legfragment-leg.level-LxAdv-p_blockquote_p_blockquote_primlaw.excerpt_primlaw.level.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_AU-Caselaw_legfragment-leg.level-leg.level-vrnt_leg.heading_legempleg_LxAdv-primlaw.excerpt_primlaw.level_primlaw.authority_primlaw.authority-item_bodytext_textitem.dita"/> -\->
	<xsl:include
		href="../../modules/leg/Rosetta_AU-Caselaw_legfragment-leg.level-leg.level-vrnt_leg.heading_legempleg_LxAdv-primlaw.excerpt_primlaw.level_primlaw.authority_primlaw.authority-item_bodytext_textitem.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- end topichead  legfragment  -->   <!-- start topichead  link  -->   <!-- <topicref href="../../common_newest/Rosetta_link-LxAdv-ref.lnlink.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>link</xd:i> becomes <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> and children can be converted as follows: 
                <xd:ul>
               <xd:li>The attribute <xd:i>link/@status</xd:i> is always suppressed, it is never output to the target document.</xd:li>
               <xd:li>
                  <xd:i>link</xd:i> content becomes <xd:b>ref:marker</xd:b>. </xd:li>
               <xd:li>Create <xd:b>ref:locator</xd:b> and describe as: 
                        <xd:ul>
                     <xd:li>Create <xd:b>ref:locator-key</xd:b> and describe as: 
                                <xd:ul>
                           <xd:li>Create <xd:b>ref:key-name</xd:b> with <xd:b>@name="attachment-key"</xd:b>. 
                                        This line is hard coded.
                                    </xd:li>
                           <xd:li>Create <xd:b>ref:key-value</xd:b> with
                                        <xd:b>@value</xd:b>, as follows: 
                                        <xd:ul>
                                 <xd:li>If <xd:i>link[@smi]</xd:i> is present,
                                                copy <xd:i>link[@filename]</xd:i> to
                                                  <xd:b>@value</xd:b>
                                 </xd:li>
                                 <xd:li>If <xd:i>link[@smi]</xd:i> is not present,
                                                then <xd:b>@value="X-Y-Z"</xd:b>, where X
                                                is LNI, Y is SMI, and Z is filename. LNI and SMI
                                                (retreived from CSSM) values are added by
                                                <xd:b>"Workflow Generic Image Handlers</xd:b>. The last
                                                component "Z" is copied from
                                                <xd:i>link[@filename]</xd:i>.</xd:li>
                                 <xd:li>If <xd:i>link[@smi]</xd:i> is not present,
                                                then conversion program should pass
                                                <xd:i>link[@filename]</xd:i> value to
                                                <xd:b>Workflow Generic Image Handler</xd:b> as is and
                                                Workflow Generic Image Handler will do conversion
                                                of filename value as noted above. <xd:b>Conversion of
                                                    filename replaces underscore, blank, and period
                                                    with hyphen.</xd:b>
                                 </xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                     </xd:li>
                     <xd:li>Create <xd:b>ref:locator-params</xd:b> and describe as: 
                                <xd:ul>
                           <xd:li>
                              <xd:b>ref:locator-params</xd:b> element contains locator parameters. It provides a parameter
                                        (identified as a name/value pair) passing mechanism for link services. Each parameter is expressed as a
                                        <xd:b>@name</xd:b> and <xd:b>@value</xd:b> pair in <xd:b>proc:param</xd:b>
                                        element. It is used to identify the attachment type and component sequence.
                                    </xd:li>
                           <xd:li>Create <xd:b>proc:param</xd:b> with <xd:b>@name</xd:b> and <xd:b>@value</xd:b>.
                                        <xd:b>@name</xd:b> and <xd:b>@value</xd:b> are required attributes in
                                        <xd:b>proc:param</xd:b>.
                                    </xd:li>
                           <xd:li>Three <xd:b>proc:param[@name]</xd:b> and <xd:b>proc:param[@value]</xd:b> pairs are described
                                        below: 
                                        <xd:ul>
                                 <xd:li>
                                    <xd:b>proc:param[@name="componentseq"]</xd:b> with the attribute
                                                <xd:b>@value="1"</xd:b>. This line is hard coded.
                                            </xd:li>
                                 <xd:li>
                                    <xd:b>proc:param[@name="attachment-type"]</xd:b> with the
                                                attribute <xd:b>@value</xd:b>. The <xd:b>@value</xd:b> value is from
                                                <xd:b>link[@type]</xd:b>. Allowable values: image; PDF; spreadsheet; audio; HTML; video; hotdoc; wordprocess.
                                            </xd:li>
                                 <xd:li>
                                    <xd:b>proc:param[@name="attachment-smi"]</xd:b> with the
                                                attribute <xd:b>@value</xd:b>. The <xd:b>@value</xd:b>
                                                value is from <xd:i>link[@smi]</xd:i>. If
                                                <xd:i>link[@smi]</xd:i> is not present, obtain SMI from CSSM.
                                                This <xd:b>@value</xd:b> assignment is done by conversion program.</xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                     </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML. Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;link type="pdf" smi="98765" filename="xmpl-c1.pdf" status="valid"&gt;Download in PDF&lt;/link&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML. Source @smi present</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink service="ATTACHMENT"&gt;
    &lt;ref:marker role="label"&gt;Download in PDF&lt;/ref:marker&gt; 
    &lt;ref:locator&gt;
        &lt;ref:locator-key&gt;
            &lt;ref:key-name name="attachment-key"/&gt;
            &lt;ref:key-value value="xmpl-c1"/&gt;
        &lt;/ref:locator-key&gt;
        &lt;ref:locator-params&gt;
            &lt;proc:param name="componentseq" value="1"/&gt;
            &lt;proc:param name="attachment-type" value="PDF"/&gt;
            &lt;proc:param name="attachment-smi" value="98765"/&gt;
        &lt;/ref:locator-params&gt;
    &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML. Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;link type="pdf" filename="pbap-c1.pdf" status="valid"&gt;Download in PDF&lt;/link&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML. Source @smi not present</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink service="ATTACHMENT"&gt;
    &lt;ref:marker role="label"&gt;Download in PDF&lt;/ref:marker&gt; 
    &lt;ref:locator&gt;
        &lt;ref:locator-key&gt;
            &lt;ref:key-name name="attachment-key"/&gt;
            &lt;ref:key-value value="X-Y-pbap-c1"/&gt; 
            &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
        &lt;/ref:locator-key&gt;
        &lt;ref:locator-params&gt;
            &lt;proc:param name="componentseq" value="1"/&gt;
            &lt;proc:param name="attachment-type" value="PDF"/&gt;
            &lt;proc:param name="attachment-smi" value=""/&gt; 
            &lt;!-- @value populated with SMI obtained from CSSM --&gt;
            &lt;!-- This @value assignment is done by conversion program --&gt;
        &lt;/ref:locator-params&gt;
    &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

	</xd:pre>
         <!--Changes2015-09-08: Minor XPATH correction in title to change 
                ref:lnlink/@service="ATTACHMENT" to be 
                ref:lnlink[@service="ATTACHMENT"].2015-05-22: Changed the instructions to indicate link/@status is always dropped and removed ref:lnlink/@status from target example. This is a very low-priority change and has been added for technical correctness, particularly with respect to new CIs. Existing scripts do not have to implement this change since ref:lnlink/@status is ignored by LexisAdvance if it is present.2013-09-24: Not a rule change. Modified examples to illustrate when @status suppressed and when retained.2013-08-21: Added instruction for when to suppress @status.2013-05-24: Updated instruction for handling of link when smi is present and some of the verbiage is changed.2013-05-02: Some of the verbiage is changed and updated target example to if the SMI is present then a ref:lnlink/@status attribute is set to valid.2013-05-01: Updated instructions and target example per latest Apollo markup.2013-02-26: Updated target example per project requirement.2012-10-26: Changed to reflect recent requirements for attachment-type links.-->
         <!-- Added from /Rosetta-to-LA/modules/nonamespace/Rosetta_ci.cite-LxAdv-lnci.cite.xsl -->
         <xd:p>
            <xd:b>Exception: When <xd:i>link</xd:i> is used as intra-document linking within
                <xd:i>ci:content</xd:i>
            </xd:b>.</xd:p>
         <xd:p>If the <xd:i>ci:content</xd:i> contains a <xd:i>link</xd:i> child,
                the <xd:i>link</xd:i> wrapper markup (not its content) shall be removed (omit
                tag and retain content) and the <xd:i>link/@refpt</xd:i> value shall be moved
                to <xd:b>lnci:cite/@citeref</xd:b>.</xd:p>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_link-LxAdv-ref.lnlink.dita  -->
   <!--   
        
        *****PLEASE READ*****
        
Image handling background note 2017-11-30:
        
Please use $streamID in Rosetta_link-LxAdv-ref.lnlink.xsl due to notation below.  

It was originally intended that Apollo jurisdictions would use these (when first introduced in the DITA):

\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_lnlink_service_ATTACHMENT-LxAdv-ref.lnlink.xsl
\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_link-LxAdv-ref.lnlink.xsl
\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_inlineobject-LxAdv-ref.inlineobject.xsl

And blobstore jurisdictions would use these (notice BLOBSTORE in the file name):

\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_lnlink_service_ATTACHMENT-LxAdv-ref.lnlink_BLOBSTORE.xsl
\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_link-LxAdv-ref.lnlink_BLOBSTORE.xsl
\svn\dataArch\XSLT\ContentArch\Rosetta-to-LA\modules\nonamespace\Rosetta_inlineobject-LxAdv-ref.inlineobject_BLOBSTORE.xsl

They were originally meant to be mutually exclusive.

Ditamap includes (and subsequently xsl drivers) may have included both blobstore and Apollo handling during the transition from one to the other even though only one image handling 
is done in an LBU.  Image handling is LBU wide and not individual stream specific.

Very importantly, there is a named template (@name="generic-link") in Rosetta_link-LxAdv-ref.lnlink.xsl which is called by both "Rosetta_p-LxAdv-p.xsl" and "Rosetta_bodytext-link-LxAdv-seclaw.bodytext-p-text-ref.lnlink.xsl".   Both of these common modules are not LBU specific.  . 
This effectively, although unintentionally, crossed the original exclusivity described above.

Current fix is to use $streamID indicating HK and UK which are currently the only blobstore jurisdictions.  Ultimately, goal is to re-establish these image handling files are mutually exclusive.
-->
   <xsl:template match="link[not(parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp or parent::text[parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp])]"
                 name="generic-link">
      <xsl:choose><!-- Awantika:2017-11-07: updated for NZ12 for webstar #7039775 and #7076843 -->
         <xsl:when test="$streamID='NZ12' and parent::pgrp or parent::li">
            <p>
               <text>
                  <ref:lnlink service="ATTACHMENT">
                     <ref:marker role="label">
                        <xsl:apply-templates/>
                     </ref:marker>
                     <ref:locator>
                        <ref:locator-key>
                           <ref:key-name name="attachment-key"/>
                           <ref:key-value>
                              <xsl:attribute name="value">
                                 <xsl:choose><!-- JL: 20170526: Per Roopa and Selva, we should output the filename extension for image links to work -->
                                    <xsl:when test="@smi">
                                       <xsl:value-of select="@filename"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                       <xsl:value-of select="@filename"/>
                                    </xsl:otherwise>
                                 </xsl:choose>
                              </xsl:attribute>
                           </ref:key-value>
                        </ref:locator-key>
                        <ref:locator-params>
                           <proc:param name="componentseq" value="1"/>
                           <proc:param>
                              <xsl:attribute name="name">attachment-type</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:apply-templates select="@type"/>
                              </xsl:attribute>
                           </proc:param>
                           <proc:param>
                              <xsl:attribute name="name">attachment-smi</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:choose>
                                    <xsl:when test="@smi">
                                       <xsl:value-of select="@smi"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                       <xsl:value-of select="$smi"/>
                                    </xsl:otherwise>
                                 </xsl:choose>
                              </xsl:attribute>
                           </proc:param>
                        </ref:locator-params>
                     </ref:locator>
                  </ref:lnlink>
               </text>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <ref:lnlink service="ATTACHMENT">
               <ref:marker role="label">
                  <xsl:apply-templates/>
               </ref:marker>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name name="attachment-key"/>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:choose><!-- JL: 20170526: Per Roopa and Selva, we should output the filename extension for image links to work -->
                              <xsl:when test="@smi">
                                 <xsl:value-of select="@filename"/>
                              </xsl:when>
                              <xsl:otherwise>
                                 <xsl:value-of select="@filename"/>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <ref:locator-params><!--SS - 2017-11-26: Added the below condition for added blobstore when link comes under 'paragraph' p.--><!-- JL: 2017-11-30: this module is supposed to be for Apollo but has been included in some blobstore LBUs (HK, UK). 
                                Using streamID to make sure Blobstore information goes to Blobstore LBUs. -->
                     <xsl:choose>
                        <xsl:when test="contains(./@type, 'wordprocess') and (starts-with($streamID, 'HK') or starts-with($streamID , 'UK'))">
                           <xsl:choose>
                              <xsl:when test="contains(./@type, 'wordprocess')">
                                 <proc:param name="attachment-type" value="wordprocess"/>
                              </xsl:when>
                              <xsl:otherwise>
                                 <proc:param name="attachment-type" value="IMG"/>
                              </xsl:otherwise>
                           </xsl:choose>
                           <proc:param name="external-or-local" value="external"/>
                           <proc:param name="attachment-server" value="BlobStore"/>
                           <proc:param name="attachment-pguid"
                                       value="urn:contentItem:0000-0000-0000-0000-00000-00"/>
                           <proc:param name="componentseq" value="1"/>
                        </xsl:when>
                        <xsl:otherwise><!--SS: end here-->
                           <proc:param name="componentseq" value="1"/>
                           <proc:param>
                              <xsl:attribute name="name">attachment-type</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:apply-templates select="@type"/>
                              </xsl:attribute>
                           </proc:param>
                           <proc:param>
                              <xsl:attribute name="name">attachment-smi</xsl:attribute>
                              <xsl:attribute name="value">
                                 <xsl:choose>
                                    <xsl:when test="@smi">
                                       <xsl:value-of select="@smi"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                       <xsl:value-of select="$smi"/>
                                    </xsl:otherwise>
                                 </xsl:choose>
                              </xsl:attribute>
                           </proc:param>
                        </xsl:otherwise>
                     </xsl:choose>
                  </ref:locator-params>
               </ref:locator>
            </ref:lnlink>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="link/@status"/>

   <xsl:template match="link/@smi"/>

   <xsl:template match="link/@filename"/>

   <xsl:template match="link/@type">
      <xsl:choose>
         <xsl:when test=".=('para','page', 'ed-pnum','refpt','logo')">
            <xsl:message>attachment-type is invalid, cannot be determined.</xsl:message>
         </xsl:when>
         <xsl:when test=".=('pdf' , 'pdf-fillable')">PDF</xsl:when>
         <xsl:when test=".='hotdoc-nonfillable'">hotdoc</xsl:when>
         <xsl:otherwise>
            <xsl:value-of select="."/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- MDS - 2017-03-14 - Passes through children of link if parent is ci:content
        This is taken from /Rosetta-to-LA/modules/nonamespace/Rosetta_ci.cite-LxAdv-lnci.cite.xsl documentation.  Also copied to documentation in this module.-->
   <xsl:template match="link[parent::ci:content]">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- Vikas Rohilla : Template to match the link[@refpt]-->   <!-- JL removing status att because it's not valid in output schema and some modules copy it -->
   <xsl:template match="link[@refpt][not($streamID='AU21' or 'USLPA')]" priority="25">
      <ref:lnlink>
         <ref:marker>
            <xsl:apply-templates/>
         </ref:marker>
         <ref:locator>
            <xsl:apply-templates select="@* except @status"/>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>
   <!-- Vikas Rohilla : Handle the empty link having no attributes and the content webstar #7045989 -->
   <xsl:template match="link[not(@*)][.='']" priority="10"/>
   <!-- MDS - 2017-09-07 Unhandled in NZ07-DN Examples in CI show the @alttext dropped.  There are no obviously matching structures in the ref:lnlink or ref:marker elements for LA.-->
   <xsl:template match="link/@alttext"/>
   <!-- <topicref href="../../common_newest/Rosetta_link_refpt-LxAdv-ref.lnlink-ref.locator_anchoridref.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>If <xd:i>link</xd:i> only has the attribute <xd:i>@refpt</xd:i>, then the following instructions should be used: <xd:ul>
               <xd:li>
                  <xd:i>link</xd:i> becomes <xd:b>ref:lnlink</xd:b>.</xd:li>
               <xd:li>The content of <xd:i>link</xd:i> becomes <xd:b>ref:marker</xd:b>.</xd:li>
               <xd:li>Create <xd:b>ref:locator</xd:b> and populate the attribute <xd:b>ref:locator/@anchoridref</xd:b> with the
          value of <xd:i>link/@refpt</xd:i>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>ref:locator/@anchoridref</xd:b> that begins with a number must
        have an underscore added at start. Also apply other identifier data type format as
        used for <xd:b>xml:id</xd:b> and <xd:b>ref:anchor/@id</xd:b>
        (e.g. change colon to underscore). Refer to the section titled "Identifiers to ID Data Type - 
        Handling Pattern Restrictions", if that section exists in this CI.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
        If the link element source also includes a <xd:i>@dpsi</xd:i>, the attribute should be dropped. 
      </xd:p>
         <xd:p>
            <xd:b>Source XML: only attribute of <xd:i>link</xd:i> is <xd:i>refpt</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;link refpt="x98-1174a2"&gt;page 324 line 46&lt;/link&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML: only attribute of <xd:i>link</xd:i> is <xd:i>refpt</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink&gt;
    &lt;ref:marker&gt;page 324 line 46&lt;/ref:marker&gt;
    &lt;ref:locator anchoridref="x98-1174a2"/&gt;
&lt;/ref:lnlink&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>CA02-CC</xd:b>
            <xd:b>: </xd:b>
            <xd:i>emph</xd:i> will be dropped in
        <xd:i>link/emph</xd:i>. </xd:p>
         <!--Changes2016-11-16: Added to note regarding applying any rules related to 
        @anchoridref, referring specifically to section for "Identifiers to ID Data Type - 
        Handling Pattern Restrictions".2014-11-24: Updated instruction for CA02-CC to drop
            emph in link/emph.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_link_refpt-LxAdv-ref.lnlink-ref.locator_anchoridref.dita  -->
   <!-- Vikas Rohilla : updated the priority attribute because the ambigous math with in the file Rosetta_link-LxAdv-ref.lnlink.xsl at line 177 -->
   <xsl:template match="link[@refpt][not(@type or @smi or @filename)]" priority="2">
      <ref:lnlink>
         <ref:marker>
            <xsl:choose>
               <xsl:when test="$streamID='CA02-CC'">
                  <xsl:value-of select="."/>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="node()"/>
               </xsl:otherwise>
            </xsl:choose>
         </ref:marker>
         <ref:locator>
            <xsl:attribute name="anchoridref">
               <xsl:apply-templates select="@refpt"/>
            </xsl:attribute>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>

   <xsl:template match="link/@refpt">
      <xsl:attribute name="anchoridref">
         <xsl:call-template name="normalizeIdString"/>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="link/@dpsi"/>
   <!-- <topicref href="../../common_newest/Rosetta_bodytext-link-LxAdv-seclaw.bodytext-p-text-ref.lnlink.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
                shared topic rather than duplicated to ensure consistency and accuracy. The xml
                snippets contained in this topic reflect markup needed for the Apollo image handling
                application. The UK is the first LBU to move from Apollo to the Blobstore
                application for image handling. Therefore, if this is a UK conversion instruction
                document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
                        <xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
                        (id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
                        <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
                        images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
                If <xd:i>link</xd:i> element occurs as direct child of <xd:i>bodytext</xd:i> then conversion need to move
                <xd:b>ref:lnlink</xd:b> as child of <xd:b>p/text</xd:b>, i.e, <xd:i>bodytext/link</xd:i> becomes
                <xd:b>seclaw:bodytext/p/text/ref:lnlink</xd:b>.
                
                <xd:p>
               <xd:b>Note: </xd:b>
               <xd:b>Please note that, in Commentary-Form-Precedents element <xd:i>bodytext</xd:i> maps to <xd:b>seclaw:bodytext</xd:b>,
                    <xd:b>form:bodytext</xd:b> and <xd:b>pubfm:narrative</xd:b> in different content models.</xd:b>
            </xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML : if element link is direct child of bodytext</xd:b>
         </xd:p>
         <xd:pre>

&lt;bodytext searchtype="FORM"&gt;
    &lt;!-- ETC. --&gt;
    &lt;link type="pdf" filename="adm120-1.pdf"&gt;Download in PDF&lt;/link&gt;
    &lt;!-- ETC. --&gt;
&lt;/bodytext&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML : if element link is direct child of bodytext</xd:b>
         </xd:p>
         <xd:pre>

&lt;form:bodytext&gt;
    &lt;!-- ETC. --&gt;
    &lt;form:p&gt;
        &lt;form:text&gt;
            &lt;ref:lnlink service="ATTACHMENT"&gt;
                &lt;ref:marker role="label"&gt;Download in PDF&lt;/ref:marker&gt;
                &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="attachment-key"/&gt;
                        &lt;ref:key-value value="X-Y-adm120-1"/&gt; 
                        &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                    &lt;/ref:locator-key&gt;
                    &lt;ref:locator-params&gt;
                        &lt;proc:param name="componentseq" value="1"/&gt;
                        &lt;proc:param name="attachment-type" value="PDF"/&gt;
                        &lt;proc:param name="attachment-smi" value=""/&gt;
                        &lt;!-- @value populated with SMI obtained from CSSM --&gt;
                        &lt;!-- This @value assignment is done by conversion program --&gt;
                    &lt;/ref:locator-params&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:lnlink&gt;
        &lt;/form:text&gt;
    &lt;/form:p&gt;
    &lt;!-- ETC. --&gt;
&lt;/form:bodytext&gt;

			</xd:pre>
         <!--Changes2016-08-01: Added Note about xml snippets that illustrate image handling. Note summarizes move from Apollo to Blobstore application. UK is first LBU to move to Blobstore.2013-05-01: Updated instructions and target example per latest Apollo markup.2013-02-26: Updated target example per project requirement.2012-10-26: Updated ref:locator markup in Target sample. -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_bodytext-link-LxAdv-seclaw.bodytext-p-text-ref.lnlink.dita  -->
   <!-- JL don't need to worry about the target parent element name because it's already been transformed by other modules
	 copied link processing from link template although I'd rather call it. -->
   <xsl:template match="bodytext/link | leg:bodytext/link" priority="30">
      <p>
         <text>
            <xsl:call-template name="generic-link"/>
         </text>
      </p>
   </xsl:template>
   <!-- JD: 2017-08-08: added and set @priority to 31 for NZ06 to match DT output, where <ref:lnlink> occurs directly under <primlaw:bodytext> -->
   <xsl:template match="bodytext/link[$streamID='NZ06'] | leg:bodytext/link[$streamID='NZ06']"
                 priority="31">
      <xsl:call-template name="generic-link"/>
   </xsl:template>

   <xsl:template match="bodytext[parent::level[@leveltype=('prec.grp' , 'precgrp' , 'precgrp1' , 'precgrp2' , 'prec', 'form')] or          parent::level[@leveltype='comm.chap'][level[@leveltype=('prec.grp' , 'precgrp1' , 'precgrp' , 'precgrp2' , 'prec', 'form')]][not(level[@leveltype='para0'])]]/link"
                 priority="31">
      <form:p>
         <form:text>
            <xsl:call-template name="generic-link"/>
         </form:text>
      </form:p>
   </xsl:template>
   <!-- end topichead  link  -->   <!-- start topichead  ln.user_displayed  -->   <!-- temp note 04/12/2013 from andrew martin -->   <!-- <topicref href="../../common_newest/Rosetta_levelinfo_classification-LxAdv-SUPPRESS.dita"/> -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!--<xsl:include href="../../modules/nonamespace/Rosetta_levelinfo_classification-LxAdv-SUPPRESS.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_case.decisiondate_ln.user-displayed-LxAdv-decision.dates.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i>
        are used for certain functionality in Rosetta that does not exist in Lexis Advance. Each of
        the following elements have mappings described elsewhere in this CI for when this attribute
        does not exist. The examples here are ONLY for when this
          <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a
        "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>When ln.user-displayed="false" appears on any date element (i.e.
          <xd:i>case:decisiondate ln.user-displayed="false"</xd:i>), that element is
        translated into the target but with the element content omitted. Only the attributes are
        populated. So there is no displayable content.</xd:p>
         <xd:p> The attribute <xd:b>decision:decisiondate/@normdate</xd:b> should be populated
        with the values of <xd:i>case:decisiondate/date/@year</xd:i>,
          <xd:i>case:decisiondate/date/@month</xd:i> and
          <xd:i>case:decisiondate/date/@day</xd:i> concatenated and separated by a single
        hyphen. The values of <xd:i>case:decisiondate/date/@month</xd:i> and
          <xd:i>case:decisiondate/date/@day</xd:i> should be padded with zeroes so that
        they are 2 digits. <xd:p>
               <xd:b>Note: </xd:b>If one or more of the three date values (year, month or day) are
          absent, then <xd:b>decision:decisiondate/@normdate</xd:b> should <xd:b>not</xd:b> be
          populated.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:decisiondate ln.user-displayed="false"&gt;
  &lt;date year="1995" month="04" day="8"&gt;8 April 1995&lt;/date&gt; 
&lt;/case:decisiondate&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;decision:dates&gt;  
    &lt;decision:decisiondate year="1995" month="04" day="08" normdate="1995-04-08"/&gt;
&lt;/decision:dates&gt;

	</xd:pre>
         <!--Changes2013-01-09: Instructions have been added with directions for
          populating the attribute decision:decisiondate/@normdate.2012-10-24: Added note to zero pad month and day
        attributes.2012-09-13: Created-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.decisiondate_ln.user-displayed-LxAdv-decision.dates.dita  -->
   <!-- Vikas Rohilla : compleated  -->
   <xsl:template match="case:decisiondate/@ln.user-displayed[.='false']"/>
   <!-- <topicref href="../../common_newest/Rosetta_case.disposition_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>case:disposition</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> then suppress it.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:disposition ln.user-displayed="false"&gt;Appeal dismissed.&lt;/case:disposition&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;!-- output Suppressed --&gt;
        
            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.disposition_ln.user-displayed.dita  -->
   <xsl:template match="case:disposition/@ln.user-displayed[.='false']"/>
   <!-- <topicref href="../../common_newest/Rosetta_case.judges_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:b>
               <xd:i>case:judges</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i>
            </xd:b>: data has been fixed by LBU so it won't occur in updated data.  In
        meantime conversion can suppress it.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:judges ln.user-displayed="false"&gt;
    &lt;emph typestyle="bf"&gt;WILLIAMS J&lt;/emph&gt;
&lt;/case:judges&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;!-- output Suppressed --&gt;

	</xd:pre>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.judges_ln.user-displayed.dita  -->
   <!-- Vikas Rohilla : compleated -->
   <xsl:template match="case:judges/@ln.user-displayed[.='false']"/>
   <!-- <topicref href="../../common_newest/Rosetta_case.reportercite_ln.user-displayed-LxAdv-ref.citations.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>case:reportercite</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> then map to citation as usual. Suppress the attribute
        @ln.user-displayed.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:reportercite ln.user-displayed="false"&gt;
    &lt;ci:cite type="cite4thisdoc"&gt;
        &lt;ci:case&gt;
            &lt;ci:caseinfo&gt;
                &lt;ci:decisiondate year="2009"/&gt;
            &lt;/ci:caseinfo&gt;
            &lt;ci:caseref&gt;
                &lt;ci:reporter value="ALR"/&gt;
                &lt;ci:volume num="256"/&gt;
                &lt;ci:edition&gt;
                    &lt;ci:date year="2009"/&gt;
                &lt;/ci:edition&gt;
                &lt;ci:page num="25"/&gt;
                &lt;ci:pinpoint targettype="para" num="4"/&gt;
            &lt;/ci:caseref&gt;
        &lt;/ci:case&gt;
        &lt;ci:content&gt;
            &lt;citefragment searchtype="CASE-CITE-REF"&gt;(2009) 256 ALR 25&lt;/citefragment&gt;
        &lt;/ci:content&gt;
    &lt;/ci:cite&gt;
&lt;/case:reportercite&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:citations&gt;
    &lt;ref:cite4thisresource citetype="reporter"&gt;
        &lt;lnci:cite&gt;
            &lt;lnci:case&gt;
                &lt;lnci:caseinfo&gt;
                    &lt;lnci:decisiondate year="2009"/&gt;
                &lt;/lnci:caseinfo&gt;
                &lt;lnci:caseref&gt;
                    &lt;lnci:reporter value="ALR"/&gt;
                    &lt;lnci:volume num="256"/&gt;
                    &lt;lnci:edition&gt;
                        &lt;lnci:date year="2009"/&gt;
                    &lt;/lnci:edition&gt;
                    &lt;lnci:page num="25"/&gt;
                    &lt;lnci:pinpoint targettype="para" num="4"/&gt;
                &lt;/lnci:caseref&gt;
            &lt;/lnci:case&gt;
            &lt;lnci:content&gt;(2009) 256 ALR 25&lt;/lnci:content&gt;
        &lt;/lnci:cite&gt;
    &lt;/ref:cite4thisresource&gt;
&lt;/ref:citations&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.reportercite_ln.user-displayed-LxAdv-ref.citations.dita  -->
   <!-- Vikas Rohilla -->
   <xsl:template match="case:reportercite/@ln.user-displayed[.='false']"/>
   <!-- <topicref href="../../common_newest/Rosetta_edpnum_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>edpnum</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> then map to <xd:b>desig</xd:b> or
        <xd:b>altdesig</xd:b> as usual but no element content carried forward. Only the attribute @value is populated.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;edpnum ln.user-displayed="false"&gt;2343&lt;/edpnum&gt;

</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;desig value="2343"/&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!-- CSN: Created pednum when @ln.user-displayed='false' -->
   <xsl:template match="epdnum[@ln.user-displayed='false']">
      <xsl:element name="desig">
         <xsl:attribute name="value">
            <xsl:value-of select="."/>
         </xsl:attribute>
      </xsl:element>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_heading_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis Advance. Each of the
          following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when this
            <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>heading</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> the element is suppressed.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:heading ln.user-displayed="false"&gt; &lt;title&gt;Preliminary&lt;/title&gt; &lt;/leg:heading&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;!-- output Suppressed --&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;level id="ASC_ARCHIVE.SGM_MISC.INS_2" leveltype="miscins"&gt; &lt;heading ln.user-displayed="false"&gt; &lt;title&gt;[Instrument]&lt;/title&gt; &lt;/heading&gt; ...
          &lt;/level&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;!-- output Suppressed --&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:heading ln.user-displayed="false"&gt; &lt;title&gt;Preliminary&lt;/title&gt; &lt;/leg:heading&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;!-- output Suppressed --&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;leg:juris ln.userdisplayed="false"&gt;NSW&lt;/leg:juris&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;jurisinfo:legisbodyinfo&gt; &lt;jurisinfo:jurisdiction&gt; &lt;jurisinfo:system&gt;NSW&lt;/jurisinfo:system&gt; &lt;/jurisinfo:jurisdiction&gt; &lt;/jurisinfo:legisbodyinfo&gt;
          &lt;dc:metadata&gt; &lt;dc:coverage&gt; &lt;location:state codescheme="ISO-3166-2" statecode="AU-NS"&gt;NSW&lt;/location:state&gt; &lt;/dc:coverage&gt; &lt;/dc:metadata&gt; </xd:pre>
         <!-- SEP 2015-8-12 added -->
      </xd:desc>
   </xd:doc>
   <xsl:template match="heading[@ln.user-displayed = 'false']" priority="25"/>
   <!-- suppress -->
   <xsl:template match="leg:heading[@ln.user-displayed = 'false']" priority="25"/>
   <!-- suppress -->   <!-- <topicref href="../../common_newest/Rosetta_leg.heading_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc><!-- *********************** --><!-- DO NOT USE - functionality elsewhere --><!-- See Rosetta_heading_ln.user-displayed.xsl  --><!-- *********************** -->
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>leg:heading</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> the element is suppressed.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:heading ln.user-displayed="false"&gt;
    &lt;title&gt;Preliminary&lt;/title&gt;
&lt;/leg:heading&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;!-- output Suppressed --&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <xsl:template match="leg:heading[@ln.user-displayed='false' and not(parent::leg:level-vrnt)]"/>
   <!-- <topicref href="../../common_newest/Rosetta_leg.juris_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>leg:juris</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> then map it as usual (as if the
        <xd:i>@ln.user-displayed</xd:i> did not exist).</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:juris ln.userdisplayed="false"&gt;NSW&lt;/leg:juris&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

    &lt;jurisinfo:legisbodyinfo&gt;
        &lt;jurisinfo:jurisdiction&gt;
            &lt;jurisinfo:system&gt;NSW&lt;/jurisinfo:system&gt;
        &lt;/jurisinfo:jurisdiction&gt;
    &lt;/jurisinfo:legisbodyinfo&gt;
    
    &lt;dc:metadata&gt;
        &lt;dc:coverage&gt;
            &lt;location:state codescheme="ISO-3166-2" statecode="AU-NS"&gt;NSW&lt;/location:state&gt;
        &lt;/dc:coverage&gt;
    &lt;/dc:metadata&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_leg.juris_ln.user-displayed.dita  -->
   <!-- JL Nothing to do or see here.  Commenting out of HK01 driver; this will validate if empty but is pretty useless. -->
   <!-- <topicref href="../../common_newest/Rosetta_leg.levelstatus_ln.user-displayed.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
       Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
       this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>leg:levelstatus</xd:i> has attribute <xd:i>@isrepealed="true"</xd:i> then map the @statuscode regardless of whether
       <xd:i>@ln.user-displayed</xd:i> exists or not. If the attribute <xd:i>@ln.user-displayed</xd:i> exists, then don't create the
       <xd:b>statustext</xd:b> element (but retain the <xd:b>@statuscode</xd:b> as stated here).</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:levelstatus isrepealed="true" ln.userdisplayed="false"&gt;(Repealed)&lt;/leg:levelstatus&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;legisinfo:status statuscode="repealed" /&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--	<xsl:template match="leg:levelstatus[@ln.user-displayed='false' and @isrepealed='true']">

		<!-\-  Original Target XPath:  statustext   -\->
		<legisinfo:statusgroup>
		  <legisinfo:status>
		    <xsl:attribute name="statuscode" select="'repealed'"/>
		  </legisinfo:status>
		</legisinfo:statusgroup>

	</xsl:template>-->
   <!-- MDS 2017-05-18 - Functionality in general module leg.levelstatus -->
   <!--<xsl:template match="leg:levelstatus[@ln.user-displayed='false' and not(@isrepealed='true')]"/>-->
   <!--xsl:template match="leg:levelinfo[* and not(*[not(self::leg:levelstatus)])]"-->
   <!-- JD: 2017-08-01: rewriting rule; original rule intended to apply when the only child of 
		leg:levelinfo is leg:levelstatus, which omits that output when other elements are present -->
   <xsl:template match="leg:levelinfo[leg:levelstatus]">
      <xsl:choose>
         <xsl:when test="leg:levelstatus/@isrepealed='true'">
            <primlaw:levelinfo>
               <primlawinfo:primlawinfo>
                  <legisinfo:legisinfo>
                     <xsl:apply-templates select="node() except (source_docinfo:authorattribution)"/>
                  </legisinfo:legisinfo>
               </primlawinfo:primlawinfo>
            </primlaw:levelinfo>
         </xsl:when>
         <xsl:otherwise/>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="leg:levelstatus[@isrepealed = 'true'][$streamID='UK12']">
      <legisinfo:statusgroup>
         <legisinfo:status>
            <xsl:attribute name="statuscode" select="'repealed'"/>
         </legisinfo:status>
      </legisinfo:statusgroup>
   </xsl:template>

   <xsl:template match="leg:levelstatus[parent::leg:levelinfo][$streamID=('HK06')]"/>
   <!-- <topicref href="../../common_newest/Rosetta_leg.officialname_ln.user-displayed-LxAdv-legisinfo.officialtitle.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>leg:officialname</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> becomes
        <xd:b>legisinfo:officialtitle</xd:b> with attribute <xd:b>source="editoriallyassigned"</xd:b>
            <xd:p>
               <xd:b>Note: </xd:b>In order to enable searching and indexing while retaining the display integrity of the information. The @source
          attribute will be populated with "editoriallyassigned" indicating these fields were assigned their value.
          The viewspec will utilize the @source attribute to choose whether to display this information
          differently or not at all depending on the needs of the LBU users.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:officialname searchtype="LEGISLATION" ln.user-displayed="false"&gt;SUPREME COURT (FOREIGN JUDGMENTS) RULES 1993&lt;/leg:officialname&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;legisinfo:names&gt;
&lt;legisinfo:officialtitle source="editoriallyassigned"&gt;SUPREME COURT (FOREIGN JUDGMENTS) RULES 1993&lt;/legisinfo:officialtitle&gt;
&lt;/legisinfo:names&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!-- MCJ:  Single template to handle leg:officialname.  This collapses the specific instructions around @ln.user-displayed="false" with the
             generic-case of no @ln.user-displayed and the lack of @ln.user-displayed. -->
   <xsl:template match="leg:officialname"><!--  JL: ref:anchor is not valid in legisinfo:officialtitle   -->
      <xsl:choose>
         <xsl:when test="parent::leg:info">
            <legisinfo:names>
               <legisinfo:officialtitle>
                  <xsl:apply-templates select="@*"/>
                  <!-- MCJ:  Only create the @source attribute of 'editoriallyassigned' if @ln.user-displayed="false". -->
                  <xsl:if test="@ln.user-displayed='false'">
                     <xsl:attribute name="source">editoriallyassigned</xsl:attribute>
                  </xsl:if>
                  <xsl:apply-templates select="node() except refpt"/>
               </legisinfo:officialtitle>
            </legisinfo:names>
         </xsl:when>
         <xsl:otherwise>
            <legisinfo:legisinfo>
               <legisinfo:names>
                  <legisinfo:officialtitle>
                     <xsl:apply-templates select="@*"/>
                     <!-- MCJ:  Only create the @source attribute of 'editoriallyassigned' if @ln.user-displayed="false". -->
                     <xsl:if test="@ln.user-displayed='false'">
                        <xsl:attribute name="source">editoriallyassigned</xsl:attribute>
                     </xsl:if>
                     <xsl:apply-templates select="node() except refpt"/>
                  </legisinfo:officialtitle>
               </legisinfo:names>
            </legisinfo:legisinfo>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="leg:officialname/@ln.user-displayed"/>

   <xsl:template match="leg:officialname/@searchtype"/>
   <!--<topicref href="../../common_newest/Rosetta_AU-Regulatory_Material_leg.officialname_ln.user-displayed-LxAdv-admindoc.officialtitle.dita"/>-->   <!-- <topicref href="../../common_newest/Rosetta_leg.officialnum_ln.user-displayed-LxAdv-primlawinfo.identifier_source.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>If <xd:i>leg:officialnum</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> becomes <xd:b>primlawinfo:identifier</xd:b> with attribute <xd:b>source="editoriallyassigned"</xd:b>
            <xd:p>
               <xd:b>Note: </xd:b>In order to enable searching and indexing while retaining the display integrity of the information. The @source
          attribute will be populated with "editoriallyassigned" indicating these fields were assigned their value.
          The viewspec will utilize the @source attribute to choose whether to display this information
          differently or not at all depending on the needs of the LBU users.</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:officialnum searchtype="LEGISLATION" ln.user-displayed="false"&gt;Act No. 91, 1993&lt;/leg:officialnum&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;primlawinfo:identifier idtype="officialnum" source="editoriallyassigned"&gt;Act No. 91, 1993&lt;/primlawinfo:identifier&gt;
       
         </xd:pre>
      </xd:desc>
   </xd:doc>
   <!-- MCJ:  Single template to handle leg:officialnum.  This collapses the specific instructions around @ln.user-displayed="false" with the
             generic-case of no @ln.user-displayed and the lack of @ln.user-displayed. -->
   <xsl:template match="leg:officialnum">
      <primlawinfo:identifier>
         <xsl:apply-templates select="@*"/>
         <xsl:attribute name="idtype" select="'officialnum'"/>
         <!-- MCJ:  Set @source='editoriallyassigned' if @ln.user-displayed is explicitly set to 'false'.  -->
         <xsl:if test="@ln.user-displayed='false'">
            <xsl:attribute name="source" select="'editoriallyassigned'"/>
         </xsl:if>
         <xsl:apply-templates select="node()"/>
      </primlawinfo:identifier>
   </xsl:template>
   <!-- JD: @searchtype not mentioned in DITA, but examples illustrate this is suppressed. -->
   <xsl:template match="leg:officialnum/@searchtype | leg:officialnum/@ln.user-displayed"/>
   <!-- <topicref href="../../common_newest/Rosetta_leg.year_ln.user-displayed.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>When <xd:i>leg:year</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> (i.e. <xd:i>leg:year/@ln.user-displayed="false"</xd:i>),
      that element is translated into the target but with the element content omitted. Only the attributes are populated. So there is no displayable content.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:year searchtype="LEGISLATION" ln.userdisplayed="false"&gt;1970&lt;/leg:year&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;primlawinfo:dates&gt;
    &lt;primlawinfo:enactdate year="1970"/&gt;
&lt;/primlawinfo:dates&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!-- JD: 2017-07-27: the instructions for this are ambiguous; I read it 
		as the <primlaw:enactdate> is used as an example of when only date attributes and not 
		content would be output, i.e., the target element for leg:year could be different
		(as in NZ06, where the target is <primlawinfo:assentdate>).
		
		If that reading is correct, then this template should just output attributes
	-->
   <xsl:template match="leg:year[@ln.user-displayed='false']">
      <primlawinfo:dates>
         <primlawinfo:enactdate>
            <xsl:if test="matches(normalize-space(.) , '^[1|2]\d{3}$')">
               <xsl:attribute name="year">
                  <xsl:value-of select="normalize-space(.)"/>
               </xsl:attribute>
            </xsl:if>
         </primlawinfo:enactdate>
      </primlawinfo:dates>
   </xsl:template>
   <!-- Awantika: When leg:year does not have an attribute ln.user-displayed -->
   <xsl:template match="leg:year[not(@ln.user-displayed)]">
      <primlawinfo:dates>
         <primlawinfo:enactdate>
            <xsl:if test="matches(normalize-space(.) , '^[1|2]\d{3}$')">
               <xsl:attribute name="year">
                  <xsl:value-of select="normalize-space(.)"/>
               </xsl:attribute>
            </xsl:if>
         </primlawinfo:enactdate>
         <!-- Awantika: In AU20 primlawinfo:assentdate need to be merged inside primlawinfo:dates -->
         <xsl:if test="$streamID='AU20'">
            <xsl:apply-templates select="parent::leg:info/leg:dates/leg:assentdate" mode="legdate"/>
         </xsl:if>
      </primlawinfo:dates>
   </xsl:template>

   <xsl:template match="@ln.user-displayed"/>

   <xsl:template match="leg:level" priority="35"><!--  Original Target XPath:  primlaw:level   -->
      <xsl:choose>
         <xsl:when test="parent::legfragment/parent::blockquote"><!--<primlaw:excerpt>-->
            <primlaw:level>
               <xsl:choose>
                  <xsl:when test="leg:level-vrnt[@leveltype='sect']">
                     <xsl:attribute name="leveltype" select="'section'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='subsect']">
                     <xsl:attribute name="leveltype" select="'subsection'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='sched']">
                     <xsl:attribute name="leveltype" select="'schedule'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov1']">
                     <xsl:attribute name="leveltype" select="'section'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov2']">
                     <xsl:attribute name="leveltype" select="'subsection'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov3']">
                     <xsl:attribute name="leveltype" select="'paragraph'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov4']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov1']">
                     <xsl:attribute name="leveltype" select="'paragraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov2']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov3']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov4']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:attribute name="leveltype"
                                    select="if(number(leg:level-vrnt/@leveltype)) then 'unclassified' else leg:level-vrnt/@leveltype"/>
                  </xsl:otherwise>
               </xsl:choose>
               <!-- <xsl:if test="(not(refpt) or not(leg:level-vrnt/refpt) or not(parent::leg:body/descendant::level/refpt) or not(parent::leg:body/descendant::leg:comntry/refpt) or   not(leg:level-vrnt/leg:levelbody/refpt) or not(leg:level-vrnt/refpt) or not(leg:level-vrnt/leg:heading/refpt) or not(leg:level-vrnt/leg:levelbody/refpt)) and not(parent::leg:endmatter or parent::leg:body)">
				<ref:anchor id="TOC00{position()}" anchortype="local"/>
			</xsl:if>-->
               <xsl:apply-templates select="@* | node()"/>
            </primlaw:level>
            <!--</primlaw:excerpt>-->
         </xsl:when>
         <xsl:otherwise>
            <primlaw:level>
               <xsl:choose>
                  <xsl:when test="leg:level-vrnt[@leveltype='sect']">
                     <xsl:attribute name="leveltype" select="'section'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='subsect']">
                     <xsl:attribute name="leveltype" select="'subsection'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='sched']">
                     <xsl:attribute name="leveltype" select="'schedule'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov1']">
                     <xsl:attribute name="leveltype" select="'section'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov2']">
                     <xsl:attribute name="leveltype" select="'subsection'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov3']">
                     <xsl:attribute name="leveltype" select="'paragraph'"/>
                  </xsl:when>
                  <xsl:when test="leg:level-vrnt[@leveltype='prov4']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov1']">
                     <xsl:attribute name="leveltype" select="'paragraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov2']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov3']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:when test="ancestor:: leg:level/leg:level-vrnt[@leveltype='sched']/leg:level-vrnt[@leveltype='prov4']">
                     <xsl:attribute name="leveltype" select="'subparagraph'"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:attribute name="leveltype"
                                    select="if(number(leg:level-vrnt/@leveltype)) then 'unclassified' else leg:level-vrnt/@leveltype"/>
                  </xsl:otherwise>
               </xsl:choose>
               <!-- <xsl:if test="(not(refpt) or not(leg:level-vrnt/refpt) or not(parent::leg:body/descendant::level/refpt) or not(parent::leg:body/descendant::leg:comntry/refpt) or   not(leg:level-vrnt/leg:levelbody/refpt) or not(leg:level-vrnt/refpt) or not(leg:level-vrnt/leg:heading/refpt) or not(leg:level-vrnt/leg:levelbody/refpt)) and not(parent::leg:endmatter or parent::leg:body)">
				<ref:anchor id="TOC00{position()}" anchortype="local"/>
			</xsl:if>-->
               <xsl:apply-templates select="@* | node()"/>
            </primlaw:level>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="leg:level/@id"><!--  Original Target XPath:  @xml:id   -->
      <xsl:attribute name="xml:id" select="."/>
   </xsl:template>

   <xsl:template match="leg:level/@subdoc"><!--  Original Target XPath:  @includeintoc   -->
      <xsl:attribute name="includeintoc" select="."/>
   </xsl:template>

   <xsl:template match="leg:level/@toc-caption"><!--  Original Target XPath:  @alternatetoccaption   -->
      <xsl:attribute name="alternatetoccaption" select="."/>
   </xsl:template>

   <xsl:template match="leg:level-vrnt"><!--  Original Target XPath:  @leveltype   -->
      <xsl:apply-templates select="node()"/>
   </xsl:template>

   <xsl:template match="leg:levelbody"><!--  Original Target XPath:  primlaw:bodytext   -->
      <xsl:choose><!-- Checking if leg:bodytext is comming simultanious under leg:levelbody. -->
         <xsl:when test="*[1][self::leg:bodytext]">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:apply-templates select="@* | node()"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="leg:heading"><!--  Original Target XPath:  heading   -->
      <heading>
         <xsl:apply-templates select="@* | node() except leg:empleg"/>
      </heading>
      <xsl:apply-templates select="leg:empleg"/>
   </xsl:template>

   <xsl:template match="leg:heading/@align"><!--  Original Target XPath:  @align   -->
      <xsl:attribute name="align" select="."/>
   </xsl:template>

   <xsl:template match="leg:heading/@inline"><!--  Original Target XPath:  @inline   -->
      <xsl:attribute name="inline" select="."/>
   </xsl:template>
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>Elements that contain the attribute <xd:i>@ln.user-displayed="false"</xd:i> are used for certain functionality in Rosetta that does not exist in Lexis
        Advance. Each of the following elements have mappings described elsewhere in this CI for when this attribute does not exist. The examples here are ONLY for when
        this <xd:i>@ln.user-displayed="false"</xd:i> appears. (This attribute never has a "true" value, i.e. @ln.user-displayed="true".)</xd:p>
         <xd:p>When <xd:i>refnum</xd:i> has attribute <xd:i>@ln.user-displayed="false"</xd:i> (i.e. <xd:i>refnum/@ln.user-displayed="false"</xd:i>),
      that element is translated into the target but with the element content omitted. Only the attributes are populated. So there is no displayable content.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;refnum refnumtype="UCN" ln.user-displayed="false"&gt;00836591&lt;/refnum&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;refnum refnumscheme="UCN" num="00836591"/&gt;

            </xd:pre>
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_refnum_ln.user-displayed.dita  -->
   <xsl:template match="refnum[@ln.user-displayed='false']"><!--  Original Target XPath:     --><!--  Could not determine target element or attribute name:  <>  --><!--  Could not determine target element or attribute name:  </>  -->
      <refnum>
         <xsl:attribute name="refnumscheme">UCN</xsl:attribute>
         <xsl:attribute name="num" select="node()"/>
      </refnum>
   </xsl:template>

   <xsl:template match="refnum/@ln.user-displayed"/>
   <!-- Awantika: not in GDS -->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_abbrvname_ln.user-displayed.dita"/> -->   <!--<xsl:include href="../../modules/nonamespace/Rosetta_abbrvname_ln.user-displayed.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_case.courtcode_ln.user-displayed.dita"/> -\->
	<xsl:include href="../../modules/nonamespace/Rosetta_case.courtcode_ln.user-displayed.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refnum_ln.user-displayed.dita"/> -\->
	
	<!-\- <topicref href="../../common_newest/Rosetta_case.juris_ln.user-displayed.dita"/> -\->
	<xsl:include href="../../modules/nonamespace/Rosetta_case.juris_ln.user-displayed.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- end topichead  ln.user_displayed  -->   <!-- start topichead  lnlink  -->   <!-- <topicref href="../../common_newest/Rosetta_lnlink_service_SEARCH-LxAdv-SUPPRESS.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>lnlink[@service="SEARCH"]</xd:i> occurs it is suppressed. The service type "SEARCH" is not supported in New Lexis. It is recommended that <xd:i>lnlink</xd:i> elements with <xd:i>@service="SEARCH"</xd:i> be copied as is into an XML comment. This retains the content for future analysis without creating unsupported target markup. The risk of this approach is the non-conversion of any marker/display text that is within the <xd:i>lnlink</xd:i> and the consequent lack of this text being displayed in NewLexis products.
    </xd:p>
         <xd:p>
            <xd:b>Source XML showing service type "SEARCH" converted to XML comment.</xd:b>
         </xd:p>
         <xd:pre>

&lt;lnlink scope="All Subscribed Australian Cases and Commentary" scope-protocol="combined-source-name" service="SEARCH" status="valid"&gt;
	&lt;api-params&gt;
		&lt;param name="expressSearch" value="true"/&gt;
		&lt;param name="searchString" value="ELECTRICITY SAFETY ACT 1998 w/s LEG-REF(1)"/&gt;
	&lt;/api-params&gt;
&lt;/lnlink&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>


&lt;!--  lnlink[@service="SEARCH"] source:

&lt;lnlink scope="All Subscribed Australian Cases and Commentary" scope-protocol="combined-source-name" service="SEARCH" status="valid"&gt;
	&lt;api-params&gt;
		&lt;param name="expressSearch" value="true"/&gt;
		&lt;param name="searchString" value="ELECTRICITY SAFETY ACT 1998 w/s LEG-REF(1)"/&gt;
	&lt;/api-params&gt;
&lt;/lnlink&gt;

--&gt;


	</xd:pre>
         <!--Changes2015-09-08: Minor XPATH correction in instruction title and body to change 
        lnlink/@service='SEARCH' to be lnlink[@service='SEARCH'].-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_lnlink_service_SEARCH-LxAdv-SUPPRESS.dita  -->
   <xsl:template match="lnlink[@service='SEARCH']">
      <xsl:comment>
         <xsl:copy-of select="."/>
      </xsl:comment>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_lnlink_service_ATTACHMENT-LxAdv-ref.lnlink.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> becomes <xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b>, and its child elements are transformed as follows:
                    <xd:ul>
               <xd:li>The attribute <xd:i>lnlink/@status</xd:i> is always suppressed, it is never output to the target document.</xd:li>
               <xd:li>
                  <xd:i>lnlink/marker</xd:i> becomes <xd:b>ref:lnlink/ref:marker</xd:b>, with attribute <xd:i>marker/@role</xd:i> becoming <xd:b>ref:marker/@role</xd:b> if present</xd:li>
               <xd:li>create <xd:b>ref:lnlink/ref:locator</xd:b> and populate as follows:<xd:ul>
                     <xd:li>
                        <xd:b>
                           <xd:i>if and only if</xd:i>
                        </xd:b> there is an
                  <xd:i>lnlink/api-params/param</xd:i> where
                  <xd:i>param/@name="attachment-key"</xd:i>, then this
                  <xd:i>param</xd:i> becomes
                  <xd:b>ref:locator/ref:key-name/@name="attachment-key"</xd:b>, then a
                  <xd:b>ref:key-value</xd:b> element is also created, and the attribute
                  <xd:i>param/@value</xd:i> becomes
                  <xd:b>ref:locator/ref:key-value/@value</xd:b>.</xd:li>
                     <xd:li>otherwise <xd:i>lnlink/api-params</xd:i>&gt; becomes
                  <xd:b>ref:locator/ref:locator-params</xd:b>, and its child elements are
                transformed as follows:<xd:ul>
                           <xd:li>all other <xd:i>api-params/param</xd:i> elements (<xd:b>
                                 <xd:i>with the
                        exception of</xd:i>
                              </xd:b>
                              <xd:i>param/@name="attachment-key"</xd:i>) become
                      <xd:b>ref:locator-params/proc:param</xd:b>, with attribute
                      <xd:i>param/@name</xd:i> becoming
                      <xd:b>proc:param/@name</xd:b> and attribute
                      <xd:i>param/@value</xd:i> becoming
                      <xd:b>proc:param/@value</xd:b>.</xd:li>
                        </xd:ul>
                     </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;lnlink service="ATTACHMENT" status="valid"&gt;
  &lt;marker role="content"&gt;PDF Format&lt;/marker&gt;
  &lt;api-params&gt;
    &lt;param name="attachment-key" value="application_for_apportionment-xxxx-xxxx-xxxxx-xx"/&gt;
    &lt;param name="attachment-type" value="pdf"/&gt;
    &lt;param name="attachment-smi" value="4364"/&gt;
    &lt;param name="componentseq" value="1"/&gt;
  &lt;/api-params&gt;
&lt;/lnlink&gt;
                
            </xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink service="ATTACHMENT"&gt;
  &lt;ref:marker role="content"&gt;PDF Format&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
   &lt;ref:locator-key&gt;
    &lt;ref:key-name name="attachment-key"/&gt;
    &lt;ref:key-value value="application_for_apportionment-xxxx-xxxx-xxxxx-xx"/&gt;
   &lt;/ref:locator-key&gt;
   &lt;ref:locator-params&gt;
    &lt;proc:param name="componentseq" value="1"/&gt;
    &lt;proc:param name="attachment-type" value="PDF"/&gt;
    &lt;proc:param name="attachment-smi" value="4364"/&gt;
   &lt;/ref:locator-params&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;
                
            </xd:pre>
         <!--Changes2015-09-08: Minor XPATH correction in instruction title and body to change 
        lnlink/@service="ATTACHMENT" to be lnlink[@service="ATTACHMENT"], 
        ref:lnlink to be ref:lnlink[@service="ATTACHMENT"], and 
        ref:lnlink/@service="ATTACHMENT" to be ref:lnlink[@service="ATTACHMENT"].2015-05-22: Added an instruction to explicitly indicate lnlink/@status is always dropped (suppressed). This is a very low-priority change and has been added for technical correctness, particularly with respect to new CIs. Existing scripts do not have to implement this change unless needed since prior to the change lnlink/@status handling was not explicitly specified.2014-10-15: Rewrote instructions, including the correction of a typographic error, and added an example.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_lnlink_service_ATTACHMENT-LxAdv-ref.lnlink.dita  -->
   <xsl:template match="lnlink[@service='ATTACHMENT']/marker" priority="2">
      <ref:marker>
         <xsl:apply-templates select="@*|node()"/>
      </ref:marker>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT']/marker/@role" priority="2">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT']/@status"/>
   <!-- SNB: 2017-11-02 add LPA to the NZ11/AU10 fix; looks to me like the general template rule above 
   (xsl:template match="lnlink[@service='ATTACHMENT'][not(parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp)])
   is WRONG for all other streams because it doesnt create api-params, and the general template rule for api-params is wrong 
   because it results in 2 smi values, and this fix really should be for all streams, but I'd be afraid to do it :) -->
   <xsl:template match="lnlink[@service='ATTACHMENT'][not(parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp)]">
      <ref:lnlink service="ATTACHMENT">
         <xsl:apply-templates select="marker"/>
         <ref:locator>
            <xsl:choose>
               <xsl:when test="api-params/param[@name='attachment-key']">
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">attachment-key</xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:value-of select="api-params/param[@name='attachment-key']/@value"/>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
                  <xsl:if test="$streamID=('NZ11','AU10','USLPA')">
                     <xsl:apply-templates select="api-params"/>
                  </xsl:if>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="api-params"/>
               </xsl:otherwise>
            </xsl:choose>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>
   <!-- SNB: 2017-11-02 add LPA to this fix; looks to me like the general template rule above 
   (xsl:template match="lnlink[@service='ATTACHMENT'][not(parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp)])
   is WRONG for all other streams because it doesnt create api-params, and the general template rule for api-params is wrong 
   because it results in 2 smi values, and this fix really should be for all streams, but I'd be afraid to do it :) -->
   <xsl:template match="lnlink[@service='ATTACHMENT'][not(parent::docinfo:assoc-links or parent::docinfo:assoc-links-grp)][$streamID=('NZ11','AU10','USLPA')]/api-params"
                 priority="2">
      <ref:locator-params>
         <xsl:for-each select="param[not(@name='attachment-key')]">
            <proc:param name="{@name}" value="{@value}"/>
         </xsl:for-each>
      </ref:locator-params>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT']/api-params">
      <ref:locator-params>
         <xsl:apply-templates/>
         <xsl:if test="parent::lnlink[@service='ATTACHMENT']">
            <proc:param>
               <xsl:attribute name="name">attachment-smi</xsl:attribute>
               <xsl:attribute name="value"/>
               <xsl:message>need SMI from CSSM? Is this a parameter?</xsl:message>
            </proc:param>
         </xsl:if>
      </ref:locator-params>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT']/api-paramsparam">
      <xsl:if test="@name!='attachment-key'">
         <proc:param>
            <xsl:apply-templates select="@name | @value"/>
         </proc:param>
      </xsl:if>
   </xsl:template>

   <xsl:template match="lnlink[@service='ATTACHMENT']/api-paramsparam/@name | lnlink[@service='ATTACHMENT']/api-paramsparam/@value">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!-- end topichead  lnlink  -->   <!-- start topichead  marker  -->   <!-- <topicref href="../../common_newest/Rosetta_marker-LxAdv-ref.marker.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>marker</xd:i> becomes <xd:b>ref:marker</xd:b>.</xd:p>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_marker-LxAdv-ref.marker.dita  -->
   <xsl:template match="marker">
      <ref:marker>
         <xsl:apply-templates select="@* | node()"/>
      </ref:marker>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_marker_inlineobject-LxAdv-SUPPRESS.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>marker</xd:i> is suppressed if it contains <xd:i>inlineobject</xd:i> as a child element.
            </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;lnlink status="valid" service="SEARCH" scope="All Subscribed Australian Cases and Commentary" scope-protocol="combined-source-name"&gt;
    &lt;marker&gt;
        &lt;inlineobject width="21px" type="image" filename="mb.gif" attachment="web-server" alttext="click to find cases &amp;amp; commentary"/&gt;
    &lt;/marker&gt;
    &lt;api-params&gt;
        &lt;param name="expressSearch" value="true"/&gt;
        &lt;param name="searchString" value="SUPREME COURT RULES 1970"/&gt;
    &lt;/api-params&gt;
&lt;/lnlink&gt;

            </xd:pre>
         <xd:p>
            <xd:b>Suppress <xd:i>marker</xd:i>. A corresponding product requirement should be created with an instruction to instantiate the image on retrieval based on information/semantic markup in the document.</xd:b>
         </xd:p>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_marker_inlineobject-LxAdv-SUPPRESS.dita  -->
   <!-- JL WE NEED TO RESOLVE THIS INLINEOBJECT ISSUE !!!!! -->
   <xsl:template match="marker[inlineobject]" priority="25"/>
   <!--JL This is what I envision in the future:
        
 <xsl:template match="marker[inlineobject]" priority="25">
        <xsl:apply-templates select="inlineobject" mode="to-be-determined"/>
    </xsl:template> -->   <!-- end topichead  marker  -->   <!-- rosetta element: nl -->   <!-- <topicref href="../../common_newest/Rosetta_nl-LxAdv-proc.nl.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>nl</xd:i> becomes <xd:b>proc:nl</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:i>nl</xd:i> comes with <xd:i>@n</xd:i> then
          <xd:i>@n</xd:i> will be suppressed in NL conversion.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>MLV: NSW Law reports - preserve spacing and linebreaks for licensing.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;tbody&gt;
    &lt;row&gt;
        &lt;entry colname="c1" align="left"&gt;On the day after this Regulation's notification
            day.&lt;nl/&gt;(4/11/2008)&lt;/entry&gt;
    &lt;/row&gt;
&lt;/tbody&gt;
    	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;tbody&gt;
    &lt;row&gt;
        &lt;entry colname="c1" align="left"&gt;On the day after this Regulation's notification
            day.&lt;proc:nl/&gt;(4/11/2008)&lt;/entry&gt;
    &lt;/row&gt;
&lt;/tbody&gt;

    	</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;nl n="2"/&gt;
    &lt;/text&gt;
&lt;/p&gt;
      </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;text&gt;
        &lt;proc:nl/&gt;
    &lt;/text&gt;
&lt;/p&gt;
</xd:pre>
         <!--Changes2013-03-14: Add instruction and example
            nl/@n.-->
      </xd:desc>
   </xd:doc>
   <!-- Awantika:2017-11-30- CI has differnt rule for CA02CC,DC and DS."Any nl elements that occur inside case:casename should be suppressed if they are preceded or followed by a space. Any nl elements that
are not preceded or followed by a space should be converted into a single space character. Webstar# 6994049" -->
   <xsl:template match="nl">
      <xsl:choose><!-- Awantika: Commenting this for CA02CC.Webstar  6994049. CI doesn't say to create proc:nl
                "Any nl elements that occur inside case:casename should be suppressed if they are preceded or followed by a space. Any nl elements that
are not preceded or followed by a space should be converted into a single space character."
                -->
         <xsl:when test="$streamID='CA02CC' and parent::case:casename">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:when test="$streamID='AU21'">
            <xsl:choose>
               <xsl:when test="parent::text/parent::p/parent::source_dict:subtopic/@id[starts-with(.,'BOOK:')]"/>
               <xsl:otherwise>
                  <xsl:element name="proc:nl">
                     <xsl:apply-templates/>
                  </xsl:element>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="proc:nl">
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="nl/@n"><!-- suppress --></xsl:template>
   <!-- start topichead  num_frac  -->   <!-- <topicref href="../../common_newest/Rosetta_num-LxAdv-num.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>num</xd:i> becomes <xd:b>num</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;h align="left"&gt;
&lt;num&gt;103&lt;/num&gt;
&lt;emph typestyle="bf"&gt;Introduction&lt;/emph&gt;
&lt;/h&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;h align="left"&gt;
&lt;num&gt;103&lt;/num&gt;
&lt;emph typestyle="bf"&gt;Introduction&lt;/emph&gt;
&lt;/h&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!-- PS: templated created for num conversion -->
   <xsl:template match="num">
      <num>
         <xsl:apply-templates select="node()"/>
      </num>
   </xsl:template>
   <!-- Awnatika:2017-11-20- Webstar# 7043263- Suppressed @searchtype. -->
   <xsl:template match="num/@searchtype"/>
   <!-- <topicref href="../../common_newest/Rosetta_frac-LxAdv-num_frac.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>frac</xd:i> becomes <xd:b>frac</xd:b>. The output
          <xd:b>frac</xd:b> must be within a <xd:b>num</xd:b> or
          <xd:b>formula</xd:b> ancestor element (one of these does not have to be an
        immediate parent, just an ancestor). If the output <xd:b>frac</xd:b> does not have
        such an ancestor, then a parent <xd:b>num</xd:b> element must be created to
        contain the <xd:b>frac</xd:b>.</xd:p>
         <xd:p>Within <xd:i>frac</xd:i> the child <xd:i>numer</xd:i> becomes <xd:b>numer</xd:b> 
      	and the child <xd:i>denom</xd:i> becomes <xd:b>denom</xd:b>. Both <xd:b>numer</xd:b> 
      	and <xd:b>denom</xd:b> are required children of <xd:b>frac</xd:b>.
        </xd:p>
         <xd:p>
            <xd:b>Source XML where <xd:i>num</xd:i> occurs as parent of <xd:i>frac</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;&lt;text&gt;...&lt;num&gt;
&lt;frac&gt;
	&lt;numer&gt;2&lt;/numer&gt;
	&lt;denom&gt;5&lt;/denom&gt;
&lt;/frac&gt;
&lt;/num&gt;...&lt;/text&gt;&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;&lt;text&gt;...&lt;num&gt;
&lt;frac&gt;
	&lt;numer&gt;2&lt;/numer&gt;
	&lt;denom&gt;5&lt;/denom&gt;
&lt;/frac&gt;
&lt;/num&gt;...&lt;/text&gt;&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML where <xd:i>frac</xd:i> occurs outside of <xd:i>num</xd:i> (has no ancestor that is <xd:i>num</xd:i>)</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;&lt;text&gt;Given the ratio
&lt;frac&gt;
	&lt;numer&gt;3&lt;/numer&gt;
	&lt;denom&gt;7&lt;/denom&gt;
&lt;/frac&gt; then the ...&lt;/text&gt;&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;&lt;text&gt;Given the ratio 
&lt;num&gt;
&lt;frac&gt;
	&lt;numer&gt;3&lt;/numer&gt;
	&lt;denom&gt;7&lt;/denom&gt;
&lt;/frac&gt;
&lt;/num&gt; then the ...&lt;/text&gt;&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML where <xd:i>emph</xd:i> occurs as parent of <xd:i>frac</xd:i> and the <xd:i>frac</xd:i> itself contains a nested <xd:i>frac</xd:i>.</xd:b>
         </xd:p>
         <xd:pre>

&lt;title&gt;...&lt;emph&gt;
&lt;!-- This is the outer &lt;frac&gt;. --&gt;
&lt;frac&gt;
 &lt;numer&gt;
    &lt;!-- This is a nested &lt;frac&gt;. --&gt;
   &lt;frac&gt;
     &lt;numer&gt;3&lt;/numer&gt;
     &lt;denom&gt;8&lt;/denom&gt;
   &lt;/frac&gt;
 &lt;/numer&gt;
 &lt;denom&gt;7&lt;/denom&gt;
&lt;/frac&gt;
&lt;/emph&gt;...&lt;/title&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph&gt;
&lt;!-- 
      This &lt;num&gt; is created to contain the outer &lt;frac&gt;, 
      since otherwise this &lt;frac&gt; would have no ancestor that is &lt;num&gt;.
--&gt;
&lt;num&gt;
&lt;frac&gt;
 &lt;numer&gt;
    &lt;!-- 
          Note the nested &lt;frac&gt; is not wrapped in another &lt;num&gt;, 
          since it already has an ancestor that is &lt;num&gt;. 
    --&gt;
   &lt;frac&gt;
     &lt;numer&gt;3&lt;/numer&gt;
     &lt;denom&gt;8&lt;/denom&gt;
   &lt;/frac&gt;
 &lt;/numer&gt;
 &lt;denom&gt;7&lt;/denom&gt;
&lt;/frac&gt;
&lt;/num&gt;
&lt;/emph&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!-- 2017-10-04 - MDS: added 'or parent:fracor' to match modified monolith. -->
   <!-- 2017-10-06 - JL: added 'or parent:frac' to match modified monolith for HK01. -->
   <xsl:template match="frac[parent::num or ancestor::formula or ancestor::dispformula or parent::fracor or parent::frac]"><!--  Original Target XPath:  num/frac   -->
      <frac>
         <xsl:apply-templates select="@* | node()"/>
      </frac>
   </xsl:template>

   <xsl:template match="frac[not(parent::num or ancestor::formula or ancestor::dispformula or parent::frac)]"><!--  Original Target XPath:  num/frac   -->
      <num>
         <frac>
            <xsl:apply-templates select="@* | node()"/>
         </frac>
      </num>
   </xsl:template>

   <xsl:template match="numer"><!--  Original Target XPath:  numer   -->
      <numer>
         <xsl:apply-templates select="@* | node()"/>
      </numer>
   </xsl:template>

   <xsl:template match="denom"><!--  Original Target XPath:  denom   -->
      <denom>
         <xsl:apply-templates select="@* | node()"/>
      </denom>
   </xsl:template>
   <!-- end topichead  num_frac  -->   <!-- Rosetta element: org -->   <!-- <topicref href="../../common_newest/Rosetta_org-to-LexisAdvance_entity_org.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>org</xd:i> becomes <xd:b>entity:org</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
 &lt;text&gt;
  &lt;org&gt;Judges Chambers&lt;/org&gt;
 &lt;/text&gt;
&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
 &lt;text&gt;
  &lt;entity:org&gt;Judges Chambers&lt;/entity:org&gt;
 &lt;/text&gt;
&lt;/p&gt;

	</xd:pre>
         <!--Changes2013-03-14: Created.-->
         <!--  <xsltinclusion>
      <xsl:stylesheet version="2.0">
        <!-\- BRT: the following template is in entity.xsl, match="org" in xsl:otherwise choice. I did not split this out in entity.xsl - left 'as is' -\->
        <xsl:template match="org">
          <xsl:element name="entity:org">
              <xsl:apply-templates/>
          </xsl:element>
        </xsl:template>
      </xsl:stylesheet>
    </xsltinclusion>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_org-to-LexisAdvance_entity_org.dita  -->
   <!-- BRT: the following template is in entity.xsl, match="org" in xsl:otherwise choice. I did not split this out in entity.xsl - left 'as is' -->
   <xsl:template match="org">
      <xsl:element name="entity:org">
         <xsl:apply-templates/>
      </xsl:element>
   </xsl:template>
   <!-- Vikas Rohilla : Template to match the org -->
   <xsl:template match="org[child::remotelink][parent::contrib[parent::comm:info]]">
      <xsl:apply-templates select="@*|node()"/>
   </xsl:template>
   <!-- start topichead  p  -->   <!-- <topicref href="../../common_newest/Rosetta_p-LxAdv-p.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>Except where otherwise noted, <xd:i>p</xd:i> becomes
                        <xd:b>p</xd:b> comes with <xd:i>@indent</xd:i> becomes
                        <xd:b>@indent</xd:b>. <xd:b>@indent</xd:b> has tokenized
                    value in NewLexis schema. And <xd:i>p/@style</xd:i> becomes
                        <xd:b>p/@align</xd:b>. <xd:b>@align</xd:b> has tokenized
                    value in NewLexis Schema. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;p indent="hang"&gt; &lt;text&gt;Note: There is no
                    penalty for this Rule.&lt;/text&gt;&lt;/p&gt; &lt;/blockquote&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;p indent="hang"&gt; &lt;text&gt;Note: There is no
                    penalty for this Rule.&lt;/text&gt; &lt;/p&gt; &lt;/blockquote&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>If <xd:i>p</xd:i> comes with <xd:i>@i</xd:i> then
                        <xd:i>@i</xd:i> will get dropped in NewLexis.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;p i="3.5" indent="hang"&gt; &lt;text&gt;Note:
                    There is no penalty for this Rule.&lt;/text&gt;&lt;/p&gt; &lt;/blockquote&gt;
                </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;blockquote&gt; &lt;p indent="hang"&gt; &lt;text&gt;Note: There is no
                    penalty for this Rule.&lt;/text&gt; &lt;/p&gt; &lt;/blockquote&gt; </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>If <xd:i>p</xd:i> comes with <xd:i>@nl</xd:i> this means the
                        <xd:b>p</xd:b> should start with the same number of
                        <xd:b>proc:nl</xd:b> elements before any text content in order to
                    maintain vertical white space.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p nl="1"&gt; &lt;text&gt; &lt;emph typestyle="bf"&gt;EDITORIAL
                    NOTE&lt;/emph&gt; ... &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;proc:nl/&gt; &lt;emph
                    typestyle="bf"&gt;EDITORIAL NOTE&lt;/emph&gt; ... &lt;/text&gt; &lt;/p&gt;
                </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>p</xd:i> comes with <xd:i>@nl=0</xd:i>, this means
                the first <xd:i>&lt;nl/&gt;</xd:i> encountered within the
                    <xd:i>&lt;p&gt;</xd:i> should be omitted.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p nl="0"&gt; &lt;text&gt; &lt;nl/&gt; &lt;ci:cite
                    searchtype="LEG-REF"&gt; &lt;ci:content&gt;Companies Code (NSW)
                    s129&lt;/ci:content&gt; &lt;/ci:cite&gt; &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;lnci:cite&gt; &lt;lnci:content&gt;Companies
                    Code (NSW) s129&lt;/lnci:content&gt; &lt;/lnci:cite&gt; &lt;/text&gt; &lt;/p&gt;
                </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p style="right"&gt; &lt;text&gt;&lt;emph typestyle="it"&gt;Last
                    updated: June 2011&lt;/emph&gt;&lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p align="right"&gt; &lt;text&gt;&lt;emph typestyle="it"&gt;Last
                    updated: June 2011&lt;/emph&gt;&lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Exceptional scenario for NZ07-Linxplus</xd:b>
         </xd:p>
         <xd:p>If <xd:i>p</xd:i> or <xd:i>p/@nl="0"</xd:i> is a child of
                        <xd:i>references</xd:i> element then merge all
                        <xd:i>p</xd:i> or <xd:i>p/@nl="0"</xd:i> in a single
                        <xd:b>p</xd:b> in target. Also all occurences of
                        <xd:i>nl</xd:i> within <xd:i>text</xd:i> becomes
                        <xd:b>proc:nl</xd:b>. Refer below example.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;references referencetype="statutes"&gt; &lt;p&gt; &lt;text&gt;
                    &lt;process-ignore process="kwd"&gt; &lt;emph typestyle="bf"&gt;References to
                    Legislation&lt;/emph&gt; &lt;/process-ignore&gt; &lt;/text&gt; &lt;/p&gt; &lt;p
                    nl="0"&gt; &lt;text&gt;&lt;ci:cite
                    searchtype="LEG-REF"&gt;&lt;ci:content&gt;&lt;citefragment
                    searchtype="LEG-NAME-REF"&gt;&lt;remotelink service="DOC-ID" dpsi="0069"
                    remotekey1="REFPTID" refpt="2000A38"&gt;Bail Act
                    2000&lt;/remotelink&gt;&lt;/citefragment&gt;&lt;/ci:content&gt;&lt;/ci:cite&gt;
                    &lt;ci:cite searchtype="LEG-REF"&gt;&lt;ci:content&gt;&lt;citefragment
                    searchtype="LEG-PROV-REF"&gt;&lt;remotelink service="DOC-ID" dpsi="0069"
                    remotekey1="REFPTID"
                    refpt="2000A38S8"&gt;s8&lt;/remotelink&gt;&lt;/citefragment&gt;&lt;/ci:content&gt;&lt;/ci:cite&gt;,
                    &lt;ci:cite searchtype="LEG-REF"&gt;&lt;ci:content&gt;&lt;citefragment
                    searchtype="LEG-PROV-REF"&gt;&lt;remotelink service="DOC-ID" dpsi="0069"
                    remotekey1="REFPTID" refpt="2000A38S13"
                    &gt;s13&lt;/remotelink&gt;&lt;/citefragment&gt;&lt;/ci:content&gt;&lt;/ci:cite&gt;&lt;/text&gt;
                    &lt;/p&gt; &lt;p nl="0"&gt; &lt;text&gt; &lt;nl/&gt; &lt;ci:cite
                    searchtype="LEG-REF"&gt; &lt;ci:content&gt; &lt;citefragment
                    searchtype="LEG-NAME-REF"&gt; &lt;remotelink service="DOC-ID" dpsi="0069"
                    remotekey1="REFPTID" refpt="1975A116"&gt;Misuse of Drugs Act
                    1975&lt;/remotelink&gt; &lt;/citefragment&gt; &lt;/ci:content&gt;
                    &lt;/ci:cite&gt; &lt;/text&gt; &lt;/p&gt; &lt;p nl="0"&gt; &lt;text&gt;
                    &lt;nl/&gt; &lt;ci:cite searchtype="LEG-REF"&gt; &lt;ci:content&gt;
                    &lt;citefragment searchtype="LEG-NAME-REF"&gt; &lt;remotelink service="DOC-ID"
                    dpsi="0069" remotekey1="REFPTID" refpt="2002A9"&gt;Sentencing Act
                    2002&lt;/remotelink&gt; &lt;/citefragment&gt; &lt;/ci:content&gt;
                    &lt;/ci:cite&gt; &lt;ci:cite searchtype="LEG-REF"&gt; &lt;ci:content&gt;
                    &lt;citefragment searchtype="LEG-PROV-REF"&gt; &lt;remotelink service="DOC-ID"
                    dpsi="0069" remotekey1="REFPTID" refpt="2002A9S65"&gt;s65&lt;/remotelink&gt;
                    &lt;/citefragment&gt; &lt;/ci:content&gt; &lt;/ci:cite&gt; &lt;/text&gt;
                    &lt;/p&gt; &lt;/references&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;ref:relatedrefs referencetype="statutes"&gt; &lt;bodytext&gt;
                    &lt;p&gt; &lt;text&gt; &lt;emph typestyle="bf"&gt;References to
                    Legislation&lt;/emph&gt; &lt;/text&gt; &lt;text&gt; &lt;lnci:cite
                    type="legislation"&gt; &lt;lnci:content&gt; &lt;ref:crossreference
                    crossreferencetype="seeAlso"&gt; &lt;ref:content&gt;Bail Act
                    2000&lt;/ref:content&gt; &lt;ref:locator&gt; &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt; &lt;ref:key-value value="0069-2000A38"/&gt;
                    &lt;/ref:locator-key&gt; &lt;/ref:locator&gt; &lt;/ref:crossreference&gt;
                    &lt;/lnci:content&gt; &lt;/lnci:cite&gt; &lt;lnci:cite type="legislation"&gt;
                    &lt;lnci:content&gt; &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
                    &lt;ref:content&gt;s8&lt;/ref:content&gt; &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt; &lt;ref:key-name name="DOC-ID"/&gt; &lt;ref:key-value
                    value="0069-2000A38S8"/&gt; &lt;/ref:locator-key&gt; &lt;/ref:locator&gt;
                    &lt;/ref:crossreference&gt; &lt;/lnci:content&gt; &lt;/lnci:cite&gt;,
                    &lt;lnci:cite type="legislation"&gt;&lt;lnci:content&gt; &lt;ref:crossreference
                    crossreferencetype="seeAlso"&gt; &lt;ref:content&gt;s13&lt;/ref:content&gt;
                    &lt;ref:locator&gt; &lt;ref:locator-key&gt; &lt;ref:key-name name="DOC-ID"/&gt;
                    &lt;ref:key-value value="0069-2000A38S13"/&gt; &lt;/ref:locator-key&gt;
                    &lt;/ref:locator&gt; &lt;/ref:crossreference&gt; &lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt; &lt;proc:nl/&gt; &lt;lnci:cite type="legislation"&gt;
                    &lt;lnci:content&gt; &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
                    &lt;ref:content&gt;Misuse of Drugs Act 1975&lt;/ref:content&gt;
                    &lt;ref:locator&gt; &lt;ref:locator-key&gt; &lt;ref:key-name name="DOC-ID"/&gt;
                    &lt;ref:key-value value="0069-1975A116"/&gt; &lt;/ref:locator-key&gt;
                    &lt;/ref:locator&gt; &lt;/ref:crossreference&gt; &lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt; &lt;proc:nl/&gt; &lt;lnci:cite type="legislation"&gt;
                    &lt;lnci:content&gt; &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
                    &lt;ref:content&gt;Sentencing Act 2002&lt;/ref:content&gt; &lt;ref:locator&gt;
                    &lt;ref:locator-key&gt; &lt;ref:key-name name="DOC-ID"/&gt; &lt;ref:key-value
                    value="0069-2002A9"/&gt; &lt;/ref:locator-key&gt; &lt;/ref:locator&gt;
                    &lt;/ref:crossreference&gt; &lt;/lnci:content&gt; &lt;/lnci:cite&gt;
                    &lt;lnci:cite type="legislation"&gt; &lt;lnci:content&gt; &lt;ref:crossreference
                    crossreferencetype="seeAlso"&gt; &lt;ref:content&gt;s65&lt;/ref:content&gt;
                    &lt;ref:locator&gt; &lt;ref:locator-key&gt; &lt;ref:key-name name="DOC-ID"/&gt;
                    &lt;ref:key-value value="0069-2002A9S65"/&gt; &lt;/ref:locator-key&gt;
                    &lt;/ref:locator&gt; &lt;/ref:crossreference&gt; &lt;/lnci:content&gt;
                    &lt;/lnci:cite&gt; &lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt;
                    &lt;/ref:relatedrefs&gt; </xd:pre>
         <xd:p>
            <xd:p>
               <xd:b>Note: </xd:b>If source document is having the input scenario
                            "<xd:i>pgrp/p/leg:histnote</xd:i>" then conversion needs to
                        drop '<xd:i>p</xd:i>' markup in target conversion and target
                        mapping xpath is
                        "<xd:b>pgrp/note[@notetype="historical"]</xd:b>".</xd:p>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>For Stream 'HK06'</xd:p>
         <xd:p> When the source has <xd:i>deflist/defitem/p/text</xd:i> then omit
                        <xd:i>p/text</xd:i> and retain <xd:i>defitem</xd:i>.
                </xd:p>
         <!--Changes2014-03-14: Removed Colons from Labels.. DB item
                        #12552012-10-05: Removed @i from the example.2013-03-14: Add instruction and example
                            p/@style.2013-10-09: Added instruction and example
                            p comes with
                    @nl=0.2013-10-25: Added instruction and example
                            p/@nl="0" comes in
                            references.2013-11-21: Updated instruction and example
                            p or p/@nl="0" comes in
                            references, this change directly affects
                        NZ07.2013-12-04: Updated target example when
                            p or p/@nl="0" comes in
                            references, this change directly affects
                        NZ07.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-LxAdv-p.dita  -->
   <!-- BRT: this template is the otherwise condition in match="p" in base.xsl. 
                 The rules in this topic for handling @nl are different than the existing XSLT, which ignores and suppresses the element. 
                 Adding template match="p[@nl!='']/text" to handle this rule. *** Also, did not address NZ07 exception scenario** 
                 
       JL: seems like the @nl handling  will not behave properly unless we move it to the text template.  
        I moved it to XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_text-LxAdv-text-with-test-for-whitespace-content.xsl
        PLEASE LOOK THERE!!!!!! IF YOU NEED TO ADD IT TO ANOTHER MODULE FOR ELEMENT <text> WE MIGHT WANT TO FURTHER MODULARIZE IT -->
   <xsl:template match="p">
      <xsl:variable name="docinfoidtext" select="/*/docinfo/docinfo:doc-id/text()"/>
      <xsl:choose><!-- Priya Kaushal: Added below code for UK 15 -->
         <xsl:when test="parent::references[$streamID = 'UK15']">
            <bodytext>
               <p>
                  <xsl:apply-templates select="@* | node()"/>
               </p>
            </bodytext>
         </xsl:when>
         <xsl:when test="parent::in:body[$streamID = 'AU16']">
            <p>
               <xsl:apply-templates select="node()"/>
            </p>
         </xsl:when>
         <xsl:when test="parent::in:body">
            <bodytext>
               <p>
                  <xsl:apply-templates select="node()"/>
               </p>
            </bodytext>
         </xsl:when>
         <!-- Vikas Rohilla : Included for the stream UK12          -->
         <xsl:when test="parent::blockquote[$streamID = 'UK12']">
            <p>
               <xsl:apply-templates select="@* | refpt, node() except refpt"/>
            </p>
         </xsl:when>
         <xsl:when test="child::text/child::note[@notetype!='xref'][$streamID = 'UK12']">
            <xsl:apply-templates select="@* | refpt, node() except refpt"/>
         </xsl:when>
         <xsl:when test="(parent::frm:div                  | parent::frm:body                  | parent::clause[ancestor::frm:div | ancestor::frm:body]                  | parent::li[ancestor::frm:body and not(parent::l/parent::entry)])[not(ancestor::footnote or ancestor::note)]                 [$streamID = ('NZ11','AU10')]">
            <form:p>
               <xsl:if test="not(@style) and child::text[1]/@align[.!='']">
                  <xsl:copy-of select="child::text[1]/@align"/>
               </xsl:if>
               <xsl:apply-templates select="@* | refpt, node() except refpt"/>
            </form:p>
         </xsl:when>
         <xsl:when test="(parent::frm:div | parent::frm:body | parent::clause[ancestor::frm:div | ancestor::frm:body] | parent::li[ancestor::frm:body])[not(ancestor::footnote or ancestor::note)][$streamID = 'UK12']">
            <form:p>
               <xsl:if test="not(@style) and child::text[1]/@align[.!='']">
                  <xsl:copy-of select="child::text[1]/@align"/>
               </xsl:if>
               <xsl:apply-templates select="@* | refpt, node() except refpt"/>
            </form:p>
         </xsl:when>
         <xsl:when test="(parent::sigblock[ancestor::frm:div | ancestor::frm:body])[not(ancestor::footnote)][$streamID = 'UK12']">
            <form:line>
               <xsl:apply-templates select="@* | node()"/>
            </form:line>
         </xsl:when>
         <!-- MDS - occurs in HK04 -  child is leg:histnote then the p element is not output and simply passed through.-->
         <!-- JL revised to handle the many scenarios when p has other children than leg:histnote
            also revised to strip the p wrapper in certain conditions when legfragment is a child
            -->
         <xsl:when test="leg:histnote | blockquote[legfragment and not(child::*[2])][parent::p[parent::*:bodytext or parent::pgrp or parent::li or parent::fnbody or parent::glp:note or parent::case:judgmentbody or parent::case:appendix]]"><!--<xsl:apply-templates select="node()"/>-->
            <xsl:for-each-group select="*"
                                group-adjacent="                     if (self::leg:histnote or self::blockquote[legfragment and not(child::*[2])][parent::p[parent::*:bodytext or parent::pgrp or parent::li or parent::fnbody or parent::glp:note or parent::case:judgmentbody or parent::case:appendix]]) then                             0                         else                             1">
               <xsl:choose>
                  <xsl:when test="current-grouping-key() = 0">
                     <xsl:apply-templates select="current-group()"/>
                  </xsl:when>
                  <!--Satbir: Added below template for changing order of reft before desig in NZ03 only-->
                  <xsl:when test="$streamID = 'NZ03'">
                     <p>
                        <xsl:apply-templates select="following-sibling::refpt[preceding-sibling::pnum]"/>
                        <xsl:for-each select="current-group()">
                           <xsl:apply-templates select="current() except self::refpt"/>
                        </xsl:for-each>
                     </p>
                  </xsl:when>
                  <xsl:otherwise>
                     <p>
                        <xsl:apply-templates select="parent::p/@*"/>
                        <xsl:if test="not(parent::p/@style)">
                           <xsl:copy-of select="parent::p/text[1]/@align"/>
                        </xsl:if>
                        <!-- MDS 2017-08-08 Added handling for refpt to reorder in output-->
                        <xsl:apply-templates select="current-group()[self::refpt]"/>
                        <xsl:for-each select="current-group()">
                           <xsl:apply-templates select=". except(self::refpt)"/>
                        </xsl:for-each>
                     </p>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:for-each-group>
         </xsl:when>
         <!-- JL: funky NZ07 case where we collapse p or p[@nl='0'] element children of references 
            full logic isn't given but I assume we don't do the collapse if the reference has any non-p children or if 
            references has any p children where the @nl value is not zero or we're going to be here all year -->
         <xsl:when test="parent::references[not(child::*[not(self::p[@nl = '0' or not(@nl)])])] and starts-with($streamID, 'NZ07') and (not(@nl) or @nl = '0') and not(preceding-sibling::p)">
            <xsl:element name="p"
                         namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"><!-- JL this "if" condition that moves text align att value to the parent p is generic and cannot be used for CA -->
               <xsl:apply-templates select="@*"/>
               <xsl:if test="not(@style) and child::text[@align[. != '']] and not(child::text[2]) and not(starts-with($streamID, 'CA'))">
                  <xsl:attribute name="align">
                     <xsl:value-of select="text/@align"/>
                  </xsl:attribute>
               </xsl:if>
               <!-- JL: the sample seems to indicate they want to collapse some of the text child elements too, 
                        but doesn't give the logic for doing that so I'm GUESSING based on the sample!
                        My guess at the logic used: if the @nl has the same value as (or is missing the same as) the previous p, then collapse 
                        text element children too.                          
                        This needs to be very carefully tested when we test  NZ07 data.
                    
                    -->
               <xsl:choose>
                  <xsl:when test="child::*[not(self::text)] or following-sibling::p[child::*[not(self::text)]]">
                     <xsl:apply-templates select="refpt | following-sibling::p/refpt"/>
                     <xsl:apply-templates select="*[not(self::refpt)] | text()"/>
                     <!-- if any p elements have ANY child elements other than <text>, don't merge child text nodes. cleaner -->
                     <xsl:for-each select="following-sibling::p">
                        <xsl:apply-templates select="*[not(self::refpt)] | text()"/>
                     </xsl:for-each>
                  </xsl:when>
                  <xsl:otherwise><!-- can assume p has only text children, yay! And we have also whittled the possibilities down to "p contains an nl att or not" -->
                     <xsl:for-each-group select="self::p | following-sibling::p" group-adjacent="exists(@nl)">
                        <xsl:element name="text"
                                     namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                           <xsl:apply-templates select="current-group()[1]/text[1]/@*"/>
                           <xsl:for-each select="current-group()">
                              <xsl:apply-templates select="text/node()"/>
                           </xsl:for-each>
                        </xsl:element>
                     </xsl:for-each-group>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:element>
         </xsl:when>
         <!-- suppresses context nodes already accessed in previous condition -->
         <xsl:when test="parent::references[not(child::*[not(self::p[@nl = '0' or not(@nl)])])] and starts-with($streamID, 'NZ07') and (not(@nl) or @nl = '0') and preceding-sibling::p"/>
         <xsl:when test="starts-with($streamID, 'CA') and count(text) &gt; 1 and not(@style) and text[@align]">
            <xsl:for-each-group select="*" group-adjacent="concat('', @align)">
               <xsl:element name="p"
                            namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                  <xsl:apply-templates select="parent::p/@*"/>
                  <xsl:copy-of select="@align"/>
                  <xsl:for-each select="current-group()">
                     <xsl:apply-templates select="."/>
                  </xsl:for-each>
               </xsl:element>
            </xsl:for-each-group>
         </xsl:when>
         <!-- Awantika: conditional change for AU20, using double slashes as full path is not working here  -->
         <xsl:when test="//source_cttr:annotations/child::heading/note/h[. = 'ActName' or . = 'Act Name'] and $streamID = 'AU20'">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:when test="parent::bodytext[$streamID = 'CA12']">
            <p>
               <xsl:if test="child::text/ci:cite[not(preceding::p/text/ci:cite)] and not(child::text/@searchtype='CASE-NAME')">
                  <ref:anchor>
                     <xsl:attribute name="id">dict-CASENAME-CITE</xsl:attribute>
                     <xsl:attribute name="anchortype">local</xsl:attribute>
                  </ref:anchor>
               </xsl:if>
               <xsl:apply-templates select="node()"/>
            </p>
         </xsl:when>
         <!-- 2017-10-17 - MDS: Added due to Webstar 7025682 -->
         <xsl:when test="parent::l[$streamID='UK12']">
            <listitem>
               <bodytext>
                  <p>
                     <xsl:apply-templates select="@* | node()"/>
                  </p>
               </bodytext>
            </listitem>
         </xsl:when>
         <xsl:when test="$streamID='UK22CF' and parent::legfragment and (preceding-sibling::leg:prelim or preceding-sibling::leg:info)">
            <xsl:element name="primlaw:bodytext">
               <xsl:element name="p">
                  <xsl:apply-templates select="refpt"/>
                  <xsl:apply-templates select="*[not(self::refpt)] | text()"/>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:when test="$streamID='HK07' and parent::bodytext[parent::level[@leveltype='prec' or @leveltype='prec.grp' or @leveltype='precgrp' or @leveltype='precgrp1' or @leveltype='precgrp2' or parent::comm.chap or ancestor::level[@leveltype = 'prec.grp']]]">
            <form:p>
               <xsl:apply-templates select="node() except inlineobject"/>
            </form:p>
         </xsl:when>
         <!--    <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and ancestor::source_cttr:annotations[not(@annotgroup='prov-al')]/heading/note[descendant::lnlink/marker['List of Provisions' or 'Defined Terms' or 'Government Website'][not(@id='OI13')]] | source_cttr:annotations[not(@annotgroup='prov-al')]/heading/remotelink">
                <xsl:apply-templates/>
            </xsl:when>-->
         <!-- Awantika:2018-02-15- mapping refpt inside <p>. Webstar # 7116564 -->
         <xsl:when test="$streamID='CA02CC' and preceding-sibling::heading[child::title/refpt]">
            <p>
               <xsl:apply-templates select="/CASEDOC/case:body/case:headnote/case:decisionsummary/heading/title/refpt"/>
               <xsl:apply-templates/>
            </p>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose><!-- Awantika: 2017-10-26- Added the condition to check multiple text/@align in one p
                   as per CI instructions which is currently only for Canada applying for HK07. 
                   Creating seperate <p> for each text/@align.-->
               <xsl:when test="count(child::text/@align) &gt;= 1 and $streamID='HK07'">
                  <xsl:for-each select="child::*">
                     <xsl:element name="p">
                        <xsl:if test="self::*[1]/@align">
                           <xsl:attribute name="align">
                              <xsl:value-of select="self::*[1]/@align"/>
                           </xsl:attribute>
                        </xsl:if>
                        <xsl:apply-templates select="self::*"/>
                     </xsl:element>
                  </xsl:for-each>
               </xsl:when>
               <!-- Awantika:2017-10-27: p/text will be converted to <textitem> for AU20 for specific scenario -->
               <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'history') and /CITATORDOC/source_cttr:body/source_cttr:content/source_cttr:annotations/heading/note[@id='HI4']| /CITATORDOC/source_cttr:body/source_cttr:content/source_cttr:annotations/heading/title[.='Assent']">
                  <xsl:apply-templates select="@* | node()"/>
               </xsl:when>
               <!--Satbir: Added mdule for handling glp:note under p/text-->
               <xsl:when test="$streamID='NZ03' and child::text/child::glp:note[not(child::node except glp:note)][ancestor::case:judgmentbody]">
                  <xsl:apply-templates select="child::text/child::glp:note"/>
               </xsl:when>
               <!-- Awntika: 2017-12-13- Updated for webstar# 7065522 -->
               <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and parent::note[ancestor::source_cttr:annotations[@id='OI2']/heading/title[.,'Former Title']]">
                  <xsl:apply-templates select="node()"/>
               </xsl:when>
               <xsl:otherwise>
                  <p><!-- JL this "if" condition that moves text align att value to the parent p is generic and cannot be used for CA -->
                     <xsl:apply-templates select="@*"/>
                     <!-- <xsl:if
                        test="not(@style) and child::text[@align[. != '']] and not(child::text[2]) and not(starts-with($streamID, 'CA'))">
                        <xsl:attribute name="align">
                            <xsl:value-of select="text/@align"/>
                        </xsl:attribute>
                    </xsl:if>-->
                     <!--                   Chaitanya :Making the for the P/@align as CA08 require this change, Luckabaugh, Joy H. (LNG-HBE) <Joy.Luckabaugh@lexisnexis.com> has approved to change this module  -->
                     <xsl:if test="not(@style) and child::text[@align[. != '']] and not(child::text[2])">
                        <xsl:attribute name="align">
                           <xsl:value-of select="text/@align"/>
                        </xsl:attribute>
                     </xsl:if>
                     <!-- JD: 2017-07-25: modifying the above for NZ18 create @align from only the first text/align so as to not concat -->
                     <xsl:if test="not(@style) and child::text[@align[. != '']]                    and $streamID=('NZ18','AU04','NZ13')">
                        <xsl:attribute name="align"><!-- take the @align from the first child <text> (don't concatenate all child text/@align values) -->
                           <xsl:value-of select="text[1]/@align"/>
                        </xsl:attribute>
                     </xsl:if>
                     <!-- Vikas Rohilla : Created desig altdesig before other element to meet schema ordering                  -->
                     <!-- create ref:anchor before other elements to meet schema ordering -->
                     <xsl:if test="not($streamID=('UK06','UK07'))">
                        <xsl:apply-templates select="(refpt | text/refpt), edpnum, pnum"/>
                     </xsl:if>
                     <!-- the above is the wrong order for legis and regulation if pnum goes to desig and edpnum goes to altdesig  -->
                     <xsl:if test="$streamID=('UK06','UK07')">
                        <xsl:apply-templates select="(refpt | text/refpt), pnum, edpnum"/>
                     </xsl:if>
                     <!-- JD: 2017-07-31: added loop in order to properly wrap p/link elements and proces other children when present -->
                     <xsl:for-each select="*">
                        <xsl:choose><!--SS: Added this condition for p/link becomes p/text/ref:lnlink - HK07--><!-- JD: 2017-07-28: this produces an extra <text> when there is a child <link> AND a child <text>;
                		adding "and not(child::text)" -->
                           <xsl:when test="self::link">
                              <xsl:element name="text"><!--<xsl:apply-templates />-->
                                 <xsl:call-template name="generic-link"/>
                              </xsl:element>
                              <!--SS: Added "except link" condition for handling p/link - HK07-->
                              <!--<xsl:apply-templates
                					select="*[not(self::refpt | self::edpnum | self::pnum)] except link | text()"/>-->
                           </xsl:when>
                           <!--SS: Added template for converting images from inline to figure/inline-->
                           <!-- Awantika: 2018-01-12- inlineobject was getting dropped when coming in text for AU01. -->
                           <xsl:when test="child::inlineobject[$streamID=('AU18','AU01')]">
                              <text>
                                 <xsl:apply-templates/>
                              </text>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:apply-templates select=".[not(self::refpt | self::edpnum | self::pnum)]"/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:for-each>
                     <!-- Vikas Rohilla : Created desig altdesig before other element to meet schema ordering                  -->
                     <!-- create ref:anchor before other elements to meet schema ordering -->
                     <!--<xsl:apply-templates select="(refpt | text/refpt), edpnum, pnum"/>
                    <!-\-SS: Added "except link" condition for handling p/link - HK07-\->
                	<!-\- JD: removing 'except link' -\->
                		<xsl:apply-templates
                			select="*[not(self::refpt | self::edpnum | self::pnum)] except link | text()"/>-->
                     <xsl:if test="note[@notetype='xref'] and $streamID='UK11DN'">
                        <xsl:for-each-group select="*" group-adjacent="if (self::note) then 1 else 0">
                           <xsl:choose>
                              <xsl:when test="current-grouping-key()=1"><!--  <xsl:apply-templates select="ancestor::p/text"/>-->
                                 <text>
                                    <marginnote>
                                       <ref:anchor>
                                          <xsl:attribute name="id">
                                             <xsl:value-of select="generate-id()"/>
                                          </xsl:attribute>
                                          <xsl:attribute name="anchortype">
                                             <xsl:text>local</xsl:text>
                                          </xsl:attribute>
                                       </ref:anchor>
                                       <bodytext>
                                          <xsl:for-each select="current-group()">
                                             <xsl:apply-templates select="@* | node()"/>
                                          </xsl:for-each>
                                       </bodytext>
                                    </marginnote>
                                 </text>
                              </xsl:when>
                           </xsl:choose>
                        </xsl:for-each-group>
                     </xsl:if>
                  </p>
               </xsl:otherwise>
            </xsl:choose>
            <xsl:for-each select="following-sibling::level">
               <xsl:call-template name="following_p_level"/>
            </xsl:for-each>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="p/@i"><!-- suppress --></xsl:template>

   <xsl:template match="p/@nl"><!-- suppress --><!-- see module for handling text when parent p has @nl --></xsl:template>

   <xsl:template match="p/@ln.nsprefix"><!-- suppress --></xsl:template>

   <xsl:template match="p/@class"><!-- suppress --></xsl:template>

   <xsl:template match="p/@style">
      <xsl:choose>
         <xsl:when test=". = 'right' or . = 'left' or . = 'center'">
            <xsl:attribute name="align">
               <xsl:value-of select="."/>
            </xsl:attribute>
         </xsl:when>
         <xsl:otherwise>
            <xsl:message>'p' element 'style' attribute has unexpected and unmappable value
                        <xsl:value-of select="."/> and will be omitted on output.</xsl:message>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- Vikas Rohilla : Added template for the streamID CA01   -->   <!-- Sudhanshu Srivastava : Added streamID CA02CC -->
   <xsl:template match="p[parent::glp:note[parent::text]][$streamID = 'CA01' or $streamID = 'CA02CC' or $streamID = 'CA04']">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="p/@indent">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="p[parent::text][$streamID = 'UK12']">
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>
   <!-- Awantika: Added template to handle p/inlineobject in HK07 to p/text/ref:inlineobject
    JL: this isn't going to account for all scenarios; moved functionality to inlineobject templates-->   <!-- from text dita: <note><b>(For CANADA Content Stream only )</b>Only move the <sourcexml>
        text@align</sourcexml> to the parent <targetxml>p</targetxml> if it is the only
        text in <sourcexml>p</sourcexml>, Otherwise, wrap the <sourcexml>text</sourcexml>
        with <targetxml>p</targetxml> and move the <sourcexml>@align</sourcexml> attribute
        to the newly created <targetxml> p</targetxml>.</note>
    <section>
        <codeblock> &lt;p&gt; &lt;text&gt;Dated at Calgary, Alberta this 31 day of March
            1998.&lt;/text&gt; &lt;text&gt;The Honourable W. Kenneth Moore, Chief Justice of
            the Court of Queen's Bench of Alberta&lt;/text&gt; &lt;text
            align="center"&gt;ALBERTA RULES&lt;/text&gt; &lt;text&gt;Rules of practice made
            pursuant to subsection 745.64 of the Criminal Code to reflect the changes made
            to the Criminal Code regarding applications for reduction in the number of years
            of imprisonment without eligibility for parole.&lt;/text&gt; &lt;/p&gt; </codeblock>
        <b>Becomes</b>
        <codeblock> &lt;p&gt; &lt;text&gt;Dated at Calgary, Alberta this 31 day of March
            1998.&lt;/text&gt; &lt;text&gt;The Honourable W. Kenneth Moore, Chief Justice of
            the Court of Queen's Bench of Alberta&lt;/text&gt; &lt;/p&gt; &lt;p
            align="center"&gt; &lt;text&gt;ALBERTA RULES&lt;/text&gt; &lt;/p&gt; &lt;p&gt;
            &lt;text&gt;Rules of practice made pursuant to subsection 745.64 of the Criminal
            Code to reflect the changes made to the Criminal Code regarding applications for
            reduction in the number of years of imprisonment without eligibility for
            parole.&lt;/text&gt; &lt;/p&gt; </codeblock>
    </section>-->   <!-- JL: seems like the @nl handling  will not behave properly unless we move it to the text template.  
        I moved it to XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_text-LxAdv-text-with-test-for-whitespace-content.xsl
        PLEASE LOOK THERE!!!!!! IF YOU NEED TO ADD IT TO ANOTHER MODULE FOR ELEMENT <text> -->   <!-- BRT: included this specific text match template because it's part of p[@nl]. Added this template -->   <!--    <xsl:template match="p[@nl != '']/text">
        <xsl:element name="text">
            <xsl:apply-templates select="@*"/>           
            <!-\- BRT add number of nl that are in p/@nl -\->
            <xsl:call-template name="add_nl">
                <xsl:with-param name="length" select="parent::p/@nl"/>
                <xsl:with-param name="i" select="1"/>
            </xsl:call-template>

            <!-\- BRT remove hard-coded nl that are in source -\->
            <xsl:apply-templates select="*[not(self::nl)] | text()"/>
        </xsl:element>
    </xsl:template>



    <xsl:template name="add_nl">
        <xsl:param name="length" select="."/>
        <xsl:param name="i" select="1"/>
        <!-\- BRT: create <nl/> for each iteration of @nl value -\->
        <xsl:if test="$length &gt; 0">
            <xsl:element name="proc:nl"/>
            <xsl:call-template name="add_nl">
                <xsl:with-param name="length" select="$length - 1"/>
                <xsl:with-param name="i" select="$i + 1"/>
            </xsl:call-template>
        </xsl:if>
    </xsl:template>-->
   <xsl:template name="following_p_level">
      <xsl:choose>
         <xsl:when test="child::heading/title/refpt">
            <seclaw:level>
               <xsl:attribute name="leveltype">
                  <xsl:value-of select="@leveltype"/>
               </xsl:attribute>
               <xsl:apply-templates select="child::heading/title/refpt"/>
               <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
            </seclaw:level>
         </xsl:when>
      </xsl:choose>
   </xsl:template>
   <!-- JD: 2017-07-21: added trap for p containing only empty node or single whitespace to match DT output.
	e.g., 
	<p>
	  <text/>
	</p>
	-->
   <xsl:template match="p[text[not(node()) or (string() and not(normalize-space()) and not(*))] and count(*)=1 ]"/>
   <!-- 
		JD:		match p that has at least one element child, and don't have any children not named 'text', which doesn't have any text() or children not named 'br' 
		e.g.,
 		 <p>
				<text>
					<nl/>
					<nl/>
				</text>
			</p>
		taken from https://stackoverflow.com/questions/11438787/find-an-element-that-only-has-one-other-kind-of-child
	-->
   <xsl:template match="p[* and not(*[not(self::text[* and not(text()) and not(*[not(self::nl)])])])]"/>
   <!-- MDS 2017-08-11 - Added supression of completely empty paragraph elements.  Only for specific streams -->
   <xsl:template match="p[not(node())][$streamID = 'AU13']"/>
   <!-- <topicref href="../../common_newest/Rosetta_form_bodytext_p-LxAdv-form.p.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>If <xd:i>p</xd:i> comes within <xd:i>/COMMENTARYDOC/comm:body/level/level/bodytext/form/bodytext/p</xd:i> then
                <xd:i>p</xd:i> becomes <xd:b>form:p</xd:b>. And if <xd:i>@indent</xd:i> occurred into the <xd:i>p</xd:i>
                then <xd:i>@indent</xd:i> becomes <xd:b>@indent</xd:b> and populated as follows:</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
                    
                    &lt;form&gt;
                    &lt;bodytext searchtype="FORM"&gt;
                    &lt;p&gt;&lt;text&gt;&lt;emph typestyle="bf"&gt;THIS AGREEMENT&lt;/emph&gt; is made on&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 2010&lt;/text&gt;&lt;/p&gt;
                    .......
                    .......
                    &lt;h align="center"&gt;1.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; The Independent Expert has been appointed by the parties under clause .. of the Agreement to assist in resolving the dispute or to resolve the dispute by determining the meaning of clause &amp;hellip;&amp;#160; of
                    the Agreement and also to determine which party or parties should pay the costs of and incidental to the resolution of the dispute.&lt;/h&gt;
                    &lt;h align="center"&gt;2.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; The Independent Expert has accepted the appointment, and will assist in determining or will determine the dispute in accordance with the terms of this agreement.&lt;/h&gt;
                    ........
                    ........
                    &lt;h align="center"&gt;&amp;#160;&lt;/h&gt;
                    &lt;/bodytext&gt;
                    &lt;/form&gt;
                    
                </xd:pre>
         <xd:b>Becomes</xd:b>
         <xd:pre>
                    
                    &lt;form:form&gt;
                    &lt;form:document annotated="false" official="false" typeofdoc="unnamed"&gt;
                    &lt;form:bodytext&gt;
                    &lt;form:p&gt;
                    &lt;form:text&gt;&lt;emph typestyle="bf"&gt;THIS AGREEMENT&lt;/emph&gt; is made on&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0; 2010&lt;/form:text&gt;&lt;/form:p&gt;
                    ......
                    ......
                    &lt;form:h align="center"&gt;1.&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;The Independent Expert has been appointed by the parties under clause .. of the Agreement to assist in resolving the
                    dispute or to resolve the dispute by determining the meaning of clause &amp;#x2026;&amp;#x00A0; of the Agreement and also to determine which party or parties should pay the costs of and
                    incidental to the resolution of the dispute.&lt;/form:h&gt;
                    &lt;form:h align="center"&gt;2.&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;The Independent Expert has accepted the appointment, and will assist in determining or will determine the dispute in accordance with the terms of this agreement.&lt;/form:h&gt;
                    ......
                    ......
                    &lt;form:h align="center"&gt;&amp;#x00A0;&lt;/form:h&gt;
                    &lt;/form:bodytext&gt;
                    &lt;/form:document&gt;
                    &lt;/form:form&gt;
                    
                </xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="p[(parent::blockquote|parent::bodytext)[not(ancestor::fnbody)][ancestor::form[ancestor::COMMENTARYDOC]]]"><!--  Original Target XPath:  form:p   -->
      <form:p>
         <xsl:apply-templates select="@* | node()"/>
      </form:p>
   </xsl:template>

   <xsl:template match="p[$streamID=('UK14', 'UK12')][(parent::blockquote)[ancestor::form[ancestor::COMMENTARYDOC]]]"
                 priority="2"><!-- WPK: form:p is not schema valid within blockquote -->
      <p>
         <xsl:apply-templates select="@* | node()"/>
      </p>
   </xsl:template>

   <xsl:template match="@indent"><!--  Original Target XPath:  @indent   -->
      <xsl:attribute name="indent">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_p_glp.note-LxAdv-bodytext_note.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
                If <xd:i>glp:note</xd:i> comes within <xd:i>p</xd:i> then <xd:b>note</xd:b> 
                would become part of <xd:b>bodytext</xd:b> as a sibling to <xd:b>p</xd:b>
            <xd:pre>
                    &lt;li&gt;&lt;lilabel&gt;(b)&lt;/lilabel&gt;
                    &lt;p&gt;&lt;text&gt;a copy of the certificate.&lt;/text&gt;&lt;/p&gt;&lt;!-- branch 2 --&gt;
                    &lt;p&gt;
                    &lt;glp:note&gt;
                    &lt;p&gt;&lt;text&gt;&lt;emph typestyle="it"&gt;&lt;emph typestyle="it"&gt;Note 1&lt;/emph&gt; If a form is approved under s&amp;#160;15 for this provision, the form must be used.&lt;/emph&gt;&lt;/text&gt;&lt;/p&gt;
                    &lt;/glp:note&gt;&lt;/p&gt;
                </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre>
                   &lt;listitem&gt;
                   &lt;label&gt;(b)&lt;/label&gt;
                   &lt;bodytext&gt;
                   &lt;p&gt;&lt;text&gt;a copy of the certificate.&lt;/text&gt;&lt;/p&gt;
                   &lt;note&gt;
                   &lt;bodytext&gt;
                   &lt;p&gt;&lt;text&gt;&lt;emph typestyle="it"&gt;&lt;emph typestyle="it"&gt;Note 1&lt;/emph&gt; If a form is approved under s&amp;#160;15 for this provision, the form must be used.&lt;/emph&gt;&lt;/text&gt;&lt;/p&gt;
                   &lt;/bodytext&gt;
                   &lt;/note&gt;
                   &lt;/bodytext&gt;
                    
                 </xd:pre>
         </xd:p>
         <xd:p>
            <xd:b>Added from Rosetta_defitem-LxAdv-deflist_defitem_desfdesc_bodytext.xsl</xd:b>
         </xd:p>
         <xd:p>
             If the source XML has <xd:i>deflist/defitem/glp:note</xd:i> it will be handled as <xd:b>deflist/defitem/defdesc/bodytext/note</xd:b>.
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
             
             &lt;deflist&gt;
             &lt;defitem&gt;
             ...
             &lt;glp:note&gt;
             &lt;p&gt;
             &lt;text&gt;
             &lt;emph typestyle="it"&gt;Note: The definition of
             &amp;ldquo;community corrections officer&amp;rdquo; is
             affected by section&amp;#160;10.&lt;/emph&gt;
             &lt;/text&gt;
             &lt;/p&gt;
             &lt;/glp:note&gt;
             &lt;/defitem&gt;
             &lt;/deflist&gt;
             
         </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
             
             &lt;deflist&gt;
             &lt;defitem&gt;
             ...
             &lt;defdesc&gt;
             &lt;bodytext&gt;
             &lt;note&gt;
             &lt;bodytext&gt;
             &lt;p&gt;
             &lt;text&gt;
             &lt;emph typestyle="it"&gt;Note: The definition of
             &amp;ldquo;community corrections officer&amp;rdquo; is
             affected by section&amp;#160;10.&lt;/emph&gt;
             &lt;/text&gt;
             &lt;/p&gt;
             &lt;/bodytext&gt;
             &lt;/note&gt;
             &lt;/bodytext&gt;
             &lt;/defdesc&gt;
             &lt;/defitem&gt;
             &lt;/deflist&gt;
             
         </xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!-- BRT: the following template is in base.xsl, match="p" in xsl:when test="child::glp:note" choice. I did not split this out in base.xsl - left 'as is' in when -->
   <xsl:template match="p[child::glp:note]"><!-- don't create p in LA if the child of p is glp:note. This won't work if there is more than glp:note that is a child of p -->
      <xsl:apply-templates/>
   </xsl:template>
   <!-- BRT: the following template is taken from base.xsl, match="glp:note" in otherwise choice. I did not split this out in base.xsl - left 'as is' in otherwise choice-->
   <xsl:template match="p/glp:note">
      <xsl:element name="note">
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="heading"/>
         <xsl:element name="bodytext"><!-- BRT: added choice group -->
            <xsl:choose><!-- may be other elements that need to be added to this choice -->
               <xsl:when test="remotelink">
                  <xsl:element name="p">
                     <xsl:element name="text">
                        <xsl:apply-templates select="*[not(self::heading or self::refpt)]"/>
                     </xsl:element>
                  </xsl:element>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="*[not(self::heading or self::refpt)]"/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- end topichead  p  -->   <!-- start topichead  p-limited  -->   <!-- <topicref href="../../common_newest/Rosetta_p-limited-LxAdv-p.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>p-limited</xd:i> becomes <xd:b>p</xd:b>. Also create a child element <xd:b>text</xd:b> within <xd:b>p</xd:b> for capturing the PCDATA of <xd:i>p-limited</xd:i>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry align="center"&gt;
    &lt;p-limited&gt;
        &lt;emph typestyle="bu"&gt;AGENDA&lt;/emph&gt;
    &lt;/p-limited&gt;
&lt;/entry&gt;
			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry align="center"&gt;
    &lt;p&gt;
        &lt;text&gt;
            &lt;emph typestyle="bu"&gt;AGENDA&lt;/emph&gt;
        &lt;/text&gt;
    &lt;/p&gt;
&lt;/entry&gt;
				</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-limited-LxAdv-p.dita  -->
   <!-- BRT: this is the same rule as in Rosetta_p-limited_emph-LxAdv-p_text_emph.dita, and is already addressed there. 
                 The otherwise condition in match="p-limited" creates p (no text), which conflicts with this rule. -->
   <!--Satbir: Define low priority in below template for p-limited because same template created in another xsl (Rosetta_entry_p-limited-LxAdv-entry_p.xsl)-->
   <xsl:template match="p-limited" priority="10">
      <p>
         <text>
            <xsl:apply-templates select="@* | node()"/>
         </text>
      </p>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_p-limited_emph-LxAdv-p_text_emph.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>emph</xd:i> occurs as a direct child of <xd:i>p-limited</xd:i> then <xd:i>p-limited/emph</xd:i> becomes <xd:b>p/text/emph</xd:b>.
    </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry&gt;
    &lt;p-limited&gt;
        &lt;emph typestyle="caps"&gt;Box&lt;/emph&gt;
    &lt;/p-limited&gt;
&lt;/entry&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry&gt;
    &lt;p&gt;
        &lt;text&gt;
            &lt;emph typestyle="caps"&gt;Box&lt;/emph&gt;
        &lt;/text&gt;
    &lt;/p&gt;
&lt;/entry&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-limited_emph-LxAdv-p_text_emph.dita  -->
   <!-- BRT: this template is in one condition of match="p-limited" in base.xsl
             -->
   <xsl:template match="p-limited[child::emph]">
      <xsl:element name="p">
         <xsl:element name="text">
            <xsl:apply-templates/>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_p-limited_glp.note-LxAdv-entry_note.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>glp:note</xd:i> occurs as a direct child of <xd:i>entry/p-limited</xd:i> then <xd:i>entry/p-limited/glp:note</xd:i> becomes <xd:b>entry/note</xd:b>. The <xd:b>entry/note</xd:b> will occur as a sibling to any <xd:b>p</xd:b> elements within the <xd:b>entry</xd:b>. If there is any text (PC-DATA) that is part of the <xd:i>entry</xd:i> but occurs immediately before the <xd:i>p-limited</xd:i>, an empty <xd:b>p</xd:b> element should be created immediately before the <xd:b>note</xd:b> as a sibling to the <xd:b>note</xd:b>.
    </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry colname="c2" colsep="0" rowsep="0"&gt;deal... 
    &lt;p-limited&gt;
        &lt;glp:note&gt;
            &lt;blockquote&gt;
                &lt;p indent="none"&gt;
                    &lt;text&gt;In relation to the...&lt;/text&gt;
                &lt;/p&gt;
            &lt;/blockquote&gt;
        &lt;/glp:note&gt;
    &lt;/p-limited&gt;
&lt;/entry&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry colname="c2" colsep="0" rowsep="0"&gt;deal... 
    &lt;p/&gt;
    &lt;note&gt;
        &lt;bodytext&gt;
            &lt;blockquote&gt;
                &lt;p indent="none"&gt;
                    &lt;text&gt;In relation to the...&lt;/text&gt;
                &lt;/p&gt;
            &lt;/blockquote&gt;
        &lt;/bodytext&gt;
    &lt;/note&gt;
&lt;/entry&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-limited_glp.note-LxAdv-entry_note.dita  -->
   <!-- BRT: Added this template as a condition to match="p-limited" in base.xsl.
             -->
   <xsl:template match="entry/p-limited[child::glp:note]">
      <xsl:element name="p"/>
      <xsl:apply-templates/>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_entry_p-limited-LxAdv-entry_p.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>entry/p-limited</xd:i> becomes <xd:b>entry/p</xd:b>. Also create a child element <xd:b>text</xd:b> within <xd:b>entry/p</xd:b> for capturing the PCDATA of <xd:i>entry/p-limited</xd:i>.
                </xd:p>
         <xd:p> If multiple consecutive <xd:i>p-limited</xd:i> elements occur within
                    <xd:i>entry</xd:i> then create only one <xd:b>p</xd:b>
                    within <xd:b>entry</xd:b> and multiple child <xd:b>text</xd:b>
                    elements with the single <xd:b>p</xd:b>. Create one
                    <xd:b>p/text</xd:b> element for each <xd:i>p-limited</xd:i>
                    element. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
                    
                    &lt;entry&gt;
                    &lt;p-limited&gt;Pleaded guilty to one charge of cultivating cannabis, one charge of possession for supply and one charge of supply.&lt;/p-limited&gt; 
                    &lt;p-limited&gt;The appellant was the owner of a horticultural property. No criminal history. Four rows of cannabis plants growing in an extension to a hothouse. Maturing plants, stalks from harvested plants, and traces of drying cannabis leaf found. A total of 303 cannabis plants grown in a hydroponic solution.&lt;/p-limited&gt; 
                    &lt;/entry&gt;
                    
                </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                    
                    &lt;entry&gt;
                    &lt;p&gt;
                    &lt;text&gt;Pleaded guilty to one charge of cultivating cannabis, one charge of possession for supply and one charge of supply.&lt;/text&gt;
                    &lt;text&gt;The appellant was the owner of a horticultural property. No criminal history. Four rows of cannabis plants growing in an extension to a hothouse. Maturing plants, stalks from harvested plants, and traces of drying cannabis leaf found. A total of 303 cannabis plants grown in a hydroponic solution.&lt;/text&gt; 
                    &lt;/p&gt;
                    &lt;/entry&gt;
                    
                </xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>If <xd:i>l</xd:i> is a child of <xd:i>entry/p-limited</xd:i> then
                <xd:i>entry/p-limited/l</xd:i> becomes
                <xd:b>entry/p/list</xd:b>. For further clarification please see the following example.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
                    &lt;entry colname="col2"&gt;
                    &lt;p-limited&gt;Act is partly in force:
                    &lt;l&gt;
                    &lt;li&gt;
                    &lt;p&gt;
                    &lt;text&gt;ss. 61 (a) as it repeals the definition of ...&lt;/text&gt;
                    &lt;/p&gt;
                    &lt;/li&gt;
                    &lt;/l&gt;
                    &lt;/p-limited&gt;
                    &lt;/entry&gt;
                </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
                    &lt;entry colname="col2"&gt;
                    &lt;p&gt;
                    &lt;text&gt;Act is partly in force:&lt;/text&gt;
                    &lt;list&gt;
                    &lt;listitem&gt;
                    &lt;bodytext&gt;
                    &lt;p&gt;
                    &lt;text&gt;ss. 61 (a) as it repeals the definition of ...&lt;/text&gt;
                    &lt;/p&gt;
                    &lt;/bodytext&gt;
                    &lt;/listitem&gt;
                    &lt;/list&gt;
                    &lt;/p&gt;
                    &lt;/entry&gt;
                </xd:pre>
         <!--Changes2014-11-11: Updated instruction when multiple consecutive p-limited elements occur within entry.2014-10-28: Added note to handle scenario when l is a child of entry/p-limited.-->
         <!--<xsltinclusion>
                <xsl:stylesheet version="2.0">
                    <xsl:template match="p-limited">
                        <xsl:choose>
                            <xsl:when test="child::emph">
                                <xsl:element name="p">
                                    <xsl:element name="text">
                                        <xsl:apply-templates/>
                                    </xsl:element>
                                </xsl:element>
                            </xsl:when>
                            <!-\- BRT: added the following case, result is entry/note -\->
                            <xsl:when test="parent::entry and child::glp:note">
                                <xsl:apply-templates/>    
                            </xsl:when>
                            <!-\- generalizing this condition -\->
                            <!-\- AS: As per the instructions for p-limited "p-limited becomes p. Also create a child element text within p for capturing the PCDATA of p-limited." -\->
                            <xsl:when test="parent::entry">
                                <xsl:element name="p">
                                    <xsl:element name="text">
                                        <xsl:apply-templates/>
                                    </xsl:element>
                                </xsl:element>
                            </xsl:when>
                            <!-\- BRT: added the following -\->
                            <xsl:when test="child::remotelink">
                                <xsl:element name="p">
                                    <xsl:element name="text">
                                        <xsl:apply-templates/>
                                    </xsl:element>
                                </xsl:element>
                            </xsl:when>
                            <xsl:when test="child::ci:cite">
                                <xsl:element name="p">
                                    <xsl:element name="text">
                                        <xsl:apply-templates/>
                                    </xsl:element>
                                </xsl:element>
                            </xsl:when>
                            <xsl:otherwise>
                                <xsl:element name="p">
                                    <xsl:apply-templates/>
                                </xsl:element>
                            </xsl:otherwise>
                        </xsl:choose>
                    </xsl:template>
                </xsl:stylesheet>
            </xsltinclusion>
           -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_entry_p-limited-LxAdv-entry_p.dita  -->
   <!--<xsl:message>Rosetta_entry_p-limited-LxAdv-entry_p.xsl requires manual development!</xsl:message> -->
   <!--Satbir: Define the high priority in below template for p-limited because same template created in another xsl (Rosetta_p-limited-LxAdv-p.xsl)-->
   <xsl:template match="p-limited" priority="15">
      <xsl:variable name="docinfoidtext"
                    select="/CITATORDOC/docinfo/source_docinfo:doc-id/text()"/>
      <xsl:choose>
         <xsl:when test="parent::table and preceding-sibling::tgroup">
            <xsl:element name="note">
               <xsl:element name="bodytext">
                  <xsl:element name="p">
                     <xsl:element name="text">
                        <xsl:apply-templates/>
                     </xsl:element>
                  </xsl:element>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:when test="child::emph">
            <xsl:element name="p">
               <xsl:element name="text"><!-- Awantika:2017-11-24- Webstar # 7048152. If glp:note is coming in p-limited with emph then in target we need to take out glp:note target markup note
                            from p/text as schema does not allow note inside p/text.
                            entry/p-limited/glp:note to entry/note -->
                  <xsl:apply-templates select="node() except glp:note"/>
               </xsl:element>
            </xsl:element>
            <xsl:apply-templates select="glp:note"/>
         </xsl:when>
         <!-- BRT: added the following case, result is entry/note -->
         <xsl:when test="parent::entry and child::glp:note">
            <xsl:apply-templates/>
         </xsl:when>
         <!-- generalizing this condition -->
         <!-- AS: As per the instructions for p-limited "p-limited becomes p. Also create a child element text within p for capturing the PCDATA of p-limited." -->
         <xsl:when test="parent::entry"><!-- Awantika: For AU20 entry/p-limited becomes textitem  -->
            <xsl:choose>
               <xsl:when test="contains(lower-case($docinfoidtext),'history') and parent::entry and $streamID='AU20'">
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:element name="p">
                     <xsl:element name="text">
                        <xsl:apply-templates/>
                     </xsl:element>
                  </xsl:element>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <!-- BRT: added the following -->
         <xsl:when test="child::remotelink">
            <xsl:element name="p">
               <xsl:element name="text">
                  <xsl:apply-templates/>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:when test="child::ci:cite">
            <xsl:element name="p">
               <xsl:element name="text">
                  <xsl:apply-templates/>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="p">
               <xsl:apply-templates/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_p-limited_remotelink-LxAdv-p_text_ref.lnlink.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
					shared topic rather than duplicated to ensure consistency and accuracy. The xml
					snippets contained in this topic reflect markup needed for the Apollo image handling
					application. The UK is the first LBU to move from Apollo to the Blobstore
					application for image handling. Therefore, if this is a UK conversion instruction
					document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
							<xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
							images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
							<xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
							(id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
							<xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
							images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>When <xd:i>remotelink</xd:i> occurs as a direct child of <xd:i>p-limited</xd:i> then <xd:i>p-limited/remotelink</xd:i> becomes <xd:b>p/text/lnlink</xd:b>.
				</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry colname="col3" colsep="0" rowsep="0" align="right" valign="top"&gt;
    &lt;!-- ETC. --&gt;
    &lt;p-limited&gt;
        &lt;remotelink href="www.kpmg.com.au/default.aspx?tabid=145" hrefclass="http" newwindow="YES"&gt;
            &lt;inlineobject type="image" attachment="ln-server" filename="kpmglogo.gif" /&gt;
        &lt;/remotelink&gt;
    &lt;/p-limited&gt;
&lt;/entry&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry colname="col3" colsep="0" rowsep="0" align="right" valign="top"&gt;
    &lt;!-- ETC. --&gt;
    &lt;p&gt;&lt;text&gt;
        &lt;ref:lnlink service="URL"&gt;
            &lt;ref:marker&gt;
                &lt;ref:inlineobject&gt;
                    &lt;ref:locator&gt;
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="object-key"/&gt;
                            &lt;ref:key-value value="X-Y-kpmglogo"/&gt;  &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
                        &lt;/ref:locator-key&gt;
                        &lt;ref:locator-params&gt;
                            &lt;proc:param name="componentseq" value="1"/&gt;
                            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
                            &lt;proc:param name="object-smi" value=""/&gt;  &lt;!-- This @value assignment is done by conversion program --&gt;
                        &lt;/ref:locator-params&gt;
                    &lt;/ref:locator&gt;
                &lt;/ref:inlineobject&gt;
            &lt;/ref:marker&gt;
            &lt;ref:locator&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="URL"/&gt;
                    &lt;ref:key-value value="http://www.kpmg.com.au/default.aspx?
                            tabid=145"/&gt;
                &lt;/ref:locator-key&gt;
            &lt;/ref:locator&gt;
        &lt;/ref:lnlink&gt;
    &lt;/text&gt;&lt;/p&gt;
&lt;/entry&gt;

			</xd:pre>
         <!--Changes2012-10-26: Updated ref:locator markup in Target sample. 2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0 and after" and another for "Pre-Release 4.0".2013-04-30: Updated target sample according to latest Apollo markup.2013-05-01: Removed instructions for section
					"Pre-Release 4.0" because according to latest Apollo markup, section
					"Release 4.0 and after" and section "Pre-Release 4.0" now have
					similar conversion markup.2013-05-08: Extended the list of allowable values for image handling.2015-07-24: Corrected typo in title (was 
					"p-limited/emph to p/text/emph", corrected to be 
					"p-limited/remotelink to p/text/lnlink".2016-08-03: Added Note about xml snippets that illustrate
					image handling. Note summarizes move from Apollo to Blobstore application. UK is
					first LBU to move to Blobstore.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-limited_remotelink-LxAdv-p_text_ref.lnlink.dita  -->
   <!--    The XSLT for this module is covered in Rosetta_remotelink-LxAdv-ref.crossreference.xsl  -->
   <!-- <topicref href="../../common_newest/Rosetta_p-limited_ci.cite-LxAdv-p_text_lnci.cite.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>When <xd:i>ci:cite</xd:i> occurs as a direct child of <xd:i>p-limited</xd:i> then <xd:i>p-limited/ci:cite</xd:i> becomes <xd:b>p/text/lnci:cite</xd:b>.
    </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry&gt;
    &lt;p-limited&gt;Diagram drawn at August 16, 2001 hearing by Mr. Yakimishyn. Location plan NW 4 &lt;ci:cite&gt;&lt;ci:case&gt;&lt;ci:caseref ID="cref00000588" spanref="cspan00000588"&gt;&lt;ci:reporter country="US" value="N.E." normpubcode="627"/&gt;&lt;ci:volume num="8"/&gt;&lt;ci:page num="5"/&gt;&lt;/ci:caseref&gt;&lt;/ci:case&gt;&lt;ci:content&gt;&lt;ci:span spanid="cspan00000588"&gt;8 NE 5&lt;/ci:span&gt;&lt;/ci:content&gt;&lt;/ci:cite&gt;-56-17-4. Submitted by Mr. Yakimishyn.&lt;/p-limited&gt;
&lt;/entry&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;entry&gt;
    &lt;p&gt;&lt;text&gt;Diagram drawn at August 16, 2001 hearing by Mr. Yakimishyn. Location plan NW 4 &lt;lnci:cite&gt;&lt;lnci:case&gt;&lt;lnci:caseref ID="cref00000588"&gt;&lt;lnci:reporter country="US" value="N.E." normpubcode="627"/&gt;&lt;lnci:volume num="8"/&gt;&lt;lnci:page num="5"/&gt;&lt;/lnci:caseref&gt;&lt;/lnci:case&gt;&lt;lnci:content&gt;8 NE 5&lt;/lnci:content&gt;&lt;/lnci:cite&gt;-56-17-4. Submitted by Mr. Yakimishyn.&lt;/text&gt;&lt;/p&gt;
&lt;/entry&gt;

	</xd:pre>
         <!--Changes-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_p-limited_ci.cite-LxAdv-p_text_lnci.cite.dita  -->
   <!-- BRT: this template is in one condition of match="p-limited" in base.xsl
             -->
   <xsl:template match="p-limited[child::ci:cite]">
      <xsl:element name="p">
         <xsl:element name="text">
            <xsl:apply-templates/>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- end topichead  p-limited  -->   <!-- start topichead  page  -->   <!-- <topicref href="../../common_newest/Rosetta_page-LxAdv-ref.page.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>page</xd:i> becomes <xd:b>ref:page</xd:b> and also create
                    <xd:b>doc:docinfo/doc:pagination/doc:pagination-scheme</xd:b> and
                attributes are mapped as follows: <xd:ul>
               <xd:li>
                  <xd:i>page/@count</xd:i> becomes
                            <xd:b>ref:page/@num</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>page/@reporter</xd:i> becomes
                            <xd:b>ref:page/@page-scheme</xd:b> and
                            <xd:b>doc:pagination-scheme/@page-scheme</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>ref:page/@page-scheme-type</xd:b> and
                            <xd:b>doc:pagination-scheme/@page-scheme-type</xd:b> should be
                        set to "reporter-abbreviation"</xd:li>
               <xd:li>
                  <xd:i>page/@text</xd:i> should be dropped. </xd:li>
               <xd:li>
                  <xd:i>page/@subdoc</xd:i> becomes
                            <xd:b>ref:page/@includeintoc</xd:b>. </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>Do not create multiple <xd:i>identical</xd:i>
            <xd:b>doc:pagination-scheme</xd:b>. Source may have multiple
                <xd:i>page</xd:i> with identical <xd:i>@reporter</xd:i> value.
            Create only one <xd:b>doc:pagination-scheme</xd:b> for each unique
                <xd:i>@reporter</xd:i> value.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>According to the LBU, the presentation spec expects the page references to generate
            the displayable reporter part from the citation. The <xd:i>@text</xd:i> is
            dropped because the stylesheet is expected to generate the displayable portion of the
            page break.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;page count="3" reporter="alr" subdoc="true" text="256 ALR 1 at "/&gt;
...
&lt;page count="4" reporter="alr" subdoc="true" text="256 ALR 1 at "/&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:page num="3" page-scheme="alr" page-scheme-type="reporter-abbreviation" includeintoc="true"/&gt;
...
&lt;ref:page num="4" page-scheme="alr" page-scheme-type="reporter-abbreviation" includeintoc="true"/&gt;

and

&lt;doc:docinfo&gt;
    &lt;doc:pagination&gt;
        &lt;doc:pagination-scheme page-scheme="alr" page-scheme-type="reporter-abbreviation"/&gt;
    &lt;/doc:pagination&gt;
&lt;/doc:docinfo&gt;
	</xd:pre>
         <xd:p>
            <xd:b>If comma ( , ) or periods ( . ) occurs in attribute value of count i.e,
                    <xd:i>page/@count</xd:i> then comma or period should be stripped out
                (removed) from target attribute value i.e, <xd:b>ref:page/@num</xd:b>.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;page reporter="bpr" count="23,043" text="12 BPR 23,041 at " subdoc="true" /&gt;
		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;ref:page num="23043" page-scheme="bpr" page-scheme-type="reporter-abbreviation" includeintoc="true"/&gt;

and 

&lt;doc:docinfo&gt;
    &lt;doc:pagination&gt;
        &lt;doc:pagination-scheme page-scheme="bpr" page-scheme-type="reporter-abbreviation"/&gt;
    &lt;/doc:pagination&gt;
&lt;/doc:docinfo&gt;
	</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;page text="(2009) 1(2) JML 159172 at" count="164" reporter="JML" /&gt;
		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;ref:page num="164" page-scheme="JML" page-scheme-type="reporter-abbreviation"/&gt;

and 

&lt;doc:docinfo&gt;
    &lt;doc:pagination&gt;
        &lt;doc:pagination-scheme page-scheme="JML" page-scheme-type="reporter-abbreviation"/&gt;
    &lt;/doc:pagination&gt;
&lt;/doc:docinfo&gt;
	</xd:pre>
         <xd:p>
            <xd:b>If space occurs in attribute value of reporter i.e,
                    <xd:i>page/@reporter</xd:i> then underscore( _ ) should be used at the
                place of space in target attribute value i.e,
                <xd:b>ref:page/@page-scheme</xd:b> and <xd:b>doc:pagination-scheme/@page-scheme</xd:b>.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;page reporter="Fam LR" count="1033" text="10 Fam LR 1032 at " subdoc="true"/&gt;
		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;ref:page num="1033" page-scheme="Fam_LR" page-scheme-type="reporter-abbreviation" includeintoc="true"/&gt;
	
and 
	
&lt;doc:docinfo&gt;
    &lt;doc:pagination&gt;
        &lt;doc:pagination-scheme page-scheme="Fam_LR" page-scheme-type="reporter-abbreviation"/&gt;
    &lt;/doc:pagination&gt;
&lt;/doc:docinfo&gt;
	</xd:pre>
         <xd:p>
            <xd:b>If <xd:i>page</xd:i> is a child of <xd:i>li</xd:i>, then the
                    <xd:b>ref:page</xd:b> should be placed at the beginning of the
                following <xd:b>label</xd:b> in the target.</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;l&gt;
    &lt;li&gt;
        &lt;lilabel&gt;(a)&lt;/lilabel&gt;
        &lt;p&gt;
            &lt;text&gt;if subparagraph (1)(b)(i) applies &amp;#x2013; under the provision of the new corporations legislation that corresponds to the relevant
                old provision; or&lt;/text&gt;
        &lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
        &lt;page reporter="Qd R" count="147" text="[2004] 1 Qd R 146 at " subdoc="true"/&gt;
        &lt;lilabel&gt;(b)&lt;/lilabel&gt;
        &lt;p&gt;
            &lt;text&gt;if subparagraph (1)(b)(ii) applies &amp;#x2013; as, or connected with, a prosecution for an offence against the provision of the new
                corporations legislation that corresponds to the relevant old provision.&lt;/text&gt;
        &lt;/p&gt;
    &lt;/li&gt;
&lt;/l&gt;
	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;list&gt;
    &lt;listitem&gt;
        &lt;label&gt;(a)&lt;/label&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;if subparagraph (1)(b)(i) applies &amp;#x2013; under the provision of the new corporations legislation that corresponds to the
                    relevant old provision; or&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/listitem&gt;
    &lt;listitem&gt;
        &lt;label&gt;&lt;ref:page page-scheme-type="reporter-abbreviation" page-scheme="Qd_R" num="147" includeintoc="true"/&gt;(b)&lt;/label&gt;
        &lt;bodytext&gt;
            &lt;p&gt;
                &lt;text&gt;if subparagraph (1)(b)(ii) applies &amp;#x2013; as, or connected with, a prosecution for an offence against the provision of the new
                    corporations legislation that corresponds to the relevant old provision.&lt;/text&gt;
            &lt;/p&gt;
        &lt;/bodytext&gt;
    &lt;/listitem&gt;
&lt;/list&gt;

and

&lt;doc:docinfo&gt;
    &lt;doc:pagination&gt;
        &lt;doc:pagination-scheme page-scheme="Qd_R" page-scheme-type="reporter-abbreviation"/&gt;
    &lt;/doc:pagination&gt;
&lt;/doc:docinfo&gt;
	</xd:pre>
         <!--Changes2015-01-05: Defined handling for page/@count if period (.) occurs in the value.2011-12-15: Created.2012-01-05: Defined handling for page/@count if comma occurs in the value.2012-01-05: Defined handling for page/@reporter if space occurs in the value.2012-02-07: Added a note for dropping page/@text.2012-02-15: Added mapping for @subdoc.2012-03-02: Corrected the value of @page-scheme-type from
                reporterabbreviation to reporter-abbreviation.2012-04-16: Defined handling for /CASEDOC/case:body/case:headnote/page between two
                decisionsummary as sibling.2012-05-09: Added instructions for handling li/page. 2012-08-23: Moved instruction for page occurring between
                decisionsummary elements to separate module
                LNInternational\common\Rosetta_page_with_preceding-following-siblings_case.decisionsummary.dita. 2012-10-05: Corrected the spelling of "attribute".2014-06-03: Added instruction and example to generate
                        doc:pagination/doc:pagination-scheme in target and
                    this immediately applies to all LNI streams.-->
      </xd:desc>
   </xd:doc>
   <!-- CSN - 2018-03-07 - Webstar 7135509 - UK03 can handle a page in catchwordgrp -->
   <xsl:template match="page[not(ancestor::entry) and not(parent::catchwordgrp or parent::catchwords)] |                       page[$streamID='UK03'][not(ancestor::entry) and not(parent::catchwords)]"
                 name="page-generic">
      <xsl:if test="@count!='' and matches(translate(@count,',.',''),'^\d+$')"><!-- don't process if there is no value converted to @num (invalid), or if source @count is not a digit -->
         <xsl:element name="ref:page">
            <xsl:attribute name="num">
               <xsl:value-of select="translate(@count,',.','')"/>
            </xsl:attribute>
            <xsl:if test="@reporter!=''">
               <xsl:attribute name="page-scheme">
                  <xsl:value-of select="translate(@reporter,' ','_')"/>
               </xsl:attribute>
            </xsl:if>
            <xsl:if test="@subdoc!=''">
               <xsl:attribute name="includeintoc">
                  <xsl:value-of select="@subdoc"/>
               </xsl:attribute>
            </xsl:if>
            <xsl:attribute name="page-scheme-type">
               <xsl:text>reporter-abbreviation</xsl:text>
            </xsl:attribute>
         </xsl:element>
      </xsl:if>
   </xsl:template>

   <xsl:template match="page[$streamID='HK03'][parent::case:headnote | parent::case:info | parent::catchwords]"
                 priority="1"><!--[parent::case:info and $streamID='HK03'][not(parent::catchwords and $streamID='HK03')]-->
      <xsl:if test="parent::case:info">
         <classify:classification>
            <classify:classitem>
               <classify:classitem-identifier>
                  <classify:classname>
                     <xsl:element name="ref:page">
                        <xsl:attribute name="num">
                           <xsl:value-of select="translate(@count,',.','')"/>
                        </xsl:attribute>
                        <xsl:if test="@reporter!=''">
                           <xsl:attribute name="page-scheme">
                              <xsl:value-of select="translate(@reporter,' ','_')"/>
                           </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="@subdoc!=''">
                           <xsl:attribute name="includeintoc">
                              <xsl:value-of select="@subdoc"/>
                           </xsl:attribute>
                        </xsl:if>
                        <xsl:attribute name="page-scheme-type">
                           <xsl:text>reporter-abbreviation</xsl:text>
                        </xsl:attribute>
                     </xsl:element>
                  </classify:classname>
               </classify:classitem-identifier>
            </classify:classitem>
         </classify:classification>
      </xsl:if>
      <xsl:if test="parent::catchwords">
         <classify:classitem>
            <classify:classitem-identifier>
               <classify:classname>
                  <xsl:element name="ref:page">
                     <xsl:attribute name="num">
                        <xsl:value-of select="translate(@count,',.','')"/>
                     </xsl:attribute>
                     <xsl:if test="@reporter!=''">
                        <xsl:attribute name="page-scheme">
                           <xsl:value-of select="translate(@reporter,' ','_')"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:if test="@subdoc!=''">
                        <xsl:attribute name="includeintoc">
                           <xsl:value-of select="@subdoc"/>
                        </xsl:attribute>
                     </xsl:if>
                     <xsl:attribute name="page-scheme-type">
                        <xsl:text>reporter-abbreviation</xsl:text>
                     </xsl:attribute>
                  </xsl:element>
               </classify:classname>
            </classify:classitem-identifier>
         </classify:classitem>
      </xsl:if>
      <xsl:if test="parent::case:headnote">
         <xsl:element name="ref:page">
            <xsl:attribute name="num">
               <xsl:value-of select="translate(@count,',.','')"/>
            </xsl:attribute>
            <xsl:if test="@reporter!=''">
               <xsl:attribute name="page-scheme">
                  <xsl:value-of select="translate(@reporter,' ','_')"/>
               </xsl:attribute>
            </xsl:if>
            <xsl:if test="@subdoc!=''">
               <xsl:attribute name="includeintoc">
                  <xsl:value-of select="@subdoc"/>
               </xsl:attribute>
            </xsl:if>
            <xsl:attribute name="page-scheme-type">
               <xsl:text>reporter-abbreviation</xsl:text>
            </xsl:attribute>
         </xsl:element>
      </xsl:if>
   </xsl:template>
   <!--Satbir: Generate this template for handling the 'exception timestamp' error while during the transforming of input files-->
   <xsl:template match="page[ancestor::entry]"/>
   <!-- 20171017 JL: for when page is a child of seclaw:bodytext -->
   <xsl:template match="page[parent::bodytext[parent::level]][$streamID=('AU05' , 'NZ09')]"
                 priority="2">
      <textitem>
         <xsl:call-template name="page-generic"/>
      </textitem>
   </xsl:template>
   <!-- Webstar 7043871 - CSN - 20171108 - adding page wrapper for schema validity. CI does not address this so matching DT. -->
   <xsl:template match="page[parent::case:info][$streamID=('UK01')]" priority="2">
      <note notetype="other">
         <bodytext>
            <xsl:call-template name="page-generic"/>
         </bodytext>
      </note>
   </xsl:template>
   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- <topicref href="../../common_newest/Rosetta_page_with_preceding-following-siblings_case.decisionsummary.dita"/> -->   <!--	<xsl:include
		href="../../modules/nonamespace/Rosetta_page_with_preceding-following-siblings_case.decisionsummary.xsl"/>-->   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->   <!-- end topichead  page  -->   <!-- start topichead  person  -->   <!-- <topicref href="../../common_newest/Rosetta_person-LxAdv-person.person.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>person</xd:i> becomes <xd:b>person:person</xd:b>. </xd:p>
         <xd:ul>
            <xd:li>
               <xd:i>role</xd:i> becomes <xd:b>role</xd:b>.<xd:ul>
                  <xd:li>
                     <xd:i>fnr[@fntoken]</xd:i> becomes
                                    <xd:b>footnote/ref:anchor[@id]</xd:b>
                  </xd:li>
               </xd:ul>
            </xd:li>
            <xd:li>
               <xd:i>name.text</xd:i> becomes
                            <xd:b>person:name.text</xd:b>
            </xd:li>
            <xd:li>
               <xd:i>name.detail</xd:i> becomes
                            <xd:b>person:name.detail</xd:b>
               <xd:ul>
                  <xd:li>
                     <xd:i>name.degree</xd:i> becomes
                                    <xd:b>person:name.degree</xd:b>
                  </xd:li>
                  <xd:li>
                     <xd:i>name.honorific</xd:i> becomes
                                    <xd:b>person:name.honorific</xd:b>
                  </xd:li>
               </xd:ul>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Note: </xd:b> If <xd:i>remotelink[@hrefclass="http"][@href]</xd:i> or
                        <xd:i>url/remotelink[@hrefclass="http"]</xd:i> is present, convert
                    according to the instructions for <xd:i>url/remotelink</xd:i>, only
                    creating a parent <xd:b>url</xd:b> if it is present.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;person&gt; &lt;name.text&gt;Norman
                    Lyall&lt;/name.text&gt; &lt;name.detail&gt; &lt;name.degree&gt;BA,
                    LLB,&lt;/name.degree&gt; &lt;/name.detail&gt; &lt;role&gt;Solicitor of the
                    Supreme Court of New South Wales&lt;/role&gt; &lt;/person&gt; &lt;/text&gt;
                    &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;person:person&gt;
                    &lt;person:name.text&gt;Norman Lyall&lt;/person:name.text&gt;
                    &lt;person:name.detail&gt; &lt;person:name.degree&gt;BA,
                    LLB,&lt;/person:name.degree&gt; &lt;/person:name.detail&gt;
                    &lt;role&gt;Solicitor of the Supreme Court of New South Wales&lt;/role&gt;
                    &lt;/person:person&gt; &lt;/text&gt;&lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML: <xd:i>role/fnr</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;person&gt; &lt;role&gt;by&lt;/role&gt;
                    &lt;name.text&gt;A J ABADEE&lt;/name.text&gt; &lt;role&gt;Barrister-at-law,
                    Sydney &lt;fnr fntoken="ACLP.C3.SC4.FNT1"
                    fnrtoken="ACLP.C3.SC4.FNT1-R"&gt;*&lt;/fnr&gt; &lt;/role&gt; &lt;/person&gt;
                    &lt;/text&gt;&lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML: <xd:i>role/fnr</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;person:person&gt; &lt;role&gt;by&lt;/role&gt;
                    &lt;person:name.text&gt;A J ABADEE&lt;/person:name.text&gt;
                    &lt;role&gt;Barrister-at-law, Sydney &lt;footnote&gt; &lt;ref:anchor
                    id="ACLP.C3.SC4.FNT1"/&gt; &lt;label&gt;&amp;#x002A;&lt;/label&gt;
                    &lt;bodytext&gt; &lt;p&gt;&lt;text&gt;Based on original commentary
                    by&lt;/text&gt;&lt;/p&gt; &lt;p&gt;&lt;text&gt;J F
                    CORKERY&lt;/text&gt;&lt;/p&gt; &lt;p&gt;&lt;text&gt;Professor of Law, Bond
                    University&lt;/text&gt;&lt;/p&gt; &lt;/bodytext&gt; &lt;/footnote&gt;
                    &lt;/role&gt; &lt;/person:person&gt; &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;role&gt;Chairman, Australian Advocacy
                    Institute&lt;/role&gt; &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;person:person&gt; &lt;role&gt;Chairman,
                    Australian Advocacy Institute&lt;/role&gt; &lt;/person:person&gt; &lt;/text&gt;
                    &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Source person/name.detail/name.honorific</xd:b>
         </xd:p>
         <xd:pre> &lt;person&gt; &lt;name.text&gt;The Hon R O Blanch&lt;/name.text&gt;
                    &lt;name.detail&gt; &lt;name.honorific&gt;AM&lt;/name.honorific&gt;
                    &lt;/name.detail&gt; ... &lt;/person&gt; </xd:pre>
         <xd:p>
            <xd:b>Target person:person/person:name.detail/person:name.honorific</xd:b>
         </xd:p>
         <xd:pre> &lt;person:person&gt; &lt;person:name.text&gt;The Hon R O
                    Blanch&lt;/person:name.text&gt; &lt;person:name.detail&gt;
                    &lt;person:name.honorific&gt;AM&lt;/person:name.honorific&gt;
                    &lt;/person:name.detail&gt; ... &lt;/person:person&gt; </xd:pre>
         <!--Changes2011-12-21: Created.2011-12-21: defined instructions to handle a scenario that occurs in case
                    law.2011-12-22: defined instructions to handle a scenario that occurs in case
                    law.2012-01-16: defined instructions to handle name.detail and name.degree.2012-01-19: defined instructions to handle role, if it occurs as direct child of
                    case:author.2012-04-30: Add a note in CI's saying "A CR has been raised to allow
                        footnote in role".2012-05-14: Removed a note from CI's saying "A CR has been raised to allow
                            footnote in role and CR
                        number is DAAM2012043003311600".2012-05-14: Example added for role/fnr becomes
                        role/footnote2012-08-23: Added mapping for fnr becomes
                        footnote/ref:anchor[@id]. Removed courtcase specific
                    instructions to separate modules.2013-03-14: Add instruction and example: if role occurred
                    as a direct child of text.2015-02-03: Added instruction for
                            name.detail/name.honorific mapping to
                            person:name.detail/person:name.honorific.2015-07-16: Added instruction for
                            person/remotelink mapping to
                            ref:lnlink.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_person-LxAdv-person.person.dita  -->
   <xsl:template match="person">
      <xsl:choose>
         <xsl:when test="parent::contrib and $streamID = 'UK09'">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:when>
         <!-- SNB 2018-01-19 webstar 7091986: add special handling from CI for LPA when comm:info/contrib/note/p/text/person/remotelink[@href] -->
         <xsl:when test="$streamID = 'USLPA' and                  parent::text[parent::p[parent::note[parent::contrib[parent::comm:info]]]] and                  remotelink[@href]">
            <xsl:apply-templates select="remotelink"/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="person:person">
               <xsl:apply-templates select="@* | node()"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="bio[not(child::addl-info)][$streamID='UK12']" priority="25">
      <xsl:choose>
         <xsl:when test="parent::person">
            <person:bio>
               <person:bio.text>
                  <bodytext>
                     <xsl:apply-templates select="@* | node()"/>
                  </bodytext>
               </person:bio.text>
            </person:bio>
         </xsl:when>
         <xsl:otherwise>
            <person:person>
               <person:bio>
                  <person:bio.text>
                     <bodytext>
                        <xsl:apply-templates select="@* | node()"/>
                     </bodytext>
                  </person:bio.text>
               </person:bio>
            </person:person>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="bio[not(addl-info)]"><!--  Original Target XPath:  person:person/person:bio   --><!--  <person:person>-->
      <person:bio>
         <person:bio.text>
            <bodytext>
               <xsl:apply-templates select="@* | node()"/>
            </bodytext>
         </person:bio.text>
      </person:bio>
      <!--</person:person>-->
   </xsl:template>

   <xsl:template match="bio[addl-info]"><!--  Original Target XPath:  person:person/person:bio   --><!--<person:person>-->
      <person:bio>
         <xsl:apply-templates select="@* | node()"/>
      </person:bio>
      <!--</person:person>-->
   </xsl:template>

   <xsl:template match="addl-info"><!--  Original Target XPath:  person:bio/person:bio.text   -->
      <person:bio.text>
         <bodytext>
            <xsl:apply-templates select="@* | node()"/>
         </bodytext>
      </person:bio.text>
   </xsl:template>

   <xsl:template match="govt-entity"><!--  Original Target XPath:  person:person/person:bio/person:bio.text/bodytext/p/text/entity:govt-entity   -->
      <entity:govt-entity>
         <xsl:apply-templates select="@* | node()"/>
      </entity:govt-entity>
   </xsl:template>

   <xsl:template match="role"><!--  Original Target XPath:  person:person/person:bio/person:bio.text/bodytext/p/text/person:person/role   -->
      <role>
         <xsl:apply-templates select="@* | node()"/>
      </role>
   </xsl:template>

   <xsl:template match="person/role">
      <role>
         <xsl:apply-templates select="@* | node()"/>
      </role>
   </xsl:template>

   <xsl:template match="text/role">
      <xsl:element name="person:person">
         <xsl:element name="role"
                      namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
            <xsl:apply-templates select="@* | node()"/>
         </xsl:element>
      </xsl:element>
   </xsl:template>
   <!-- BRT: instruction includes conversion of fnr to footnote. Will not include it here. JL agrees: generic rule should handle this.
              Same for remotelink. -->
   <xsl:template match="name.text">
      <xsl:choose>
         <xsl:when test="$streamID='USLPA'">
            <xsl:element name="person:person">
               <xsl:element name="person:name.text">
                  <xsl:apply-templates select="@* | node()"/>
               </xsl:element>
            </xsl:element>
         </xsl:when>
         <xsl:otherwise>
            <xsl:element name="person:name.text">
               <xsl:apply-templates select="@* | node()"/>
            </xsl:element>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="name.detail">
      <xsl:element name="person:name.detail">
         <xsl:apply-templates select="@* | node()"/>
      </xsl:element>
   </xsl:template>
   <!-- BRT: created and added to base.xsl -->
   <xsl:template match="name.degree">
      <xsl:element name="person:name.degree">
         <xsl:apply-templates select="@* | node()"/>
      </xsl:element>
   </xsl:template>
   <!-- BRT: created and added to base.xsl -->
   <xsl:template match="name.honorific">
      <xsl:element name="person:name.honorific">
         <xsl:apply-templates select="@* | node()"/>
      </xsl:element>
   </xsl:template>
   <!-- JD: 2017-07-14: added; note additional handling in /modules/nonamespace/Rosetta_docinfo-LxAdv-doc.metadata_doc.docinfo.xsl -->
   <xsl:template match="person/@searchtype"/>
   <!-- <topicref href="../../common_newest/Rosetta_case.author_person-LxAdv-byline_person.contributor.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:author/person</xd:i> becomes
                    <xd:b>byline/person:contributor</xd:b> populated with a required
                attribute <xd:b>@contributor-type="author"</xd:b>. </xd:p>
         <xd:ul>
            <xd:li>
               <xd:i>name.text</xd:i> becomes <xd:b>person:person/person:name.text</xd:b>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:author&gt;
    &lt;person&gt;
        &lt;name.text&gt;SAM ROSEWARNE&lt;/name.text&gt;
        &lt;role&gt;BARRISTER&lt;/role&gt;
    &lt;/person&gt;
&lt;/case:author&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;byline&gt;
    &lt;person:contributor contributor-type="author"&gt;
        &lt;person:person&gt;
            &lt;person:name.text&gt;SAM ROSEWARNE&lt;/person:name.text&gt;
            &lt;role&gt;BARRISTER&lt;/role&gt;
        &lt;/person:person&gt;
    &lt;/person:contributor&gt;
&lt;/byline&gt;

	</xd:pre>
         <!--Changes2011-08-23: Created.-->
      </xd:desc>
   </xd:doc>
   <!-- MDS 2017-06-21 - Defined in /case/Rosetta_case.author-to-LexisAdvance_note-byline.xsl -->
   <!-- JD: 2017-06-28: need to create the person:contributor/person:person wrappers, which is not included in  /case/Rosetta_case.author-to-LexisAdvance_note-byline.xsl -->
   <!-- MDS 2017-06-29 - The person:contributor/person:person wrapper is too included in the /case/Rosetta_case.author-to-LexisAdvance_note-byline.xsl :-P -->
   <xsl:template match="case:author/person">
      <xsl:choose>
         <xsl:when test="child::name.text | child::role and $streamID='AU09'">
            <person:contributor>
               <xsl:attribute name="contributor-type">
                  <xsl:text>author</xsl:text>
               </xsl:attribute>
               <person:person>
                  <xsl:apply-templates select="@* | node()"/>
               </person:person>
            </person:contributor>
         </xsl:when>
         <xsl:otherwise>
            <person:person>
               <xsl:apply-templates select="@* | node()"/>
            </person:person>
         </xsl:otherwise>
      </xsl:choose>
      <!--  Original Target XPath:  byline/person:contributor   -->
   </xsl:template>
   <!--<xsl:template match="name.text">

		<!-\-  Original Target XPath:  person:person/person:name.text   -\->
		<person:person>
			<person:name.text>
				<xsl:apply-templates select="@* | node()"/>
			</person:name.text>
		</person:person>

	</xsl:template>-->   <!-- <topicref href="../../common_newest/Rosetta_case.author_role-LxAdv-byline_person_role.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:author/role</xd:i> becomes
                <xd:b>byline/person:person/role</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:author&gt;
    &lt;date&gt;27 October 2000&lt;/date&gt;
    &lt;person&gt;
        &lt;name.text&gt;M H WINNEKE&lt;/name.text&gt;
    &lt;/person&gt;
    &lt;role&gt;Associate to the President&lt;/role&gt;
&lt;/case:author&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;byline&gt;
    &lt;date&gt;27 October 2000&lt;/date&gt;
    &lt;person:person&gt;
        &lt;person:name.text&gt;M H WINNEKE&lt;/person:name.text&gt;
        &lt;role&gt;Associate to the President&lt;/role&gt;
    &lt;/person:person&gt;
&lt;/byline&gt;

	</xd:pre>
         <!--Changes2011-08-23: Created.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.author_role-LxAdv-byline_person_role.dita  -->
   <xsl:template match="case:author/role"><!--  Original Target XPath:  byline/person/role   -->
      <person:person>
         <role>
            <xsl:apply-templates select="@* | node()"/>
         </role>
      </person:person>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_case.constituent_person-LxAdv-person.counselor_person.person.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>case:constituent/person</xd:i> becomes
                    <xd:b>person:counselor/person:person</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;case:constituent&gt;
     &lt;role&gt;Respondent's Counsel:&lt;/role&gt; 
     &lt;person&gt;
         &lt;name.text&gt;B Keith and V A Cochrane&lt;/name.text&gt;
     &lt;/person&gt;
 &lt;/case:constituent&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;courtcase:counsel&gt;
     &lt;role&gt;Respondent's Counsel:&lt;/role&gt;
     &lt;person:counselor&gt;
        &lt;person:person&gt;
            &lt;person:name.text&gt;B Keith and V A Cochrane&lt;/person:name.text&gt;
        &lt;/person:person&gt;
     &lt;/person:counselor&gt;
&lt;/courtcase:counsel&gt;

	</xd:pre>
         <!--Changes2011-08-23: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_case.constituent_person-LxAdv-person.counselor_person.person.dita  -->
   <!-- Vikas Rohilla : Initial updated may be changed if required-->
   <xsl:template match="case:constituent/person">
      <person:counselor>
         <person:person>
            <xsl:apply-templates select="@* | node()"/>
         </person:person>
      </person:counselor>
   </xsl:template>
   <!-- end topichead  person  -->   <!-- rosetta element: pgrp -->   <!-- <topicref href="../../common_newest/Rosetta_pgrp-LxAdv-pgrp.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>pgrp</xd:i> becomes <xd:b>pgrp</xd:b>.</xd:p>
         <xd:p>If <xd:i>pgrp</xd:i> comes with following attributes: <xd:ul>
               <xd:li>
                  <xd:i>@id</xd:i> becomes <xd:b>@xml:id</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>@subdoc</xd:i> becomes
                        <xd:b>@includeintoc</xd:b>
               </xd:li>
               <xd:li>
                  <xd:i>@toc-caption</xd:i> becomes
                            <xd:b>@alternatetoccaption</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp&gt;
    &lt;heading&gt;
        &lt;title&gt;Background&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
        &lt;pnum count="1"&gt;[1]&lt;/pnum&gt;
        &lt;text&gt;
            The present applicants are five 
            individuals who at one time or another were engaged by Combined 
            Insurance Company of America (Combined) as insurance agents. 
            In recent times, the five have sued Combined in the 
            Chief Industrial Magistrates&amp;#x2019; Court of New South Wales claiming 
            entitlements both to annual leave and long service leave. 
            One of the principal issues to be resolved in those proceedings is 
            the question of whether the agents were employees of Combined, 
            as they contend, or rather independent contractors, as Combined contends. 
            No doubt the resolution of that issue will involve a close consideration 
            of a broad range of indicia. One of the matters to which 
            Combined points is a term in its contract with each agent by 
            which each agreed, or appears to have agreed, that his relationship 
            with Combined was not one of employment.
        &lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;pnum count="2"&gt;[2]&lt;/pnum&gt;
        &lt;text&gt;
            That question is, therefore, now pending before the Chief 
            Industrial Magistrates Court. Notwithstanding that circumstance, 
            Combined has commenced the present proceeding in this court 
            seeking three heads of relief:
        &lt;/text&gt;
    &lt;/p&gt;
&lt;/pgrp&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp&gt;
    &lt;heading&gt;
        &lt;title&gt;Background&lt;/title&gt;
    &lt;/heading&gt;
    &lt;p&gt;
        &lt;desig value="1" inline="true"&gt;[1]&lt;/desig&gt;
        &lt;text&gt;
            The present applicants are five 
            individuals who at one time or another were engaged by Combined 
            Insurance Company of America (Combined) as insurance agents. 
            In recent times, the five have sued Combined in the Chief Industrial 
            Magistrates&amp;#x2019; Court of New South Wales claiming entitlements 
            both to annual leave and long service leave. One of the principal 
            issues to be resolved in those proceedings is the question of whether 
            the agents were employees of Combined, as they contend, or rather 
            independent contractors, as Combined contends. No doubt the resolution
            of that issue will involve a close consideration of a broad range of indicia. 
            One of the matters to which Combined points is a term in its contract 
            with each agent by which each agreed, or appears to have agreed, that 
            his relationship with Combined was not one of employment.
        &lt;/text&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;desig value="2" inline="true"&gt;[2]&lt;/desig&gt;
        &lt;text&gt;
            That question is, therefore, now pending before the Chief
            Industrial Magistrates Court. Notwithstanding that circumstance,
            Combined has commenced the present proceeding in this court 
            seeking three heads of relief:
        &lt;/text&gt;
    &lt;/p&gt;  
&lt;/pgrp&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp id="BCA.C5.CHECK"&gt;
 &lt;heading&gt;
  &lt;title&gt;Check List for Lease prior to Lodgment (LPI August 2007)&lt;/title&gt;
 &lt;/heading&gt;
 &lt;!-- ETC. --&gt;
&lt;/pgrp&gt; 
        
    </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp xml:id="BCA.C5.CHECK"&gt;
 &lt;heading&gt;
  &lt;title&gt;Check List for Lease prior to Lodgment (LPI August 2007)&lt;/title&gt;
 &lt;/heading&gt;
 &lt;!-- ETC. --&gt;
&lt;/pgrp&gt; 
        
    </xd:pre>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp subdoc="true" toc-caption="Contributors"&gt;
 &lt;heading&gt;&lt;title&gt;Authors&lt;/title&gt;&lt;/heading&gt;
 &lt;!-- ETC. --&gt;
&lt;/pgrp&gt; 
        
    </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;pgrp includeintoc="true" alternatetoccaption="Contributors"&gt;
 &lt;heading&gt;&lt;title&gt;Authors&lt;/title&gt;&lt;/heading&gt;
 &lt;!-- ETC. --&gt;
&lt;/pgrp&gt; 
        
    </xd:pre>
         <!--Changes2015-03-17: An attribute @inline
                    get added with desig element even when the
                        sourcepnum is not having that
                        attribute@inline Applicable on CA12 only.2015-02-24: Example updated as per new rule an attribute
                        @inlineget added with
                    desigelement when the sourcepnumis
                    not having that attribute@inline2011-12-15: Created.2013-03-14: Add instruction and example
                        pgrp/@id.2014-02-11: Add instruction and example
                        pgrp/@subdoc and
                        pgrp/@toc-caption. Support Discussion Board: NZ09
                    Commentary, Form and Precedents-->
         <!-- <xsltinclusion>
            <xsl:stylesheet version="2.0">
                <!-\- BRT: this template is in the otherwise condition in base.xsl, but added the attributes to that template. 
                    This rule is similar to a rule in another topic in which pggrp is converted to pggrp.
             -\->
                <xsl:template match="pgrp">
                    <xsl:element name="pgrp">
                        <xsl:if test="@id">
                            <xsl:attribute name="xml:id">
                                <xsl:value-of select="@id"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="@subdoc">
                            <xsl:attribute name="includeintoc">
                                <xsl:value-of select="@subdoc"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:if test="@toc-caption">
                            <xsl:attribute name="alternatetoccaption">
                                <xsl:value-of select="@toc-caption"/>
                            </xsl:attribute>
                        </xsl:if>
                        <xsl:apply-templates/>
                    </xsl:element>
                </xsl:template>
            </xsl:stylesheet>
        </xsltinclusion>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_pgrp-LxAdv-pgrp.dita  -->
   <!--<xsl:message>Rosetta_pgrp-LxAdv-pgrp.xsl requires manual development!</xsl:message> -->
   <!-- BRT: this template is in the otherwise condition in base.xsl, but added the attributes to that template. 
                    This rule is similar to a rule in another topic in which pggrp is converted to pggrp.
             -->
   <xsl:template match="pgrp">
      <xsl:element name="pgrp">
         <xsl:if test="@id">
            <xsl:apply-templates select="@id"/>
         </xsl:if>
         <xsl:if test="@subdoc">
            <xsl:attribute name="includeintoc">
               <xsl:value-of select="@subdoc"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="@toc-caption">
            <xsl:attribute name="alternatetoccaption">
               <xsl:value-of select="@toc-caption"/>
            </xsl:attribute>
         </xsl:if>
         <xsl:apply-templates/>
      </xsl:element>
   </xsl:template>
   <!-- Vikas Rohilla : Template to match the pgrp and the parrent case:constituents and the streamID UK03   -->
   <xsl:template match="pgrp[parent::case:constituents][$streamID=('UK03', 'UK04')]">
      <courtcase:arguments>
         <bodytext>
            <pgrp>
               <xsl:apply-templates/>
            </pgrp>
         </bodytext>
      </courtcase:arguments>
   </xsl:template>
   <!-- Satbir : Template for creating textitem as a wrapper of ref:link-->
   <xsl:template match="pgrp[child::link][$streamID='AU18']">
      <pgrp>
         <xsl:for-each select="node()">
            <xsl:choose>
               <xsl:when test="self::link">
                  <textitem>
                     <xsl:apply-templates select="self::link"/>
                  </textitem>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:apply-templates select="."/>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:for-each>
      </pgrp>
   </xsl:template>
   <!-- Awantika: update to create wrapper around pgrp -->   <!--Awantika: Removed this and added it to case:appendix -->   <!-- <xsl:template xmlns:ditaarch="http://dita.oasis-open.org/architecture/2005/" match="pgrp[parent::case:appendix and $streamID='HK03']">
        <xsl:variable name="name" select="local-name()"/>
        
        
        <xsl:if test="local-name(preceding-sibling::*[position()=1]) != $name">
            <bodytext>
            <pgrp>
                <xsl:apply-templates />
                
                <!-\- Match the next sibling if it has the same name -\->
                <xsl:apply-templates select="following-sibling::*[1][local-name()=$name]" mode="nextpg"/>
            </pgrp>
            </bodytext>
        </xsl:if>
    </xsl:template>
    
    
    <xsl:template match="pgrp" mode="nextpg">
        <xsl:variable name="name" select="local-name()"/>
        <pgrp xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"><xsl:apply-templates /></pgrp>
        <xsl:apply-templates select="following-sibling::*[1][local-name()=$name]" mode="nextpg"/>
    </xsl:template>-->   <!-- rosetta element: pnum -->   <!-- <topicref href="../../common_newest/Rosetta_pnum-to-LexisAdvance_desig_ref.para.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>pnum</xd:i> becomes <xd:b>desig/ref:para</xd:b>.</xd:p>
         <xd:p>Attribute <xd:i>pnum/@count</xd:i> becomes <xd:b>desig/@value</xd:b> and
					<xd:b>desig/ref:para/@num</xd:b> and <xd:i>@inline</xd:i>
				becomes <xd:b>@inline</xd:b>. </xd:p>
         <xd:p>Value of <xd:b>ref:para/@para-scheme</xd:b> is
					<xd:i>ci:reporter</xd:i> value from (<xd:b>
               <xd:i>first</xd:i>
            </xd:b>)
					<xd:i>ci:cite/[@type=cite4thisdoc]/ci:case/ci:caseref/ci:reporter</xd:i>.</xd:p>
         <xd:p>
            <xd:b>ref:para/@para-scheme-type="reporter-abbrev"</xd:b> is hardcoded
				value.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;pnum count="1"&gt;[1]&lt;/pnum&gt;
    &lt;text&gt;...&lt;/text&gt;
&lt;/p&gt;

<xd:b>and</xd:b>

&lt;ci:cite type="cite4thisdoc"&gt;
    &lt;ci:case&gt;
        &lt;ci:caseref&gt;
            &lt;ci:reporter value="urj" /&gt;
            &lt;ci:refnum num="BC200000011" /&gt;
        &lt;/ci:caseref&gt;
    &lt;/ci:case&gt;
    &lt;ci:content&gt;
        &lt;citefragment searchtype="CASE-CITE-REF"&gt;BC200000011&lt;/citefragment&gt;
        &lt;refpt id="BC200000011" type="ext"&gt;&lt;/refpt&gt;
    &lt;/ci:content&gt;
&lt;/ci:cite&gt;
	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>
&lt;p&gt;
    &lt;desig value="1"&gt;&lt;ref:para num="1" para-scheme="urj" para-scheme-type="reporter-abbrev"&gt;[1]&lt;/ref:para&gt;&lt;/desig&gt;
    &lt;text&gt;...&lt;/text&gt;
&lt;/p&gt;
</xd:pre>
         <!--Changes2017-05-15: The same rule is applicable on CA10.2014-09-12: Created, Applicable on AU01, AU13, NZ03, CA01 and CA04.-->
         <!--  <xsltinclusion>
        <xsl:stylesheet version="2.0">
            <!-\- BRT: This rule is stream-specific and doesn't below in common -\-></xsl:stylesheet>
    </xsltinclusion>-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated (although the DITA file already has embedded XSLT).  Remove this comment after manual development complete!  (also remove the embedded XSLT within the DITA above) @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_pnum-to-LexisAdvance_desig_ref.para.dita  -->
   <!--<xsl:message>Rosetta_pnum-to-LexisAdvance_desig_ref.para.xsl requires manual development!</xsl:message> -->
   <!-- BRT: This rule is stream-specific and doesn't below in common -->
   <!-- Awantika: Created this template, one can add streamID if same xpath is required -->
   <xsl:template match="pnum">
      <xsl:if test="$streamID=('HK03','AU01', 'NZ03','CA04','CA01' , 'CA10')">
         <desig>
            <xsl:attribute name="value">
               <xsl:value-of select="@count"/>
            </xsl:attribute>
            <ref:para>
               <xsl:attribute name="num">
                  <xsl:value-of select="@count"/>
               </xsl:attribute>
               <xsl:if test="//ci:cite[position()=1]/ci:case/ci:caseref/ci:reporter/@value[1]">
                  <xsl:attribute name="para-scheme"><!--<xsl:value-of select="(//ci:cite[position()=1]/ci:case/ci:caseref/ci:reporter/@value)[1]"/>--><!-- Awantika:2017-10-30- translated to remove the space and create underscore to get the valid attribute value-->
                     <xsl:value-of select="translate((//ci:cite[position()=1]/ci:case/ci:caseref/ci:reporter/@value)[1],' ','_')"/>
                  </xsl:attribute>
               </xsl:if>
               <xsl:attribute name="para-scheme-type">reporter-abbrev</xsl:attribute>
               <xsl:apply-templates/>
            </ref:para>
            <!-- Awantika: Duplicate ref:para if case:courtcite/ci:cite/@type="cite4thisdoc" in AU01 and NZ03-->
            <xsl:if test="$streamID=('AU01', 'NZ03') and //case:courtcite[ci:cite[@type='cite4thisdoc']]">
               <ref:para>
                  <xsl:attribute name="num">
                     <xsl:value-of select="@count"/>
                  </xsl:attribute>
                  <!--Satbir: Added choose condition for ci:nz because NZ03 contet is not having ci:au markup in source-->
                  <xsl:choose>
                     <xsl:when test="not((//ci:nz/@courtcode)[1])"/>
                     <xsl:otherwise>
                        <xsl:attribute name="para-scheme">
                           <xsl:value-of select="(//ci:nz/@courtcode)[1]"/>
                        </xsl:attribute>
                     </xsl:otherwise>
                  </xsl:choose>
                  <xsl:attribute name="para-scheme-type">
                     <xsl:text>court-code</xsl:text>
                  </xsl:attribute>
               </ref:para>
            </xsl:if>
         </desig>
      </xsl:if>
   </xsl:template>
   <!-- start topichead  refpt  -->   <!-- <topicref href="../../common_newest/Rosetta_refpt-LxAdv-ref.anchor.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Please note that the conversion of <xd:i>refpt</xd:i> into
							<xd:b>ref:anchor</xd:b> must follow specific rules based on
						its location in the source document.</xd:b> These context sensitive aspects are
					not all discussed in detail in the general instructions given here. Please see
					the specific document type instructions for more information regarding the
					context sensitive conversion details of this element. If there is any
					contradiction between these general instructions and the document type specific
					instructions, the specific instructions should be given precedence.</xd:p>
         <xd:p>Drop <xd:i>refpt</xd:i> when it occurs as a child of
						<xd:i>ci:content</xd:i> or
					<xd:i>case:casename</xd:i>.</xd:p>
         <xd:p>
            <xd:i>refpt</xd:i> becomes <xd:b>ref:anchor</xd:b>. Attribute
						<xd:i>@id</xd:i> becomes <xd:b>@id</xd:b> and
						<xd:i>@type</xd:i> becomes <xd:b>@anchortype</xd:b> with
					values tokenized as follows: <xd:ul>
               <xd:li>
                  <xd:b>ref:anchor[@anchortype="global"]</xd:b>
               </xd:li>
               <xd:li>
                  <xd:b>ref:anchor[@anchortype="local"]</xd:b>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>All occurrences of refpt/@type="ext" should map to
					ref:anchor/@anchortype="global". If value of refpt/@type="local", or is omitted
					or any other value the mapping should be ref:anchor/@anchortype="local" </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>ref:anchor/@id</xd:b> that begins with a number must have an
					underscore added at start. </xd:p>
         <xd:p>Duplicate anchors should be suppressed. Repeating anchors are ok however (non
					duplicate multiple anchors). Need to remove duplicates. </xd:p>
         <xd:p>If <xd:i>refpt</xd:i> comes within <xd:i>l/li/lilabel</xd:i>
					then <xd:b>ref:anchor</xd:b> will become the first child of
						<xd:b>listitem</xd:b>.</xd:p>
         <xd:p>
            <xd:i>entry/refpt</xd:i> becomes
						<xd:b>entry/ref:anchor</xd:b>
         </xd:p>
         <xd:p>If <xd:i>refpt</xd:i> comes within <xd:i>figure</xd:i> then
					drop the <xd:i>refpt</xd:i> since id has dummy values.</xd:p>
         <xd:p>If <xd:i>refpt</xd:i> comes with <xd:i>page</xd:i> as sibling
					then drop the <xd:i>refpt</xd:i> element.</xd:p>
         <xd:p>If <xd:i>refpt</xd:i> and <xd:i>remotelink</xd:i> occur as
					adjacent siblings, refer to topic <xd:i>
               <xd:i>endnote</xd:i> to
							<xd:b>endnote</xd:b>
            </xd:i>.</xd:p>
         <!-- 2013-11-14 (JCG): Removed the xref to the endnote topic in the above sentence because there are times when the refpt topic is used in a CI but the endnote topic is not. In this case, the xref causes a validation warning because endnote is xref'ed but is not in the DITAMAP. 
		    NOTE: I purposely made this a comment rather than a change log entry because there is no need for it to appear in a change log. -->
         <xd:p>
            <xd:b>Note: </xd:b>Whenever an <xd:b>@xml:id</xd:b> has the same value as ANY
						<xd:b>ref:anchor/@id</xd:b>, suppress the
						<xd:b>@xml:id</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;case:judgments&gt; &lt;glp:note&gt; &lt;refpt id="257_ALR_1_2"
					type="ext"/&gt; &lt;remotelink dpsi="000G" refpt="257_ALR_1_1"
					remotekey1="REFPTID" service="DOC-ID"&gt; Previous page in this case
					&lt;/remotelink&gt; &lt;/glp:note&gt; &lt;case:order subdoc="true"
					toc-caption="Orders"&gt; &lt;heading&gt; &lt;title&gt;Orders&lt;/title&gt;
					&lt;/heading&gt; &lt;p&gt; &lt;text&gt; Order that the questions stated in the
					amended special case be answered as follows: &lt;/text&gt; &lt;/p&gt;
					&lt;/case:order&gt; &lt;/case:judgments&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre> &lt;courtcase:opinions&gt; &lt;note&gt; &lt;ref:anchor id="_257_ALR_1_2"
					anchortype="global"/&gt; ... &lt;/note&gt; courtcase:order will be moved under
					courtcase:body... &lt;courtcase:opinions&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:p>Here is an example of <xd:i>refpt</xd:i> occurring within
						<xd:i>ci:content</xd:i>. </xd:p>
         <xd:pre> &lt;ci:cite type="cite4thisdoc"&gt; &lt;ci:case&gt; &lt;ci:caseref&gt;
					&lt;ci:reporter value="urj"/&gt; &lt;ci:refnum num="BC200702133"/&gt;
					&lt;/ci:caseref&gt; &lt;/ci:case&gt; &lt;ci:content&gt; &lt;citefragment
					searchtype="CASE-CITE-REF"&gt;BC200702133&lt;/citefragment&gt; &lt;refpt
					id="BC200702133" type="ext"&gt;&lt;/refpt&gt; &lt;/ci:content&gt;
					&lt;/ci:cite&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:p>When <xd:i>refpt</xd:i> occurs within
					<xd:i>ci:content</xd:i>, it is dropped. </xd:p>
         <xd:pre> &lt;ref:cite4thisresource citetype="reporter"&gt; &lt;lnci:case&gt;
					&lt;lnci:caseref&gt; &lt;lnci:reporter value="urj"/&gt; &lt;lnci:refnum
					num="BC200702133"/&gt; &lt;/lnci:caseref&gt; &lt;/lnci:case&gt;
					&lt;lnci:content&gt;BC200702133&lt;/lnci:content&gt;
					&lt;/ref:cite4thisresource&gt; </xd:pre>
         <xd:p>
            <xd:b>Source XML 3: Element refpt comes with page element.</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;refpt id="PAGE6" type="ext"/&gt; &lt;page
					reporter="PBAP" text="Page " count="6"/&gt; In civil trials the position is
					summarised by Wrottesley, &lt;emph typestyle="it"&gt;Principles of
					Advocacy&lt;/emph&gt;, p13: &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;ref:page num="6" page-scheme="PBAP"
					page-scheme-type="reporter-abbreviation"/&gt; In civil trials the position is
					summarised by Wrottesley, &lt;emph typestyle="it"&gt;Principles of
					Advocacy&lt;/emph&gt;, p13: &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <!--Changes2012-08-30: Major revision for modularization.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_refpt-LxAdv-ref.anchor.dita  -->
   <xsl:template match="refpt" name="refpt-generic"><!--  Original Target XPath:  ref:anchor   -->
      <xsl:variable name="dup">
         <xsl:call-template name="amIaDuplicate"/>
      </xsl:variable>
      <xsl:choose>
         <xsl:when test="parent::leg:bodytext or parent::ci:content or parent::case:casename or ancestor::figure or preceding-sibling::page      or following-sibling::*[1][self::page] or $dup='true'"/>
         <xsl:otherwise>
            <ref:anchor>
               <xsl:apply-templates select="@*"/>
               <xsl:if test="not(@type)">
                  <xsl:attribute name="anchortype" select="'local'"/>
               </xsl:if>
               <xsl:if test="node()">
                  <ref:anchortext>
                     <xsl:apply-templates select="node()"/>
                  </ref:anchortext>
               </xsl:if>
            </ref:anchor>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- JL: @id and @xml:id transformations handled by module
		XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_identifier-LxAdv-ID_data_type-HandlingDuplicates.xsl -->
   <xsl:template match="refpt/@type"><!--  Original Target XPath:  @anchortype   -->
      <xsl:attribute name="anchortype">
         <xsl:value-of select="if(.='ext') then 'global' else 'local'"/>
      </xsl:attribute>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_Casedoc_refpt-Chof-emph-LxAdv-bodytext_p_ref.anchor.dita"/> -->   <xd:doc>
      <xd:desc>
				refpt child of emph to bodytext/p/ref:anchor id-CCCC-10265
				
				
				case:judgmentbody/h/emph/emph/refpt becomes
				bodytext/p/ref:anchor. 
				
				
				Source XML
				
				
				&lt;case:judgmentbody&gt;
				...
				&lt;h l="3"&gt;
				&lt;emph typestyle="ro"&gt;
				&lt;emph typestyle="it"&gt;
				&lt;refpt id="po.98-984a1" /&gt; 
				1. The question in issue 
				&lt;/emph&gt;
				&lt;/emph&gt;
				&lt;/h&gt;
				...
				&lt;/case:judgmentbody&gt;
				
				
				
				
				Target XML
				
				
				&lt;bodytext&gt;
				...
				&lt;p&gt;
				&lt;ref:anchor id="po.98-984a1&gt;
				&lt;/p&gt;
				&lt;h&gt;
				&lt;emph typestyle="ro"&gt;
				&lt;emph typestyle="it"&gt;
				1. The question in issue
				&lt;/emph&gt;
				&lt;/emph&gt;
				&lt;/h&gt;
				...
				&lt;/bodytext&gt;
				
				
				
				
				Changes
				2012-08-30: Created. 
			</xd:desc>
   </xd:doc>
   <xsl:template match="case:judgementbody/h/emph/emph[refpt]">
      <xsl:apply-templates select="node()"/>
   </xsl:template>

   <xsl:template match="case:judgementbody/h/emph[emph/refpt]">
      <xsl:apply-templates select="node()"/>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_refpt_firstChildOf_leg.bodytext-LxAdv-primlaw.level_ref.anchor.dita"/> -->   <xd:doc>
      <xd:desc> refpt first child of leg:bodytext to primlaw:level/ref:anchor
				id-CCCC-10459 If refpt is the immediate child of leg:bodytext then ref:anchor will
				become the first child of primlaw:level. Source XML &lt;leg:level
				xml:id="QLD_ACT_1895-15_SD1"&gt; &lt;leg:level-vrnt leveltype="subdoc" subdoc="true"
				toc-caption="Anglican Church of Australia Act 1895 Amendment Act 1901"&gt;
				&lt;leg:heading ln.user-displayed="false"&gt; &lt;title align="center"&gt; &lt;emph
				typestyle="bf"&gt; Anglican Church of Australia Act 1895 Amendment Act 1901
				&lt;/emph&gt; &lt;/title&gt; &lt;/leg:heading&gt; &lt;leg:levelbody&gt;
				&lt;leg:bodytext searchtype="LEGISLATION"&gt; &lt;refpt id="QLD_ACT_1895-15_COMP1"
				type="ext"/&gt; &lt;refpt id="QLD_ACT_1895-15_SD1" type="ext"/&gt; &lt;p&gt;
				&lt;text&gt;Queensland&lt;/text&gt; &lt;/p&gt; &lt;/leg:bodytext&gt; ... Target XML
				&lt;primlaw:level leveltype="unclassified" includeintoc="true"
				altternatetoccaption="Anglican Church of Australia Act 1895 Amendment Act 1901"&gt;
				&lt;ref:anchor id="QLD_ACT_1895-15_COMP1" anchortype="global"/&gt; &lt;ref:anchor
				id="QLD_ACT_1895-15_SD1" anchortype="global"/&gt; &lt;primlaw:bodytext&gt; &lt;p&gt;
				&lt;text&gt;Queensland&lt;/text&gt; &lt;/p&gt; &lt;/primlaw:bodytext&gt;
				&lt;/primlaw:level&gt; Changes 2012-08-30: Created. </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!-- <xsl:message>Requires manual development!</xsl:message> -->
   <!-- 20170512:  MCJ:  This is a do nothing module. -->
   <!-- Awantika: Not in GDS -->
   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
   <!-- <topicref href="../../common_newest/Rosetta_refpt-Chof-case.body_heading_edpnum-LxAdv-casedigest.body_ref.anchor.dita"/> -->
   <!--<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-case.body_heading_edpnum-LxAdv-casedigest.body_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.endmatter_index_heading_title-LxAdv-primlaw.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.endmatter_index_heading_title-LxAdv-primlaw.level_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.histcite_heading_title-LxAdv-primlawhist.histgrp_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.histcite_heading_title-LxAdv-primlawhist.histgrp_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.history_heading_title-LxAdv-primlawhist.primlawhist_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.history_heading_title-LxAdv-primlawhist.primlawhist_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_desig_designum-LxAdv-primlaw.level_OR_admindoc.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_desig_designum-LxAdv-primlaw.level_OR_admindoc.level_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_edpnum-LxAdv-admindoc.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_edpnum-LxAdv-admindoc.level_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_title-LxAdv-primlaw.level_OR_seclaw.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.heading_title-LxAdv-primlaw.level_OR_seclaw.level_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.levelinfo_leg.levelstatus-LxAdv-primlaw.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.level_leg.level-vrnt_leg.levelinfo_leg.levelstatus-LxAdv-primlaw.level_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.relatedleg-LxAdv-primlaw.subordinatelaw_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.relatedleg-LxAdv-primlaw.subordinatelaw_ref.anchor.xsl"/>
	<!-\- <topicref href="../../common_newest/Rosetta_refpt-Chof-leg.sectionlist_heading_title-LxAdv-primlaw.level_ref.anchor.dita"/> -\->
	<xsl:include
		href="../../modules/nonamespace/Rosetta_refpt-Chof-leg.sectionlist_heading_title-LxAdv-primlaw.level_ref.anchor.xsl"/>-->
   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
   <!-- <topicref href="../../common_newest/Rosetta_refpt-Chof-level_heading_edpnum-LxAdv-admindoc.level_ref.anchor.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>If <xd:i>refpt</xd:i> occurs under
						<xd:i>level/heading/edpnum</xd:i> then
						<xd:b>ref:anchor</xd:b> will become the first child of
						<xd:b>admindoc:level</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre/>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre/>
         <!--Changes2012-08-30: Created. -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_refpt-Chof-level_heading_edpnum-LxAdv-admindoc.level_ref.anchor.dita  -->
   <!-- <xsl:message>Rosetta_refpt-Chof-level_heading_edpnum-LxAdv-admindoc.level_ref.anchor.xsl
		requires manual development!</xsl:message> -->
   <!-- 20170512:  MCJ:  This is a do nothing module as it is unlikely that the instructions can be implemented
    	                  on their own... it is more likely that the handling of level/heading/epdnum to admindoc:level/ref:anchor
    	                  will occur elsewhere. -->
   <!-- <topicref href="../../common_newest/Rosetta_refpt-Chof-level_heading_title-LxAdv-primlaw.level_OR_seclaw.level_ref.anchor.dita"/> -->
   <xd:doc>
      <xd:desc>refpt child of level/heading/title to
		seclaw:level/ref:anchor, primlaw:level/ref:anchor and section/ref:anchor id-CCCC-10454
	
		
			If refpt is a child of level/heading/title then ref:anchor will become the first child of seclaw:level, primlaw:level and section depending on the target schema.
			AU Commentary-Form-Precedents: If refpt is a child of level/heading/edpnum and refpt element has text then ref:anchor will become the first child of seclaw:level and refpt text will retain seclaw:level/heading/altdesig
		
		
			Source XML
			

&lt;level id="ABCA_ASICA_ACT.SGM_ABCA.ASICA.PT1" leveltype="comm.chap"&gt;
  &lt;heading searchtype="COMMENTARY"&gt;
	  &lt;title&gt;
	  	&lt;refpt type="ext" id="ABCA.ASICA.PT1"/&gt;
	  	Part 1 &amp;mdash; Preliminary [ss 1&amp;ndash;6]
	  &lt;/title&gt;
  &lt;/heading&gt;
  ...

		
		
		
			Target XML
			

&lt;seclaw:level xml:id="ABCA_ASICA_ACT.SGM_ABCA.ASICA.PT1" leveltype="unclassified"&gt;
  &lt;ref:anchor id="ABCA.ASICA.PT1" anchortype="global"/&gt;
  &lt;heading&gt;
  	&lt;title&gt;Part 1 &amp;#x2014; Preliminary [ss 1&amp;#x2013;6]&lt;/title&gt;
  &lt;/heading&gt;
  ...
  
		
		
		
		
		
			Source XML
			

&lt;level id="BCA.C2.AGRP1.ATTJ" leveltype="attachment" subdoc="false" toc-caption="[14,090] Attachment J Deed of Subcontractor's Warranty"&gt;
 &lt;heading&gt;
  &lt;edpnum&gt;
   &lt;refpt id="BCA.C2.AGRP1.ATTJ" type="ext"&gt;[14,090]&lt;/refpt&gt;
  &lt;/edpnum&gt;
  &lt;desig&gt;&lt;designum&gt;Attachment J&lt;/designum&gt;&lt;/desig&gt;
  &lt;title&gt;Deed of Subcontractor's Warranty&lt;/title&gt;
 &lt;/heading&gt;
 ...

		
		
		
			Target XML
			

&lt;seclaw:level leveltype="attachment" toc-caption="&amp;#x005B;14,090&amp;#x005D; Attachment J Deed of Subcontractor&amp;#x0027;s Warranty"&gt;
 &lt;ref:anchor id="BCA.C2.AGRP1.ATTJ" anchortype="global"/&gt;
 &lt;heading&gt;
  &lt;altdesig&gt;&amp;#x005B;14,090&amp;#x005D;&lt;/altdesig&gt;
  &lt;desig&gt;Attachment J&lt;/desig&gt;
  &lt;title&gt;Deed of Subcontractor&amp;#x0027;s Warranty&lt;/title&gt;
&lt;/heading&gt;
...
  
		
		
		
		
			Changes
			2012-08-30: Created
			2012-12-07: Instruction and Example added: refpt has text.
		
      </xd:desc>
   </xd:doc>
   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
   <!-- <topicref href="../../common_newest/Rosetta_refpt-Chof-p_text-LxAdv-p_ref.anchor.dita"/> -->
   <!--	<xsl:include href="../../modules/nonamespace/Rosetta_refpt-Chof-p_text-LxAdv-p_ref.anchor.xsl"/>-->
   <!-- xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx -->
   <!-- <topicref href="../../common_newest/Rosetta_refpt-Chof-p_text_emph-LxAdv-p_ref.anchor.dita"/> -->
   <xd:doc>
      <xd:desc>refpt child of p/text/emph to
			p/ref:anchor id-CCCC-10457
	
		
			p/text/emph/refpt becomes p/ref:anchor.
			All occurrences of refpt[@type="ext"] should map to ref:anchor[@anchortype="global"]. If value of refpt[@type="local"], or is omitted or any other value the mapping should be ref:anchor[@anchortype="local"].
			If any text comes under the refpt then conversion needs to map in
				target ref:anchor/ref:anchortext. (i.e.
					p/text/emph/refpt becomes
					p/ref:anchor/ref:anchortext).
		
		
			Source XML
			

&lt;p&gt;
	 &lt;text&gt;
	 	&lt;emph&gt;
			 &lt;refpt id="x98-525a1"/&gt;
		 	Section 115 contains the general right of 
		 	appeal given to a defendant in proceedings 
		 	governed by the Summary Proceedings Act. 
		 	...
	 	&lt;/emph&gt;
	 &lt;/text&gt;
&lt;/p&gt;

		
		
		
			Target XML
			

&lt;p&gt;
		&lt;ref:anchor id="x98-525a1" anchortype="local"/&gt;
        &lt;text&gt;
	        Section 115 contains the general right of 
	 		appeal given to a defendant in proceedings 
	 		governed by the Summary Proceedings Act.
	 		...
	 	&lt;/text&gt;
&lt;/p&gt;
  
		
		
		
		
			Changes
			2016-07-27: Added a note for handling of text which is
					comes under the refpt in source.
			2013-10-11: Added a note and update the target examples when refpt
				comes without attribute [@type="ext"] and
				[@type="local"] in source documents.
			2012-08-30: Created. 
		
		</xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!-- end topichead  refpt  -->
   <!-- start topichead  remotelink  -->
   <!-- <topicref href="../../common_newest/Rosetta_remotelink-LxAdv-ref.crossreference.dita"/> -->
   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>This topic is used in numerous conversion instructions for several LBUs. It is a
			shared topic rather than duplicated to ensure consistency and accuracy. The xml
			snippets contained in this topic reflect markup needed for the Apollo image handling
			application. The UK is the first LBU to move from Apollo to the Blobstore
			application for image handling. Therefore, if this is a UK conversion instruction
			document, please refer to the following topics for correct image handling markup.<xd:ul>
               <xd:li>
                  <xd:i>lnlink[@service="ATTACHMENT"]</xd:i> to
				<xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
				images (id-CCCC-10542)</xd:li>
               <xd:li>
                  <xd:i>inlineobject</xd:i> to
				<xd:b>ref:inlineobject</xd:b> for BLOBSTORE images
				(id-CCCC-10540)</xd:li>
               <xd:li>
                  <xd:i>link[@filename]</xd:i> to
				<xd:b>ref:lnlink[@service="ATTACHMENT"]</xd:b> for BLOBSTORE
				images (id-CCCC-10541)</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>Regardless of which of the use cases described below occurs, the attribute <xd:i>remotelink/@status</xd:i> is always suppressed, it is never output to the target document.</xd:p>
         <xd:ul>
            <xd:li>Use case: <xd:i>remotelink[@service='SEARCH']</xd:i>. The service type
			  "SEARCH" is not supported in New Lexis. Unless
				<xd:i>remotelink[@hrefclass='http']</xd:i> it is recommended that such
			  remotelink elements be copied into an xml comment. This retains the content for future
			  analysis without creating unsupported target markup. The risk of this approach is the loss
			  of ref:marker text content from display to the user. If there is a
				<xd:i>remotelink/@hrefclass]</xd:i> attribute equal to "http" then the
			  remotelink is <xd:b>not</xd:b> copied into a comment but is instead converted to either a
				<xd:b>url</xd:b> or <xd:b>ref:lnlink</xd:b>, see below for details. </xd:li>
            <xd:li>Use case: <xd:i>remotelink[@service='QUERY']</xd:i>: <xd:ul>
                  <xd:li>In General, convert the pcdata, but suppress the <xd:i>remotelink</xd:i>
				  tag and its attributes.</xd:li>
                  <xd:li>
                     <xd:p>For the following exceptional contexts, do not convert the pcdata of
					  <xd:i>remotelink[@service="QUERY"]</xd:i>. Instead, suppress both the
					pcdata and <xd:i>remotelink</xd:i> markup: <xd:ul>
                           <xd:li>
                              <xd:p> docinfo:assoc-links/remotelink[@service="QUERY"] </xd:p>
                              <xd:p>
                                 <xd:b>Note: </xd:b>For CA05-CA07 please follow <xd:a href="../common_newest/Rosetta_docinfo.assoc-links-LxAdv-doc.related-content.dita">
                                    <xd:i>docinfo:assoc-links/remotelink[@service="QUERY"]</xd:i>
                                 </xd:a>
                              </xd:p>
                           </xd:li>
                           <xd:li>
                              <xd:p> docinfo:assoc-links-grp/remotelink[@service="QUERY"] </xd:p>
                           </xd:li>
                           <xd:li>
                              <xd:p> NZ-Cases only:glp:note/remotelink[@service="QUERY"]</xd:p>
                           </xd:li>
                        </xd:ul>
                     </xd:p>
                  </xd:li>
               </xd:ul>
               <xd:p>A corresponding product requirement shall be created with an instruction to build
				the link on retrieval based on semantic markup in the document. </xd:p>
            </xd:li>
            <xd:li>Use case: <xd:i>remotelink[@service='DOC-ID']</xd:i> becomes
				<xd:b>ref:crossreference</xd:b> with required child
				<xd:b>ref:content</xd:b> and attribute
				<xd:i>remotelink/@xml:lang</xd:i> becomes
				<xd:b>ref:content/@xml:lang</xd:b>. For multiple, immediate, sibling
			  occurrences without intermediary text, group within a
				<xd:b>ref:crossreferencegroup</xd:b> parent except for
				<xd:b>lnci:content</xd:b> and <xd:b>title</xd:b>.<xd:ul>
                  <xd:li>The value of <xd:b>ref:crossreference/@crossreferencetype</xd:b> should be
				  set to "seeAlso".</xd:li>
                  <xd:li>
                     <xd:p> Create <xd:b>ref:crossreference/ref:locator/ref:locator-key</xd:b> with
					attributes and children as follows: <xd:ul>
                           <xd:li>If <xd:i>@remotekey1="DOC-ID"</xd:i> or
						  <xd:i>@remotekey1="DOCID"</xd:i> then <xd:ul>
                                 <xd:li>
                                    <xd:b>ref:key-name/@name</xd:b> will have the value
							"DOC-ID".</xd:li>
                                 <xd:li>
                                    <xd:b>key-value/@value</xd:b> will be the value of
							  <xd:i>@dpsi</xd:i> followed by hyphen and concatenated with
							  <xd:i>@refpt</xd:i> or <xd:i>@remotekey2</xd:i>, which
							ever is present (if both are present, use
							<xd:i>@remotekey2</xd:i>).</xd:li>
                              </xd:ul>
                           </xd:li>
                           <xd:li>If <xd:i>@remotekey1="REFPTID"</xd:i> or
						  <xd:i>@remotekey1="REFPT"</xd:i> then <xd:ul>
                                 <xd:li>
                                    <xd:b>ref:key-name/@name</xd:b> will have the value
							"DOC-ID".</xd:li>
                                 <xd:li>
                                    <xd:b>ref:key-value/@value</xd:b> will be the value of
							  <xd:i>@dpsi</xd:i> followed by hyphen and concatenated with
							  <xd:i>@docidref</xd:i>.</xd:li>
                                 <xd:li>Create <xd:b>ref:locator/@anchoridref</xd:b> with value from
							  <xd:i>@refpt</xd:i> or <xd:i>@remotekey2</xd:i>, which
							ever is present (if both are present, use
							<xd:i>@refpt</xd:i>).  If <xd:i>@refpt</xd:i> is empty or only whitespace, do not output a <xd:b>@anchoridref</xd:b>.</xd:li>
                              </xd:ul>
                           </xd:li>
                        </xd:ul>
                     </xd:p>
                     <xd:p>
                        <xd:b>Note: </xd:b>If <xd:i>remotelink/@dpsi</xd:i> is not present, use value from
					  <xd:i>docinfo:dpsi/@id-string</xd:i> or capture value from the LBU
					manifest file.</xd:p>
                     <xd:p>
                        <xd:b>Note: </xd:b>
                        <xd:b>ref:locator/@anchoridref</xd:b> that begins with a number must
					have an underscore added at start. Also apply other identifier data type format as
					used for <xd:b>xml:id</xd:b> and <xd:b>ref:anchor/@id</xd:b>
					(e.g. change colon to underscore). Refer to the section titled "Identifiers to ID Data Type - 
					Handling Pattern Restrictions", if that section exists in this CI.</xd:p>
                  </xd:li>
               </xd:ul>
            </xd:li>
            <xd:li>Use case: <xd:i>remotelink[@service='URL']</xd:i> or
				<xd:i>remotelink[@hrefclass='http'][@href]</xd:i> or
				<xd:i>remotelink[@href]</xd:i>
               <!-- SP: added 2013-10-03 -->
               <xd:b>and</xd:b> the data content of the remotelink is a URL. That is, the data content of
				<xd:i>remotelink</xd:i> starts with text such as "http://...", "https://...",
			  "www.some.domain", or is of type (http | https | nohttp | mailto | ftp). In this case,
				<xd:i>remotelink</xd:i> becomes <xd:b>url</xd:b>, and populated as follows:<xd:ul>
                  <xd:li>
                     <xd:p>If the <xd:i>remotelink/@hrefclass</xd:i> attribute is present in the
					source document, the <xd:i>remotelink[@hrefclass="http"]</xd:i> becomes
					  <xd:b>url</xd:b> and <xd:i>@href</xd:i> becomes
					  <xd:b>@normval</xd:b>. The value of the attribute
					  <xd:i>@hrefclass</xd:i> is prepended to the value of
					  <xd:i>@href</xd:i> with the addition of '://' to form the
					  <xd:b>@normval</xd:b>.</xd:p>
                     <xd:ul>
                        <xd:li>Exception: If content of <xd:i>@hrefclass</xd:i> is already present in
						<xd:i>@href</xd:i> then do not concatenate. Populate
						<xd:b>@normval</xd:b> with content of
					  <xd:i>@href</xd:i>.</xd:li>
                     </xd:ul>
                  </xd:li>
                  <xd:li>
                     <xd:p>When <xd:i>remotelink/@hrefclass</xd:i> does not exist in
					  <xd:i>remotelink</xd:i> then nothing will be prepended to the
					  <xd:i>@href</xd:i> value. That is, <xd:i>remotelink</xd:i>
					with <xd:i>@href</xd:i> attribute but no <xd:i>@hrefclass</xd:i>
					attribute converts to <xd:b>url</xd:b> where the
					  <xd:b>@normval</xd:b> attribute is set to
					  <xd:i>remotelink/@href</xd:i>. </xd:p>
                  </xd:li>
               </xd:ul>
            </xd:li>
            <xd:li>Use case: <xd:i>remotelink[@service='URL']</xd:i> or
				<xd:i>remotelink[@hrefclass='http'][@href]</xd:i>
               <xd:b>but</xd:b> the data content of the remotelink is <xd:b>not</xd:b> a URL. That is, the data
			  content of <xd:i>remotelink</xd:i>
               <xd:b>does not</xd:b> start with text such as "http://...", "https://...", "www.some.domain",
			  nor is it of type (http | https | nohttp | mailto | ftp). In this case,
				<xd:i>remotelink</xd:i> becomes <xd:b>ref:lnlink</xd:b> with
			  children <xd:b>ref:marker</xd:b> and <xd:b>ref:locator</xd:b>,
			  populated as follows: <xd:ol>
                  <xd:li>The <xd:b>ref:lnlink/@service</xd:b> attribute is set to "URL".</xd:li>
                  <xd:li>The contents of <xd:i>remotelink</xd:i> becomes the contents of child
					<xd:b>ref:lnlink/ref:marker</xd:b>. Any subelements (such as
					<xd:i>emph</xd:i> and <xd:i>inlineobject</xd:i>) are converted
				  as described elsewhere by instructions given for those specific elements. </xd:li>
                  <xd:li>The child <xd:b>ref:lnlink/ref:locator</xd:b> is created, and within it
				  the child <xd:b>ref:lnlink/ref:locator/ref:locator-key</xd:b> is created,
				  and within it the children
					<xd:b>ref:lnlink/ref:locator/ref:locator-key/ref:key-name</xd:b> and
					<xd:b>ref:lnlink/ref:locator/ref:locator-key/ref:key-value</xd:b> are
				  created.</xd:li>
                  <xd:li>The <xd:b>ref:key-name/@name</xd:b> attribute is set to "URL".</xd:li>
                  <xd:li>If the <xd:i>remotelink/@hrefclass</xd:i> attribute is present,
					<xd:b>ref:key-value/@value</xd:b> is set to the combined value of
					<xd:i>remotelink/@hrefclass</xd:i>, followed by "://", followed by the
				  value of <xd:i>remotelink/@href</xd:i>.<xd:ul>
                        <xd:li>Exception: If content of <xd:i>@hrefclass</xd:i> is already present in
						<xd:i>@href</xd:i> then do not concatenate. Populate
						<xd:b>@value</xd:b> with content of <xd:i>@href</xd:i>.</xd:li>
                     </xd:ul>
                  </xd:li>
                  <xd:li>If the <xd:i>remotelink/@hrefclass</xd:i> attribute is <xd:b>not</xd:b> present,
					<xd:b>ref:key-value/@value</xd:b> is set to the value of
					<xd:i>remotelink/@href</xd:i>.</xd:li>
               </xd:ol>
            </xd:li>
            <xd:li>Use case: <xd:i>remotelink[@href]</xd:i>
            </xd:li>
            <xd:li>If <xd:i>remotelink</xd:i> doesn't have any attributes, then
				<xd:i>remotelink</xd:i> should be suppressed, but any elements contained
			  within <xd:i>remotelink</xd:i> should be processed according to the appropriate
			  instructions.</xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:p>In the source documents, <xd:i>remotelink</xd:i> is used for two distinct
			purposes:</xd:p>
            <xd:ul>
               <xd:li>To create an inter-document link; a link to a location outside the containing
				document.</xd:li>
               <xd:li>To create link for a traditional URL.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>If <xd:i>refpt</xd:i> and <xd:i>remotelink</xd:i> occurs as adjacent
			siblings then refer to the instructions for converting <xd:i>endnote</xd:i>.</xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>Exception for NZ17CC:</xd:b> When <xd:i>remotelink</xd:i> is a child of
				<xd:i>emph</xd:i> then conversion should suppress <xd:i>emph</xd:i>
			  element only and process <xd:i>remotelink</xd:i> as per above instruction. See
			  example 17.</xd:p>
         <xd:p>
            <xd:b>Source XML 1: showing service type "DOC-ID" converted to ref:crossreference.</xd:b>
         </xd:p>
         <xd:pre>
					
	&lt;remotelink service="DOC-ID" remotekey1="DOC-ID" dpsi="0062"
				refpt="QLD_ACT_1992-48_20050831"&gt;31/8/2005 to
				18/11/2005&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 1</xd:b>
         </xd:p>
         <xd:pre>
				                              
	&lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
		&lt;ref:content&gt;31/8/2005 to 18/11/2005&lt;/ref:content&gt;                                        
			&lt;ref:locator&gt;                                            
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="0062-QLD_ACT_1992-48_20050831"/&gt;
				&lt;/ref:locator-key&gt;		
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;
			</xd:pre>
         <xd:p>
            <xd:b>Source XML 2: showing <xd:i>remotelink/@xml:lang</xd:i>.</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink dpsi="03JC" remotekey1="DOC-ID" remotekey2="currentness" 
service="DOC-ID" xml:lang="en"&gt;Current&amp;#x20;to&amp;#x20;June&amp;#x20;23,&amp;#x20;2012&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 2</xd:b>
         </xd:p>
         <xd:pre>
				                              
	&lt;ref:crossreference&gt;                                        
		&lt;ref:content xml:lang="en"&gt;Current&amp;#x20;to&amp;#x20;June&amp;#x20;23,&amp;#x20;2012&lt;/ref:content&gt;
    &lt;ref:locator&gt;
      &lt;ref:locator-key&gt;
         &lt;ref:key-name name="DOC-ID"/&gt;
         &lt;ref:key-value value="03JC-currentness"/&gt;
     &lt;/ref:locator-key&gt;
   &lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Source XML 3: showing service type "DOC-ID" converted to ref:crossreference (multiple,
			immediate siblings).</xd:b>
         </xd:p>
         <xd:pre>
				           
&lt;remotelink service="DOC-ID" remotekey1="REFPTID" dpsi="0062" docidref="ABCD_5641"      
            refpt="QLD_ACT_1992-48_20050831"&gt;31/8/2005 to
            18/11/2005&lt;/remotelink&gt;
&lt;remotelink service="DOC-ID" remotekey1="DOC-ID" dpsi="0000"
            refpt="QLD_ACT_1992-48_00000000"&gt;31/8/2005 to
            18/11/2005&lt;/remotelink&gt;
&lt;remotelink service="DOC-ID" remotekey1="REFPTID" dpsi="1111" docidref="EFGH_2468"  
            refpt="QLD_ACT_1992-48_11111111"&gt;31/8/2005 to
            18/11/2005&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 3</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;ref:crossreferencegroup&gt;
	&lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
		&lt;ref:content&gt;31/8/2005 to 18/11/2005&lt;/ref:content&gt;                                        
			&lt;ref:locator anchoridref="QLD_ACT_1992-48_20050831"&gt;                                             
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="0062-ABCD_5641"/&gt;
				&lt;/ref:locator-key&gt;			
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;
	&lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
		&lt;ref:content&gt;31/8/2005 to 18/11/2005&lt;/ref:content&gt;                                        
			&lt;ref:locator&gt;                                            
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="0000-QLD_ACT_1992-48_00000000"/&gt;
				&lt;/ref:locator-key&gt;			
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;
	&lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
		&lt;ref:content&gt;31/8/2005 to 18/11/2005&lt;/ref:content&gt;                                        
			&lt;ref:locator anchoridref="QLD_ACT_1992-48_11111111"&gt;                                            
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="1111-EFGH_2468"/&gt;
				&lt;/ref:locator-key&gt;	
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;
&lt;/ref:crossreferencegroup&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Source XML 4: showing remotelink/sup</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink remotekey1="REFPTID" service="DOC-ID" dpsi="0062" docidref="ABCD_5641" refpt="VIC_ACT_6231_FN31"&gt;
&lt;sup&gt;31&lt;/sup&gt;
&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 4</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;ref:crossreferencegroup&gt;
	&lt;ref:crossreference crossreferencetype="seeAlso"&gt;
		&lt;ref:content&gt;&lt;sup&gt;31&lt;/sup&gt;&lt;/ref:content&gt;
			&lt;ref:locator anchoridref="VIC_ACT_6231_FN31"&gt;                                                
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="0062-ABCD_5641"/&gt;
				&lt;/ref:locator-key&gt;                                                    
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;                                    
&lt;/ref:crossreferencegroup&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 5: for link to URL, with URL as content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink href="www.statedevelopment.qld.gov.au" hrefclass="http" newwindow="YES"&gt;www.statedevelopment.qld.gov.au&lt;/remotelink&gt;

&lt;!-- The following illustrates scenario where content of @hrefclass is already present in @href and so values are not concatenated for target --&gt;

&lt;remotelink href="http://www.acmecorp.com" hrefclass="http" newwindow="YES"&gt;www.acmecorp.com&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 5: for link to URL, with URL as content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;url normval="http://www.statedevelopment.qld.gov.au"&gt;www.statedevelopment.qld.gov.au&lt;/url&gt;

&lt;url normval="http://www.acmecorp.com"&gt;www.acmecorp.com&lt;/url&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>As shown here in Example 6, the use of an @href attribute without @hrefclass, where 
			the @href attribute does not itself contain an hrefclass, ("http://" for example),
			is not advised because the resulting @normval would not contain
			the hrefclass. Normalized values should be consistent in providing the href class.
			The link to the target may not work.</xd:p>
         <xd:p>
            <xd:b>Source XML 6: for link to URL with no hrefclass attribute, and with URL as
			content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink href="www.asx.com" newwindow="YES" service="SEARCH"&gt;www.asx.com&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 6: for link to URL with no hrefclass attribute, and with URL as
			content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;url normval="www.asx.com"&gt;www.asx.com&lt;/url&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 7: for link to URL, with non-URL text content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink href="www.asx.com" hrefclass="http" newwindow="YES" service="SEARCH" status="valid"&gt;Australian Securities Exchange (ASX)&lt;/remotelink&gt;

&lt;!-- The following illustrates scenario where content of @hrefclass is already present in @href and so values are not concatenated for target --&gt;

&lt;remotelink href="http://www.acmecorp.com" hrefclass="http" newwindow="YES"&gt;Acme Corporation&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 7: for link to URL, with non-URL text content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;Australian Securities Exchange (ASX)&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.asx.com"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;Acme Corporation&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.acmecorp.com"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Note: </xd:b>Please note that XML comments need to be added around markup <xd:b>ref:marker
		  </xd:b> if it is in <xd:b>ref:lnlink@service=URL</xd:b>and the
			<xd:b>ref:key-value@value</xd:b> starts-with
			(<xd:b>'http://www.lexisnexis.com/au/legal/api'</xd:b>). Please see the below target xml for more
		  details. </xd:p>
         <xd:p>
            <xd:b>Source XML 7a: for link to URL, with non-URL text content</xd:b>
         </xd:p>
         <xd:pre>

    &lt;remotelink href=www.lexisnexis.com/au/legal/api/version1/sr?csi=357205&amp;sr=FILE%2DCODE(%28%23LL00093CF%23+OR+%23LL000CQNJ%23%29)&amp;shr=T&amp;oc=00254"
 hrefclass="http" newwindow="YES" service="SEARCH" status="valid"&gt;Search LexisNexisAU&lt;/remotelink&gt;

		  </xd:pre>
         <xd:p>
            <xd:b>Target XML 7a: for link to URL, with non-URL text content</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink service="URL"&gt;
  &lt;!--&lt;ref:marker&gt;Search LexisNexisAU&lt;/ref:marker&gt;--&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.lexisnexis.com/au/legal/api/version1/sr?csi=357205&amp;sr=FILE%2DCODE(%28%23LL00093CF%23+OR+%23LL000CQNJ%23%29)&amp;shr=T&amp;oc=00254"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

		  </xd:pre>
         <xd:p>
            <xd:b>Source XML 8: for link to URL with no hrefclass attribute, and with non-URL text
			content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink href="http://www.legislation.vic.gov.au/Domino/Web_Notes/LDMS/PubStatbook.nsf/b05145073fa2a882ca256da4001bc4e7/DDB2D286D7B9C8E2CA2578C6001CCC82/$FILE/11-058sr%20authorised.pdf" service="URL" newwindow="YES"&gt;Government Website&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 8: for link to URL with no hrefclass attribute, and with non-URL text
			content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;Government Website&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.legislation.vic.gov.au/Domino/Web_Notes/LDMS/PubStatbook.nsf/b05145073fa2a882ca256da4001bc4e7/DDB2D286D7B9C8E2CA2578C6001CCC82/$FILE/11-058sr%20authorised.pdf"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

				</xd:pre>
         <xd:p>
            <xd:ul>
               <xd:li>If <xd:i>remotelink[@service= DOC-ID]</xd:i> is a child of
				  <xd:i>glp:note</xd:i>; glp:note becomes
				  <xd:b>note/bodytext/p/text</xd:b>, <xd:i>remotelink[@service=
				  DOC-ID]</xd:i> becomes <xd:b>ref:crossreference</xd:b> (see
				conversion rules in remotelink section). </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Source XML 9:</xd:b>
         </xd:p>
         <xd:pre>

&lt;glp:note&gt;
    &lt;remotelink dpsi="006P" refpt="AFL.FL.FLA75.PT1_2" remotekey1="REFPTID" service="DOC-ID"  docidref="ABCD_5641" status="unval"&gt;
        Next page in this legislation
    &lt;/remotelink&gt;
&lt;/glp:note&gt;

		  </xd:pre>
         <xd:p>
            <xd:b>Target XML 9</xd:b>
         </xd:p>
         <xd:pre>

&lt;note&gt;
    &lt;bodytext&gt;
        &lt;p&gt;
            &lt;text&gt;					                            
                &lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
                    &lt;ref:content&gt;Next page in this legislation&lt;/ref:content&gt;                                        
                    &lt;ref:locator anchoridref="AFL.FL.FLA75.PT1_2"&gt;                                            
                        &lt;ref:locator-key&gt;
                            &lt;ref:key-name name="DOC-ID"/&gt;
                            &lt;ref:key-value value="006P-ABCD_5641"/&gt;
                        &lt;/ref:locator-key&gt;		
                    &lt;/ref:locator&gt;                                 
                &lt;/ref:crossreference&gt;                             
            &lt;/text&gt;
        &lt;/p&gt;
    &lt;/bodytext&gt;
&lt;/note&gt;

		  </xd:pre>
         <xd:p>
            <xd:b>Source XML 10: <xd:i>remotelink</xd:i> as a child of
			  <xd:i>ci:cite/ci:content</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
			
      &lt;ci:cite searchtype="LEG-REF"&gt;
        &lt;ci:content&gt;
          &lt;remotelink refpt="CTH_ACT_1993-80" dpsi="005X" docidref="ABCD_9876" 
            remotekey1="REFPTID" service="DOC-ID" 
            alttext="Click to link to LawNow Legislation"&gt;Superannuation (Resolution of Complaints) Act 1993&lt;/remotelink&gt;.
        &lt;/ci:content&gt;
      &lt;/ci:cite&gt;			
			
			</xd:pre>
         <xd:p>
            <xd:b>Target XML 10: <xd:i>remotelink</xd:i> as a child of
			  <xd:i>ci:cite/ci:content</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;lnci:cite type="legislation"&gt;
    &lt;lnci:content&gt;
        &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
            &lt;ref:content&gt;Superannuation (Resolution of Complaints) Act 1993&lt;/ref:content&gt;
            &lt;ref:locator anchoridref="CTH_ACT_1993-80"&gt;
                &lt;ref:locator-key&gt;
                    &lt;ref:key-name name="DOC-ID"/&gt;  
                    &lt;ref:key-value value="005X-ABCD_9876"/&gt;
                &lt;/ref:locator-key&gt;
            &lt;/ref:locator&gt;
        &lt;/ref:crossreference&gt;
    &lt;/lnci:content&gt;
&lt;/lnci:cite&gt;			

			</xd:pre>
         <xd:p>
            <xd:b>Source XML 11: <xd:i>remotelink</xd:i> as a child of
			  <xd:i>title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
				
&lt;level id="ACLPP_C1.SGM_ACLP.1.2.0015" leveltype="para0" toc-caption="[1.2.0015] Interpretation rules applicable to the Corporations Act: Pt&amp;#x00A0;1.2" subdoc="true"&gt;
    &lt;!-- ETC. --&gt;
    &lt;heading searchtype="COMMENTARY"&gt;
        &lt;edpnum&gt;
            &lt;refpt type="ext" id="ACLP.1.2.0015"&gt;&lt;/refpt&gt;[1.2.0015]&lt;/edpnum&gt;
        &lt;title&gt;Interpretation rules applicable to the Corporations Act:
            &lt;remotelink refpt="ACLL.CL.PT1-2" dpsi="006K" remotekey1="REFPTID" service="DOC-ID"  docidref="EFGH_2468"&gt;Pt&amp;#x00A0;1.2&lt;/remotelink&gt;
        &lt;/title&gt;
    &lt;/heading&gt;
    &lt;bodytext searchtype="COMMENTARY"&gt;
        &lt;!-- ETC. --&gt;
    &lt;/bodytext&gt;
&lt;/level&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Target XML 11: <xd:i>remotelink</xd:i> as a child of
			  <xd:i>title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
				
&lt;seclaw:level xml:id="ACLPP_C1.SGM_ACLP.1.2.0015" leveltype="paragraph" alternatetoccaption="&amp;#x005B;1.2.0015&amp;#x005D; Interpretation rules applicable to the Corporations Act: Pt&amp;#x00A0;1.2" includeintoc="true"&gt;
    &lt;ref:anchor id="ACLP.1.2.0015" anchortype="global"/&gt;
    &lt;heading&gt;
        &lt;desig&gt;&amp;#x005B;1.2.0015&amp;#x005D;&lt;/desig&gt;
        &lt;title&gt;Interpretation rules applicable to the Corporations Act: &lt;ref:crossreferencegroup&gt;
                    &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
                        &lt;ref:content&gt;Pt&amp;#x00A0;1.2&lt;/ref:content&gt;
                        &lt;ref:locator anchoridref="ACLL.CL.PT1-2"&gt;
                            &lt;ref:locator-key&gt;
                                &lt;ref:key-name name="DOC-ID"/&gt;
                                &lt;ref:key-value value="006K-EFGH_2468"/&gt;
                            &lt;/ref:locator-key&gt;
                        &lt;/ref:locator&gt;
                    &lt;/ref:crossreference&gt;
                &lt;/ref:crossreferencegroup&gt;&lt;/title&gt;
    &lt;/heading&gt;
    &lt;!-- ETC. --&gt;
    &lt;seclaw:bodytext&gt;
        &lt;!-- ETC. --&gt;
    &lt;/seclaw:bodytext&gt;
&lt;/seclaw:level&gt;
				</xd:pre>
         <xd:p>
            <xd:b>Source XML 12: <xd:i>remotelink</xd:i> with no attributes</xd:b>
         </xd:p>
         <xd:pre>

&lt;remotelink&gt;&lt;emph typestyle="smcaps"&gt;agency&lt;/emph&gt;&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 12: <xd:i>remotelink</xd:i> with no attributes</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="smcaps"&gt;agency&lt;/emph&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 13: for link to URL with inlineobject as content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;remotelink href="www.kpmg.com.au/default.aspx?tabid=145" hrefclass="http" newwindow="YES"&gt;
  &lt;inlineobject type="image" attachment="ln-server" filename="kpmglogo.gif"/&gt;
&lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Target XML 13: for link to URL with inlineobject as content</xd:b>
         </xd:p>
         <xd:pre>
				
&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;
    &lt;ref:inlineobject&gt;
      &lt;ref:locator&gt;
        &lt;ref:locator-key&gt;
            &lt;ref:key-name name="object-key"/&gt;
            &lt;ref:key-value value="X-Y-kpmglogo"/&gt;   &lt;!-- X and Y are LNI and SMI values obtained from CSSM --&gt;
        &lt;/ref:locator-key&gt;
        &lt;ref:locator-params&gt;
            &lt;proc:param name="componentseq" value="1"/&gt;
            &lt;proc:param name="object-type" value="image"/&gt; &lt;!-- allowable values: image; (from .jpg, .gif, .png, .bmp)--&gt;
            &lt;proc:param name="object-smi" value=""/&gt;    &lt;!-- This @value assignment is done by conversion program --&gt;
        &lt;/ref:locator-params&gt;
      &lt;/ref:locator&gt;
    &lt;/ref:inlineobject&gt;
  &lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.kpmg.com.au/default.aspx?tabid=145"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 14: <xd:i>emph</xd:i> as child of
			  <xd:i>remotelink</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

    &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="04M2_1_1662:HTCOMM-PARAGRAPH" dpsi="04M2"&gt;
           HEC &lt;emph typestyle="bf"&gt;[1662]&lt;/emph&gt;
     &lt;/remotelink&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 14: <xd:i>emph</xd:i> as child of
			  <xd:i>remotelink</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
				
 &lt;ref:crossreference crossreferencetype="seeAlso"&gt;                                        
		&lt;ref:content&gt;HEC &lt;emph typestyle="bf"&gt;[1662]&lt;/emph&gt;&lt;/ref:content&gt;                                        
			&lt;ref:locator anchoridref="04M2_1_1662:HTCOMM-PARAGRAPH"&gt;                                             
				&lt;ref:locator-key&gt;
					&lt;ref:key-name name="DOC-ID"/&gt;
					&lt;ref:key-value value="04M2-ABC"/&gt;
				&lt;/ref:locator-key&gt;			
			&lt;/ref:locator&gt;                                 
	&lt;/ref:crossreference&gt;

				</xd:pre>
         <xd:p>
            <xd:b>Source XML 15: <xd:i>remotelink</xd:i> occurs as multiple, immediate siblings
			and without intermediary text within <xd:i>title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;leg:level&gt;
 &lt;leg:level-vrnt leveltype="prov1"&gt;
  &lt;leg:heading&gt;
   &lt;title&gt;&lt;refpt id="EU_LEGISLATION:31998L0096R_02:" type="ext"/&gt;Corrigendum to Council &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:Directive_98_96_EC_" dpsi="08LU" docidref="08LU_EU_LEGISLATION:Directive_98_96_EC_"&gt;Directive 98/96/EC&lt;/remotelink&gt; of 14 December 1998 amending, inter alia, as regards unofficial field inspections under &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:Directives_66_400_EEC__" dpsi="08LU" docidref="08LU_EU_LEGISLATION:Directives_66_400_EEC__"&gt;Directives 66/400/EEC, &lt;/remotelink&gt;66/401/EEC, 66/402/EEC, 66/403/EEC, 69/208/EEC, 70/457/EEC and 70/458/EEC on the marketing of beet seed, fodder plant seed, cereal seed, seed potatoes, seed of oil and fibre plants and vegetable seed and on the common catalogue of varieties of agricultural plant species (OJL25 of 1.2
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_EEC__66_401" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_EEC__66_401"&gt;/EEC, 66/401&lt;/remotelink&gt;
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_EEC__66_402" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_EEC__66_402"&gt;/EEC, 66/402&lt;/remotelink&gt;
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_EEC__66_403" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_EEC__66_403"&gt;/EEC, 66/403&lt;/remotelink&gt;
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_EEC__69_208" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_EEC__69_208"&gt;/EEC, 69/208&lt;/remotelink&gt;
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_EEC__70_457" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_EEC__70_457"&gt;/EEC, 70/457&lt;/remotelink&gt;/EEC and
   &lt;remotelink service="DOC-ID" remotekey1="REFPTID" refpt="EU_LEGISLATION:_70_458" dpsi="08LU" docidref="08LU_EU_LEGISLATION:_70_458"&gt; 70/458&lt;/remotelink&gt;/EEC on the marketing of beet seed, fodder plant seed, cereal seed, seed potatoes, seed of oil and fibre plants and vegetable seed and on the common catalogue of varieties of agricultural plant species (OJL25 of 1.2.1999)&lt;/title&gt;
  &lt;/leg:heading&gt;
  &lt;!-- ETC. --&gt;
 &lt;/leg:level-vrnt&gt;
&lt;/leg:level&gt;
		  </xd:pre>
         <xd:p>
            <xd:b>Target XML 15: <xd:i>remotelink</xd:i> occurs as multiple, immediate siblings
			and without intermediary text within <xd:i>title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;primlaw:level leveltype="section"&gt;
 &lt;heading&gt;
  &lt;title&gt;Corrigendum to Council &lt;ref:crossreference crossreferencetype="seeAlso"&gt;&lt;ref:content&gt;Directive 98/96/EC &lt;/ref:content&gt;&lt;ref:locator anchoridref="EU_LEGISLATION_Directive_98_96_EC_"&gt;&lt;ref:locator-key&gt;&lt;ref:key-name name="DOC-ID"/&gt;&lt;ref:key-value value="08LU-08LU_EU_LEGISLATION_Directive_98_96_EC_"/&gt;&lt;/ref:locator-key&gt;&lt;/ref:locator&gt;&lt;/ref:crossreference&gt; of 14 December 1998 amending, inter alia, as regards unofficial field inspections under &lt;ref:crossreference crossreferencetype="seeAlso"&gt;&lt;ref:content&gt;Directives 66/400/EEC, &lt;/ref:content&gt;&lt;ref:locator anchoridref="EU_LEGISLATION_Directives_66_400_EEC__"&gt;&lt;ref:locator-key&gt;&lt;ref:key-name name="DOC-ID"/&gt;&lt;ref:key-value value="08LU-08LU_EU_LEGISLATION_Directives_66_400_EEC__"/&gt;&lt;/ref:locator-key&gt;&lt;/ref:locator&gt;&lt;/ref:crossreference&gt;66/401/EEC, 66/402/EEC, 66/403/EEC, 69/208/EEC, 70/457/EEC and 70/458/EEC on the marketing of beet seed, fodder plant seed, cereal seed, seed potatoes, seed of oil and fibre plants and vegetable seed and on the common catalogue of varieties of agricultural plant species (OJL25 of 1.2
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt;/EEC, 66/401&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__EEC__66_401"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__EEC__66_401"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt;/EEC, 66/402&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__EEC__66_402"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__EEC__66_402"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt;/EEC, 66/403&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__EEC__66_403"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__EEC__66_403"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt;/EEC, 69/208&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__EEC__69_208"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__EEC__69_208"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt;/EEC, 70/457&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__EEC__70_457"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__EEC__70_457"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;/EEC and
   &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
    &lt;ref:content&gt; 70/458&lt;/ref:content&gt;
    &lt;ref:locator anchoridref="EU_LEGISLATION__70_458"&gt;
     &lt;ref:locator-key&gt;
      &lt;ref:key-name name="DOC-ID"/&gt;
      &lt;ref:key-value value="08LU-08LU_EU_LEGISLATION__70_458"/&gt;
     &lt;/ref:locator-key&gt;
    &lt;/ref:locator&gt;
   &lt;/ref:crossreference&gt;/EEC on the marketing of beet seed, fodder plant seed, cereal seed, seed potatoes, seed of oil and fibre plants and vegetable seed and on the common catalogue of varieties of agricultural plant species (OJL25 of 1.2.1999)&lt;/title&gt;
  &lt;/heading&gt;
  &lt;!-- ETC. --&gt;
&lt;/primlaw:level&gt;  

		  </xd:pre>
         <xd:p>
            <xd:b>Source XML 16: <xd:i>remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;Consultation Paper: The Award of Costs from Central Funds in Criminal
        Cases - &lt;remotelink service="QUERY"
            remotekey1="DIGEST-CITATION(LNB News 06/11/2008 25)"
            remotekey2="All Subscribed Current Awareness Sources" cmd="f:exp"
            alttext="References to"&gt;LNB News 06/11/2008 25&lt;/remotelink&gt;; &lt;/text&gt;
&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML 16: <xd:i>remotelink[@service="QUERY"]</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;Consultation Paper: The Award of Costs from Central Funds in Criminal
        Cases - LNB News 06/11/2008 25; &lt;/text&gt;
&lt;/p&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 17: <xd:i>remotelink</xd:i> as a child of <xd:i>emph</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;ci:cite searchtype="LEG-REF"&gt;
    &lt;ci:content&gt;
        &lt;citefragment searchtype="LEG-NAME-REF"&gt;
            &lt;emph typestyle="it"&gt;
                &lt;remotelink dpsi="0069" remotekey1="REFPTID" service="DOC-ID" refpt="1952A52"
                    docidref="1952A52.BODY"&gt;Land Transfer Act 1952&lt;/remotelink&gt;
            &lt;/emph&gt;
        &lt;/citefragment&gt;
        &lt;emph typestyle="it"&gt;, ss 62, 105 and 119&lt;/emph&gt;
    &lt;/ci:content&gt;
&lt;/ci:cite&gt;
	</xd:pre>
         <xd:p>
            <xd:b>Target XML 17: <xd:i>remotelink</xd:i> as a child of <xd:i>emph</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;lnci:cite type="legislation"&gt;
    &lt;lnci:content&gt;
            &lt;ref:crossreference crossreferencetype="seeAlso"&gt;
                &lt;ref:content&gt;Land Transfer Act 1952&lt;/ref:content&gt;
                &lt;ref:locator anchoridref="_1952A52"&gt;
                    &lt;ref:locator-key&gt;
                        &lt;ref:key-name name="DOC-ID"/&gt;
                        &lt;ref:key-value value="0069-1952A52.BODY"/&gt;
                    &lt;/ref:locator-key&gt;
                &lt;/ref:locator&gt;
            &lt;/ref:crossreference&gt;
        &lt;emph typestyle="it"&gt;, ss 62, 105 and 119&lt;/emph&gt;
    &lt;/lnci:content&gt;
&lt;/lnci:cite&gt;
	</xd:pre>
         <!--Changes2016-11-16: Added to note regarding applying any rules related to 
			@anchoridref, referring specifically to section for "Identifiers to ID Data Type - 
			Handling Pattern Restrictions".2011-12-16: Created. 2011-12-16: Changed URL/Email link instructions and example to map to url target element. 2011-12-22: Defined a rule for glp:note/remotelink, per linking strategy.2011-12-22: Removed reference to Email links, these do not happen in AU nor NZ data. 2011-12-22: Fixed formating of a sublist. 2011-12-22: Updated to match linking strategy. 2012-01-17: Updated instruction and example for handling remotelink[@service="DOC-ID"].2012-01-17: Added example for handling of remotelink/sup.2012-02-23: Added conversion instructions and the NL example for /remotelink @dpsi for the
			use case - remotelink @service='DOC-ID'.2012-02-28: Instruction update for handling remotelink appear in
			  title.2012-02-28: Example added for handling remotelink appear in
			  title.2012-02-29: Added instruction and example when remotelink has no
			  @hrefclass.2012-03-12: Added instruction and example for handling of scenario glp:note/remotelink in
			AU legislation/Courtrule.2012-03-15: Added instruction for single versus multiple, sibling occurrences of
			  remotelink.2012-03-16: Corrected target markup for ref:key-name/@name value.
			Changed from "DOC-ID" to "REFPTID.2012-04-26: Modified the instructions for the use case:
			  remotelink[@service='DOC-ID'] to include the text -'without
			intermediary text'.2012-04-27: Made fundemental modifications the instructions regarding
			  remotelink[@service='URL']. This is now usually converted to
			  ref:lnlink and only converted to url under
			certain conditions as described in the instructions. 2012-05-09: Removed the reference to AU Legislation/Courtrule: for the rule when
			  remotelink is the child of glp:note . This
			instruction is common across content types and not just AU Legis/Courtrule2012-05-14: Removed a note for handling remotelink appear in
			  title.2012-05-14: Example updated for handling title/remotelink.2012-05-24: Instructions updated for handling
			  glp:note/remotelink/@service='QUERY'.2012-06-06: Updated the instruction The ref:marker/@service attribute is set to "URL"
			  to The ref:lnlink/@service attribute is set to "URL".2012-06-12: Updated the instructions for use case:
			  remotelink[@service='DOC-ID']. Described exactly how to obtain a
			value for ref:key-value/@value depending on what other attributes and
			values are present.2012-07-04: Added instructions for the situation when remotelink
			doesn't have any attributes.2012-07-12: modified instruction for glp:note/remotelink handling when
			remotelink@service="DOC-ID".2012-07-31: Replaced the instruction "some other form of a URL" with dtd values (http |
			https | nohttp | mailto | ftp).2012-07-31: Updated the instructions for use case
			  remotelink[@service='DOC-ID'] with directions to set the value of
			  ref:crossreference/@crossreferencetype to "seeAlso".2012-08-17: Updated the instructions for use case
			  remotelink[@service='DOC-ID'] with new instructions for
			  ref:crossreference/ref:locator/ref:locator-key.2012-08-17: Moved handling for NZ Cases to a separate module.2012-09-05: Added to note for ref:locator/@anchoridref that begins
			with a number... Also apply other identifier data type format as used for
			  xml:id and ref:anchor/@id (e.g. change colon
			to underscore).2012-12-03: Instruction and example added for
			remotelink/@xml:lang.2013-01-22: Instruction and example added for
			  ci:cite/ci:content/remotelink specifying that the
			  remotelink is to be converted to
			  ref:crossreference but the containing elements' start-tags and
			end-tags (ci:cite and ci:content) are
			dropped.2013-02-18: Target example updated per inlineobject instructions. 2013-02-18: Created two sections, one for "Release 4.0 and
				after" and another for "Pre-Release 4.0".2013-03-11: Instruction and example added on how to handle
				ref:marker  if it is in
				ref:lnlink@service=URLand the
				ref:key-value@value starts-with (.,
				'http://www.lexisnexis.com/au/legal/api')2013-04-10: Added Source XML 7a: for link to URL, with non-URL
			  text content because it was previously missing, only the target example was here.2013-04-30: Updated target sample according to latest Apollo
			  markup.2013-05-01: Removed instructions for section "Pre-Release
				4.0" because according to latest Apollo markup, section "Release 4.0 and
				after" and section "Pre-Release 4.0" now have similar conversion
			markup.2013-05-01: "Instruction added for
				ci:cite/ci:content/remotelink specifying that the
				remotelink is to be converted to
				ref:crossreference but the containing elements' start-tags and
			  end-tags (ci:cite and ci:content) are
			  dropped", has been removed from the instructions and now remotelink
			  will be converted to the resulting mapping where it is. For more details you can see
			  example: Source XML 10: remotelink as a child of
				  ci:cite/ci:content2013-05-08: Extended the list of allowable values for image
			  handling.2013-06-03: Updated the Target XML 2 by removing the
				@crossreferencetype for Canada example.2013-08-22: Not a rule change. Modified Sample #10 on
				ci:cite/ci:content/remotelink. Removed target attribute
				lnci:cite[@citeref] because value captured in
				ref:crossreference/ref:locator[@anchoridref].2013-10-03: Added use case where remotelink contains @href
			  which is a URL but does not contain @hrefclass='http'.2013-10-23: Added Example when
				remotelink having child emph. Webteam #
			  2398162014-02-03: Instruction updated if
				remotelink occurs as multiple, immediate siblings and without
			  intermediary text within title. Also added a example for the same
			  scenario. Phase 5 UK discussion-defect tracking issue #1612014-02-25: Updated instruction and created new example (#16)
			  for handling remotelink[@service="QUERY"]. New instruction
			  preserves pcdata but suppresses remotelink markup. Webstar #250335.
			  Change applies immediately to all Pacific streams, and in the long run to all
			  streams.2014-10-27: Minor. Within use case for
				@service="DOC-ID", rule for
				@remotekey1="REFPTID" now also applies when
				@remotekey1="REFPT". That is, the condition is expanded to
			  include value "REFPT"; the mapping is unchanged. The value
				"REFPT" is new in Oct 2014 redelivery of UK11-DN but the rule
			  applies to any stream where @remotekey1="REFPT" may occur. R4.5
			  Content Issue 2003.2015-01-09: For the two use cases associated with url (target
				url or ref:lnlink): Added exceptional rule
			  to not concatenate values when @hrefclass content is already
			  present in @href. Expanded examples 5 and 7 to illustrate the
			  scenario. Responds to data for UK10 Dictionaries but applies in general. R4.5 Content
			  Issue 2120.2015-05-22: Added an instruction to explicitly indicate remotelink/@status is always dropped (suppressed). This is a very low-priority change and has been added for technical correctness, particularly with respect to new CIs. Existing scripts do not have to implement this change unless needed since prior to the change remotelink/@status handling was not explicitly specified.2015-06-24: Added clarification note about url, @normval, and @hrefclass. Webstar 302055.2016-02-05: Added note and example when
				remotelink is a child of emph. Applicable
			on NZ17CC, Webstar: 319232 and 318735.2016-08-03: Added Note about xml snippets that illustrate
			image handling. Note summarizes move from Apollo to Blobstore application. UK is
			first LBU to move to Blobstore.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_remotelink-LxAdv-ref.crossreference.dita  -->
   <xsl:template match="remotelink/@status"/>
   <!-- JL: suppressing attributes as templates because they are used in more complex ways below -->
   <xsl:template match="remotelink/@refpt"/>

   <xsl:template match="remotelink/@dpsi"/>

   <xsl:template match="remotelink/@service"/>

   <xsl:template match="remotelink/@remotekey1"/>

   <xsl:template match="remotelink[@hrefclass ne 'http'  and @service = 'SEARCH']">
      <xsl:comment>
         <xsl:copy-of select="."/>
      </xsl:comment>
   </xsl:template>

   <xsl:template match="remotelink[ @service = 'QUERY' ][ not( ancestor::docinfo:assoc-links or parent::glp:note[ not( starts-with( $streamID , 'NZ' ) ) ] ) ]"><!--  Original Target XPath:  ref:crossreference   --><!-- Suppress remotelink and retain the content -->
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="remotelink[ancestor::docinfo:assoc-links][ @service = 'QUERY' ][ not( $streamID = ( 'CA03', 'CA05' , 'CA06' , 'CA07', 'CA08' ) ) ]"/>
   <!--Commeted below line for stop the warning of duplicate rule of glp:note/remotelink-->   <!--<xsl:template match="glp:note/remotelink[ @service = 'QUERY' ][ starts-with( $streamID , 'NZ' ) ]"/>-->
   <xsl:template name="remotelinkDOCID"><!--  Original Target XPath:  ref:crossreference   -->
      <ref:crossreference><!-- following atts and inlineobject template from modules/cttr/HK08k_subseqcases_cttr.annot.xsl --><!-- Sudhanshu Srivastava : Added condition for parent cttr:annot and streamID CA03. --><!-- Awantika: Added inlineobject for AU01 -->
         <xsl:attribute name="crossreferencetype"
                        select="if (((parent::source_cttr:annot or parent::source_cttr:annot or ancestor::citefragment[ancestor::case:references]) and $streamID=('HK08' , 'AU02', 'AU04','UK05','CA03')) or (ancestor::citefragment and inlineobject and $streamID=('NZ09', 'AU17'))or (parent::ci:content and $streamID='AU20') or inlineobject and $streamID='AU01') then 'citatorAlert' else 'seeAlso'"/>
         <xsl:if test="(parent::source_cttr:annot or parent::source_cttr:annot and $streamID=('HK08' , 'AU02', 'AU04','UK05','CA03')) or (ancestor::citefragment and inlineobject and $streamID=('NZ09', 'AU17')) or (parent::ci:content and $streamID='AU20') or inlineobject and $streamID='AU01'">
            <xsl:attribute name="referencedresourcetype" select="'citator'"/>
            <xsl:apply-templates select="inlineobject" mode="citator-ref"/>
         </xsl:if>
         <!-- JD: 20170525: (from UK05) following if test for att 'referencedresourcesentiment' from modules/cttr/UK05_Citator_annotations_cttr.annot-LxAdv-cttr.refs.xsl -->
         <xsl:if test="parent::source_cttr:annot/@signal or parent::source_cttr:annot/@signal and $streamID=('UK05','CA03')">
            <xsl:attribute name="referencedresourcesentiment">
               <xsl:choose>
                  <xsl:when test="parent::source_cttr:annot/@signal='citation'">
                     <xsl:value-of select="'none'"/>
                  </xsl:when>
                  <xsl:when test="not(parent::source_cttr:annot/@signal='citation') and parent::source_cttr:annot/@signal">
                     <xsl:value-of select="parent::source_cttr:annot/@signal"/>
                  </xsl:when>
                  <xsl:when test="parent::source_cttr:annot/@signal='citation'">
                     <xsl:value-of select="'none'"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:copy-of select="parent::source_cttr:annot/@signal"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:attribute>
         </xsl:if>
         <xsl:if test="ancestor::citefragment and inlineobject and $streamID=('AU17')">
            <xsl:attribute name="referencedresourcesentiment">
               <xsl:value-of select="lower-case(substring-before(inlineobject/@alttext, ' '))"/>
            </xsl:attribute>
         </xsl:if>
         <!-- JL: Ok to output empty ref:content as ref:content is a required element -->
         <!-- Awantika:24-07-2017: for AU20 added parent::ci:content -->
         <ref:content>
            <xsl:if test="$streamID='AU19_CC'">
               <xsl:attribute name="xml:lang">
                  <xsl:value-of select="/CASEDOC/docinfo/docinfo:doc-lang/@lang"/>
               </xsl:attribute>
            </xsl:if>
            <xsl:copy-of select="@xml:lang"/>
            <xsl:apply-templates select="if($streamID='UK12') then @* except(@xml:lang,@refpt) else @* except@xml:lang"/>
            <xsl:if test="parent::source_cttr:annot and $streamID=('HK08' , 'AU02', 'AU04') or parent::ci:content and $streamID='AU20'">
               <xsl:value-of select="if (contains(inlineobject/@alttext, ' - Click for CaseBase entry')) then substring-before(inlineobject/@alttext, ' - Click for CaseBase entry') else inlineobject/@alttext"/>
            </xsl:if>
            <xsl:if test=" $streamID=('NZ09', 'AU17','AU01','NZ11','AU10','HK07')">
               <xsl:value-of select="if (contains(inlineobject/@alttext, ' - Click for CaseBase entry')) then substring-before(inlineobject/@alttext, ' - Click for CaseBase entry') else inlineobject/@alttext"/>
            </xsl:if>
            <!-- Sudhanshu Srivastava: Added if condition for getting ref content for CA03 -->
            <xsl:if test="parent::source_cttr:annot and $streamID=('CA03')">
               <xsl:value-of select="if (contains(inlineobject/@alttext, 'QuickCITE - ')) then substring-after(inlineobject/@alttext, 'QuickCITE - ') else inlineobject/@alttext"/>
            </xsl:if>
            <!-- Awantika:24-07-2017: blobstore mapping was getting created therefore added 'except' for AU20 not to create that instead create the 
					below ref:locator-->
            <xsl:apply-templates select="node() except inlineobject[parent::remotelink[parent::ci:content][$streamID=('AU20','HK07')]] except inlineobject[$streamID='AU01']"/>
         </ref:content>
         <ref:locator>
            <xsl:for-each select=" if (@refpt) then @refpt else @remotekey2"><!-- MDS - 2017-05-12 - Created choose statement to deal with empty @refpt in source resulting in empty @anchoridref in target. -->
               <xsl:choose>
                  <xsl:when test="normalize-space(.) = ''"/>
                  <xsl:otherwise><!-- JD: 2017-05-26: adding 'if' to prevent @anchoridref being added from markup like this:
							<remotelink remotekey1="DOC-ID" service="DOC-ID" remotekey2="a1baecf6-dc1f-4bd0-ba0c-a91177f0efe6" dpsi="03W6" status="valid"/>
							so as to match DT output.
							--><!-- Sudhanshu Srivastava: addrd StreamID CA03, no need to generate anchoridref attribute. --><!-- Paul: this is often the case.  May want "and @remotekey1="REFPTID" in this somewhere.
								I'm getting it with DOC-ID in the attribute.  AU08
								PS2017042700263627135LNIAUCOURTRULES_input_VIC_REG_2008-14810000.xml
			                    <remotelink dpsi="03AP" remotekey1="DOC-ID" remotekey2="LAWNOW_LEG_LAUNCH_VIC" service="DOC-ID">LawNow Home Page</remotelink>
							If @remotekey1="REFPTID" then
								 Create ref:locator/@anchoridref with value from @refpt or @remotekey2, which ever is present (if both are present, use
								@refpt).-->
                     <xsl:if test="not($streamID='UK05' or $streamID='CA03' or $streamID='AU19_CC') and parent::remotelink/@remotekey1='REFPTID'">
                        <xsl:attribute name="anchoridref">
                           <xsl:call-template name="normalizeIdString"/>
                        </xsl:attribute>
                     </xsl:if>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:for-each>
            <ref:locator-key>
               <xsl:choose><!-- Awantika: Added choose as it is required to capture URL in ref:key-name while creating ref:crossreference for p/remotelink in AU20 -->
                  <xsl:when test="parent::p[parent::note][$streamID='AU20']">
                     <ref:key-name name="URL"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <ref:key-name name="DOC-ID"/>
                  </xsl:otherwise>
               </xsl:choose>
               <ref:key-value>
                  <xsl:attribute name="value"><!-- Awantika: Added choose as it is required to capture value of @href while creating ref:crossreference for p/remotelink in AU20 -->
                     <xsl:choose>
                        <xsl:when test="@dpsi">
                           <xsl:value-of select="@dpsi"/>
                        </xsl:when>
                        <xsl:when test="parent::p[parent::note][$streamID='AU20']">
                           <xsl:value-of select="@href"/>
                        </xsl:when>
                        <xsl:when test="not(@dpsi) and //docinfo/docinfo:dpsi/@id-string">
                           <xsl:value-of select="//docinfo/docinfo:dpsi/@id-string"/>
                        </xsl:when>
                        <xsl:when test="not(@dpsi) and not(//docinfo/docinfo:dpsi/@id-string)">
                           <xsl:value-of select="$dpsi"/>
                        </xsl:when>
                        <!-- JL if @dpsi isn't present, use DPSI from document or LBU manifest file as in CI above. 
									Verified with Pacific LBU 2017-11-06 -->
                        <!-- JL : dpsi may be validly missing if the link is invalid -->
                        <xsl:when test="@status=('unval','invalid')"><!-- no @dpsi however status is unvalidated or invalid so don't throw error  --></xsl:when>
                        <xsl:otherwise><!--<xsl:value-of select="$dpsi"/>-->
                           <xsl:call-template name="outputErrorMessage">
                              <xsl:with-param name="messageText"
                                              as="xs:string"
                                              select=" 'remotelink/@dpsi is missing and link cannot be correctly completed' "/>
                              <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                              <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
                              <xsl:with-param name="context" as="xs:string">
                                 <xsl:value-of select="base-uri()"/>
                              </xsl:with-param>
                           </xsl:call-template>
                        </xsl:otherwise>
                     </xsl:choose>
                     <xsl:text>-</xsl:text>
                     <xsl:choose>
                        <xsl:when test="$streamID='AU19_CC'">
                           <xsl:value-of select="@refpt"/>
                        </xsl:when>
                        <!-- CSN - 2017/11/06 - Backing this change out from the last SVN Version becuase it may fix AU08 but it breaks links for the other Conversions
								<xsl:when test=" @remotekey1 = 'DOC-ID' or @remotekey1 = 'DOCID' or @service='DOC-ID'">
								-->
                        <xsl:when test=" @remotekey1 = 'DOC-ID' or @remotekey1 = 'DOCID'">
                           <xsl:value-of select="if (@remotekey2) then @remotekey2 else @refpt"/>
                        </xsl:when>
                        <xsl:when test=" @remotekey1 = 'REFPTID' or @remotekey1 = 'REFPT' ">
                           <xsl:choose>
                              <xsl:when test="@docidref">
                                 <xsl:value-of select="@docidref"/>
                              </xsl:when>
                              <xsl:when test="@status=('unval','invalid')"><!-- no @docidref however status is unvalidated or invalid so don't throw error  --></xsl:when>
                              <xsl:otherwise><!-- This should be an error message -->
                                 <xsl:text>XXXX</xsl:text>
                                 <xsl:call-template name="outputErrorMessage">
                                    <xsl:with-param name="messageText"
                                                    as="xs:string"
                                                    select=" 'remotelink/@docidref is missing and link cannot be correctly completed' "/>
                                    <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
                                    <xsl:with-param name="errorCode" as="xs:string*" select=" '403' "/>
                                    <!--SNB: 2017-10-27 adding the XPATH of problem link to error output instead of previous base:uri() -->
                                    <xsl:with-param name="context" as="xs:string">
                                       <xsl:call-template name="generateXPath"/>
                                    </xsl:with-param>
                                    <!--<xsl:with-param name="context" as="xs:string"><xsl:value-of select="base-uri()"/> </xsl:with-param>-->
                                 </xsl:call-template>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:when>
                     </xsl:choose>
                  </xsl:attribute>
               </ref:key-value>
            </ref:locator-key>
         </ref:locator>
      </ref:crossreference>
   </xsl:template>
   <!--  multiple immediate sibling remotelinks will get grouped, see further below  -->
   <xsl:template match="remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ][ preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] ]"/>
   <!--  process immediate sibling remotelink elements one by one  -->
   <xsl:template match="remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ]"
                 mode="combineSiblingRemotelinks"><!--  output  ref:crossreference for the current remotelink  -->
      <xsl:call-template name="remotelinkDOCID"/>
      <!--  process immediate sibling remotelink elements one by one  -->
      <xsl:apply-templates select="following-sibling::node()[1][self::remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ] ]"
                           mode="combineSiblingRemotelinks"/>
   </xsl:template>
   <!-- JD: 2017-10-13: trap remotelink as child of <li>  -->
   <xsl:template match="remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ][ not( preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] ) ]     [parent::li]"
                 priority="1">
      <p>
         <text>
            <xsl:choose>
               <xsl:when test=" following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] and not(parent::ci:content)"><!--  multiple immediate sibling remotelinks, so group in ref:crossreferencegroup  -->
                  <ref:crossreferencegroup><!--  output  ref:crossreference for the current remotelink  -->
                     <xsl:call-template name="remotelinkDOCID"/>
                     <!--  process immediate sibling remotelink elements one by one  -->
                     <xsl:apply-templates select="following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ]"
                                          mode="combineSiblingRemotelinks"/>
                  </ref:crossreferencegroup>
               </xsl:when>
               <xsl:otherwise><!--  no grouping needed, so just output  ref:crossreference for the current remotelink  -->
                  <xsl:call-template name="remotelinkDOCID"/>
               </xsl:otherwise>
            </xsl:choose>
         </text>
      </p>
   </xsl:template>
   <!-- For multiple, immediate, sibling
			  occurrences without intermediary text, group within a
				<targetxml>ref:crossreferencegroup</targetxml> parent except for
				<targetxml>lnci:content</targetxml> and <targetxml>title</targetxml>.<ul>  -->   <!--  @@@ SBy:  I do not understand what is meant by "except for lnci:content and title" since the examples have those under ref:crossreferencegroup even if there is only one remotelink[ @service = 'DOC-ID' ] sibling !!!  -->   <!-- JL: seems like lnci:content/ref:crossreferencegroup is not schema valid -->
   <xsl:template match="remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ][ not( preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] ) ]"
                 priority="2">
      <xsl:choose><!-- BRT 1/30/17 fix issue with missing p element -->
         <xsl:when test="parent::bodytext and $streamID = ('UK15_DS')">
            <p>
               <text>
                  <xsl:call-template name="remotelinkDOCID"/>
               </text>
            </p>
         </xsl:when>
         <xsl:when test="$streamID=('AU10','NZ11') and ancestor::level/@leveltype='landingpage'"><!--  no grouping needed, it becomes seclaw:subjectmatterreference 
					which doesn't allow groupings so just output  ref:crossreference for the current remotelink  -->
            <xsl:call-template name="remotelinkDOCID"/>
         </xsl:when>
         <xsl:when test=" following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] and not(parent::ci:content)"><!--  multiple immediate sibling remotelinks, so group in ref:crossreferencegroup  -->
            <ref:crossreferencegroup><!--  output  ref:crossreference for the current remotelink  -->
               <xsl:call-template name="remotelinkDOCID"/>
               <!--  process immediate sibling remotelink elements one by one  -->
               <xsl:apply-templates select="following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ]"
                                    mode="combineSiblingRemotelinks"/>
            </ref:crossreferencegroup>
         </xsl:when>
         <xsl:otherwise><!--  no grouping needed, so just output  ref:crossreference for the current remotelink  -->
            <xsl:call-template name="remotelinkDOCID"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--  If there is a
				<sourcexml>remotelink/@hrefclass]</sourcexml> attribute equal to "http" then the
			  remotelink is <b>not</b> copied into a comment but is instead converted to either a
				<targetxml>url</targetxml> or <targetxml>ref:lnlink</targetxml>   -->   <!-- remotelink[@service='URL'] or remotelink[@hrefclass='http'][@href] or remotelink[@href] and the data content of the remotelink is a URL -->   <!--  @@@ SBy:  how does one check for "... or is of type (http | https | nohttp | mailto | ftp ..."  ??? using contains...  -->
   <xsl:template match="remotelink[ ( @service = 'URL' or @href ) and ( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) ) ][not(parent::ci:content)]"
                 name="remotelink-url-urltext"><!--   @@@TODO:  perhaps fix type (http | https | nohttp | mailto | ftp handling.  Probably @hrefclass ?  also check for case insensitivity  --><!-- <li>Use case: <sourcexml>remotelink[@service='URL']</sourcexml> or
				<sourcexml>remotelink[@hrefclass='http'][@href]</sourcexml> or
				<sourcexml>remotelink[@href]</sourcexml>
			  <b>and</b> the data content of the remotelink is a URL. That is, the data content of
				<sourcexml>remotelink</sourcexml> starts with text such as "http://...", "https://...",
			  "www.some.domain", or is of type (http | https | nohttp | mailto | ftp). In this case,
				<sourcexml>remotelink</sourcexml> becomes <targetxml>url</targetxml>		-->
      <url>
         <xsl:attribute name="normval">
            <xsl:if test=" @hrefclass and not( contains( @href , @hrefclass ) ) ">
               <xsl:value-of select="@hrefclass"/>
               <xsl:text>://</xsl:text>
            </xsl:if>
            <xsl:value-of select="normalize-space( @href )"/>
         </xsl:attribute>
         <xsl:apply-templates/>
      </url>
   </xsl:template>
   <!-- JL emph is invalid as a child of url, so adding this: -->
   <xsl:template match="emph[parent::remotelink [( @service = 'URL' or @href ) and ( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) ) ][not(parent::ci:content)]]"
                 priority="35">
      <xsl:apply-templates/>
   </xsl:template>
   <!--Awantika: If lnci:content/remotelink have the following scenarios:if it's href,url,or www.... then retain the content of remotelink and suppress the element-->   <!-- Awantika:11-07-2017: Added priority to resolve the conflict on template "remotelink[not(ancestor::docinfo:assoc-links)][ @service = 'DOC-ID' ][ not( preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] ) ]" -->
   <xsl:template match="remotelink[ ( @service = 'URL' or @href ) and ( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) ) ][parent::ci:content]"
                 priority="5">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- 2017-11-28 - MDS: person/remotelink output does not allow for ref:lnlink.  url is sufficient for UK12 stream -->
   <xsl:template match="person/remotelink[$streamID='UK12']" priority="25">
      <url>
         <xsl:attribute name="normval">
            <xsl:value-of select="@hrefclass"/>
            <xsl:text>://</xsl:text>
            <xsl:value-of select="@href"/>
         </xsl:attribute>
         <xsl:apply-templates select="node()"/>
      </url>
   </xsl:template>
   <!-- remotelink[@service='URL'] or remotelink[@hrefclass='http'][@href] but the data content of the remotelink is not a URL. -->   <!--  @@@ SBy:  how does one check for "... nor is it of type (http | https | nohttp | mailto | ftp ..."  ??? using contains...  -->
   <xsl:template match="remotelink[ ( @service = 'URL' or @href ) and not( ( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) ) ) ]"
                 name="remotelink-url"><!--   @@@TODO:  perhaps fix type (http | https | nohttp | mailto | ftp handling.  Probably @hrefclass ?  also check for case insensitivity  --><!-- <li>Use case: <sourcexml>remotelink[@service='URL']</sourcexml> or
				<sourcexml>remotelink[@hrefclass='http'][@href]</sourcexml>
			  <b>but</b> the data content of the remotelink is <b>not</b> a URL. That is, the data
			  content of <sourcexml>remotelink</sourcexml>
			  <b>does not</b> start with text such as "http://...", "https://...", "www.some.domain",
			  nor is it of type (http | https | nohttp | mailto | ftp). In this case,
				<sourcexml>remotelink</sourcexml> becomes <targetxml>ref:lnlink</targetxml> with
			  children <targetxml>ref:marker</targetxml> and <targetxml>ref:locator</targetxml>	-->
      <ref:lnlink service="URL">
         <ref:marker>
            <xsl:apply-templates/>
         </ref:marker>
         <ref:locator>
            <ref:locator-key>
               <ref:key-name name="URL"/>
               <ref:key-value>
                  <xsl:attribute name="value">
                     <xsl:if test=" @hrefclass and not( contains( @href , @hrefclass ) ) ">
                        <xsl:value-of select="@hrefclass"/>
                        <xsl:text>://</xsl:text>
                     </xsl:if>
                     <xsl:value-of select="normalize-space( @href )"/>
                  </xsl:attribute>
               </ref:key-value>
            </ref:locator-key>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>

   <xsl:template match="remotelink/@href"/>
   <!-- suppress remotelink and retain its content as text -->
   <xsl:template match="remotelink[not(@*)]">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- @@@  SBy:  TODO, need to coordinate with Mark S footnote/endote logic:   <p>If <sourcexml>refpt</sourcexml> and <sourcexml>remotelink</sourcexml> occurs as adjacent
				siblings then refer to the instructions for converting <sourcexml>endnote</sourcexml>.</p>  

				There's another separate module for this... -->
   <xsl:template match="emph[ remotelink and $streamID = 'NZ17-CCD' ]">
      <xsl:apply-templates/>
   </xsl:template>

   <xsl:template match="remotelink/@remotekey2"/>
   <!-- it doesn't seem like we use this att -->
   <xsl:template match="remotelink/@newwindow"/>

   <xsl:template match="remotelink/@docidref"/>

   <xsl:template match="remotelink[parent::in:entry-text][$streamID='AU16']"
                 priority="25">
      <index:locator><!-- <in:entry-text>
          <remotelink dpsi="009K" remotekey1="REFPTID" service="DOC-ID" refpt="CTH_BIL_2017-74"
            status="unval">ASIC SUPERVISORY COST RECOVERY LEVY BILL 2017</remotelink>
        </in:entry-text> -->
         <ref:lnlink>
            <xsl:attribute name="service">DOCUMENT</xsl:attribute>
            <ref:marker>
               <xsl:apply-templates select="node()"/>
            </ref:marker>
            <ref:locator>
               <xsl:choose>
                  <xsl:when test="not(@refpt)">
                     <xsl:attribute name="anchoridref">
                        <xsl:choose>
                           <xsl:when test="string(number(substring(@remotekey2, 1, 1))) = 'NaN'">
                              <xsl:value-of select="@remotekey2"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:value-of select="concat('_', @remotekey2)"/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:attribute name="anchoridref">
                        <xsl:choose>
                           <xsl:when test="string(number(substring(@refpt, 1, 1))) = 'NaN'">
                              <xsl:value-of select="@refpt"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:value-of select="concat('_', @refpt)"/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                  </xsl:otherwise>
               </xsl:choose>
               <ref:locator-key>
                  <ref:key-name name="DOC-ID"/>
                  <ref:key-value>
                     <xsl:attribute name="value">
                        <xsl:choose><!-- <in:entry-text>Insurance Premiums Order (January-June) 2014 <remotelink dpsi="005Y"
              remotekey1="REFPTID" service="DOC-ID" refpt="NSW_REG_2013-622_WA"
              docidref="NSW_REG_2013-622_SCH11">SCH11CL1SUB1</remotelink></in:entry-text> -->
                           <xsl:when test="@remotekey1 = 'DOC-ID'">
                              <xsl:value-of select="concat(@dpsi, '-')"/>
                              <xsl:choose>
                                 <xsl:when test="not(@remotekey2)">
                                    <xsl:value-of select="@refpt"/>
                                 </xsl:when>
                                 <xsl:otherwise>
                                    <xsl:value-of select="@remotekey2"/>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </xsl:when>
                           <xsl:when test="@remotekey1 = 'REFPTID'">
                              <xsl:value-of select="concat(@dpsi, '-')"/>
                              <xsl:choose>
                                 <xsl:when test="@docidref">
                                    <xsl:value-of select="@docidref"/>
                                 </xsl:when>
                                 <xsl:otherwise>
                                    <xsl:text>XXXX</xsl:text>
                                 </xsl:otherwise>
                              </xsl:choose>
                           </xsl:when>
                        </xsl:choose>
                     </xsl:attribute>
                  </ref:key-value>
               </ref:locator-key>
            </ref:locator>
         </ref:lnlink>
      </index:locator>
   </xsl:template>
   <!--Vikas Rohilla : Template to match the remotelink-->
   <xsl:template match="remotelink[ ( @service = 'URL' or @href ) and not(( contains( . , 'www' ) or contains( . , 'http' ) or contains( . , 'mailto' ) or contains( . , 'ftp' ) )) ][$streamID='UK11DA']"
                 priority="20">
      <url>
         <xsl:attribute name="normval">
            <xsl:if test=" @hrefclass and not( contains( @href , @hrefclass ) ) ">
               <xsl:value-of select="@hrefclass"/>
               <xsl:text>://</xsl:text>
            </xsl:if>
            <xsl:value-of select="normalize-space( @href )"/>
         </xsl:attribute>
         <xsl:apply-templates/>
      </url>
   </xsl:template>

   <xsl:template match="remotelink/@alttext"/>
   <!-- Priya Kaushal added below for UK15 -->
   <xsl:template match="remotelink[(ancestor::docinfo:assoc-links)| (ancestor::docinfo:assoc-links-grp)] [parent::text] [ @service = 'DOC-ID' ][ not( preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] ) ] [$streamID='UK15' or $streamID='UK12' or $streamID='UK14']"
                 priority="40">
      <xsl:choose>
         <xsl:when test=" following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ] and not(parent::ci:content)"><!--  multiple immediate sibling remotelinks, so group in ref:crossreferencegroup  --><!--<doc:related-content-item>
					<doc:related-content-desc>
						<p>
							<text>-->
            <ref:crossreferencegroup><!--  output  ref:crossreference for the current remotelink  -->
               <xsl:call-template name="remotelinkDOCID"/>
               <!--  process immediate sibling remotelink elements one by one  -->
               <xsl:apply-templates select="following-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ] ][not($streamID='UK15')]"
                                    mode="combineSiblingRemotelinks"/>
            </ref:crossreferencegroup>
            <!--</text>
											</p>
											</doc:related-content-desc>
				</doc:related-content-item>-->
         </xsl:when>
         <xsl:otherwise><!--  no grouping needed, so just output  ref:crossreference for the current remotelink  -->
            <xsl:call-template name="remotelinkDOCID"/>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="remotelink[(ancestor::docinfo:assoc-links)| (ancestor::docinfo:assoc-links-grp)][parent::text][preceding-sibling::node()[1][self::remotelink[ @service = 'DOC-ID' ]]][$streamID='UK15']"
                 priority="2">
      <xsl:call-template name="remotelinkDOCID"/>
   </xsl:template>
   <!-- Vikas Rohilla : included for the UK12	-->
   <xsl:template match="remotelink[@refpt=''][$streamID='UK12']" priority="25">
      <ref:lnlink>
         <ref:marker>
            <xsl:apply-templates select="node()"/>
         </ref:marker>
         <ref:locator>
            <xsl:apply-templates select="@refpt"/>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>

   <xsl:template match="remotelink/@refpt[$streamID='UK12']" priority="25">
      <xsl:choose>
         <xsl:when test="normalize-space(.)!=''">
            <xsl:attribute name="anchoridref">
               <xsl:call-template name="normalizeIdString"/>
            </xsl:attribute>
         </xsl:when>
         <xsl:otherwise>
            <xsl:comment>Mandatory element according to the CI</xsl:comment>
            <xsl:call-template name="outputErrorMessage">
               <xsl:with-param name="messageText"
                               as="xs:string"
                               select=" 'remotelink/@refpt is missing and link cannot be correctly completed' "/>
               <xsl:with-param name="errorType" as="xs:string" select=" 'ICCE' "/>
               <xsl:with-param name="errorCode" as="xs:string*" select=" 'TBD' "/>
               <xsl:with-param name="context" as="xs:string">
                  <xsl:value-of select="base-uri()"/>
               </xsl:with-param>
            </xsl:call-template>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--SS 28-11-2017: Added handling of remotelink/@refpt='dummy' value comes in HK07.-->
   <xsl:template match="remotelink[@refpt='dummy' and @status='unval'][$streamID='HK07']">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- @@@  SBy:  below is from Awntika and likely from QC code base, but not mentioned in DITA so commenting out for now -->   <!--xsl:template match="remotelink[@service=ATTACHMENT]">
		<!-/-  Original Target XPath:  ref:lnlink[@service="ATTACHMENT"]   -/->
		<xsl:element name="ref:lnlink">
			<xsl:attribute name="service"><xsl:text>URL</xsl:text></xsl:attribute>
			<xsl:element name="ref:marker">
				<xsl:apply-templates/>
			</xsl:element>
			<xsl:element name="ref:locator">
				<xsl:element name="ref:locator-key">
					<xsl:element name="ref:key-name">
						<xsl:attribute name="name"><xsl:value-of select="@remotekey1='DOC-ID' or @remotekey1='DOCID'"/></xsl:attribute>
					</xsl:element>
					<xsl:element name="ref:key-value">
						<xsl:attribute name="value"><xsl:value-of select="@dpsi"/><xsl:text>_</xsl:text><xsl:choose><xsl:when test="@docidref"><xsl:value-of select="./@docidref"/></xsl:when><xsl:otherwise><xsl:value-of select="./@refpt"/></xsl:otherwise></xsl:choose></xsl:attribute>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
	</xsl:template>

	<xsl:template match="remotelink[parent::glp:note]">
		<xsl:element name="note">
			<xsl:element name="bodytext">
				<xsl:element name="p">
					<xsl:element name="text">
						<ref:crossreference>
							<xsl:attribute name="crossreferencetype">See Also</xsl:attribute>
							<ref:content>
								<xsl:if test="remotelink[@xml:lang]">
									<xsl:attribute name="xml:lang"><xsl:value-of select="@xml:lang"/></xsl:attribute>
								</xsl:if>
								<xsl:apply-templates/>
							</ref:content>
							<xsl:element name="ref:locator">
								<xsl:choose>
									<xsl:when test="@remotekey1='DOC-ID' or @remotekey1='DOCID'">
										<xsl:element name="ref:locator-key">
											<xsl:element name="ref:key-name">
												<xsl:attribute name="name"><xsl:text>DOC-ID</xsl:text></xsl:attribute>
											</xsl:element>
											<xsl:element name="ref:key-value">
												<xsl:attribute name="value"><xsl:choose><xsl:when test="@dpsi"><xsl:value-of select="@dpsi"/><xsl:text>-</xsl:text></xsl:when><xsl:when test="../docinfo:dpsi/@id-string"><xsl:value-of select="../docinfo:dpsi/@id-string"/></xsl:when><xsl:otherwise>***no dpsi</xsl:otherwise></xsl:choose><xsl:choose><xsl:when test="@remotekey2"><xsl:value-of select="@remotekey2"/></xsl:when><xsl:otherwise><xsl:value-of select="@refpt"/></xsl:otherwise></xsl:choose></xsl:attribute>
											</xsl:element>
										</xsl:element>
									</xsl:when>
									<xsl:when test="@remotekey1='REFPTID'">
										<xsl:attribute name="anchoridref"><xsl:choose><xsl:when test="contains('0123456789', substring(@refpt,1,1))"><xsl:text>_</xsl:text><xsl:value-of select="@refpt or @remotelink2"/></xsl:when><xsl:otherwise><xsl:value-of select="@refpt"/></xsl:otherwise></xsl:choose></xsl:attribute>
									</xsl:when>
								</xsl:choose>
							</xsl:element>
						</ref:crossreference>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
	</xsl:template>

	<xsl:template match="remotelink[child::inlineobject]">
		<xsl:element name="ref:lnlink">
			<xsl:attribute name="service"><xsl:text>URL</xsl:text></xsl:attribute>
			<xsl:element name="ref:marker">
				<xsl:apply-templates/>
			</xsl:element>
			<xsl:element name="ref:locator">
				<xsl:element name="ref:locator-key">
					<xsl:element name="ref:key-name">
						<xsl:attribute name="name"><xsl:text>URL</xsl:text></xsl:attribute>
					</xsl:element>
					<xsl:element name="ref:key-value">
						<xsl:attribute name="value"><xsl:value-of select="normalize-space(@href)"/></xsl:attribute>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
	</xsl:template>

	<xsl:template match="docinfo:assoc-links/remotelink[@service='DOC-ID']">
		<!-/-  Original Target XPath:  ref:crossreference   -/->
		<xsl:element name="doc:related-content">
			<xsl:element name="doc:related-content-item">
				<xsl:element name="doc:related-content-link">
					<xsl:element name="ref:lnlink">
						<xsl:attribute name="service"><xsl:text>DOCUMENT</xsl:text></xsl:attribute>
						<xsl:element name="ref:marker">
							<xsl:value-of select="./remotelink[@service='DOC-ID']"/>
						</xsl:element>
						<xsl:element name="ref:locator">
							<xsl:attribute name="anchoridref"><xsl:choose><xsl:when test="./remotelink[@service='DOC-ID']/@refpt"><xsl:value-of select="./remotelink[@service='DOC-ID']/@refpt"/></xsl:when><xsl:otherwise><xsl:value-of select="./remotelink[@service='DOC-ID']/@remotekey2"/></xsl:otherwise></xsl:choose></xsl:attribute>
							<xsl:element name="ref:locator-key">
								<xsl:element name="ref:key-name">
									<xsl:attribute name="name"><xsl:value-of select="./remotelink[@service='DOC-ID']/@service"/></xsl:attribute>
								</xsl:element>
								<xsl:element name="ref:key-value">
									<xsl:attribute name="value"><xsl:value-of select="./remotelink[@service='DOC-ID']/@dpsi"/><xsl:text>-</xsl:text><xsl:value-of select="remotelink[@service='DOC-ID']/@remotekey2"/></xsl:attribute>
								</xsl:element>
							</xsl:element>
						</xsl:element>
					</xsl:element>
				</xsl:element>
			</xsl:element>
		</xsl:element>
	</xsl:template-->   <!-- <topicref href="../../common_newest/Rosetta_remotelink-self-inter-document-link-LxAdv-intra-document-link.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>If a <xd:i>remotelink</xd:i> is created as an <xd:i>
               <xd:b>inter</xd:b>-document</xd:i>
                link in the source file, yet its target is contained within the same source file,
                the <xd:i>remotelink</xd:i> must be converted to an
                    <xd:i>
               <xd:b>intra</xd:b>-document</xd:i> link.</xd:p>
         <xd:p>For any given <xd:i>remotelink</xd:i> where its
                    <xd:i>@refpt</xd:i> value is equivalent to an
                    <xd:i>refpt/@id</xd:i> value within the same soure file, create an
                        <xd:i>
               <xd:b>intra</xd:b>-document</xd:i> link.</xd:p>
         <xd:p>
            <xd:ul>
               <xd:li>
                  <xd:i>remotelink</xd:i> becomes
                        <xd:b>ref:lnlink</xd:b>.</xd:li>
               <xd:li>The attribute <xd:i>remotelink/@status</xd:i> is always suppressed, it is never output to the target document.</xd:li>
               <xd:li>The content of <xd:i>remotelink</xd:i> becomes
                            <xd:b>ref:marker</xd:b>.</xd:li>
               <xd:li>Create <xd:b>ref:locator</xd:b> and populate the attribute
                            <xd:b>ref:locator/@anchoridref</xd:b> with the value of
                            <xd:i>remotelink/@refpt</xd:i>.</xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>ref:locator/@anchoridref</xd:b> that begins with a number must
                have an underscore added at start. Also apply other identifier data type format as
                used for <xd:b>xml:id</xd:b> and <xd:b>ref:anchor/@id</xd:b>
                (e.g. change colon to underscore).</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

...
&lt;remotelink refpt="CTH_ACT_1958-62_PROVLIST" remotekey1="REFPTID"
			service="DOC-ID"&gt;List of Provisions&lt;/remotelink&gt;
...
&lt;leg:heading&gt;
    &lt;title&gt;&lt;refpt id="CTH_ACT_1958-62_PROVLIST" type="ext"/&gt;List of provisions&lt;/title&gt;
&lt;leg:heading&gt;
...

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

...
&lt;ref:lnlink&gt;                                        
	&lt;ref:marker&gt;List of Provisions&lt;/ref:marker&gt;                                        
	&lt;ref:locator anchoridref="CTH_ACT_1958-62_PROVLIST"/&gt;                                            	                            
&lt;/ref:lnlink&gt;
...
&lt;ref:anchor id="CTH_ACT_1958-62_PROVLIST" anchortype="global"/&gt;
&lt;heading&gt;
    &lt;title&gt;List of provisions&lt;/title&gt;
&lt;heading&gt;
...

	</xd:pre>
         <!--Changes2015-05-22: Added an instruction to explicitly indicate remotelink/@status is always dropped (suppressed). This is a very low-priority change and has been added for technical correctness, particularly with respect to new CIs. Existing scripts do not have to implement this change unless needed since prior to the change remotelink/@status handling was not explicitly specified.2013-08-12: Changed module heading from ref:crossreference to ref:lnlink.  NO
              instructions are changed.  WebTeam # 230229. Affects all streams.2013-08-07: Changed target to
                        ref:lnlink; formerly
                        ref:crossreference. Changed because the only
                    supported markup for intradoc linking is ref:lnlink, as
                per Bency Thomas. WebTeam # 230229. Affects all streams.2012-11-01: Created.-->
         <!--<section>
            <title>Changes</title>
            <p>2012-11-01: Created.</p>
        </section>-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_remotelink-self-inter-document-link-LxAdv-intra-document-link.dita  -->
   <!-- keys for standalone testing below. These keys need to be in the driver file for this module to work. -->
   <!--    <xsl:key name="idTypeValue" match="*[@id]" use="@id"/>
    <xsl:key name="idTypeValue" match="*[@ID]" use="@ID"/>-->
   <!-- Awantika: 2017-12-29: Added not(parent::docinfo:assoc-links-grp and $streamID='AU04') for webstar  #7078784 -->
   <xsl:template match="remotelink[key('idTypeValue', @refpt)[self::refpt]][not(ancestor::ci:content)][not(parent::source_cttr:annot and $streamID=('HK08' , 'AU02', 'AU04','UK05','CA03'))]         [not(parent::docinfo:assoc-links-grp and $streamID='AU04')]"
                 priority="26">
      <ref:lnlink>
         <ref:marker>
            <xsl:apply-templates select="node()"/>
         </ref:marker>
         <ref:locator>
            <xsl:attribute name="anchoridref">
               <xsl:apply-templates select="@refpt" mode="intradoc"/>
            </xsl:attribute>
         </ref:locator>
      </ref:lnlink>
   </xsl:template>

   <xsl:template match="remotelink/@refpt" mode="intradoc">
      <xsl:call-template name="normalizeIdString"/>
   </xsl:template>
   <!-- end topichead  remotelink  -->   <!-- rosetta element: sigblock -->   <!-- <topicref href="../../common_newest/Rosetta_sigblock-LxAdv-sigblock.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>sigblock</xd:i> becomes <xd:b>sigblock</xd:b> with optional attribute <xd:b>@align</xd:b> and values are tokenized (left | right | center | justify).</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;sigblock&gt; &lt;p&gt; &lt;text&gt; &lt;person&gt; &lt;name.text&gt;D I CASSIDY QC&lt;/name.text&gt; &lt;/person&gt; &lt;/text&gt; &lt;/p&gt; &lt;/sigblock&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;sigblock&gt; &lt;p&gt; &lt;text&gt; &lt;person:person&gt; &lt;person:name.text&gt;D I CASSIDY QC&lt;/person:name.text&gt; &lt;/person:person&gt; &lt;/text&gt; &lt;/p&gt; &lt;/sigblock&gt;
				</xd:pre>
         <!--Changes2011-12-21: Created. -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_sigblock-LxAdv-sigblock.dita  -->
   <!-- Vikas Rohilla : Template to mach the sigblock and copy the element-->
   <xsl:template match="sigblock">
      <sigblock>
         <xsl:apply-templates select="@* | node()"/>
      </sigblock>
   </xsl:template>
   <!-- CSN - 2017/09/29 - added parent::leg:levelbody for UK07 GDS test case -->
   <xsl:template match="sigblock[parent::leg:endmatter | parent::leg:levelbody]">
      <primlaw:bodytext>
         <sigblock>
            <xsl:apply-templates select="@* | node()"/>
         </sigblock>
      </primlaw:bodytext>
   </xsl:template>

   <xsl:template match="sigblock[ancestor::form]">
      <form:sigblock>
         <xsl:apply-templates select="@* | node()"/>
      </form:sigblock>
   </xsl:template>

   <xsl:template match="sigblock/p[text][ancestor::form]"/>

   <xsl:template match="sigblock/p/text[ancestor::form]">
      <form:line>
         <xsl:apply-templates select="node()"/>
      </form:line>
   </xsl:template>

   <xsl:template match="sigblock/p/table">
      <table>
         <xsl:apply-templates select="@* | node()"/>
      </table>
   </xsl:template>
   <!-- rosetta element: strike -->   <!-- <topicref href="../../common_newest/Rosetta_strike-LxAdv-strike.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>strike</xd:i> becomes <xd:b>strike</xd:b>. The optional attribute <xd:i>@typestyle</xd:i> becomes <xd:b>@typestyle</xd:b>.
		</xd:p>
         <xd:p>
            <xd:b>Source XML 1</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="ro"&gt;
    &lt;strike typestyle="lineout"&gt;s&amp;#xA0;&lt;/strike&gt;
&lt;/emph&gt;&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="ro"&gt;
    &lt;strike typestyle="lineout"&gt;s&amp;#xA0;&lt;/strike&gt;
&lt;/emph&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Source XML 2</xd:b>
         </xd:p>
         <xd:pre>

&lt;strike&gt;Gilles Prud'homme&lt;/strike&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;strike typestyle="lineout"&gt;Gilles Prud'homme&lt;/strike&gt;

	</xd:pre>
         <!--Changes2011-12-15: Created.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_strike-LxAdv-strike.dita  -->
   <!-- Vikas Rohilla : Updated the template hegher the priorty -->
   <!-- JD: removed priority; commented competing template in /modules/nonamespace/Rosetta_text-LxAdv-text.xsl; 
	this should be the default for all <strike> handling. -->
   <xsl:template match="strike">
      <strike>
         <xsl:apply-templates select="@* | node()"/>
      </strike>
   </xsl:template>
   <!-- Vikas Rohilla : creted template for the @typestyle-->
   <xsl:template match="strike/@typestyle">
      <xsl:attribute name="typestyle">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>
   <!-- rosetta element: sub -->   <!-- <topicref href="../../common_newest/Rosetta_sub-LxAdv-sub.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>sub</xd:i> becomes <xd:b>sub</xd:b>. </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="it"&gt;
  &lt;sub&gt;*&lt;/sub&gt;
&lt;/emph&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="it"&gt;
  &lt;sub&gt;*&lt;/sub&gt;
&lt;/emph&gt;

	</xd:pre>
         <!--Changes2011-12-15: Created. -->
      </xd:desc>
   </xd:doc>
   <xsl:template match="sub">
      <sub>
         <xsl:apply-templates select="@* | node()"/>
      </sub>
   </xsl:template>
   <!-- rosetta element: subtitle -->   <!-- <topicref href="../../common_newest/Rosetta_subtitle-LxAdv-subtitle.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>subtitle</xd:i> becomes <xd:b>subtitle</xd:b>
         </xd:p>
         <!--<p>If the input document has subtitle/defterm scenario then
                    <sourcexml>defterm</sourcexml> within a subtitle can be dropped, but the child
                element and content of the tag is retained and no text is dropped. </p>-->
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
	&lt;subtitle&gt;Applications for leave to appeal against sentence not heard by a single judge of appeal&lt;/subtitle&gt;
&lt;/heading&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
	&lt;subtitle&gt;Applications for leave to appeal against sentence not heard by a single judge of appeal&lt;/subtitle&gt;
&lt;/heading&gt;

	</xd:pre>
         <!-- <example>
            <title>Source XML having subtitle/defterm scenario:</title>
            <codeblock>

&lt;subtitle&gt;
   &lt;defterm&gt;
      &lt;emph typestyle="bf"&gt;&amp;#x201C;Greenhouse Gas Storage Act 2009&amp;#x201D;&lt;/emph&gt;
   &lt;/defterm&gt;
&lt;/subtitle&gt;

	</codeblock>
        </example>
        <example>
            <title>Target XML</title>
            <codeblock>

&lt;subtitle&gt;   
      &lt;emph typestyle="bf"&gt;&amp;#x201C;Greenhouse Gas Storage Act 2009&amp;#x201D;&lt;/emph&gt;   
&lt;/subtitle&gt;

	</codeblock>
        </example>-->
         <!--Changes2011-12-15: Created.-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="subtitle"><!--  Original Target XPath:  subtitle   -->
      <subtitle>
         <xsl:apply-templates select="@* | node() except refpt"/>
      </subtitle>
   </xsl:template>
   <!-- rosetta element: sup -->   <!-- <topicref href="../../common_newest/Rosetta_sup-LxAdv-sup.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>sup</xd:i> becomes <xd:b>sup</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="it"&gt;
  &lt;sup&gt;*&lt;/sup&gt;
&lt;/emph&gt;

	</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;emph typestyle="it"&gt;
  &lt;sup&gt;*&lt;/sup&gt;
&lt;/emph&gt;

	</xd:pre>
         <!--Changes2011-12-15: Created.
		-->
      </xd:desc>
   </xd:doc>
   <xsl:template match="sup">
      <sup>
         <xsl:apply-templates select="@* | node()"/>
      </sup>
   </xsl:template>
   <!-- rosetta element: table -->   <!-- start topichead  table  -->   <!-- <topicref href="../../common_newest/Rosetta_table-LxAdv-table.dita"/> -->   <xd:doc>
						xmlns:primlawhist="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-history/1/"
		<xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>Contains the titling content for a table, and titled groups that contain rows of
					cells ("entries"). Table now allows an optional heading element, which contains
					the titling content as well. The titling elements directly within table - title
					and subtitle - are deprecated in favor of using these elements inside the
					heading. </xd:p>
         <xd:ul>
            <xd:li>
               <xd:i>table</xd:i> becomes <xd:b>table</xd:b> comes with
							<xd:i>@frame</xd:i> becomes <xd:b>@frame</xd:b>
						which has tokenized values as (top | bottom | topbot | all | sides | none)
						and required child element is described below: <xd:ul>
                  <xd:li>
                     <xd:i>tgroup</xd:i> becomes <xd:b>tgroup</xd:b>
								with attributes <xd:i>@cols</xd:i> becomes
									<xd:b>@cols</xd:b> is the required attribute.
									<xd:i>@colsep</xd:i> becomes
									<xd:b>@colsep</xd:b>
                     <xd:i>@rowsep</xd:i> becomes
									<xd:b>@rowsep</xd:b> and child element includes: <xd:ul>
                        <xd:li>
                           <xd:i>colspec</xd:i> becomes
											<xd:b>colspec</xd:b> and attributes are
										converted as follows: <xd:ul>
                              <xd:li>
                                 <xd:i>@align</xd:i> becomes
												<xd:b>@align</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@char</xd:i> becomes
												<xd:b>@char</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@charoff</xd:i> becomes
												<xd:b>@charoff</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@colname</xd:i> becomes
												<xd:b>@colname</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@colnum</xd:i> becomes
												<xd:b>@colnum</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@colsep</xd:i> becomes
												<xd:b>@colsep</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@colwidth</xd:i> becomes
												<xd:b>@colwidth</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@id</xd:i> may be dropped or may
												require special handling. It may become
												<xd:b>@ref:anchor</xd:b> and if so is
												moved to the parent or higher ancestor element. This
												will be specified in the the particular CI as it
												will be done on a stream by stream basis and will
												depend on the particular XPath of the table element.
												In the absence of specific instructions elsewhere in
												the CI, <xd:i>@id</xd:i> is dropped.</xd:li>
                              <xd:li>
                                 <xd:i>@rowsep</xd:i> becomes
												<xd:b>@rowsep</xd:b>
                              </xd:li>
                              <xd:li>
                                 <xd:i>@searchtype</xd:i> is dropped</xd:li>
                              <xd:li>
                                 <xd:i>@xml:lang</xd:i> becomes
												<xd:b>@xml:lang</xd:b>
                              </xd:li>
                           </xd:ul>
                           <xd:p>
                              <xd:b>Note: </xd:b>
                              <xd:p>CALS table markup allows for units to be embedded in
												the column width. Lexis Advance only recognizes an
												integer in pixels and proportional, identified by a
												number ending with "*".</xd:p>
                              <xd:p>If a non-Lexis Advance format is discovered a warning
												should be raised.</xd:p>
                              <xd:p>If the LBU requires a conversion of CALS units to LA
												accepted units, some of the conversions are detailed
												below.</xd:p>
                              <xd:p>If colspec@colwidth ends in in (inch) them remove
												in and multiply the value by 96 to convert to
												pixel. Only keep the integer portion of the result.
												These are not valid: 0.1, 12.86. These are valid:
												12, 185</xd:p>
                              <xd:p>cm; follow the inches example above but use a
												conversion value of 37.7952755904</xd:p>
                              <xd:p>mm; follow the inches example above but use a
												conversion value of 3.77952755904</xd:p>
                              <xd:p>pt; follow the inches example above but use a
												conversion value of 1.0</xd:p>
                           </xd:p>
                        </xd:li>
                     </xd:ul>
                     <xd:p>The following instructions apply to all table markup (table
									element and its decendents) with @morerows, @colsep, and @rowsep
										attributes:<xd:ul>
                           <xd:li>Remove any instances of @morerows=0</xd:li>
                           <xd:li>If ALL occurrences of @colsep in one table have a value
											of zero, remove them all from that table. </xd:li>
                           <xd:li>If ALL occurrences of @rowsep in one table have a value
											of zero, remove them all from that table. </xd:li>
                        </xd:ul>
                        <xd:p>
                           <xd:b>Note: </xd:b>Although these instructions apply to all content streams,
										only the UK content streams and AU18 are known to have these
										issues.</xd:p>
                     </xd:p>
                     <xd:ul>
                        <xd:li>
                           <xd:i>thead</xd:i> becomes
											<xd:b>thead</xd:b> below is the required child
										element: <xd:ul>
                              <xd:li>
                                 <xd:i>row</xd:i> becomes
												<xd:b>row</xd:b> below is the required
												child element: <xd:ul>
                                    <xd:li>
                                       <xd:i>entry</xd:i> becomes
												<xd:b>entry</xd:b> and comes with
												<xd:i>@nameend</xd:i> becomes
												<xd:b>@nameend</xd:b>
                                       <xd:i>@namest</xd:i> becomes
												<xd:b>@namest</xd:b>
                                       <xd:i>@align</xd:i> becomes
												<xd:b>@align</xd:b> with tokenized
												values as (left | right | center | justify | char)
												</xd:li>
                                 </xd:ul>
                              </xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                     <xd:ul>
                        <xd:li>
                           <xd:i>tbody</xd:i> becomes
											<xd:b>tbody</xd:b> and child element includes: <xd:ul>
                              <xd:li>
                                 <xd:i>row</xd:i> becomes
												<xd:b>row</xd:b> and child element
												includes: <xd:ul>
                                    <xd:li>
                                       <xd:i>entry</xd:i> becomes
												<xd:b>entry</xd:b> and comes with
												<xd:i>@nameend</xd:i> becomes
												<xd:b>@nameend</xd:b>
                                       <xd:i>@namest</xd:i> becomes
												<xd:b>@namest</xd:b>
                                       <xd:i>@char</xd:i> becomes
												<xd:b>@char</xd:b>
                                       <xd:i>@align</xd:i> becomes
												<xd:b>@align</xd:b> with tokenized
												values as (left | right | center | justify | char)
												</xd:li>
                                 </xd:ul>
                              </xd:li>
                           </xd:ul>
                        </xd:li>
                     </xd:ul>
                  </xd:li>
               </xd:ul>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Note: </xd:b> Multiple <xd:i>tgroup</xd:i> are retained for conversion.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;table frame="none"&gt; &lt;tgroup cols="3" colsep="0" rowsep="0"&gt;
					&lt;colspec colname="col1" colnum="1" colwidth="5*"/&gt; &lt;colspec
					colname="col2" colnum="2" colwidth="83*"/&gt; &lt;colspec align="left"
					colname="col3" colnum="3" colwidth="12*"/&gt; &lt;thead&gt; &lt;row&gt;
					&lt;entry align="center" nameend="col3" namest="col1"&gt;&lt;emph
					typestyle="bf"&gt;Table of contents&lt;/emph&gt;&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry/&gt;&lt;entry/&gt; &lt;entry align="right"
					colname="col3"&gt;&lt;emph typestyle="bf"&gt;Para no&lt;/emph&gt;&lt;/entry&gt;
					&lt;/row&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;row&gt; &lt;entry align="left"
					nameend="col2" namest="col1"&gt;Introduction&lt;/entry&gt; &lt;entry
					align="right" colname="col3"&gt;[1]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt;
					&lt;entry align="left" nameend="col2" namest="col1"&gt;Mental health legislation
					concerning informal patients&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[6]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Procedural background&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[15]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;Applicable
					statutory provisions&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[22]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;The English position&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[33]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;Submissions
					of parties&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[39]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Protective provisions&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[43]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;The 1961 Act:
					Crown authority to treat informal patients&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[45]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Leave requirements&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[50]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;The 1969
					Act&lt;/entry&gt; &lt;entry align="right" colname="col3"&gt;&lt;/entry&gt;
					&lt;/row&gt; &lt;row&gt; &lt;entry/&gt; &lt;entry align="left"
					colname="col2"&gt;(a) Crown authority to treat informal patients&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[54]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry/&gt; &lt;entry align="left" colname="col2"&gt;(b)
					Authority of hospital boards to treat informal patients&lt;/entry&gt; &lt;entry
					align="right" colname="col3"&gt;[56]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt;
					&lt;entry align="left" nameend="col2" namest="col1"&gt;Conclusion&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[75]&lt;/entry&gt; &lt;/row&gt;
					&lt;/tbody&gt; &lt;/tgroup&gt; &lt;/table&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;table frame="none"&gt; &lt;tgroup cols="3"&gt; &lt;colspec
					colname="col1" colnum="1" colwidth="5*"/&gt; &lt;colspec colname="col2"
					colnum="2" colwidth="83*"/&gt; &lt;colspec align="left" colname="col3"
					colnum="3" colwidth="12*"/&gt; &lt;thead&gt; &lt;row&gt; &lt;entry
					align="center" nameend="col3" namest="col1"&gt;&lt;emph typestyle="bf"&gt;Table
					of contents&lt;/emph&gt;&lt;/entry&gt; &lt;/row&gt; &lt;row&gt;
					&lt;entry/&gt;&lt;entry/&gt; &lt;entry align="right" colname="col3"&gt;&lt;emph
					typestyle="bf"&gt;Para no&lt;/emph&gt;&lt;/entry&gt; &lt;/row&gt; &lt;/thead&gt;
					&lt;tbody&gt; &lt;row&gt; &lt;entry align="left" nameend="col2"
					namest="col1"&gt;Introduction&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[1]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Mental health legislation
					concerning informal patients&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[6]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Procedural background&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[15]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;Applicable
					statutory provisions&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[22]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;The English position&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[33]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;Submissions
					of parties&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[39]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Protective provisions&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[43]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;The 1961 Act:
					Crown authority to treat informal patients&lt;/entry&gt; &lt;entry align="right"
					colname="col3"&gt;[45]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt; &lt;entry
					align="left" nameend="col2" namest="col1"&gt;Leave requirements&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[50]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry align="left" nameend="col2" namest="col1"&gt;The 1969
					Act&lt;/entry&gt; &lt;entry align="right" colname="col3"&gt;&lt;/entry&gt;
					&lt;/row&gt; &lt;row&gt; &lt;entry/&gt; &lt;entry align="left"
					colname="col2"&gt;(a) Crown authority to treat informal patients&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[54]&lt;/entry&gt; &lt;/row&gt;
					&lt;row&gt; &lt;entry/&gt; &lt;entry align="left" colname="col2"&gt;(b)
					Authority of hospital boards to treat informal patients&lt;/entry&gt; &lt;entry
					align="right" colname="col3"&gt;[56]&lt;/entry&gt; &lt;/row&gt; &lt;row&gt;
					&lt;entry align="left" nameend="col2" namest="col1"&gt;Conclusion&lt;/entry&gt;
					&lt;entry align="right" colname="col3"&gt;[75]&lt;/entry&gt; &lt;/row&gt;
					&lt;/tbody&gt; &lt;/tgroup&gt; &lt;/table&gt; </xd:pre>
         <!--Changes2014-07-08: Updated instruction for added the
						following rarely occurring attributes @char inside
						the entry.2014-06-04: For completeness, added instructions for
						the following rarely occurring attributes of
							table/tgroup/colspec:
							@align, @char,
							@charoff, @colsep,
							@id, @rowsep,
							@searchtype, and
						@xml:lang. This is in response to various minor
						questions on message boards that have been asked and answered over the past
						two years. These instructions should not trigger changes to existing
						conversion programs, as the programs have already been changed in response
						to previous message board answers. These instructions have been added so
						this topic is up-to-date with respect to current conversion program behavior
						for these rarely occuring attributes.2013-09-16: Removed an obsolete note regarding
						visual styling of tables.2013-09-12: WebTeam #s 235116, 235130, 235126: Added instructions for deleting
						extraneous instances of @morerows, @colsep and @rowsep. These instructions
						apply immediately to all UK streams and also to AU18.2012-01-12: Added a note for handling multiple tgroup. 2011-12-15: Created. -->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_table-LxAdv-table.dita  -->
   <!--  @SBy:  this is from QC XSLT.  Should it appear here?  -->
   <!-- BRT: process table with page elements (break table in row before each row//page, create ref:page, create another table starting from row//page -->
   <xsl:template match="table[descendant::entry/descendant::page]" priority="15"><!-- BRT create a separate table before the start of a row that contains entry/descendant::page -->
      <xsl:for-each-group select=".//row" group-starting-with="row[entry/descendant::page]"><!-- BRT: If there is a ref:page in the current-group(), create the ref:page first -->
         <xsl:if test="current-group()//page">
            <xsl:element name="ref:page">
               <xsl:attribute name="num">
                  <xsl:value-of select="translate(current-group()//page/@count, ',', '')"/>
               </xsl:attribute>
               <xsl:if test="current-group()//page/@reporter">
                  <xsl:attribute name="page-scheme">
                     <xsl:value-of select="translate(current-group()//page/@reporter, ' ', '_')"/>
                  </xsl:attribute>
               </xsl:if>
               <xsl:if test="current-group()//page/@subdoc">
                  <xsl:attribute name="includeintoc">
                     <xsl:value-of select="current-group()//page/@subdoc"/>
                  </xsl:attribute>
               </xsl:if>
               <xsl:attribute name="page-scheme-type">
                  <xsl:text>reporter-abbreviation</xsl:text>
               </xsl:attribute>
            </xsl:element>
         </xsl:if>
         <!-- BRT create separate table for each group -->
         <xsl:element name="table"
                      namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"><!-- BRT: Convert table, tgroup, and colspec  -->
            <xsl:copy-of select="ancestor::table/(@* except @id)"/>
            <xsl:if test="ancestor::table/@id">
               <xsl:variable name="count" select="position()"/>
               <xsl:for-each select="ancestor::table/@id">
                  <xsl:attribute name="xml:id">
                     <xsl:value-of select="concat(ancestor::table/@id, '_', $count)"/>
                  </xsl:attribute>
               </xsl:for-each>
            </xsl:if>
            <xsl:element name="tgroup"
                         namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
               <xsl:copy-of select="ancestor::table[1]/tgroup/@*"/>
               <xsl:for-each select="ancestor::table[1]//colspec">
                  <xsl:element name="colspec"
                               namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                     <xsl:copy-of select="@*"/>
                     <xsl:apply-templates/>
                  </xsl:element>
               </xsl:for-each>
               <xsl:for-each select="ancestor::table[1]//thead">
                  <xsl:element name="thead"
                               namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                     <xsl:copy-of select="@*"/>
                     <xsl:apply-templates/>
                  </xsl:element>
               </xsl:for-each>
               <xsl:element name="tbody"
                            namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
                  <xsl:copy-of select="ancestor::table[1]//tbody/@*"/>
                  <!-- apply all the rows of the current group to the current table -->
                  <xsl:apply-templates select="current-group()"/>
               </xsl:element>
            </xsl:element>
         </xsl:element>
      </xsl:for-each-group>
   </xsl:template>
   <!--  @SBy:  modified from QC XSLT  -->   <!-- 2017-10-17 - MDS: Added choose statment due to webstar 7025682.   -->   <!-- 2017-11-16 - CSN: Added UK03|case:dicisionsummary to existing 'when'.  webstar 7050317.   -->
   <xsl:template match="table" name="table">
      <xsl:choose>
         <xsl:when test="parent::entry or ((parent::case:decisionsummary or parent::case:typeofcase) and $streamID='UK03')">
            <p>
               <table>
                  <xsl:copy-of select="@frame | @pgwide"/>
                  <!--  @SBy:  only @frame is in DITA  -->
                  <!--  @SBy:  note @colsep | @rowsep addressed specifically in other template rules below  -->
                  <xsl:apply-templates select="@* except (@frame, @pgwide)"/>
                  <xsl:apply-templates/>
               </table>
            </p>
         </xsl:when>
         <!-- MDS - 2018-02-09 - Added to handle those otherwise empty tables that seem to be in the development data.  STREAM SPECIFIC -->
         <xsl:when test="$streamID='AU16' and not(tgroup/tbody/row/entry[2]) and not(tgroup/tbody/row[2]) and tgroup/tbody/row/entry[contains(normalize-space(.), '')]"/>
         <xsl:otherwise>
            <table>
               <xsl:copy-of select="@frame"/>
               <!-- BRT 11/16/17 added special handling for @pgwide in UK content. If value is '0', output is '0', otherwise, the output is '1' -->
               <xsl:choose>
                  <xsl:when test="$streamID = ('UK01', 'UK02', 'UK05', 'UK08CA','UK08OR', 'UK09', 'UK10', 'UK15', 'UK17', 'UK18','UK20','UK22LF')">
                     <xsl:if test="@pgwide">
                        <xsl:attribute name="pgwide">
                           <xsl:choose>
                              <xsl:when test="@pgwide='0'">
                                 <xsl:value-of select="'0'"/>
                              </xsl:when>
                              <xsl:otherwise>
                                 <xsl:value-of select="'1'"/>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:attribute>
                     </xsl:if>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:copy-of select="@pgwide"/>
                  </xsl:otherwise>
               </xsl:choose>
               <xsl:copy-of select="@frame"/>
               <!--  @SBy:  only @frame is in DITA  -->
               <!--  @SBy:  note @colsep | @rowsep addressed specifically in other template rules below  -->
               <xsl:apply-templates select="@* except (@frame, @pgwide)"/>
               <xsl:apply-templates/>
            </table>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="tgroup">
      <tgroup>
         <xsl:copy-of select="@cols"/>
         <!--  @SBy:  note @colsep | @rowsep addressed specifically in other template rules below  -->
         <xsl:apply-templates select="@* except @cols"/>
         <xsl:apply-templates/>
      </tgroup>
   </xsl:template>

   <xsl:template match="tgroup/@align">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="colspec">
      <colspec>
         <xsl:copy-of select="@align | @char | @charoff | @colname | @colnum | @xml:lang"/>
         <!--  @SBy:  note @colsep | @rowsep addressed specifically in other template rules below  -->
         <xsl:apply-templates select="@* except (@align, @char, @charoff, @colname, @colnum, @xml:lang)"/>
         <xsl:apply-templates/>
         <!--  ***NOTE  -  see DITA regarding conversions of @colwidth values; does the DT code do any of that?  ***  -->
      </colspec>
   </xsl:template>

   <xsl:template match="colspec/@colwidth">
      <xsl:attribute name="colwidth"><!--<xsl:value-of select="."/>-->
         <xsl:analyze-string select="." regex="([0-9]+)([*]|[a-z]+)">
            <xsl:matching-substring>
               <xsl:choose>
                  <xsl:when test="regex-group(2) = 'in'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number(regex-group(1)) * 96"/>
                     </xsl:variable>
                     <xsl:value-of select="$var1"/>
                     <xsl:value-of select="concat($var1, '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'cm'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number(regex-group(1)) * 37.7952755904"/>
                     </xsl:variable>
                     <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'mm'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number(regex-group(1)) * 3.77952755904"/>
                     </xsl:variable>
                     <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'pt'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number(regex-group(1)) * 1"/>
                     </xsl:variable>
                     <xsl:value-of select="concat($var1, '*')"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:value-of select="concat(regex-group(1), '*')"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:matching-substring>
         </xsl:analyze-string>
      </xsl:attribute>
   </xsl:template>
   <!-- SNB 2017-10-17 creating a new template that I think probably oght to be the template for all rosetta conversions for colwidth... 
		the above template creates flat out WRONG rarget markup when here's a decimal ( colwidth="78.50pt" resulted in 
		  colwidth="50*", and  colwidth="80.00pt" resulted in  colwidth="0*"), and catching an empty column width seems wise in general. 
		  For LPA, we need to catch numbers with no * or units, which none of these templates do. The ones below for NZ111 and AU10 catch 
		  decimal numbers well, but not the case of no units or *. -->
   <xsl:template match="colspec[$streamID=('USLPA')]/@colwidth" priority="3">
      <xsl:attribute name="colwidth">
         <xsl:choose><!-- empty colwidth -->
            <xsl:when test="normalize-space(.)=''"><!-- converts empty colwidth to "*" -->
               <xsl:value-of select="'*'"/>
            </xsl:when>
            <!-- only a number, no decimal, no units, add * at end -->
            <xsl:when test="(not(matches(.,'[a-z\.*]+','i')))">
               <xsl:value-of select="concat(., '*')"/>
            </xsl:when>
            <!-- only a DECIMAL number, no units, strip decimal and following numbers and add * at end -->
            <xsl:when test="(not(matches(.,'[a-z*]+','i')))">
               <xsl:analyze-string select="." regex="([0-9]+)(\.+)([0-9]+)">
                  <xsl:matching-substring><!--Dont need to choose; just use regex-group(1) and throw rest away-->
                     <xsl:value-of select="concat(regex-group(1), '*')"/>
                  </xsl:matching-substring>
                  <xsl:non-matching-substring/>
               </xsl:analyze-string>
            </xsl:when>
            <!-- number with decimal, with units, strip decimal, convert to specified unit, and add * at end -->
            <xsl:when test="(matches(.,'[0-9]+[\.][0-9]*([*]|[a-z]+)','i'))">
               <xsl:analyze-string select="." regex="([0-9\.]+)([*]|[a-zA-Z]+)">
                  <xsl:matching-substring>
                     <xsl:variable name="wholenumber"
                                   select="number(substring-before(regex-group(1),'.'))"/>
                     <xsl:choose>
                        <xsl:when test="lower-case(regex-group(2)) = 'in'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number($wholenumber) * 96"/>
                           </xsl:variable>
                           <xsl:value-of select="concat($var1, '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2)) = 'cm'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number($wholenumber) * 37.7952755904"/>
                           </xsl:variable>
                           <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2)) = 'mm'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number($wholenumber) * 3.77952755904"/>
                           </xsl:variable>
                           <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2)) = 'pt'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number($wholenumber) * 1"/>
                           </xsl:variable>
                           <xsl:value-of select="concat($var1, '*')"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:value-of select="concat($wholenumber, '*')"/>
                        </xsl:otherwise>
                     </xsl:choose>
                  </xsl:matching-substring>
               </xsl:analyze-string>
            </xsl:when>
            <!-- number without decimal, with units, convert to specified unit, and add * at end -->
            <xsl:when test="(matches(.,'[0-9]+([*]|[a-z]+)','i'))">
               <xsl:analyze-string select="." regex="([0-9]+)([*]|[a-zA-Z]+)">
                  <xsl:matching-substring>
                     <xsl:choose>
                        <xsl:when test="lower-case(regex-group(2)) = 'in'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number(regex-group(1)) * 96"/>
                           </xsl:variable>
                           <xsl:value-of select="concat($var1, '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2)) = 'cm'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number(regex-group(1)) * 37.7952755904"/>
                           </xsl:variable>
                           <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2))= 'mm'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number(regex-group(1)) * 3.77952755904"/>
                           </xsl:variable>
                           <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                        </xsl:when>
                        <xsl:when test="lower-case(regex-group(2)) = 'pt'">
                           <xsl:variable name="var1">
                              <xsl:value-of select="number(regex-group(1)) * 1"/>
                           </xsl:variable>
                           <xsl:value-of select="concat($var1, '*')"/>
                        </xsl:when>
                        <xsl:otherwise>
                           <xsl:value-of select="concat(regex-group(1), '*')"/>
                        </xsl:otherwise>
                     </xsl:choose>
                  </xsl:matching-substring>
               </xsl:analyze-string>
            </xsl:when>
            <!-- unsupported format -->
            <xsl:otherwise><!-- output whatever was in colwidth -->
               <xsl:value-of select="."/>
               <!-- generate warning -->
               <xsl:call-template name="outputErrorMessage">
                  <xsl:with-param name="messageText"
                                  as="xs:string"
                                  select="concat('ERROR: unexpected format for @colwidth: ',.) "/>
                  <xsl:with-param name="errorType" as="xs:string" select=" 'ROCKET' "/>
                  <xsl:with-param name="errorCode" as="xs:string*" select=" '405' "/>
                  <xsl:with-param name="context" as="xs:string">
                     <xsl:call-template name="generateXPath"/>
                  </xsl:with-param>
               </xsl:call-template>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="colspec[$streamID=('NZ11','AU10')]/@colwidth[.='']" priority="2"><!-- converts empty colwidth to "*" -->
      <xsl:attribute name="colwidth">*</xsl:attribute>
   </xsl:template>

   <xsl:template match="colspec[$streamID=('NZ11','AU10')]/@colwidth[contains(.,'.')]"
                 priority="2"><!-- for use when there is a decimal value in @colwidth.  it truncates the whole number and passes it through -->
      <xsl:attribute name="colwidth"><!--<xsl:value-of select="."/>-->
         <xsl:analyze-string select="." regex="([0-9\.]+)([*]|[a-z]+)">
            <xsl:matching-substring>
               <xsl:variable name="wholenumber"
                             select="number(substring-before(regex-group(1),'.'))"/>
               <xsl:choose>
                  <xsl:when test="regex-group(2) = 'in'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number($wholenumber) * 96"/>
                     </xsl:variable>
                     <xsl:value-of select="$var1"/>
                     <xsl:value-of select="concat($var1, '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'cm'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number($wholenumber) * 37.7952755904"/>
                     </xsl:variable>
                     <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'mm'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number($wholenumber) * 3.77952755904"/>
                     </xsl:variable>
                     <xsl:value-of select="concat(substring-before($var1, '.'), '*')"/>
                  </xsl:when>
                  <xsl:when test="regex-group(2) = 'pt'">
                     <xsl:variable name="var1">
                        <xsl:value-of select="number($wholenumber) * 1"/>
                     </xsl:variable>
                     <xsl:value-of select="concat($var1, '*')"/>
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:value-of select="concat($wholenumber, '*')"/>
                  </xsl:otherwise>
               </xsl:choose>
            </xsl:matching-substring>
         </xsl:analyze-string>
      </xsl:attribute>
   </xsl:template>

   <xsl:template match="colspec/@searchtype"/>
   <!--	  .... In the absence of specific instructions elsewhere
			  in the CI, <sourcexml>@id</sourcexml> is dropped.</li>  -->   <!--  ***NOTE  -  NEED TO ADD TO THE $streamID LIST ALL STREAMS THAT HAVE SPECIFIC INSTRUCTIONS ON colspec/@id HANDLING!!!  ***  -->
   <xsl:template match="colspec/@id[not($streamID = ('XX', 'YY', 'ZZ'))]"/>

   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@morerows[. = '0']"/>
   <!-- I think we want to preserve morerows if they're not 0, otherwise we lose formatting -->
   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@morerows[. != '0']">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!--  <li>If ALL occurrences of @colsep in one table have a value of
						zero, remove them all from that table.
				</li>
				<li>If ALL occurrences of @rowsep in one table have a value of zero,
					remove them all from that table. </li>  -->
   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@colsep[. = '0'][not(ancestor-or-self::table//@colsep[. != '0'])]"/>

   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@rowsep[. = '0'][not(ancestor-or-self::table//@rowsep[. != '0'])]"/>

   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@colsep[ancestor-or-self::table//@colsep[. != '0']]">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="*[self::table or self::tgroup or self::colspec or self::thead or self::tbody or self::row or self::entry]/@rowsep[ancestor-or-self::table//@rowsep[. != '0']]">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="thead">
      <thead>
         <xsl:apply-templates select="@* | node()"/>
      </thead>
   </xsl:template>

   <xsl:template match="row">
      <row>
         <xsl:apply-templates select="@* | node()"/>
      </row>
   </xsl:template>

   <xsl:template match="entry"><!-- Awantika: For AU20 entry becomes  primlawhist:histitemdiv/textitem for different @id-->
      <xsl:variable name="docinfoidtext" select="/*/docinfo/docinfo:doc-id/text()"/>
      <xsl:choose>
         <xsl:when test="contains(lower-case($docinfoidtext),'history') and $streamID='AU20'"><!--<primlawhist:histitem>-->
            <xsl:if test="@id='HI5'">
               <primlawhist:histitemdiv>
                  <xsl:attribute name="divtype">heading</xsl:attribute>
                  <xsl:attribute name="status">assent</xsl:attribute>
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </primlawhist:histitemdiv>
            </xsl:if>
            <xsl:if test="@id='HI7'">
               <primlawhist:histitemdiv>
                  <xsl:attribute name="divtype">text</xsl:attribute>
                  <xsl:attribute name="status">assent</xsl:attribute>
                  <textitem>
                     <date>
                        <xsl:apply-templates/>
                     </date>
                  </textitem>
               </primlawhist:histitemdiv>
            </xsl:if>
            <xsl:if test="@id='HI6'">
               <primlawhist:histitemdiv><!-- Awantika:2017-11-02: Updated for entry/p-limited to create only one textitem -->
                  <xsl:choose>
                     <xsl:when test="child::p-limited">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <xsl:otherwise>
                        <textitem>
                           <xsl:apply-templates/>
                        </textitem>
                     </xsl:otherwise>
                  </xsl:choose>
               </primlawhist:histitemdiv>
            </xsl:if>
            <xsl:if test="normalize-space(.)='Date of assent'">
               <primlawhist:histitemdiv>
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </primlawhist:histitemdiv>
            </xsl:if>
            <!--</primlawhist:histitem>-->
         </xsl:when>
         <xsl:when test="contains(lower-case($docinfoidtext),'cases') and $streamID='AU20'">
            <xsl:apply-templates/>
         </xsl:when>
         <xsl:otherwise>
            <xsl:choose>
               <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview')">
                  <xsl:apply-templates/>
               </xsl:when>
               <xsl:otherwise>
                  <entry><!-- NOTE: @colsep and @rowsep should be handled above -->
                     <xsl:copy-of select="@align | @char | @charoff | @colname | @nameend | @namest | @valign"/>
                     <xsl:apply-templates select="@* except (@align, @char, @charoff, @colname, @nameend, @namest, @valign)"/>
                     <xsl:apply-templates/>
                  </entry>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="tbody">
      <tbody>
         <xsl:apply-templates select="@* | node()"/>
      </tbody>
   </xsl:template>

   <xsl:template match="tbody/@valign">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="row/@valign">
      <xsl:copy-of select="."/>
   </xsl:template>
   <!-- Suppressed the highlight 	-->
   <xsl:template match="entry/@highlight"/>
   <!-- JD: 2017-06-13: added to "entry" above -->   <!--	<xsl:template match="entry/@valign">
		<xsl:copy-of select="."/>
	</xsl:template>
	
	<xsl:template match="entry/@align">
		<xsl:copy-of select="."/>
	</xsl:template>
-->   <!--JL Got an error due to not dealing with thead/@valign -->
   <xsl:template match="thead/@valign">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="table/@frame">
      <xsl:copy-of select="."/>
   </xsl:template>

   <xsl:template match="table/@pgwide"/>
   <!-- <topicref href="../../common_newest/Rosetta_PAC-page-wAncestor-entry-LxAdv-ref.page.dita"/> -->   <!--<xsl:include href="../../modules/nonamespace/Rosetta_PAC-page-wAncestor-entry-LxAdv-ref.page.xsl"/>-->   <!-- end topichead  table  -->   <!-- start topichead  text  -->   <!-- <topicref href="../../common_newest/Rosetta_text-LxAdv-text.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>text</xd:i> becomes <xd:b>text</xd:b>, and optional attributes <xd:i>@cont</xd:i> should be suppressed from conversion, <xd:i>@align</xd:i> becomes <xd:b>@align</xd:b> must only be used to preserve mandated horizontal spacing and <xd:b>@align</xd:b> will be moved in parent <xd:b>p</xd:b> in New Lexis conversion.
                <xd:pre>
                    &lt;p&gt;&lt;text align="right"&gt;TOBY HALLIGAN&lt;/text&gt;&lt;/p&gt;
                </xd:pre>
            <xd:b>Becomes</xd:b>
            <xd:pre>
                    &lt;p align="right"&gt;&lt;text&gt;TOBY HALLIGAN&lt;/text&gt;&lt;/p&gt;
                </xd:pre>
         </xd:p>
         <xd:p>
            <xd:b>Note: </xd:b>
            <xd:b>(For CANADA Content Stream only )</xd:b>Only move the <xd:i> text@align</xd:i> to the parent <xd:b>p</xd:b> if it is the only text in <xd:i>p</xd:i>,  Otherwise, wrap the <xd:i>text</xd:i> with <xd:b>p</xd:b> and move the <xd:i>@align</xd:i> attribute to the newly created <xd:b> p</xd:b>.</xd:p>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;Dated at Calgary, Alberta this 31 day of March 1998.&lt;/text&gt;
    &lt;text&gt;The Honourable W. Kenneth Moore, Chief Justice of the Court of Queen's Bench of Alberta&lt;/text&gt;
    &lt;text align="center"&gt;ALBERTA RULES&lt;/text&gt;
    &lt;text&gt;Rules of practice made pursuant to subsection 745.64 of the Criminal
        Code to reflect the changes made to the Criminal Code regarding
        applications for reduction in the number of years of imprisonment
        without eligibility for parole.&lt;/text&gt;
&lt;/p&gt;                     
                    

</xd:pre>
         <xd:b>Becomes</xd:b>
         <xd:pre>

&lt;p&gt;
    &lt;text&gt;Dated at Calgary, Alberta this 31 day of March 1998.&lt;/text&gt;
    &lt;text&gt;The Honourable W. Kenneth Moore, Chief Justice of the Court of Queen's Bench of Alberta&lt;/text&gt;
&lt;/p&gt;
&lt;p align="center"&gt;
    &lt;text&gt;ALBERTA RULES&lt;/text&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;text&gt;Rules of practice made pursuant to subsection 745.64 of the Criminal
        Code to reflect the changes made to the Criminal Code regarding
        applications for reduction in the number of years of imprisonment
        without eligibility for parole.&lt;/text&gt;
&lt;/p&gt;

</xd:pre>
         <!--Changes2011-12-21: Added instruction for attribute align. 2011-04-28: Added instruction for attribute cont. 2012-08-30: Moved form/bodytext/text scenario to Rosetta_form_bodytext_text-to-LexisAdvance_form.text.dita.2014-01-31: Updated instruction, align will be moved in p in NL conversion. NZ09 commentary discussion board issue for handling text/@align2014-08-12: For CANADA Content Stream: Only move the
                         text@align to the parent p if
                    it is the only text in p, Otherwise, wrap the
                        text with p and move the
                        @align attribute to the newly created 
                        p.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_text-LxAdv-text.dita  -->
   <!-- *****************************************************************************
         * NOTE: @align handling including CA exception is addressed in              *
         * /XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_p-LxAdv-p.xsl *
         * because it can't be run from p/text context node.                         *
         * NOTE: @nl is addressed here and not in                                    *
         * /XSLT/ContentArch/Rosetta-to-LA/modules/nonamespace/Rosetta_p-LxAdv-p.xsl *
         * because it can't be run from p context node.                              *
          ****************************************************************************-->
   <!-- JD: 2017-07-21: added trap for empty node or single whitespace to match DT output.  -->
   <xsl:template match="text[not(node()) or string() and normalize-space(replace(., '^[\t\p{Zs}]+$', '')) = '']"
                 priority="2"/>

   <xsl:template match="text">
      <xsl:variable name="docinfoidtext" select="/*/docinfo/docinfo:doc-id/text()"/>
      <!--  Original Target XPath:  text   -->
      <xsl:choose>
         <xsl:when test="parent::p[@nl]">
            <xsl:call-template name="insert-vertical-space"/>
         </xsl:when>
         <xsl:otherwise><!-- Awantika: For AU20 history text becomes textitem -->
            <xsl:choose>
               <xsl:when test="$streamID='AU20' and parent::p[parent::note[@notetype='xref'][parent::heading]] and contains(lower-case($docinfoidtext),'history')">
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </xsl:when>
               <xsl:when test="$streamID='AU20' and parent::p[ancestor::source_cttr:annotations[@annotgroup='prov-am']] and contains(lower-case($docinfoidtext),'history')">
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </xsl:when>
               <!-- Awantika:2017-10-27: p/text will be converted to <textitem> for AU20 for specific scenario -->
               <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'history') and parent::p[ancestor::source_cttr:annotations/heading/note[@id='HI4']]| child::heading/title[.='Assent']">
                  <textitem>
                     <xsl:apply-templates/>
                  </textitem>
               </xsl:when>
               <xsl:otherwise>
                  <xsl:choose>
                     <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and ancestor::source_cttr:annotations[@id='OP3' or @id='OI7']/heading/note/l/li">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and ancestor::source_cttr:annotations[@id='OP15']">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <!-- Vikas Rohilla : Updated for the UK12                            -->
                     <xsl:when test="child::note[@notetype!='xref'][$streamID = 'UK12']">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <!--Ravikant:2017-12-12: p/inlineobject move in form:p/from:text/figure for hk07  -->
                     <xsl:when test="$streamID='HK07' and parent::p[parent::bodytext[parent::level[@leveltype='prec' or @leveltype='prec.grp' or @leveltype='precgrp' or @leveltype='precgrp1' or @leveltype='precgrp2' or parent::comm.chap or ancestor::level[@leveltype = 'prec.grp']]]]">
                        <form:text>
                           <xsl:apply-templates select="node()"/>
                           <xsl:apply-templates select="following-sibling::inlineobject[parent::p]"/>
                        </form:text>
                     </xsl:when>
                     <!-- Awantika:2017-11-02: p/text will be converted to <textitem> for AU20 for specific scenario -->
                     <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and parent::p[ancestor::source_cttr:annotations[child::heading/note/h[.='Former Title'] or child::heading/title[.='Former Title']]/source_cttr:annot/leg:info/note]">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <xsl:when test="$streamID='AU20' and contains(lower-case($docinfoidtext),'overview') and parent::p[ancestor::heading[child::title[starts-with(lower-case(.),'international equivalents') or starts-with(lower-case(.),'uniform equivalents')]]/note/l/li]">
                        <xsl:apply-templates/>
                     </xsl:when>
                     <xsl:otherwise>
                        <text><!-- <xsl:apply-templates select="node() except refpt"/>--><!-- Awantika: Updated, as refpt should not be created in the text element --><!-- Priya Bardhan: Added ci:cite[@type='cite4thisdoc'] in except condition. Since, not required inside text -->
                           <xsl:apply-templates select="@*"/>
                           <xsl:apply-templates select="node() except (refpt,ci:cite[@type='cite4thisdoc'],copyright[$streamID='UK06'])"/>
                           <!-- Awantika: UK11DN- Need to merge the adjacent notes and move them to the end of the existing text  -->
                           <xsl:if test="parent::p[note[@notetype='xref']] and $streamID='UK11DN'">
                              <xsl:for-each-group select="parent::p[note[@notetype='xref']]/node()"
                                                  group-adjacent="if (self::note) then 0 else 1">
                                 <xsl:choose>
                                    <xsl:when test="current-grouping-key()=0"><!--  <xsl:apply-templates select="ancestor::p/text"/>-->
                                       <marginnote>
                                          <ref:anchor>
                                             <xsl:attribute name="id">
                                                <xsl:value-of select="generate-id()"/>
                                             </xsl:attribute>
                                             <xsl:attribute name="anchortype">
                                                <xsl:text>local</xsl:text>
                                             </xsl:attribute>
                                          </ref:anchor>
                                          <bodytext>
                                             <xsl:for-each select="current-group()">
                                                <xsl:apply-templates select="@* | node()"/>
                                             </xsl:for-each>
                                          </bodytext>
                                       </marginnote>
                                    </xsl:when>
                                 </xsl:choose>
                              </xsl:for-each-group>
                           </xsl:if>
                        </text>
                     </xsl:otherwise>
                  </xsl:choose>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!-- it doesn't make sense to address @align here, but to address it at the paragraph level.
        What do we do for <p> elements that get emptied by having now-empty text? Right now they remain, 
        as passively specified through omission of use case. -->   <!--    Updated by Chaitanya foe the text Alignment-->
   <xsl:template match="text/@align[$streamID!='CA09']"/>
   <!--<xsl:copy-of select="."></xsl:copy-of>-->
   <xsl:template match="text/@cont"/>

   <xsl:template match="text/@ln.nsprefix"/>

   <xsl:template match="text[$streamID='CA12']/@searchtype"/>

   <xsl:template name="insert-vertical-space">
      <xsl:element name="text"
                   namespace="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/">
         <xsl:apply-templates select="@*"/>
         <!--- BRT add number of nl that are in p/@nl -->
         <xsl:call-template name="add_nl">
            <xsl:with-param name="length" select="parent::p/@nl"/>
            <xsl:with-param name="i" select="1"/>
         </xsl:call-template>
         <!-- BRT remove hard-coded nl that are in source -->
         <xsl:apply-templates select="*[not(self::nl or self::refpt)] | text()"/>
      </xsl:element>
   </xsl:template>

   <xsl:template name="add_nl">
      <xsl:param name="length" select="."/>
      <xsl:param name="i" select="1"/>
      <!-- BRT: create <nl/> for each iteration of @nl value -->
      <xsl:if test="$length &gt; 0">
         <xsl:element name="proc:nl"/>
         <xsl:call-template name="add_nl">
            <xsl:with-param name="length" select="$length - 1"/>
            <xsl:with-param name="i" select="$i + 1"/>
         </xsl:call-template>
      </xsl:if>
   </xsl:template>
   <!-- Vikas Rohilla : Added the template for the streamID CA01    -->   <!-- Sudhanshu Srivastava : Added StreamID for passthrough. -->
   <xsl:template match="text[parent::p[parent::glp:note[parent::text]]][$streamID='CA01' or $streamID='CA02CC' or $streamID='CA04']">
      <xsl:apply-templates/>
   </xsl:template>
   <!--Satbir: Set the low priority in below template because this is common template which is already define in "Rosetta_strike-LxAdv-strike.xsl"-->   <!-- JD: 2017-07-14: just use common template "Rosetta_strike-LxAdv-strike.xsl"; removing this version because: 
				1) this is the module for the <text> element, not the <strike> element 
				2) the handling is nearly identical
				3) this version generates an empty @typestyle attribute, which causes validation errors.
		-->   <!--<xsl:template match="strike" priority="10">
        <strike>
            <xsl:attribute name="typestyle">
                <xsl:value-of select="@typestyle"/>   
            </xsl:attribute>
            <xsl:apply-templates select="node()"/>
        </strike>
    </xsl:template>-->   <!-- <!-\- Vikas Rohilla :Added template for the streamID CA01-\->
    <xsl:template match="text[matches(.,'^ARRT') or matches(.,'^HELD:') or matches(.,'^DISPOSITIF :')]">
        <xsl:element name="text">
            <xsl:choose>
                <xsl:when test="child::*">
                    <xsl:apply-templates/>
                </xsl:when>
                <xsl:when test="contains(.,'- ')">
                    <xsl:value-of select="substring-after(.,'- ')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="substring-after(.,'. ')"/>
                </xsl:otherwise>
            </xsl:choose>
        </xsl:element>
    </xsl:template>-->   <!-- Vikas Rohilla : created the template for text when ancestor frm:div    -->
   <xsl:template match="text[parent::p[parent::frm:div |                               parent::frm:body |                               parent::li[ancestor::frm:body] |                               parent::clause[ancestor::frm:div or ancestor::frm:body]]][not(ancestor::footnote or ancestor::note)][$streamID='UK12']">
      <form:text>
         <xsl:apply-templates select="@*|node()"/>
      </form:text>
   </xsl:template>
   <!-- Vikas Rohilla : created the template for text when ancestor frm:div    -->
   <xsl:template match="text[parent::p[parent::sigblock[ancestor::frm:div or ancestor::frm:body]]][$streamID='UK12']">
      <xsl:apply-templates select="@*|node()"/>
   </xsl:template>

   <xsl:template match="text[parent::p[parent::text]][$streamID='UK12']" priority="25">
      <xsl:apply-templates select="@*|node()"/>
   </xsl:template>

   <xsl:template match="text[preceding-sibling::note[@notetype='xref']]">
      <text>
         <xsl:apply-templates select="@*|node()"/>
         <xsl:if test="$streamID='UK12'">
            <xsl:apply-templates select="preceding-sibling::note[@notetype='xref']" mode="note-xref"/>
         </xsl:if>
      </text>
   </xsl:template>
   <!-- suppress the empty text    -->
   <xsl:template match="text[normalize-space(.)=''][$streamID=('UK12','UK03')]"/>

   <xsl:template match="text[matches(.,'^$')][$streamID='NZ13']" priority="25">
      <text>
         <xsl:text xml:space="preserve"></xsl:text>
      </text>
   </xsl:template>
   <!-- <topicref href="../../common_newest/Rosetta_form_bodytext_p_text-LxAdv-form.text.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:i>form/bodytext/p/text</xd:i> becomes <xd:b>form:text</xd:b>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;form&gt;
    &lt;bodytext searchtype="FORM"&gt;
        &lt;p&gt;
            &lt;text&gt;
                &lt;emph typestyle="bf"&gt;THIS AGREEMENT&lt;/emph&gt; 
                is made on&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
                &amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;
                &amp;#160;&amp;#160; 2010
            &lt;/text&gt;
        &lt;/p&gt;
    .......
    .......
        &lt;h align="center"&gt;
            1.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 
            The Independent Expert has been appointed by the parties under clause
            .. of the Agreement to assist in resolving the dispute or to 
            resolve the dispute by determining the meaning of clause &amp;hellip;&amp;#160; of
            the Agreement and also to determine which party or parties should 
            pay the costs of and incidental to the resolution of the dispute.
        &lt;/h&gt;
        &lt;h align="center"&gt;
            2.&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160;&amp;#160; 
            The Independent Expert has accepted the appointment, and will assist
            in determining or will determine the dispute in accordance with the 
            terms of this agreement.
        &lt;/h&gt;
    ........
    ........
        &lt;h align="center"&gt;&amp;#160;&lt;/h&gt;
    &lt;/bodytext&gt;
&lt;/form&gt;

        </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;form:form&gt;
    &lt;form:document annotated="false" official="false" typeofdoc="unnamed"&gt;
        &lt;form:bodytext&gt;
            &lt;form:p&gt;
                &lt;form:text&gt;
                    &lt;emph typestyle="bf"&gt;THIS AGREEMENT&lt;/emph&gt; 
                    is made on&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;
                    &amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;
                    &amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0; 2010
                &lt;/form:text&gt;
            &lt;/form:p&gt;
                ......
                ......
            &lt;form:h align="center"&gt;
                1.&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;
                The Independent Expert has been appointed by the parties under clause .. 
                of the Agreement to assist in resolving the dispute or to resolve 
                the dispute by determining the meaning of clause &amp;#x2026;&amp;#x00A0; 
                of the Agreement and also to determine which party or parties 
                should pay the costs of and incidental to the resolution of the dispute.
            &lt;/form:h&gt;
            &lt;form:h align="center"&gt;
                2.&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;&amp;#x00A0;
                The Independent Expert has accepted the appointment, and will 
                assist in determining or will determine the dispute in accordance
                with the terms of this agreement.
            &lt;/form:h&gt;
                ......
                ......
            &lt;form:h align="center"&gt;&amp;#x00A0;&lt;/form:h&gt;
        &lt;/form:bodytext&gt;
    &lt;/form:document&gt;
&lt;/form:form&gt;

        </xd:pre>
         <!--Changes2012-08-30: Created. -->
      </xd:desc>
   </xd:doc>
   <!--RS: 02-01-2018 Added Choose Condition for blockquote/p/text Webstar #7078783 -->
   <xsl:template match="text[parent::p[(parent::blockquote|parent::bodytext)[not(ancestor::fnbody)][ancestor::form[ancestor::COMMENTARYDOC|ancestor::LEGDOC]]]]">
      <xsl:choose>
         <xsl:when test="parent::p[parent::blockquote]">
            <text>
               <xsl:apply-templates select="@* | node()"/>
            </text>
         </xsl:when>
         <xsl:otherwise><!--  Original Target XPath:  form:text   -->
            <form:text>
               <xsl:apply-templates select="@* | node()"/>
            </form:text>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>

   <xsl:template match="text[$streamID=('UK14', 'UK12')][parent::p[(parent::blockquote)[ancestor::form[ancestor::COMMENTARYDOC]]]]"
                 priority="2"><!-- WPK: form:text is not schema valid within blockquote/p -->
      <text>
         <xsl:apply-templates select="@* | node()"/>
      </text>
   </xsl:template>
   <!-- end topichead  text  -->   <!-- rosetta element: title -->   <!-- <topicref href="../../common_newest/Rosetta_title-LxAdv-title.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>title</xd:i> becomes <xd:b>title</xd:b> with attributes:
					<xd:ul>
               <xd:li>
                  <xd:i>@inline</xd:i> becomes <xd:b>@inline</xd:b> with tokenized values of "true" and "false"</xd:li>
               <xd:li>
                  <xd:i>@align</xd:i> becomes <xd:b>@align</xd:b> with tokenized
							values and populated as: 
							<xd:ul>
                     <xd:li>
                        <xd:b>title[@align="left"]</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:b>title[@align="right"]</xd:b>
                     </xd:li>
                     <xd:li>
                        <xd:b>title[@align="center"]</xd:b>
                     </xd:li>
                  </xd:ul>
               </xd:li>
            </xd:ul>
         </xd:p>
         <xd:p>
					If the input document has title/defterm scenario then <xd:i>defterm</xd:i> within a title can be dropped, but the content of
					the tag is retained and no text is dropped.		
				</xd:p>
         <xd:p>Exceptional scenario for <xd:b>CA Indices</xd:b> and <xd:b>CA06 Regs</xd:b>: <xd:i>title/nl</xd:i>
					becomes <xd:b>title</xd:b>. <xd:i>nl</xd:i> will be replaces by
					a white space in the target.</xd:p>
         <xd:p>Exceptional scenario for CA Indices: When <xd:i>title</xd:i> is an child of
						<xd:i>docinfo:hierlev/heading</xd:i> and contains word <xd:b>TITLE: </xd:b>
					or <xd:b>NAME: </xd:b> or <xd:b>SITE: </xd:b> then conversion should drop the word <xd:b>TITLE: </xd:b> or <xd:b>NAME:
					</xd:b> or <xd:b>SITE: </xd:b> from conversion.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
	  &lt;title align="center"&gt;Consideration&lt;/title&gt;
&lt;/heading&gt;
....
....
&lt;heading&gt;
	  &lt;title inline="false"&gt;Summary&lt;/title&gt;
&lt;/heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;heading&gt;
  &lt;title align="center"&gt;Consideration&lt;/title&gt;
&lt;/heading&gt;
....
....
&lt;heading&gt;
	  &lt;title inline="false"&gt;Summary&lt;/title&gt;
&lt;/heading&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML having <xd:i>title/nl</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;title&gt; English-French&lt;nl/&gt;Trade-mark Lexicon&lt;/title&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Target XML </xd:b>
         </xd:p>
         <xd:pre>

&lt;title&gt; English-French Trade-mark Lexicon&lt;/title&gt;

		</xd:pre>
         <xd:p>
            <xd:b>Source XML contains word "TITLE: " in <xd:i>title</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>
&lt;docinfo:hierlev role="me"&gt;
    &lt;heading&gt;
        &lt;title&gt;TITLE: Criminal Code French/English consolidation 2010 / Code criminal codification bilingue
            2010. 2010 ed. &lt;/title&gt;
    &lt;/heading&gt;
&lt;/docinfo:hierlev&gt;
		</xd:pre>
         <xd:p>
            <xd:b>Target XML </xd:b>
         </xd:p>
         <xd:pre>
&lt;doc:hierlev&gt;
    &lt;heading&gt;
        &lt;title&gt;Criminal Code French/English consolidation 2010 / Code criminal codification bilingue
            2010. 2010 ed. &lt;/title&gt;
    &lt;/heading&gt;
&lt;/doc:hierlev&gt;
	</xd:pre>
         <!--Changes2011-12-15: Created.2013-01-08: Removed CR number to allow ref:crossreference to the content model of title and subtitle.2013-01-08: Added Instruction for title/@searchtype="DIGEST-SUBJECT".2013-04-10: Added Instruction for title/nl.2013-07-05: Added Instruction when title contains word "TITLE: ".2013-07-30: Updated Instruction when title contains word "TITLE: " or "NAME: ".2013-09-03: Updated Instruction when title contains word "TITLE: " or "NAME: " or "SITE: ".2014-10-07: Removed instruction and example to convert attribute @searchtype="DIGEST-SUBJECT". Applicable to CA12.2014-12-19: Added CA06-Regs stream name inside the existing
						instruction for handling title/nl.-->
      </xd:desc>
   </xd:doc>
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_title-LxAdv-title.dita  -->
   <!-- JD: 2017-07-24: added 'replace()' function to get rid of characters not handled by normalize-space(e.g., nbsp) -->
   <xsl:template match="title[not( normalize-space(replace(., '^[\t\p{Zs}]+$', '')) = '')]"><!--<xsl:param name="titleStringsToRemove" as="xs:string*" select="( 'TITLE:' , 'NAME:' , 'SITE:' ,':' )"/>	--><!-- these are regular expressions  --><!--pawan:added for CA15-->
      <xsl:param name="titleStringsToRemove"
                 as="xs:string*"
                 select="if ($streamID = 'CA15') then ( 'TITLE: ' , 'TITRE: ' , 'TITLE/TITRE:' , 'TITRE/TITLE:','CITED/CIT: ', 'CIT/CITED: ', 'CITE/CITED: ', 'CITED: ' )  else  ( 'TITLE:' , 'NAME:' , 'SITE:' ,':' )"/>
      <xsl:variable name="outputText" as="xs:string*">
         <xsl:apply-templates/>
      </xsl:variable>
      <xsl:variable name="subtitletext"/>
      <!--  Original Target XPath:  title   -->
      <xsl:choose><!-- Due to jrnl:prelim outputting as nitf:hedline/nitf:h1, which does not have a child title. - See HK02_Articles for example -->
         <xsl:when test="parent::heading/parent::jrnl:prelim">
            <xsl:apply-templates/>
         </xsl:when>
         <!-- do not output empty element title when it only contains refpt and is a child of heading -->
         <xsl:when test="parent::heading and refpt and not(text()) and not(child::*[2])"/>
         <!--SNB 2017-10-17 add title child of transcript for new embedded video content. Note that transcript 
				is a new element, so this cant interfere with any other processing-->
         <xsl:when test="parent::transcript">
            <h>
               <xsl:apply-templates select="@*"/>
               <!-- refpts can't be output in title elements in target schemas -->
               <xsl:apply-templates select="node() except refpt"/>
            </h>
         </xsl:when>
         <xsl:otherwise>
            <title>
               <xsl:apply-templates select="@*"/>
               <xsl:choose>
                  <xsl:when test=" $streamID = 'CA11' or $streamID = 'CA15' and parent::heading[parent::docinfo:hierlev] "><!--  remove any occurrence of $titleStringsToRemove strings but assume case sensitive   -->
                     <xsl:sequence select=" lnf:removeSequenceOfStrings( string-join( $outputText , '' ) , $titleStringsToRemove , false() ) "/>
                  </xsl:when>
                  <!-- Vikas Rohilla : Added for the streamID CA01	-->
                  <xsl:when test="$streamID ='CA01' and ancestor::case:constituents">
                     <xsl:sequence select=" lnf:removeSequenceOfStrings( string-join( $outputText , '' ) , $titleStringsToRemove , false() ) "/>
                  </xsl:when>
                  <!-- Awantika: Added for AU20 -->
                  <xsl:when test="$streamID='AU20' and following-sibling::subtitle">
                     <xsl:value-of select="concat(.,' ','(',following-sibling::subtitle,')')"/>
                  </xsl:when>
                  <xsl:otherwise><!-- refpts can't be output in title elements in target schemas -->
                     <xsl:apply-templates select="node() except refpt"/>
                  </xsl:otherwise>
               </xsl:choose>
            </title>
         </xsl:otherwise>
      </xsl:choose>
   </xsl:template>
   <!--    From Rosetta_Elements-LxAdv-Empty_Elements.dita / .xsl   -->   <!--<xsl:template match="title[ normalize-space(string-join( . , '') ) = '' ]"/>-->   <!-- JD: 2017-07-24: could probably be combined with above, but shouldn't hurt -->
   <xsl:template match="title[normalize-space(replace(., '^[\t\p{Zs}]+$', '')) = '']"/>

   <xsl:template match="title/@inline"><!--  Original Target XPath:  @inline   -->
      <xsl:copy-of select=" . "/>
   </xsl:template>

   <xsl:template match="title/@align"><!--  Original Target XPath:  @align   -->
      <xsl:copy-of select=" . "/>
   </xsl:template>

   <xsl:template match="title/defterm"><!--  Original Target XPath:  title   -->
      <xsl:apply-templates select="@* | node()"/>
   </xsl:template>

   <xsl:template match="title/nl[ $streamID = ( 'CA11' ) ]"><!--  output a space.  Note that otherwise nl becomes proc:nl which is allowed under title   -->
      <xsl:text> </xsl:text>
   </xsl:template>
   <!-- JL suppress searchtype -->
   <xsl:template match="title/@searchtype"/>

   <xsl:template match="title/num[$streamID='CA09']/@searchtype" priority="30"/>
   <!-- rosetta element: toc -->   <!-- Awantika: Completed -->   <!-- <topicref href="../../common_newest/Rosetta_AU_NZ_caselaw_toc-LxAdv-toc.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>toc</xd:i> becomes <xd:b>toc</xd:b> with optional child <xd:b>heading</xd:b>
         </xd:p>
         <xd:ul>
            <xd:li>
               <xd:i>toc-entry</xd:i> becomes <xd:b>toc-entry</xd:b>
               <xd:ul>
                  <xd:li>
                     <xd:i>heading</xd:i> becomes <xd:b>heading</xd:b> and is one of the required child element for <xd:b>toc-entry</xd:b>. </xd:li>
                  <xd:li>
                     <xd:i>entry-pageref</xd:i> becomes <xd:b>toc-pageref</xd:b>. This is optional.</xd:li>
               </xd:ul>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;toc&gt; &lt;heading&gt; &lt;title&gt; &lt;emph typestyle="bf"&gt;Table of sections&lt;/emph&gt; &lt;/title&gt; &lt;/heading&gt; &lt;toc-entry&gt; &lt;heading&gt; &lt;desig&gt;
                    &lt;designum&gt;1-1&lt;/designum&gt; &lt;/desig&gt; &lt;title&gt;Short title&lt;/title&gt; &lt;/heading&gt; &lt;entry-pageref&gt;5&lt;/entry-pageref&gt; &lt;/toc-entry&gt; &lt;/toc&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;toc&gt; &lt;heading&gt; &lt;title&gt; &lt;emph typestyle="bf"&gt;Table of sections&lt;/emph&gt; &lt;/title&gt; &lt;/heading&gt; &lt;toc-entry&gt; &lt;heading&gt;
                    &lt;desig&gt;1-1&lt;/desig&gt; &lt;title&gt;Short title&lt;/title&gt; &lt;/heading&gt; &lt;toc-pageref&gt;5&lt;/toc-pageref&gt; &lt;/toc-entry&gt; &lt;/toc&gt; </xd:pre>
         <xd:p>If <xd:i>toc</xd:i> has a child <xd:i>page</xd:i> with a following sibling <xd:i>toc-entry</xd:i>, <xd:i>page</xd:i> should map to
                        <xd:b>toc-entry/ref:page</xd:b>. The parent of <xd:b>ref:page</xd:b> should be the <xd:b>toc-entry</xd:b> that has been mapped from the following sibling of
                        <xd:i>toc/page</xd:i>.</xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;toc&gt; ... &lt;toc-entry&gt; &lt;heading&gt; &lt;title&gt;Cash flow problems..............................................................&lt;/title&gt; &lt;desig&gt;
                    &lt;designum&gt;22&lt;/designum&gt; &lt;/desig&gt; &lt;/heading&gt; &lt;/toc-entry&gt; &lt;page reporter="urj" count="2" text="BC9801738 at " subdoc="true"/&gt; &lt;toc-entry&gt; &lt;heading&gt;
                    &lt;title&gt;Lack of accounting information..................................................&lt;/title&gt; &lt;desig&gt; &lt;designum&gt;23&lt;/designum&gt; &lt;/desig&gt; &lt;/heading&gt;
                    &lt;/toc-entry&gt; ... &lt;/toc&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;toc&gt; ... &lt;toc-entry&gt; &lt;heading&gt; &lt;title&gt;Cash flow problems..............................................................&lt;/title&gt; &lt;desig
                    value="22"&gt;22&lt;/desig&gt; &lt;/heading&gt; &lt;/toc-entry&gt; &lt;toc-entry&gt; &lt;ref:page num="2" page-scheme-type="reporter-abbreviation" page-scheme="urj"/&gt; &lt;heading&gt;
                    &lt;title&gt;Lack of accounting information..................................................&lt;/title&gt; &lt;desig value="23"&gt;23&lt;/desig&gt; &lt;/heading&gt; &lt;/toc-entry&gt; ...
                    &lt;/toc&gt; </xd:pre>
         <!--Changes2014-03-20: New rule. Added mapping for entry-pageref to toc-pageref. Initially for UK12 but will apply for any stream if the
                        use case occurs. Responds to data added in UK12 delivery Mar 2014; known to occur in dpsi 02FL and 03VY. Phase 6 UK Discussion Item 79. Webteam 252434.2012-06-05: Added instructions for handling toc/page with a following sibling toc-entry.2011-12-21: Created. -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_toc-LxAdv-toc.dita  -->
   <!-- MDS 2017-06-29 - Added ordering of heading|refpt|page in order to correctly output the elements based on schema -->
   <!-- Vikas Rohilla : Template to match the toc and create the toc-->
   <!-- Awantika: Added stream AU01 as duplicate ref:page was getting created. Webstar 7089573-->
   <xsl:template match="toc">
      <toc>
         <xsl:apply-templates select="@*"/>
         <xsl:apply-templates select="heading | refpt | page[not($streamID = ('AU09','UK06','UK07','AU01'))]"/>
         <xsl:apply-templates select="node() except (heading | refpt | page)"/>
      </toc>
   </xsl:template>
   <!-- Template to match the toc-entry   -->   <!-- Awantika: 2018-01-18- Added stream AU01 for preceding-sibling page. Webstar 7089573. -->
   <xsl:template match="toc-entry">
      <toc-entry>
         <xsl:if test="preceding-sibling::*[1][self::page][$streamID = ('AU09','UK06','UK07','AU01')]">
            <xsl:apply-templates select="preceding-sibling::*[1][self::page]"/>
         </xsl:if>
         <xsl:choose>
            <xsl:when test="$streamID = ('UK12','UK06','UK07') and child::note">
               <xsl:apply-templates select="@* | node() except note"/>
            </xsl:when>
            <xsl:otherwise>
               <xsl:apply-templates select="@* | node()"/>
            </xsl:otherwise>
         </xsl:choose>
      </toc-entry>
   </xsl:template>
   <!-- Template to match the entry-pageref   -->
   <xsl:template match="entry-pageref">
      <toc-pageref>
         <xsl:apply-templates select="@* | node()"/>
      </toc-pageref>
   </xsl:template>
   <!-- rosetta element: url -->   <!-- <topicref href="../../common_newest/Rosetta_remotelink-Chof-url-LxAdv-url.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:ul>
            <xd:li>Use case: <xd:i>url/remotelink</xd:i> when the content of
            <xd:i>remotelink</xd:i> begins with "http".<xd:ul>
                  <xd:li>
                     <xd:i>url</xd:i> becomes <xd:b>url</xd:b>.</xd:li>
                  <xd:li>
                     <xd:i>remotelink</xd:i> is suppressed, but its content is mapped as
              folllows: <xd:ul>
                        <xd:li>The content of <xd:i>remotelink</xd:i> is mapped to
                    <xd:b>url/@normval</xd:b>.</xd:li>
                        <xd:li>The content of <xd:i>remotelink</xd:i> also becomes the content of
                    <xd:b>url</xd:b>.</xd:li>
                     </xd:ul>
                  </xd:li>
                  <xd:li>If <xd:i>emph</xd:i> occurs as a child <xd:i>remotelink</xd:i>,
              it should be omitted.</xd:li>
               </xd:ul>
            </xd:li>
            <xd:li>Use case: <xd:i>url/remotelink</xd:i> when the content of
            <xd:i>remotelink</xd:i> begins with "www." (4 characters, a period must follow "www").<xd:ul>
                  <xd:li>
                     <xd:i>url</xd:i> becomes <xd:b>url</xd:b>.</xd:li>
                  <xd:li>
                     <xd:i>remotelink</xd:i> is suppressed, but its content is mapped as
              follows: <xd:ul>
                        <xd:li>The content of <xd:i>remotelink</xd:i> is mapped to
                    <xd:b>url/@normval</xd:b>, with the text "http://" prepended to the
                  value of <xd:b>url/@normval</xd:b>.</xd:li>
                        <xd:li>The content of <xd:i>remotelink</xd:i> also becomes the content of
                    <xd:b>url</xd:b>. Note that http:// is <xd:b>not</xd:b> prepended to the
                  content of <xd:b>url</xd:b>.</xd:li>
                        <xd:li>If <xd:i>emph</xd:i> occurs as a child
                    <xd:i>remotelink</xd:i>, it should be omitted.</xd:li>
                     </xd:ul>
                  </xd:li>
               </xd:ul>
            </xd:li>
            <xd:li>Use case: <xd:i>url/remotelink</xd:i> when the content of
            <xd:i>remotelink</xd:i> does <xd:b>not</xd:b> begin with "http" or "www.". Drop
            <xd:i>url</xd:i> start-tag and end-tag, but not its content. The
            <xd:i>remotelink</xd:i> becomes <xd:b>ref:lnlink</xd:b> with
          children <xd:b>ref:marker</xd:b> and <xd:b>ref:locator</xd:b>,
          populated as follows: <xd:ul>
                  <xd:li>The attribute <xd:i>remotelink/@status</xd:i> is always suppressed, it is never output to the target document.</xd:li>
                  <xd:li>The <xd:b>ref:lnlink/@service</xd:b> attribute is set to "URL".</xd:li>
                  <xd:li>The contents of <xd:i>remotelink</xd:i> becomes the contents of child
                <xd:b>ref:lnlink/ref:marker</xd:b>. Any subelements (such as
                <xd:i>emph</xd:i> and <xd:i>inlineobject</xd:i>) are converted
              as described elsewhere by instructions given for those specific elements. </xd:li>
                  <xd:li>The child <xd:b>ref:lnlink/ref:locator</xd:b> is created, and within it
              the child <xd:b>ref:lnlink/ref:locator/ref:locator-key</xd:b> is created,
              and within it the children
                <xd:b>ref:lnlink/ref:locator/ref:locator-key/ref:key-name</xd:b> and
                <xd:b>ref:lnlink/ref:locator/ref:locator-key/ref:key-value</xd:b> are
              created.</xd:li>
                  <xd:li>The <xd:b>ref:key-name/@name</xd:b> attribute is set to "URL".</xd:li>
                  <xd:li>If the <xd:i>remotelink/@hrefclass</xd:i> attribute is present,
                <xd:b>ref:key-value/@value</xd:b> is set to the combined value of
                <xd:i>remotelink/@hrefclass</xd:i>, followed by "://" (a colon and two
              slashes), followed by the value of <xd:i>remotelink/@href</xd:i>.<xd:ul>
                        <xd:li>Exception: If content of <xd:i>@hrefclass</xd:i> is already present in
                    <xd:i>@href</xd:i> then do not concatenate. Populate
                    <xd:b>@value</xd:b> with content of <xd:i>@href</xd:i>.</xd:li>
                     </xd:ul>
                  </xd:li>
                  <xd:li>If the <xd:i>remotelink/@hrefclass</xd:i> attribute is <xd:b>not</xd:b> present,
                <xd:b>ref:key-value/@value</xd:b> is set to the value of
                <xd:i>remotelink/@href</xd:i>.</xd:li>
                  <xd:li>Drop <xd:i>remotelink/@newwindow</xd:i>.</xd:li>
               </xd:ul>
            </xd:li>
         </xd:ul>
         <xd:p>
            <xd:b>Source XML showing <xd:i>url/remotelink</xd:i> when the content of
          <xd:i>remotelink</xd:i> begins with "http"</xd:b>
         </xd:p>
         <xd:pre>

&lt;url&gt;
  &lt;remotelink href="www.uspto.gov/trademarks/teas/index.jsp" hrefclass="http" newwindow="YES"&gt;http://www.uspto.gov/trademarks/teas/index.jsp&lt;/remotelink&gt;
&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;url normval="http://www.uspto.gov/trademarks/teas/index.jsp"&gt;http://www.uspto.gov/trademarks/teas/index.jsp&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Source XML showing <xd:i>emph</xd:i> inside
          <xd:i>url/remotelink</xd:i>
            </xd:b>
         </xd:p>
         <xd:pre>

&lt;url&gt;
    &lt;remotelink href="www.lawandarts.co.uk/" hrefclass="http"&gt;
        &lt;emph typestyle="it"&gt;
            &lt;emph typestyle="un"&gt;www.lawandarts.co.uk&lt;/emph&gt;
        &lt;/emph&gt;
    &lt;/remotelink&gt;
&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;url normval="http://www.lawandarts.co.uk"&gt;www.lawandarts.co.uk&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Source XML showing <xd:i>url/remotelink</xd:i> when the content of
          <xd:i>remotelink</xd:i> begins with "www."</xd:b>
         </xd:p>
         <xd:pre>

&lt;url&gt;
  &lt;remotelink href="http://www.uspto.gov/trademarks/teas/index.jsp" newwindow="YES"&gt;www.uspto.gov/trademarks/teas/index.jsp&lt;/remotelink&gt;
&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre>

&lt;url normval="http://www.uspto.gov/trademarks/teas/index.jsp"&gt;www.uspto.gov/trademarks/teas/index.jsp&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Source XML showing <xd:i>url/remotelink</xd:i> when the content of
          <xd:i>remotelink</xd:i> does <xd:b>not</xd:b> begin with "http" or "www."</xd:b>
         </xd:p>
         <xd:pre>
           
&lt;url&gt;
  &lt;remotelink href="www.ato.gov.au" hrefclass="http" newwindow="YES"
    service="SEARCH" status="valid"&gt; Australian Tax Office (ATO)&lt;/remotelink&gt;
&lt;/url&gt;
&lt;!-- The following illustrates scenario where content of @hrefclass is already present in @href and so values are not concatenated for target --&gt;
&lt;url&gt;
  &lt;remotelink href="http://www.acmecorp.com" hrefclass="http"&gt;Acme Corporation&lt;/remotelink&gt;
&lt;/url&gt;

			</xd:pre>
         <xd:p>
            <xd:b>Target XML showing <xd:i>url/remotelink</xd:i> when the content of
          <xd:i>remotelink</xd:i> does <xd:b>not</xd:b> begin with "http" or "www"</xd:b>
         </xd:p>
         <xd:pre>

&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;Australian Tax Office (ATO)&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.ato.gov.au"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

&lt;ref:lnlink service="URL"&gt;
  &lt;ref:marker&gt;Acme Corporation&lt;/ref:marker&gt;
  &lt;ref:locator&gt;
    &lt;ref:locator-key&gt;
      &lt;ref:key-name name="URL"/&gt;
      &lt;ref:key-value value="http://www.acmecorp.com"/&gt;
    &lt;/ref:locator-key&gt;
  &lt;/ref:locator&gt;
&lt;/ref:lnlink&gt;

			</xd:pre>
         <!--Changes2015-05-22: Added an instruction to explicitly indicate remotelink/@status is always dropped (suppressed). This is a very low-priority change and has been added for technical correctness, particularly with respect to new CIs. Existing scripts do not have to implement this change unless needed since prior to the change remotelink/@status handling was not explicitly specified.2015-01-09: Within use case that maps to
            ref:lnlink, added exceptional rule to not concatenate values when
            @hrefclass content is already present in
            @href. Expanded example to illustrate the scenario. Responds to
          data for UK10 Dictionaries but applies in general. R4.5 Content Issue 2120.2013-03-11: Added instructions for omitting
            emph when it occurs as a child of
            url/remotelink. Added an sample mapping demonstrating this
          scenario.2012-06-28: Added instructions for the use case where remotelink
        begins with "www." as well as an example of this conversion.2012-06-22: Corrected to show mapping to ref:lnlink (instead of
          ref:crossreference) when content of
          remotelink does not begin with "http" or "www.".2012-05-21: Created.-->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_remotelink-Chof-url-LxAdv-url.dita  -->
   <!--<xsl:message>Rosetta_remotelink-Chof-url-LxAdv-url.xsl requires manual development!</xsl:message> -->
   <xsl:template match="url/remotelink" priority="25">
      <xsl:choose><!-- SNB: 2017-11-10 : add logic for LPA CI Section 6.103. remotelink/@href (id-CCCC-10467) 
         (Rosetta_remotelink-LxAdv-url_(special).dita"), which is different from logic below. Fix for webstar 7045572. -->
         <xsl:when test="(not(@service) or @service!='DOC-ID') and @href and $streamID=('USLPA')">
            <xsl:choose>
               <xsl:when test="(starts-with(., 'http://') or starts-with(., 'https://')                             or starts-with(., 'nohttp://') or starts-with(., 'mailto://')                            or starts-with(., 'ftp://') or starts-with(., 'www.')                            )">
                  <url>
                     <xsl:attribute name="normval">
                        <xsl:choose>
                           <xsl:when test="@hrefclass">
                              <xsl:value-of select="concat(@hrefclass,'://', ./@href)"/>
                           </xsl:when>
                           <xsl:otherwise>
                              <xsl:value-of select="./@href"/>
                           </xsl:otherwise>
                        </xsl:choose>
                     </xsl:attribute>
                     <xsl:apply-templates/>
                  </url>
               </xsl:when>
               <xsl:otherwise>
                  <ref:lnlink service="URL">
                     <ref:marker>
                        <xsl:apply-templates/>
                     </ref:marker>
                     <ref:locator>
                        <ref:locator-key>
                           <ref:key-name name="URL"/>
                           <ref:key-value>
                              <xsl:attribute name="value">
                                 <xsl:choose>
                                    <xsl:when test="@hrefclass and not(starts-with(./@href, ./@hrefclass))">
                                       <xsl:value-of select="concat(@hrefclass,'://', ./@href)"/>
                                    </xsl:when>
                                    <xsl:otherwise>
                                       <xsl:value-of select="./@href"/>
                                    </xsl:otherwise>
                                 </xsl:choose>
                              </xsl:attribute>
                           </ref:key-value>
                        </ref:locator-key>
                     </ref:locator>
                  </ref:lnlink>
               </xsl:otherwise>
            </xsl:choose>
         </xsl:when>
         <!-- SNB: 2017-11-10 : end change -->
         <xsl:when test="starts-with(., 'http') or starts-with(., 'www')">
            <url>
               <xsl:attribute name="normval">
                  <xsl:if test="starts-with(./@href, 'http')">
                     <xsl:value-of select="./@href"/>
                  </xsl:if>
                  <xsl:if test="starts-with(./@href, 'www')">
                     <xsl:value-of select="concat('http://', ./@href)"/>
                  </xsl:if>
               </xsl:attribute>
               <xsl:choose>
                  <xsl:when test="$streamID='UK09'">
                     <xsl:apply-templates select="text()"/>
                     <!-- AS:child element under url/remotelink should be suppressed -->
                  </xsl:when>
                  <xsl:otherwise>
                     <xsl:apply-templates/>
                  </xsl:otherwise>
               </xsl:choose>
            </url>
         </xsl:when>
         <xsl:when test="descendant::emph[starts-with(.,'http')] or descendant::emph[starts-with(.,'www')]">
            <url>
               <xsl:attribute name="normval">
                  <xsl:if test="starts-with(./@href, 'http')">
                     <xsl:value-of select="./@href"/>
                  </xsl:if>
                  <xsl:if test="starts-with(./@href, 'www')">
                     <xsl:value-of select="concat('http://', ./@href)"/>
                  </xsl:if>
               </xsl:attribute>
               <xsl:apply-templates/>
            </url>
         </xsl:when>
         <xsl:when test="(starts-with(., 'http') or starts-with(., 'www') or starts-with(@href, 'http') or starts-with(@href, 'www')) and $streamID='AU21'">
            <url>
               <xsl:attribute name="normval">
                  <xsl:if test="starts-with(./@href, 'http')">
                     <xsl:value-of select="./@href"/>
                  </xsl:if>
                  <xsl:if test="starts-with(./@href, 'www')">
                     <xsl:value-of select="concat('http://', ./@href)"/>
                  </xsl:if>
               </xsl:attribute>
               <xsl:apply-templates select="node()"/>
            </url>
         </xsl:when>
         <xsl:when test="not(starts-with(., 'http')) and not(starts-with(., 'www'))">
            <ref:lnlink>
               <xsl:attribute name="service">
                  <xsl:text>URL</xsl:text>
               </xsl:attribute>
               <ref:marker>
                  <xsl:choose>
                     <xsl:when test="$streamID='AU21'">
                        <ref:inlineobject>
                           <ref:locator>
                              <ref:locator-key>
                                 <ref:key-name name="object-key"/>
                                 <ref:key-value value="5DT1-HR81-66TK-240F-00000-00-12633-4354-CM-{ancestor::p[1]/preceding-sibling::h[1]}-2"/>
                              </ref:locator-key>
                              <ref:locator-params>
                                 <proc:param name="componentseq" value="1"/>
                                 <proc:param name="object-type" value="image"/>
                                 <proc:param name="object-smi" value="12633"/>
                              </ref:locator-params>
                           </ref:locator>
                        </ref:inlineobject>
                     </xsl:when>
                     <xsl:otherwise>
                        <xsl:apply-templates/>
                     </xsl:otherwise>
                  </xsl:choose>
               </ref:marker>
               <ref:locator>
                  <ref:locator-key>
                     <ref:key-name>
                        <xsl:attribute name="name">
                           <xsl:text>URL</xsl:text>
                        </xsl:attribute>
                     </ref:key-name>
                     <ref:key-value>
                        <xsl:attribute name="value">
                           <xsl:choose>
                              <xsl:when test="starts-with(./@href, 'http')">
                                 <xsl:value-of select="./@href"/>
                              </xsl:when>
                              <xsl:when test="starts-with(./@href, 'www')">
                                 <xsl:value-of select="concat('http://', ./@href)"/>
                              </xsl:when>
                              <xsl:when test="./@hrefclass='http'">
                                 <xsl:value-of select="concat('http://', ./@href)"/>
                              </xsl:when>
                              <xsl:otherwise>
                                 <xsl:value-of select="./@href"/>
                              </xsl:otherwise>
                           </xsl:choose>
                        </xsl:attribute>
                     </ref:key-value>
                  </ref:locator-key>
               </ref:locator>
            </ref:lnlink>
         </xsl:when>
      </xsl:choose>
      <!--  Original Target XPath:  url   -->
      <!--<url>
			<xsl:apply-templates select="@* | node()"/>
		</url>-->
   </xsl:template>

   <xsl:template match="url[remotelink]">
      <xsl:apply-templates select="@*|node()"/>
   </xsl:template>
   <!-- JL need to add emph passthrough to make this validate! -->
   <xsl:template match="emph[ancestor::remotelink[parent::url]]" priority="30">
      <xsl:apply-templates/>
   </xsl:template>
   <!-- rosetta element: verbatim -->   <!-- <topicref href="../../common_newest/Rosetta_verbatim-LxAdv-verbatim.dita"/> -->   <xd:doc>
      <xd:desc>
         <xd:p>
            <xd:b>Instructions <xd:i>[common element]</xd:i>
            </xd:b>
         </xd:p>
         <xd:p>
            <xd:i>verbatim</xd:i> becomes <xd:b>verbatim</xd:b> with attribute
            <xd:i>@verbatimclass</xd:i> becomes <xd:b>@verbatimclass</xd:b>
         </xd:p>
         <xd:p>
            <xd:b>Source XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;verbatim verbatimclass="verbatim"&gt;** Editor's
          Table **&lt;nl/&gt; &lt;nl/&gt; Provision Changed by In force Authority&lt;nl/&gt;
          &lt;nl/&gt; 487.0911 2005 c25 s11 2008 Jan 1 SI/2007-108&lt;nl/&gt; *****
          &lt;/verbatim&gt; &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <xd:p>
            <xd:b>Target XML</xd:b>
         </xd:p>
         <xd:pre> &lt;p&gt; &lt;text&gt; &lt;verbatim verbatimclass="verbatim"&gt;** Editor's
          Table **&lt;proc:nl/&gt; &lt;proc:nl/&gt; Provision Changed by In force
          Authority&lt;proc:nl/&gt; &lt;proc:nl/&gt; 487.0911 2005 c25 s11 2008 Jan 1
          SI/2007-108&lt;proc:nl/&gt; *****&lt;/verbatim&gt; &lt;/text&gt; &lt;/p&gt; </xd:pre>
         <!--Changes2012-11-27: Created. -->
      </xd:desc>
   </xd:doc>
   <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
   <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\common_newest\Rosetta_verbatim-LxAdv-verbatim.dita  -->
   <!--<xsl:message>Rosetta_verbatim-LxAdv-verbatim.xsl requires manual development!</xsl:message> -->
   <xsl:template match="verbatim"><!--  Original Target XPath:  verbatim   -->
      <verbatim>
         <xsl:apply-templates select="@* | node()"/>
      </verbatim>
   </xsl:template>

   <xsl:template match="@verbatimclass"><!--  Original Target XPath:  @verbatimclass   -->
      <xsl:attribute name="verbatimclass">
         <xsl:value-of select="."/>
      </xsl:attribute>
   </xsl:template>
   <!-- end topichead  General Markup  -->   <!-- <topicref href="AU01_changeLog.dita"/> -->   <!--<xsl:include href="../../modules/changeLog/AU01_changeLog.xsl"/>--></xsl:stylesheet>
